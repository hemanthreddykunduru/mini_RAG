{"chunks": ["Java Notes for ProfessionalsJava Notes for Professionals GoalKicker.com Free Programming BooksDisclaimer This is an unocial free book created for educational purposes and is not aliated with ocial Java groups or companys. All trademarks and registered trademarks are the property of their respective owners 900 pages of professional hints and tricks Contents About 1 ................................................................................................................................................................................... Chapter 1 Getting started with Java Language 2 .......................................................................................... Section 1.1 Creating Your First Java Program 2 ........................................................................................................... Chapter 2 Type Conversion 8 .................................................................................................................................... Section 2.1 Numeric primitive casting 8 ......................................................................................................................... Section 2.2 Basic Numeric Promotion 8 ........................................................................................................................ Section 2.3 Non-numeric primitive casting 8 ................................................................................................................ Section 2.4 Object casting 9 ........................................................................................................................................... Section 2.5 Testing if an object can be cast using instanceof 9 ................................................................................. Chapter 3 Getters and Setters 10 ........................................................................................................................... Section 3.1 Using a setter or getter to implement a constraint 10 ............................................................................. Section 3.2 Why Use Getters and Setters? 10 .............................................................................................................. Section 3.3 Adding Getters and Setters 11 ................................................................................................................... Chapter 4 Reference Data Types 13 .................................................................................................................... Section 4.1 Dereferencing 13 .......................................................................................................................................... Section 4.2 Instantiating a reference type 13 ............................................................................................................... Chapter 5 Java Compiler - javac 14 .................................................................................................................... Section 5.1 The javac command - getting started 14 ................................................................................................ Section 5.2 Compiling for a dierent", "version of Java 16 ............................................................................................ Chapter 6 Documenting Java Code 18 ................................................................................................................. Section 6.1 Building Javadocs From the Command Line 18 ....................................................................................... Section 6.2 Class Documentation 18 ............................................................................................................................. Section 6.3 Method Documentation 19 ......................................................................................................................... Section 6.4 Package Documentation 20 ....................................................................................................................... Section 6.5 Links 20 ......................................................................................................................................................... Section 6.6 Code snippets inside documentation 21 ................................................................................................... Section 6.7 Field Documentation 22 .............................................................................................................................. Section 6.8 Inline Code Documentation 22 ................................................................................................................... Chapter 7 Command line Argument Processing 24 ....................................................................................... Section 7.1 Argument processing using GWT ToolBase 24 ......................................................................................... Section 7.2 Processing arguments by hand 24 ............................................................................................................ Chapter 8 The Java Command - java and javaw 27 ................................................................................. Section 8.1 Entry point classes 27 .................................................................................................................................. Section 8.2 Troubleshooting the java command 27 .................................................................................................. Section 8.3 Running a Java application with library dependencies 29 ..................................................................... Section 8.4 Java Options 30 ........................................................................................................................................... Section 8.5 Spaces and other special characters in arguments 31 ........................................................................... Section 8.6 Running an executable JAR \ufb01le 33 ............................................................................................................ Section 8.7 Running a Java applications via a main class 33 ................................................................................. Chapter 9 Literals 35 ...................................................................................................................................................... Section 9.1 Using underscore to improve readability 35 ............................................................................................. Section 9.2 Hexadecimal, Octal and Binary literals 35 ................................................................................................ Section 9.3 Boolean literals 36 ....................................................................................................................................... Section 9.4 String literals", "36 ........................................................................................................................................... Section 9.5 The Null literal 37 ......................................................................................................................................... Section 9.6 Escape sequences in literals 37 .................................................................................................................. Section 9.7 Character literals 38 .................................................................................................................................... Section 9.8 Decimal Integer literals 38 .......................................................................................................................... Section 9.9 Floating-point literals 39 ............................................................................................................................. Chapter 10 Primitive Data Types 42 ....................................................................................................................... Section 10.1 The char primitive 42 .................................................................................................................................. Section 10.2 Primitive Types Cheatsheet 42 ................................................................................................................. Section 10.3 The \ufb02oat primitive 43 ................................................................................................................................. Section 10.4 The int primitive 44 ..................................................................................................................................... Section 10.5 Converting Primitives 45 ............................................................................................................................ Section 10.6 Memory consumption of primitives vs. boxed primitives 45 .................................................................. Section 10.7 The double primitive 46 ............................................................................................................................. Section 10.8 The long primitive 47 ................................................................................................................................. Section 10.9 The boolean primitive 48 ........................................................................................................................... Section 10.10 The byte primitive 48 ................................................................................................................................ Section 10.11 Negative value representation 49 ............................................................................................................ Section 10.12 The short primitive 50 ............................................................................................................................... Chapter 11 Strings 51 ...................................................................................................................................................... Section 11.1 Comparing Strings 51 .................................................................................................................................. Section 11.2 Changing the case of characters within a String 53 ............................................................................... Section 11.3 Finding a String Within Another String 55 ................................................................................................. Section 11.4 String pool and heap storage 56 ............................................................................................................... Section 11.5 Splitting Strings 57 ....................................................................................................................................... Section 11.6 Joining Strings with a delimiter 59 ............................................................................................................ Section 11.7 String concatenation and StringBuilders 60 ............................................................................................. Section 11.8 Substrings 61", "............................................................................................................................................... Section 11.9 Platform independent new line separator 62 ........................................................................................... Section 11.10 Reversing Strings 62 .................................................................................................................................. Section 11.11 Adding toString method for custom objects 63 .................................................................................... Section 11.12 Remove Whitespace from the Beginning and End of a String 64 ........................................................ Section 11.13 Case insensitive switch 64 ......................................................................................................................... Section 11.14 Replacing parts of Strings 65 ................................................................................................................... Section 11.15 Getting the length of a String 66 .............................................................................................................. Section 11.16 Getting the nth character in a String 66 .................................................................................................. Section 11.17 Counting occurrences of a substring or character in a string 66 ......................................................... Chapter 12 StringBuer 68 ......................................................................................................................................... Section 12.1 String Buer class 68 .................................................................................................................................. Chapter 13 StringBuilder 69 ........................................................................................................................................ Section 13.1 Comparing StringBuer, StringBuilder, Formatter and StringJoiner 69 ............................................... Section 13.2 Repeat a String n times 70 ........................................................................................................................ Chapter 14 String Tokenizer 71 ................................................................................................................................ Section 14.1 StringTokenizer Split by space 71 ............................................................................................................. Section 14.2 StringTokenizer Split by comma , 71 ...................................................................................................... Chapter 15 Splitting a string into \ufb01xed length parts 72 ............................................................................... Section 15.1 Break a string up into substrings all of a known length 72 .................................................................... Section 15.2 Break a string up into substrings all of variable length 72 .................................................................... Chapter 16 Date Class 73 ............................................................................................................................................. Section 16.1 Convert java.util.Date", "to java.sql.Date 73 ................................................................................................. Section 16.2 A basic date output 73 ............................................................................................................................... Section 16.3 Java 8 LocalDate and LocalDateTime objects 74 .................................................................................. Section 16.4 Creating a Speci\ufb01c Date 75 ....................................................................................................................... Section 16.5 Converting Date to a certain String format 75 ....................................................................................... Section 16.6 LocalTime 76 ............................................................................................................................................... Section 16.7 Convert formatted string representation of date to Date object 76 .................................................... Section 16.8 Creating Date objects 77 ........................................................................................................................... Section 16.9 Comparing Date objects 77 ...................................................................................................................... Section 16.10 Converting String into Date 80 ................................................................................................................ Section 16.11 Time Zones and java.util.Date 80 ............................................................................................................. Chapter 17 Dates and Time java.time. 82 ....................................................................................................... Section 17.1 Calculate Dierence between 2 LocalDates 82 ....................................................................................... Section 17.2 Date and time 82 ........................................................................................................................................ Section 17.3 Operations on dates and times 82 ........................................................................................................... Section 17.4 Instant 82 ..................................................................................................................................................... Section 17.5 Usage of various classes of Date Time API 83 ........................................................................................ Section 17.6 Date Time Formatting 85 ........................................................................................................................... Section 17.7 Simple Date Manipulations 85 ................................................................................................................... Chapter 18 LocalTime 87 .............................................................................................................................................. Section 18.1 Amount of time between two LocalTime 87 ............................................................................................ Section 18.2 Intro 88 ........................................................................................................................................................ Section 18.3 Time Modi\ufb01cation 88 .................................................................................................................................. Section 18.4 Time Zones and their time dierence 88 ................................................................................................. Chapter 19 BigDecimal 90 ............................................................................................................................................ Section 19.1 Comparing BigDecimals 90", "........................................................................................................................ Section 19.2 Using BigDecimal instead of \ufb02oat 90 ....................................................................................................... Section 19.3 BigDecimal.valueOf 91 ............................................................................................................................ Section 19.4 Mathematical operations with BigDecimal 91 ......................................................................................... Section 19.5 Initialization of BigDecimals with value zero, one or ten 94 ................................................................... Section 19.6 BigDecimal objects are immutable 94 ..................................................................................................... Chapter 20 BigInteger 96 ............................................................................................................................................ Section 20.1 Initialization 96 ............................................................................................................................................ Section 20.2 BigInteger Mathematical Operations Examples 97 ............................................................................... Section 20.3 Comparing BigIntegers 99 ........................................................................................................................ Section 20.4 Binary Logic Operations on BigInteger 100 ........................................................................................... Section 20.5 Generating random BigIntegers 101 ....................................................................................................... Chapter 21 NumberFormat 103 ................................................................................................................................. Section 21.1 NumberFormat 103 .................................................................................................................................... Chapter 22 Bit Manipulation 104 .............................................................................................................................. Section 22.1 Checking, setting, clearing, and toggling individual bits. Using long as bit mask 104 ........................ Section 22.2 java.util.BitSet class 104 ............................................................................................................................ Section 22.3 Checking if a number is a power of 2 105 .............................................................................................. Section 22.4 Signed vs unsigned shift 107 .................................................................................................................... Section 22.5 Expressing the power of 2 107 ................................................................................................................. Section 22.6 Packing unpacking values as bit fragments 108 ................................................................................ Chapter 23 Arrays 109 ................................................................................................................................................... Section 23.1 Creating and Initializing Arrays 109 ......................................................................................................... Section 23.2 Creating a List from an Array 115 ........................................................................................................... Section 23.3 Creating an Array from a Collection 117 ................................................................................................ Section 23.4 Multidimensional and", "Jagged Arrays 117 .............................................................................................. Section 23.5 ArrayIndexOutOfBoundsException 119 .................................................................................................. Section 23.6 Array Covariance 120 ............................................................................................................................... Section 23.7 Arrays to Stream 121 ................................................................................................................................ Section 23.8 Iterating over arrays 121 .......................................................................................................................... Section 23.9 Arrays to a String 123 ............................................................................................................................... Section 23.10 Sorting arrays 124 .................................................................................................................................... Section 23.11 Getting the Length of an Array 126 ........................................................................................................ Section 23.12 Finding an element in an array 126 ....................................................................................................... Section 23.13 How do you change the size of an array? 127 ..................................................................................... Section 23.14 Converting arrays between primitives and boxed types 128 .............................................................. Section 23.15 Remove an element from an array 129 ................................................................................................ Section 23.16 Comparing arrays for equality 130 ........................................................................................................ Section 23.17 Copying arrays 130 .................................................................................................................................. Section 23.18 Casting Arrays 131 ................................................................................................................................... Chapter 24 Collections 133 ......................................................................................................................................... Section 24.1 Removing items from a List within a loop 133 ........................................................................................ Section 24.2 Constructing collections from existing data 135 .................................................................................... Section 24.3 Declaring an ArrayList and adding objects 137 ..................................................................................... Section 24.4 Iterating over Collections 137 .................................................................................................................. Section 24.5 Immutable Empty Collections 139 ........................................................................................................... Section 24.6 Sub Collections 139 ................................................................................................................................... Section 24.7 Unmodi\ufb01able Collection 140 ..................................................................................................................... Section 24.8 Pitfall concurrent modi\ufb01cation exceptions 141 ..................................................................................... Section 24.9 Removing matching items from Lists using Iterator 141 ...................................................................... Section", "24.10 Join lists 142 ............................................................................................................................................. Section 24.11 Creating your own Iterable structure for use with Iterator or for-each loop 142 .............................. Section 24.12 Collections and Primitive Values 144 ..................................................................................................... Chapter 25 Lists 146 ....................................................................................................................................................... Section 25.1 Sorting a generic list 146 ........................................................................................................................... Section 25.2 Convert a list of integers to a list of strings 147 ..................................................................................... Section 25.3 Classes implementing List - Pros and Cons 147 ..................................................................................... Section 25.4 Finding common elements between 2 lists 150 ..................................................................................... Section 25.5 In-place replacement of a List element 150 ........................................................................................... Section 25.6 Making a list unmodi\ufb01able 151 ................................................................................................................ Section 25.7 Moving objects around in the list 151 ...................................................................................................... Section 25.8 Creating, Adding and Removing element from an ArrayList 152 ........................................................ Section 25.9 Creating a List 152 ..................................................................................................................................... Section 25.10 Positional Access Operations 153 .......................................................................................................... Section 25.11 Iterating over elements in a list 155 ........................................................................................................ Section 25.12 Removing elements from list B that are present in the list A 155 ....................................................... Chapter 26 Sets 157 ........................................................................................................................................................ Section 26.1 Initialization 157 .......................................................................................................................................... Section 26.2 Basics of Set 157 ........................................................................................................................................ Section 26.3 Types and Usage of Sets 158 ................................................................................................................... Section 26.4 Create a list from an existing Set 159 ...................................................................................................... Section 26.5 Eliminating duplicates using", "Set 159 ....................................................................................................... Section 26.6 Declaring a HashSet with values 160 ...................................................................................................... Chapter 27 List vs Set 161 ........................................................................................................................................... Section 27.1 List vs Set 161 ............................................................................................................................................. Chapter 28 Maps 162 ...................................................................................................................................................... Section 28.1 Iterating Map Entries Eciently 162 ......................................................................................................... Section 28.2 Usage of HashMap 164 ............................................................................................................................ Section 28.3 Using Default Methods of Map from Java 8 165 ................................................................................... Section 28.4 Iterating through the contents of a Map 167 ......................................................................................... Section 28.5 Merging, combine and composing Maps 168 ........................................................................................ Section 28.6 Add multiple items 169 .............................................................................................................................. Section 28.7 Creating and Initializing Maps 171 ........................................................................................................... Section 28.8 Check if key exists 172 .............................................................................................................................. Section 28.9 Add an element 172 .................................................................................................................................. Section 28.10 Clear the map 173 .................................................................................................................................... Section 28.11 Use custom object as key 173 ................................................................................................................. Chapter 29 LinkedHashMap 175 ............................................................................................................................... Section 29.1 Java LinkedHashMap class 175 ............................................................................................................... Chapter 30 WeakHashMap 176 ................................................................................................................................. Section 30.1 Concepts of WeakHashmap 176 .............................................................................................................. Chapter 31 SortedMap 177 .......................................................................................................................................... Section 31.1 Introduction to sorted Map 177 ................................................................................................................. Chapter 32 TreeMap and TreeSet 178 .................................................................................................................. Section 32.1 TreeMap of a simple Java type 178 ........................................................................................................ Section 32.2 TreeSet of a simple Java Type 178 ......................................................................................................... Section 32.3 TreeMapTreeSet of a custom Java type 179 ....................................................................................... Section", "32.4 TreeMap and TreeSet Thread Safety 180 .............................................................................................. Chapter 33 Queues and Deques 182 ...................................................................................................................... Section 33.1 The usage of the PriorityQueue 182 ......................................................................................................... Section 33.2 Deque 182 ................................................................................................................................................... Section 33.3 Stacks 183 ................................................................................................................................................... Section 33.4 BlockingQueue 184 .................................................................................................................................... Section 33.5 LinkedList as a FIFO Queue 185 ............................................................................................................... Section 33.6 Queue Interface 186 .................................................................................................................................. Chapter 34 Dequeue Interface 187 ........................................................................................................................ Section 34.1 Adding Elements to Deque 187 ................................................................................................................. Section 34.2 Removing Elements from Deque 187 ...................................................................................................... Section 34.3 Retrieving Element without Removing 187 ............................................................................................. Section 34.4 Iterating through Deque 187 .................................................................................................................... Chapter 35 Enums 189 ................................................................................................................................................... Section 35.1 Declaring and using a basic enum 189 .................................................................................................... Section 35.2 Enums with constructors 192 ................................................................................................................... Section 35.3 Enums with Abstract Methods 193 ........................................................................................................... Section 35.4 Implements Interface 194 ......................................................................................................................... Section 35.5 Implement Singleton pattern with a single-element enum 195 ............................................................ Section 35.6 Using methods and static blocks 196 ...................................................................................................... Section 35.7 Zero instance enum 196 ........................................................................................................................... Section 35.8 Enum as a bounded type parameter 197 ............................................................................................... Section 35.9 Documenting enums 197 .......................................................................................................................... Section 35.10 Enum constant speci\ufb01c body 198 ........................................................................................................... Section 35.11 Getting the values of an enum 199 ......................................................................................................... Section 35.12 Enum Polymorphism Pattern 200 ........................................................................................................... Section 35.13 Compare and", "Contains for Enum values 201 ........................................................................................ Section 35.14 Get enum constant by name 201 ........................................................................................................... Section 35.15 Enum with properties \ufb01elds 202 ........................................................................................................... Section 35.16 Convert enum to String 203 .................................................................................................................... Section 35.17 Enums with static \ufb01elds 203 ..................................................................................................................... Chapter 36 Enum Map 205 ........................................................................................................................................... Section 36.1 Enum Map Book Example 205 .................................................................................................................. Chapter 37 EnumSet class 206 .................................................................................................................................. Section 37.1 Enum Set Example 206 .............................................................................................................................. Chapter 38 Enum starting with number 207 ...................................................................................................... Section 38.1 Enum with name at beginning 207 ........................................................................................................... Chapter 39 Hashtable 208 ........................................................................................................................................... Section 39.1 Hashtable 208 ............................................................................................................................................. Chapter 40 Operators 209 .......................................................................................................................................... Section 40.1 The IncrementDecrement Operators -- 209 ................................................................................ Section 40.2 The Conditional Operator ? 209 .......................................................................................................... Section 40.3 The Bitwise and Logical Operators , , , 211 .................................................................................. Section 40.4 The String Concatenation Operator 212 ........................................................................................... Section 40.5 The Arithmetic Operators , -, , , 214 ............................................................................................. Section 40.6 The Shift Operators , and 216 ............................................................................................... Section 40.7 The Instanceof Operator 217 ................................................................................................................... Section 40.8 The Assignment Operators , , -, , , , , , , , and 218 ............................. Section 40.9 The conditional-and and conditional-or Operators and 220 .................................................. Section 40.10 The Relational Operators , , , 221 ............................................................................................", "Section 40.11 The Equality Operators , ! 222 ......................................................................................................... Section 40.12 The Lambda operator - 224 ............................................................................................................. Chapter 41 Constructors 225 ..................................................................................................................................... Section 41.1 Default Constructor 225 ............................................................................................................................. Section 41.2 Call parent constructor 226 ....................................................................................................................... Section 41.3 Constructor with Arguments 227 .............................................................................................................. Chapter 42 Object Class Methods and Constructor 229 ............................................................................. Section 42.1 hashCode method 229 ............................................................................................................................ Section 42.2 toString method 231 ............................................................................................................................... Section 42.3 equals method 232 ................................................................................................................................. Section 42.4 wait and notify methods 234 .............................................................................................................. Section 42.5 getClass method 236 .............................................................................................................................. Section 42.6 clone method 237 ................................................................................................................................... Section 42.7 Object constructor 238 .............................................................................................................................. Section 42.8 \ufb01nalize method 239 ................................................................................................................................ Chapter 43 Annotations 241 ...................................................................................................................................... Section 43.1 The idea behind Annotations 241 ............................................................................................................. Section 43.2 De\ufb01ning annotation types 241 ................................................................................................................. Section 43.3 Runtime annotation checks via re\ufb02ection 243 ....................................................................................... Section 43.4 Built-in annotations 243 ............................................................................................................................ Section 43.5 Compile time processing using annotation processor 246 ................................................................... Section 43.6 Repeating Annotations 250 ...................................................................................................................... Section 43.7 Inherited Annotations 251 ......................................................................................................................... Section 43.8 Getting Annotation values at run-time 252 ............................................................................................. Section 43.9 Annotations for this and receiver parameters 253 .............................................................................. Section 43.10 Add multiple annotation values 254 ....................................................................................................... Chapter 44 Immutable Class 255 ............................................................................................................................ Section 44.1 Example without mutable refs 255 ...........................................................................................................", "Section 44.2 What is the advantage of immutability? 255 ......................................................................................... Section 44.3 Rules to de\ufb01ne immutable classes 255 ................................................................................................... Section 44.4 Example with mutable refs 256 ................................................................................................................ Chapter 45 Immutable Objects 257 ....................................................................................................................... Section 45.1 Creating an immutable version of a type using defensive copying 257 .............................................. Section 45.2 The recipe for an immutable class 257 ................................................................................................... Section 45.3 Typical design \ufb02aws which prevent a class from being immutable 258 ............................................. Chapter 46 Visibility controlling access to members of a class 262 ................................................. Section 46.1 Private Visibility 262 ................................................................................................................................... Section 46.2 Public Visibility 262 .................................................................................................................................... Section 46.3 Package Visibility 263 ................................................................................................................................ Section 46.4 Protected Visibility 263 .............................................................................................................................. Section 46.5 Summary of Class Member Access Modi\ufb01ers 264 ................................................................................. Section 46.6 Interface members 264 ............................................................................................................................. Chapter 47 Generics 265 .............................................................................................................................................. Section 47.1 Creating a Generic Class 265 .................................................................................................................... Section 47.2 Deciding between T, ? super T, and ? extends T 267 ........................................................................ Section 47.3 The Diamond 269 ....................................................................................................................................... Section 47.4 Declaring a Generic Method 269 .............................................................................................................. Section 47.5 Requiring multiple upper bounds extends A B 270 ....................................................................... Section 47.6 Obtain class that satis\ufb01es generic parameter at runtime 270 ............................................................. Section 47.7 Bene\ufb01ts of Generic class and interface 271 ........................................................................................... Section 47.8", "Instantiating a generic type 272 .............................................................................................................. Section 47.9 Creating a Bounded Generic Class 272 ................................................................................................... Section 47.10 Referring to the declared generic type within its own declaration 274 ............................................. Section 47.11 Binding generic parameter to more than 1 type 275 ............................................................................ Section 47.12 Using Generics to auto-cast 276 ............................................................................................................. Section 47.13 Use of instanceof with Generics 276 ...................................................................................................... Section 47.14 Dierent ways for implementing a Generic Interface or extending a Generic Class 278 ............. Chapter 48 Classes and Objects 280 ..................................................................................................................... Section 48.1 Overloading Methods 280 ......................................................................................................................... Section 48.2 Explaining what is method overloading and overriding 281 ................................................................ Section 48.3 Constructors 283 ........................................................................................................................................ Section 48.4 Initializing static \ufb01nal \ufb01elds using a static initializer 284 ........................................................................ Section 48.5 Basic Object Construction and Use 285 .................................................................................................. Section 48.6 Simplest Possible Class 287 ...................................................................................................................... Section 48.7 Object Member vs Static Member 287 .................................................................................................... Chapter 49 Local Inner Class 289 ............................................................................................................................ Section 49.1 Local Inner Class 289 ................................................................................................................................. Chapter 50 Nested and Inner Classes 290 .......................................................................................................... Section 50.1 A Simple Stack Using a Nested Class 290 ............................................................................................... Section 50.2 Static vs Non Static Nested Classes 290 ................................................................................................. Section 50.3 Access Modi\ufb01ers for Inner Classes 292 ................................................................................................... Section 50.4 Anonymous Inner Classes 293 .................................................................................................................", "Section 50.5 Create instance of non-static inner class from outside 294 ................................................................. Section 50.6 Method Local Inner Classes 295 .............................................................................................................. Section 50.7 Accessing the outer class from a non-static inner class 295 ................................................................ Chapter 51 The java.util.Objects Class 297 ......................................................................................................... Section 51.1 Basic use for object null check 297 ........................................................................................................... Section 51.2 Objects.nonNull method reference use in stream api 297 .................................................................. Chapter 52 Default Methods 298 ............................................................................................................................. Section 52.1 Basic usage of default methods 298 ........................................................................................................ Section 52.2 Accessing overridden default methods from implementing class 298 ............................................... Section 52.3 Why use Default Methods? 299 ............................................................................................................... Section 52.4 Accessing other interface methods within default method 299 ........................................................... Section 52.5 Default method multiple inheritance collision 300 ................................................................................. Section 52.6 Class, Abstract class and Interface method precedence 301 .............................................................. Chapter 53 Packages 303 ............................................................................................................................................ Section 53.1 Using Packages to create classes with the same name 303 ................................................................. Section 53.2 Using Package Protected Scope 303 ...................................................................................................... Chapter 54 Inheritance 305 ........................................................................................................................................ Section 54.1 Inheritance 305 ........................................................................................................................................... Section 54.2 Abstract Classes 306 ................................................................................................................................. Section 54.3 Using \ufb01nal to restrict inheritance and overriding 308 .......................................................................... Section 54.4 The Liskov Substitution Principle 309 ...................................................................................................... Section 54.5 Abstract class and Interface usage Is-a relation vs Has-a capability", "310 ................................... Section 54.6 Static Inheritance 313 ................................................................................................................................ Section 54.7 Programming to an interface 314 ........................................................................................................... Section 54.8 Overriding in Inheritance 316 ................................................................................................................... Section 54.9 Variable shadowing 317 ........................................................................................................................... Section 54.10 Narrowing and Widening of object references 317 ............................................................................. Section 54.11 Inheritance and Static Methods 318 ........................................................................................................ Chapter 55 Reference Types 320 ............................................................................................................................ Section 55.1 Dierent Reference Types 320 ................................................................................................................. Chapter 56 Console IO 322 ........................................................................................................................................ Section 56.1 Reading user input from the console 322 ................................................................................................ Section 56.2 Aligning strings in console 323 ................................................................................................................. Section 56.3 Implementing Basic Command-Line Behavior 324 ................................................................................ Chapter 57 Streams 326 ............................................................................................................................................... Section 57.1 Using Streams 326 ..................................................................................................................................... Section 57.2 Consuming Streams 328 ........................................................................................................................... Section 57.3 Creating a Frequency Map 330 ................................................................................................................ Section 57.4 In\ufb01nite Streams 330 ................................................................................................................................... Section 57.5 Collect Elements of a Stream into a Collection 331 ............................................................................... Section 57.6 Using Streams to Implement Mathematical Functions 334 .................................................................. Section 57.7 Flatten Streams with \ufb02atMap 334 ......................................................................................................... Section 57.8 Parallel Stream 335 ................................................................................................................................... Section 57.9 Creating a Stream 336 .............................................................................................................................. Section 57.10 Finding Statistics about Numerical Streams 337 .................................................................................. Section 57.11 Converting an iterator to a stream 337 .................................................................................................. Section 57.12 Using IntStream to iterate over indexes 337 ......................................................................................... Section 57.13 Concatenate Streams", "338 ....................................................................................................................... Section 57.14 Reduction with Streams 338 .................................................................................................................... Section 57.15 Using Streams of Map.Entry to Preserve Initial Values after Mapping 341 ....................................... Section 57.16 IntStream to String 341 ............................................................................................................................ Section 57.17 Finding the First Element that Matches a Predicate 341 ...................................................................... Section 57.18 Using Streams and Method References to Write Self-Documenting Processes 342 ........................ Section 57.19 Converting a Stream of Optional to a Stream of Values 343 .............................................................. Section 57.20 Get a Slice of a Stream 343 .................................................................................................................... Section 57.21 Create a Map based on a Stream 343 ................................................................................................... Section 57.22 Joining a stream to a single String 344 ................................................................................................ Section 57.23 Sort Using Stream 345 ............................................................................................................................ Section 57.24 Streams of Primitives 346 ....................................................................................................................... Section 57.25 Stream operations categories 346 ........................................................................................................ Section 57.26 Collect Results of a Stream into an Array 347 ..................................................................................... Section 57.27 Generating random Strings using Streams 347 ................................................................................... Chapter 58 InputStreams and OutputStreams 349 ....................................................................................... Section 58.1 Closing Streams 349 .................................................................................................................................. Section 58.2 Reading InputStream into a String 349 ................................................................................................... Section 58.3 Wrapping InputOutput Streams 350 ..................................................................................................... Section 58.4 DataInputStream Example 351 ................................................................................................................ Section 58.5 Writing bytes to an OutputStream 351 ................................................................................................... Section 58.6 Copying Input Stream to Output Stream 351 ......................................................................................... Chapter 59", "Readers and Writers 353 .................................................................................................................... Section 59.1 BueredReader 353 ................................................................................................................................... Section 59.2 StringWriter Example 354 ......................................................................................................................... Chapter 60 Preferences 355 ....................................................................................................................................... Section 60.1 Using preferences 355 ............................................................................................................................... Section 60.2 Adding event listeners 355 ....................................................................................................................... Section 60.3 Getting sub-nodes of Preferences 356 .................................................................................................... Section 60.4 Coordinating preferences access across multiple application instances 357 .................................... Section 60.5 Exporting preferences 357 ....................................................................................................................... Section 60.6 Importing preferences 358 ....................................................................................................................... Section 60.7 Removing event listeners 359 .................................................................................................................. Section 60.8 Getting preferences values 360 ............................................................................................................... Section 60.9 Setting preferences values 360 ................................................................................................................ Chapter 61 Collection Factory Methods 361 ....................................................................................................... Section 61.1 ListE Factory Method Examples 361 ..................................................................................................... Section 61.2 SetE Factory Method Examples 361 ..................................................................................................... Section 61.3 MapK, V Factory Method Examples 361 .............................................................................................. Chapter 62 Alternative Collections 362 ................................................................................................................ Section 62.1 Multimap in Guava, Apache and Eclipse Collections 362 ....................................................................... Section 62.2 Apache HashBag, Guava HashMultiset and Eclipse HashBag 364 ...................................................... Section 62.3 Compare operation with collections - Create collections 366 .............................................................. Chapter 63 Concurrent Collections 371 ................................................................................................................ Section 63.1 Thread-safe Collections 371 ...................................................................................................................... Section 63.2 Insertion into ConcurrentHashMap 371 .................................................................................................. Section 63.3 Concurrent Collections 372 ....................................................................................................................... Chapter 64 Choosing Collections 374 .................................................................................................................... Section 64.1 Java Collections Flowchart 374 ................................................................................................................ Chapter 65 super keyword", "375 ................................................................................................................................. Section 65.1 Super keyword use with examples 375 .................................................................................................... Chapter 66 Serialization 378 ...................................................................................................................................... Section 66.1 Basic Serialization in Java 378 .................................................................................................................. Section 66.2 Custom Serialization 379 .......................................................................................................................... Section 66.3 Versioning and serialVersionUID 382 ...................................................................................................... Section 66.4 Serialization with Gson 383 ....................................................................................................................... Section 66.5 Custom JSON Deserialization with Jackson 384 .................................................................................... Chapter 67 Optional 387 ............................................................................................................................................... Section 67.1 Map 387 ....................................................................................................................................................... Section 67.2 Return default value if Optional is empty 388 ........................................................................................ Section 67.3 Throw an exception, if there is no value 388 ........................................................................................... Section 67.4 Lazily provide a default value using a Supplier 388 .............................................................................. Section 67.5 Filter 389 ..................................................................................................................................................... Section 67.6 Using Optional containers for primitive number types 389 .................................................................. Section 67.7 Run code only if there is a value present 390 ......................................................................................... Section 67.8 FlatMap 390 ................................................................................................................................................ Chapter 68 Object References 391 ......................................................................................................................... Section 68.1 Object References as method parameters 391 ...................................................................................... Chapter 69 Exceptions and exception handling 394 ...................................................................................... Section 69.1 Catching an exception with try-catch 394 ............................................................................................... Section 69.2 The try-with-resources statement 395 .................................................................................................... Section 69.3 Custom Exceptions 398 ............................................................................................................................. Section 69.4 Handling InterruptedException 400 ......................................................................................................... Section 69.5 Return statements in try catch block 401 ............................................................................................... Section 69.6 Introduction 402 ......................................................................................................................................... Section", "69.7 The Java Exception Hierarchy - Unchecked and Checked Exceptions 403 ........................................ Section 69.8 Creating and reading stacktraces 406 .................................................................................................... Section 69.9 Throwing an exception 409 ...................................................................................................................... Section 69.10 Advanced features of Exceptions 411 ................................................................................................... Section 69.11 The try-\ufb01nally and try-catch-\ufb01nally statements 412 ............................................................................ Section 69.12 The throws clause in a method declaration 414 ................................................................................. Chapter 70 Calendar and its Subclasses 416 .................................................................................................... Section 70.1 Creating Calendar objects 416 ................................................................................................................. Section 70.2 Increasing Decreasing calendar \ufb01elds 416 .......................................................................................... Section 70.3 Subtracting calendars 416 ........................................................................................................................ Section 70.4 Finding AMPM 416 ................................................................................................................................... Chapter 71 Using the static keyword 418 ............................................................................................................ Section 71.1 Reference to non-static member from static context 418 ..................................................................... Section 71.2 Using static to declare constants 418 ...................................................................................................... Chapter 72 Properties Class 420 .............................................................................................................................. Section 72.1 Loading properties 420 .............................................................................................................................. Section 72.2 Saving Properties as XML 420 .................................................................................................................. Section 72.3 Property \ufb01les caveat trailing whitespace 421 ........................................................................................ Chapter 73 Lambda Expressions 424 ..................................................................................................................... Section 73.1 Introduction to Java lambdas 424 ........................................................................................................... Section 73.2 Using Lambda Expressions to Sort a Collection 427 ............................................................................. Section 73.3 Method References 428 ............................................................................................................................ Section 73.4 Implementing multiple interfaces 430 ..................................................................................................... Section 73.5 Lambda - Listener Example 430 .............................................................................................................. Section 73.6 Java Closures with lambda", "expressions 431 .......................................................................................... Section 73.7 Lambdas and memory utilization 432 ..................................................................................................... Section 73.8 Using lambda expression with your own functional interface 433 ...................................................... Section 73.9 Traditional style to Lambda style 433 ..................................................................................................... Section 73.10 return only returns from the lambda, not the outer method 434 ..................................................... Section 73.11 Lambdas and Execute-around Pattern 436 ........................................................................................... Section 73.12 Using lambda expressions predicates to get a certain values from a list 436 ........................... Chapter 74 Basic Control Structures 438 ............................................................................................................ Section 74.1 Switch statement 438 ................................................................................................................................. Section 74.2 do...while Loop 439 ..................................................................................................................................... Section 74.3 For Each 440 ............................................................................................................................................... Section 74.4 Continue Statement in Java 441 .............................................................................................................. Section 74.5 If Else If Else Control 441 ..................................................................................................................... Section 74.6 For Loops 441 ............................................................................................................................................. Section 74.7 Ternary Operator 442 ............................................................................................................................... Section 74.8 Try ... Catch ... Finally 443 .......................................................................................................................... Section 74.9 Break 443 .................................................................................................................................................... Section 74.10 While Loops 444 ....................................................................................................................................... Section 74.11 If Else 444 ................................................................................................................................................ Section 74.12 Nested break continue 444 .................................................................................................................. Chapter 75 BueredWriter 446 ................................................................................................................................ Section 75.1 Write a line of text to File 446 .................................................................................................................... Chapter 76 New File IO 447 ....................................................................................................................................... Section 76.1 Creating paths 447 ..................................................................................................................................... Section 76.2 Manipulating paths 447 ............................................................................................................................. Section 76.3 Retrieving information about a path", "447 ................................................................................................ Section 76.4 Retrieving information using the \ufb01lesystem 448 .................................................................................... Section 76.5 Reading \ufb01les 449 ........................................................................................................................................ Section 76.6 Writing \ufb01les 449 .......................................................................................................................................... Chapter 77 File IO 450 ................................................................................................................................................. Section 77.1 Migrating from java.io.File to Java 7 NIO java.nio.\ufb01le.Path 450 .......................................................... Section 77.2 Reading an image from a \ufb01le 452 ........................................................................................................... Section 77.3 File ReadWrite Using FileInputStreamFileOutputStream 452 ........................................................... Section 77.4 Reading all bytes to a byte 453 ............................................................................................................ Section 77.5 Copying a \ufb01le using Channel 454 ............................................................................................................. Section 77.6 Writing a byte to a \ufb01le 454 ..................................................................................................................... Section 77.7 Stream vs WriterReader API 455 ............................................................................................................ Section 77.8 Reading a \ufb01le with a Scanner 456 ........................................................................................................... Section 77.9 Copying a \ufb01le using InputStream and OutputStream 457 .................................................................... Section 77.10 Reading from a binary \ufb01le 457 ............................................................................................................... Section 77.11 Reading a \ufb01le using Channel and Buer 457 ......................................................................................... Section 77.12 Adding Directories 458 ............................................................................................................................. Section 77.13 Blocking or redirecting standard output error 459 ............................................................................ Section 77.14 Reading a whole \ufb01le at once 460 ............................................................................................................ Section 77.15 Locking 460 ............................................................................................................................................... Section 77.16 Reading a \ufb01le using BueredInputStream 460 ..................................................................................... Section 77.17 Iterate over a directory printing subdirectories in it 461 ...................................................................... Section 77.18 Writing a \ufb01le using Channel and Buer 461", ".......................................................................................... Section 77.19 Writing a \ufb01le using PrintStream 462 ....................................................................................................... Section 77.20 Iterating over a directory and \ufb01lter by \ufb01le extension 462 ................................................................... Section 77.21 Accessing the contents of a ZIP \ufb01le 463 ................................................................................................ Chapter 78 Scanner 464 ............................................................................................................................................... Section 78.1 General Pattern that does most commonly asked about tasks 464 .................................................... Section 78.2 Using custom delimiters 466 .................................................................................................................... Section 78.3 Reading system input using Scanner 466 ............................................................................................... Section 78.4 Reading \ufb01le input using Scanner 466 ...................................................................................................... Section 78.5 Read the entire input as a String using Scanner 467 ............................................................................. Section 78.6 Carefully Closing a Scanner 467 .............................................................................................................. Section 78.7 Read an int from the command line 468 ................................................................................................ Chapter 79 Interfaces 469 ........................................................................................................................................... Section 79.1 Implementing multiple interfaces 469 ...................................................................................................... Section 79.2 Declaring and Implementing an Interface 470 ....................................................................................... Section 79.3 Extending an interface 470 ....................................................................................................................... Section 79.4 Usefulness of interfaces 471 .................................................................................................................... Section 79.5 Default methods 473 ................................................................................................................................. Section 79.6 Modi\ufb01ers in Interfaces 475 ........................................................................................................................ Section 79.7 Using Interfaces with Generics 475 .......................................................................................................... Section 79.8 Strengthen bounded type parameters 478 ............................................................................................ Section 79.9 Implementing interfaces in an abstract class 478 ................................................................................. Chapter 80 Regular Expressions 480 ..................................................................................................................... Section 80.1 Using capture groups 480 ......................................................................................................................... Section 80.2 Using", "regex with custom behaviour by compiling the Pattern with \ufb02ags 481 ................................... Section 80.3 Escape Characters 481 ............................................................................................................................. Section 80.4 Not matching a given string 482 ............................................................................................................. Section 80.5 Matching with a regex literal 482 ............................................................................................................. Section 80.6 Matching a backslash 482 ........................................................................................................................ Chapter 81 Comparable and Comparator 484 .................................................................................................. Section 81.1 Sorting a List using ComparableT or a ComparatorT 484 ............................................................. Section 81.2 The compareTo and compare Methods 487 .......................................................................................... Section 81.3 Natural comparable vs explicit comparator sorting 488 ................................................................. Section 81.4 Creating a Comparator using comparing method 489 ......................................................................... Section 81.5 Sorting Map entries 489 ............................................................................................................................. Chapter 82 Java Floating Point Operations 491 .............................................................................................. Section 82.1 Comparing \ufb02oating point values 491 ....................................................................................................... Section 82.2 OverFlow and UnderFlow 493 .................................................................................................................. Section 82.3 Formatting the \ufb02oating point values 494 ................................................................................................ Section 82.4 Strict Adherence to the IEEE Speci\ufb01cation 494 ....................................................................................... Chapter 83 Currency and Money 496 .................................................................................................................... Section 83.1 Add custom currency 496 ......................................................................................................................... Chapter 84 Object Cloning 497 ................................................................................................................................. Section 84.1 Cloning performing a deep copy 497 ...................................................................................................... Section 84.2 Cloning using a copy factory 498 ............................................................................................................ Section 84.3 Cloning using a copy constructor 498 ..................................................................................................... Section 84.4 Cloning by implementing Clonable interface 498 .................................................................................. Section 84.5 Cloning", "performing a shallow copy 499 ................................................................................................. Chapter 85 Recursion 501 ............................................................................................................................................ Section 85.1 The basic idea of recursion 501 ................................................................................................................ Section 85.2 Deep recursion is problematic in Java 501 ............................................................................................ Section 85.3 Types of Recursion 503 ............................................................................................................................. Section 85.4 Computing the Nth Fibonacci Number 503 ............................................................................................ Section 85.5 StackOver\ufb02owError recursion to loop 504 .......................................................................................... Section 85.6 Computing the Nth power of a number 506 ........................................................................................... Section 85.7 Traversing a Tree data structure with recursion 506 ............................................................................ Section 85.8 Reverse a string using Recursion 507 ..................................................................................................... Section 85.9 Computing the sum of integers from 1 to N 507 .................................................................................... Chapter 86 Converting to and from Strings 508 ............................................................................................. Section 86.1 Converting String to other datatypes 508 ............................................................................................... Section 86.2 Conversion to from bytes 509 ............................................................................................................... Section 86.3 Base64 Encoding Decoding 509 ............................................................................................................ Section 86.4 Converting other datatypes to String 510 .............................................................................................. Section 86.5 Getting a String from an InputStream 511 .......................................................................................... Chapter 87 Random Number Generation 512 .................................................................................................. Section 87.1 Pseudo Random Numbers 512 ................................................................................................................. Section 87.2 Pseudo Random Numbers in Speci\ufb01c Range 512 ................................................................................. Section 87.3 Generating cryptographically secure pseudorandom numbers 513 ................................................... Section 87.4 Generating Random Numbers with a Speci\ufb01ed Seed 513 .................................................................... Section 87.5 Select random numbers", "without duplicates 514 .................................................................................... Section 87.6 Generating Random number using apache-common lang3 515 ........................................................ Chapter 88 Singletons 516 .......................................................................................................................................... Section 88.1 Enum Singleton 516 ................................................................................................................................... Section 88.2 Singleton without use of Enum eager initialization 516 ...................................................................... Section 88.3 Thread-safe lazy initialization using holder class Bill Pugh Singleton implementation 517 ............ Section 88.4 Thread safe Singleton with double checked locking 517 ...................................................................... Section 88.5 Extending singleton singleton inheritance 518 .................................................................................... Chapter 89 Autoboxing 521 ......................................................................................................................................... Section 89.1 Using int and Integer interchangeably 521 ............................................................................................. Section 89.2 Auto-unboxing may lead to NullPointerException 522 .......................................................................... Section 89.3 Using Boolean in if statement 522 ........................................................................................................... Section 89.4 Dierent Cases When Integer and int can be used interchangeably 522 .......................................... Section 89.5 Memory and Computational Overhead of Autoboxing 524 ................................................................. Chapter 90 2D Graphics in Java 525 ...................................................................................................................... Section 90.1 Example 1 Draw and Fill a Rectangle Using Java 525 .......................................................................... Section 90.2 Example 2 Drawing and Filling Oval 527 ............................................................................................... Chapter 91 JAXB 528 ....................................................................................................................................................... Section 91.1 Reading an XML \ufb01le unmarshalling 528 ................................................................................................ Section 91.2 Writing an XML \ufb01le marshalling an object 528 ..................................................................................... Section 91.3 Manual \ufb01eldproperty XML mapping con\ufb01guration 529 ....................................................................... Section 91.4 Binding an XML namespace to a serializable", "Java class 530 ............................................................... Section 91.5 Using XmlAdapter to generate desired xml format 530 ........................................................................ Section 91.6 Using XmlAdapter to trim string 532 ........................................................................................................ Section 91.7 Automatic \ufb01eldproperty XML mapping con\ufb01guration XmlAccessorType 532 ............................ Section 91.8 Specifying a XmlAdapter instance to reuse existing data 534 ........................................................... Chapter 92 Class - Java Re\ufb02ection 537 ................................................................................................................ Section 92.1 getClass method of Object class 537 .................................................................................................... Chapter 93 Networking 538 ........................................................................................................................................ Section 93.1 Basic Client and Server Communication using a Socket 538 ................................................................ Section 93.2 Basic ClientServer Communication using UDP Datagram 540 ........................................................ Section 93.3 Loading TrustStore and KeyStore from InputStream 541 .................................................................... Section 93.4 Socket example - reading a web page using a simple socket 542 ...................................................... Section 93.5 Temporarily disable SSL veri\ufb01cation for testing purposes 543 ......................................................... Section 93.6 Downloading a \ufb01le using Channel 543 .................................................................................................... Section 93.7 Multicasting 544 ......................................................................................................................................... Chapter 94 NIO - Networking 547 ........................................................................................................................... Section 94.1 Using Selector to wait for events example with OPCONNECT 547 ................................................. Chapter 95 HttpURLConnection 549 ...................................................................................................................... Section 95.1 Get response body from a URL as a String 549 ..................................................................................... Section 95.2 POST data 550 ........................................................................................................................................... Section 95.3 Delete resource 550 ................................................................................................................................... Section 95.4 Check if resource exists 551 ..................................................................................................................... Chapter", "96 JAX-WS 553 ................................................................................................................................................ Section 96.1 Basic Authentication 553 ........................................................................................................................... Chapter 97 Nashorn JavaScript engine 554 ...................................................................................................... Section 97.1 Execute JavaScript \ufb01le 554 ........................................................................................................................ Section 97.2 Intercept script output 554 ....................................................................................................................... Section 97.3 Hello Nashorn 555 ..................................................................................................................................... Section 97.4 Evaluate Arithmetic Strings 555 ............................................................................................................... Section 97.5 Set global variables 555 ............................................................................................................................ Section 97.6 Set and get global variables 556 ............................................................................................................. Section 97.7 Usage of Java objects in JavaScript in Nashorn 556 ............................................................................ Section 97.8 Implementing an interface from script 557 ............................................................................................ Chapter 98 Java Native Interface 558 .................................................................................................................. Section 98.1 Calling C methods from Java 558 ........................................................................................................ Section 98.2 Calling Java methods from C callback 559 ..................................................................................... Section 98.3 Loading native libraries 561 ..................................................................................................................... Chapter 99 Functional Interfaces 563 ................................................................................................................... Section 99.1 List of standard Java Runtime Library functional interfaces by signature 563 .................................. Chapter 100 Fluent Interface 565 ............................................................................................................................ Section 100.1 Fluent programming style 565 ................................................................................................................ Section 100.2 Truth - Fluent Testing Framework 566 .................................................................................................. Chapter 101 Remote Method Invocation RMI 567 ......................................................................................... Section 101.1 Callback invoking methods on a client 567 ......................................................................................... Section 101.2 Simple RMI example with Client and Server implementation 571 ....................................................... Section 101.3 Client-Server invoking methods in one JVM from another 573 .......................................................... Chapter", "102 Iterator and Iterable 576 .................................................................................................................. Section 102.1 Removing elements using an iterator 576 ............................................................................................. Section 102.2 Creating your own Iterable 576 .............................................................................................................. Section 102.3 Using Iterable in for loop 577 .................................................................................................................. Section 102.4 Using the raw iterator 578 ...................................................................................................................... Chapter 103 Re\ufb02ection API 579 ................................................................................................................................. Section 103.1 Dynamic Proxies 579 ................................................................................................................................ Section 103.2 Introduction 580 ....................................................................................................................................... Section 103.3 Evil Java hacks with Re\ufb02ection 581 ....................................................................................................... Section 103.4 Misuse of Re\ufb02ection API to change private and \ufb01nal variables 583 ................................................... Section 103.5 Getting and Setting \ufb01elds 584 ................................................................................................................. Section 103.6 Call constructor 585 ................................................................................................................................. Section 103.7 Call constructor of nested class 586 ...................................................................................................... Section 103.8 Invoking a method 586 ............................................................................................................................ Section 103.9 Get Class given its fully quali\ufb01ed name 587 ....................................................................................... Section 103.10 Getting the Constants of an Enumeration 587 .................................................................................... Section 103.11 Call overloaded constructors using re\ufb02ection 588 ............................................................................... Chapter 104 ByteBuer 590 ....................................................................................................................................... Section 104.1 Basic Usage - Using DirectByteBuer 590 ............................................................................................ Section 104.2 Basic Usage - Creating a ByteBuer 590 ............................................................................................. Section 104.3 Basic Usage - Write Data to the Buer 591 .......................................................................................... Chapter 105 Applets 592 ............................................................................................................................................... Section 105.1 Minimal Applet 592 ................................................................................................................................... Section 105.2 Creating a GUI 593 ................................................................................................................................... Section 105.3 Open links from", "within the applet 593 ................................................................................................... Section 105.4 Loading images, audio and other resources 594 ................................................................................. Chapter 106 Expressions 596 ...................................................................................................................................... Section 106.1 Operator Precedence 596 ........................................................................................................................ Section 106.2 Expression Basics 597 .............................................................................................................................. Section 106.3 Expression evaluation order 598 ............................................................................................................ Section 106.4 Constant Expressions 599 ....................................................................................................................... Chapter 107 JSON in Java 601 .................................................................................................................................. Section 107.1 Using Jackson Object Mapper 601 ......................................................................................................... Section 107.2 JSON To Object Gson Library 602 ....................................................................................................... Section 107.3 JSONObject.NULL 602 ............................................................................................................................. Section 107.4 JSON Builder - chaining methods 603 ................................................................................................... Section 107.5 Object To JSON Gson Library 603 ....................................................................................................... Section 107.6 JSON Iteration 603 ................................................................................................................................... Section 107.7 optXXX vs getXXX methods 604 ............................................................................................................. Section 107.8 Extract single element from JSON 604 .................................................................................................. Section 107.9 JsonArray to Java List Gson Library 604 ........................................................................................... Section 107.10 Encoding data as JSON 605 .................................................................................................................. Section 107.11 Decoding JSON data 605 ....................................................................................................................... Chapter 108 XML Parsing using the JAXP APIs 607 ......................................................................................... Section 108.1 Parsing a document using the StAX API 607 .......................................................................................... Section 108.2 Parsing and navigating a document using the DOM API 608 ............................................................. Chapter 109 XML XPath Evaluation 610 ................................................................................................................ Section 109.1 Parsing multiple XPath Expressions in a single XML 610 ...................................................................... Section 109.2 Parsing single XPath Expression", "multiple times in an XML 610 .......................................................... Section 109.3 Evaluating a NodeList in an XML document 611 .................................................................................. Chapter 110 XOM - XML Object Model 612 ........................................................................................................... Section 110.1 Reading a XML \ufb01le 612 .............................................................................................................................. Section 110.2 Writing to a XML File 614 ......................................................................................................................... Chapter 111 Polymorphism 617 .................................................................................................................................. Section 111.1 Method Overriding 617 ............................................................................................................................... Section 111.2 Method Overloading 618 ........................................................................................................................... Section 111.3 Polymorphism and dierent types of overriding 619 ............................................................................ Section 111.4 Virtual functions 622 .................................................................................................................................. Section 111.5 Adding behaviour by adding classes without touching existing code 623 .......................................... Chapter 112 Encapsulation 625 .................................................................................................................................. Section 112.1 Encapsulation to maintain invariants 625 ............................................................................................... Section 112.2 Encapsulation to reduce coupling 626 .................................................................................................... Chapter 113 Java Agents 627 ...................................................................................................................................... Section 113.1 Modifying classes with agents 627 ........................................................................................................... Section 113.2 Adding an agent at runtime 627 ............................................................................................................. Section 113.3 Setting up a basic agent 628 .................................................................................................................... Chapter 114 Varargs Variable Argument 629 ................................................................................................ Section 114.1 Working with Varargs parameters 629 ................................................................................................... Section 114.2 Specifying a varargs parameter 629 ...................................................................................................... Chapter 115 Logging java.util.logging 630 ....................................................................................................... Section 115.1 Logging complex messages eciently 630 ......................................................................................... Section 115.2 Using the default logger 631 ................................................................................................................... Section 115.3 Logging levels 632 .................................................................................................................................... Chapter 116 log4j log4j2 634", ".................................................................................................................................. Section 116.1 Properties-File to log to DB 634 ............................................................................................................... Section 116.2 How to get Log4j 634 ................................................................................................................................ Section 116.3 Setting up property \ufb01le 635 ...................................................................................................................... Section 116.4 Basic log4j2.xml con\ufb01guration \ufb01le 636 ................................................................................................... Section 116.5 How to use Log4j in Java code 636 ........................................................................................................ Section 116.6 Migrating from log4j 1.x to 2.x 637 ........................................................................................................... Section 116.7 Filter Logoutput by level log4j 1.x 638 ................................................................................................... Chapter 117 Oracle Ocial Code Standard 639 ............................................................................................... Section 117.1 Naming Conventions 639 .......................................................................................................................... Section 117.2 Class Structure 640 ................................................................................................................................... Section 117.3 Annotations 641 ......................................................................................................................................... Section 117.4 Import statements 641 ............................................................................................................................. Section 117.5 Braces 642 ................................................................................................................................................. Section 117.6 Redundant Parentheses 643 .................................................................................................................... Section 117.7 Modi\ufb01ers 643 .............................................................................................................................................. Section 117.8 Indentation 644 .......................................................................................................................................... Section 117.9 Literals 644 ................................................................................................................................................. Section 117.10 Package declaration 644 ........................................................................................................................ Section 117.11 Lambda Expressions 644 ......................................................................................................................... Section 117.12 Java Source Files 645 .............................................................................................................................. Section 117.13 Wrapping statements 645 ....................................................................................................................... Section 117.14 Wrapping Method Declarations 646 ...................................................................................................... Section 117.15 Wrapping Expressions 646 ...................................................................................................................... Section 117.16 Whitespace 647 ........................................................................................................................................ Section 117.17 Special Characters 647 ............................................................................................................................ Section 117.18 Variable Declarations 648 ....................................................................................................................... Chapter 118 Character encoding 649 ..................................................................................................................... Section 118.1 Reading text from a \ufb01le encoded in UTF-8 649 ..................................................................................... Section 118.2 Writing text", "to a \ufb01le in UTF-8 649 ............................................................................................................ Section 118.3 Getting byte representation of a string in UTF-8 650 ........................................................................... Chapter 119 Apache Commons Lang 651 ............................................................................................................. Section 119.1 Implement equals method 651 .............................................................................................................. Section 119.2 Implement hashCode method 651 ....................................................................................................... Section 119.3 Implement toString method 652 ........................................................................................................... Chapter 120 Localization and Internationalization 654 ................................................................................ Section 120.1 Locale 654 .................................................................................................................................................. Section 120.2 Automatically formatted Dates using locale 655 .............................................................................. Section 120.3 String Comparison 655 ............................................................................................................................ Chapter 121 Parallel programming with ForkJoin framework 656 ...................................................... Section 121.1 ForkJoin Tasks in Java 656 .................................................................................................................... Chapter 122 Non-Access Modi\ufb01ers 658 ................................................................................................................. Section 122.1 \ufb01nal 658 ...................................................................................................................................................... Section 122.2 static 659 ................................................................................................................................................... Section 122.3 abstract 660 .............................................................................................................................................. Section 122.4 strictfp 661 ................................................................................................................................................ Section 122.5 volatile 661 ................................................................................................................................................ Section 122.6 synchronized 662 ..................................................................................................................................... Section 122.7 transient 663 ............................................................................................................................................. Chapter 123 Process 664 ............................................................................................................................................... Section 123.1 Pitfall Runtime.exec, Process and ProcessBuilder dont understand shell syntax 664 ...................... Section 123.2 Simple example Java version 1.5 666 ............................................................................................... Chapter 124 Java Native Access 667 ..................................................................................................................... Section 124.1 Introduction to JNA 667 ........................................................................................................................... Chapter 125 Modules 668 .............................................................................................................................................. Section 125.1 De\ufb01ning a basic module 668 ................................................................................................................... Chapter 126 Concurrent Programming Threads 669 .................................................................................. Section 126.1 Callable and Future 669", "........................................................................................................................... Section 126.2 CountDownLatch 670 ............................................................................................................................... Section 126.3 Basic Multithreading 672 ......................................................................................................................... Section 126.4 Locks as Synchronisation aids 673 ......................................................................................................... Section 126.5 Semaphore 674 ........................................................................................................................................ Section 126.6 Synchronization 675 ................................................................................................................................. Section 126.7 Runnable Object 676 ................................................................................................................................ Section 126.8 Creating basic deadlocked system 677 ................................................................................................. Section 126.9 Creating a java.lang.Thread instance 679 ............................................................................................. Section 126.10 Atomic operations 680 ........................................................................................................................... Section 126.11 Exclusive write Concurrent read access 681 ...................................................................................... Section 126.12 Producer-Consumer 682 ........................................................................................................................ Section 126.13 Visualizing readwrite barriers while using synchronized volatile 684 ........................................... Section 126.14 Get status of all threads started by your program excluding system threads 685 ........................ Section 126.15 Using ThreadLocal 686 ........................................................................................................................... Section 126.16 Multiple producerconsumer example with shared global queue 687 ............................................. Section 126.17 Add two int arrays using a Threadpool 688 ....................................................................................... Section 126.18 Pausing Execution 689 ............................................................................................................................ Section 126.19 Thread Interruption Stopping Threads 690 ....................................................................................... Chapter 127 Executor, ExecutorService and Thread pools 693 ................................................................ Section 127.1 ThreadPoolExecutor 693 .......................................................................................................................... Section 127.2 Retrieving value from computation - Callable 694 ............................................................................... Section 127.3 submit vs execute exception handling dierences 695 .................................................................. Section 127.4 Handle Rejected Execution 697 .............................................................................................................. Section 127.5 Fire and Forget - Runnable Tasks 697 ................................................................................................... Section 127.6 Use cases for dierent types", "of concurrency constructs 698 ............................................................. Section 127.7 Wait for completion of all tasks in ExecutorService 699 ...................................................................... Section 127.8 Use cases for dierent types of ExecutorService 701 .......................................................................... Section 127.9 Scheduling tasks to run at a \ufb01xed time, after a delay or repeatedly 703 .......................................... Section 127.10 Using Thread Pools 704 ......................................................................................................................... Chapter 128 ThreadLocal 705 .................................................................................................................................... Section 128.1 Basic ThreadLocal usage 705 .................................................................................................................. Section 128.2 ThreadLocal Java 8 functional initialization 706 .................................................................................. Section 128.3 Multiple threads with one shared object 707 ........................................................................................ Chapter 129 Using ThreadPoolExecutor in MultiThreaded applications. 709 .................................... Section 129.1 Performing Asynchronous Tasks Where No Return Value Is Needed Using a Runnable Class Instance 709 .............................................................................................................................................................. Section 129.2 Performing Asynchronous Tasks Where a Return Value Is Needed Using a Callable Class Instance 710 .............................................................................................................................................................. Section 129.3 De\ufb01ning Asynchronous Tasks Inline using Lambdas 713 .................................................................... Chapter 130 Common Java Pitfalls 715 ................................................................................................................ Section 130.1 Pitfall using to compare primitive wrappers objects such as Integer 715 ..................................... Section 130.2 Pitfall using to compare strings 715 ................................................................................................. Section 130.3 Pitfall forgetting to free resources 717 ................................................................................................. Section 130.4 Pitfall testing a \ufb01le before attempting to open it 718 .......................................................................... Section 130.5 Pitfall thinking of variables as objects 719", "........................................................................................... Section 130.6 Pitfall memory leaks 722 ........................................................................................................................ Section 130.7 Pitfall Not understanding that String is an immutable class 723 ....................................................... Section 130.8 Pitfall combining assignment and side-eects 724 ............................................................................. Chapter 131 Java Pitfalls - Exception usage 725 .............................................................................................. Section 131.1 Pitfall - Catching Throwable, Exception, Error or RuntimeException 725 ............................................ Section 131.2 Pitfall - Ignoring or squashing exceptions 726 ....................................................................................... Section 131.3 Pitfall - Throwing Throwable, Exception, Error or RuntimeException 727 ........................................... Section 131.4 Pitfall - Using exceptions for normal \ufb02owcontrol 728 ........................................................................... Section 131.5 Pitfall - Directly subclassing Throwable 729 ......................................................................................... Section 131.6 Pitfall - Catching InterruptedException 729 ............................................................................................ Section 131.7 Pitfall - Excessive or inappropriate stacktraces 731 .............................................................................. Chapter 132 Java Pitfalls - Language syntax 732 ........................................................................................... Section 132.1 Pitfall - Missing a break in a switch case 732 ...................................................................................... Section 132.2 Pitfall - Declaring classes with the same names as standard classes 732 ........................................ Section 132.3 Pitfall - Leaving out braces the dangling if and dangling else problems 733 ............................. Section 132.4 Pitfall - Octal literals 735 .......................................................................................................................... Section 132.5 Pitfall - Using to test a boolean 735 ................................................................................................. Section 132.6 Pitfall - Ignoring method visibility 736 .................................................................................................... Section 132.7 Pitfall Using assert for argument", "or user input validation 736 ......................................................... Section 132.8 Pitfall - Wildcard imports can make your code fragile 737 ................................................................. Section 132.9 Pitfall - Misplaced semicolons and missing braces 738 ....................................................................... Section 132.10 Pitfall - Overloading instead of overriding 739 .................................................................................... Section 132.11 Pitfall of Auto-Unboxing Null Objects into Primitives 740 .................................................................... Chapter 133 Java Pitfalls - Threads and Concurrency 741 ......................................................................... Section 133.1 Pitfall - Extending java.lang.Thread 741 ................................................................................................ Section 133.2 Pitfall - Too many threads makes an application slower 742 ............................................................. Section 133.3 Pitfall incorrect use of wait notify 743 ........................................................................................... Section 133.4 Pitfall Shared variables require proper synchronization 743 .............................................................. Section 133.5 Pitfall - Thread creation is relatively expensive 746 ............................................................................. Chapter 134 Java Pitfalls - Nulls and NullPointerException 749 ............................................................. Section 134.1 Pitfall - Making good unexpected nulls 749 ......................................................................................... Section 134.2 Pitfall - Using null to represent an empty array or collection 750 ...................................................... Section 134.3 Pitfall - Not checking if an IO stream isnt even initialized when closing it 751 ............................... Section 134.4 Pitfall - Returning null instead of throwing an exception 751 .............................................................. Section 134.5 Pitfall - Unnecessary use of Primitive Wrappers can lead to NullPointerExceptions 752 ................ Section 134.6 Pitfall - Using", "Yoda notation to avoid NullPointerException 753 ...................................................... Chapter 135 Java Pitfalls - Performance Issues 754 ...................................................................................... Section 135.1 Pitfall - String concatenation in a loop does not scale 754 .................................................................. Section 135.2 Pitfall - Using size to test if a collection is empty is inecient 755 .................................................. Section 135.3 Pitfall - Interning strings so that you can use is a bad idea 755 ..................................................... Section 135.4 Pitfall - Using new to create primitive wrapper instances is inecient 757 ..................................... Section 135.5 Pitfall - Eciency concerns with regular expressions 757 ................................................................... Section 135.6 Pitfall - Small reads writes on unbuered streams are inecient 760 ........................................... Section 135.7 Pitfall - Over-use of primitive wrapper types is inecient 762 ............................................................ Section 135.8 Pitfall - The overheads of creating log messages 763 ......................................................................... Section 135.9 Pitfall - Iterating a Maps keys can be inecient 764 ........................................................................... Section 135.10 Pitfall - Calling System.gc is inecient 764 ....................................................................................... Section 135.11 Pitfall - Calling new StringString is inecient 765 ............................................................................ Chapter 136 ServiceLoader 766 ................................................................................................................................ Section 136.1 Simple ServiceLoader Example 766 ........................................................................................................ Section 136.2 Logger Service 767 ................................................................................................................................... Chapter 137 Classloaders 769 .................................................................................................................................... Section 137.1 Implementing a custom classLoader 769 ............................................................................................... Section 137.2 Loading an external", ".class \ufb01le 769 .......................................................................................................... Section 137.3 Instantiating and using a classloader 770 ............................................................................................. Chapter 138 Creating Images Programmatically 772 ................................................................................... Section 138.1 Creating a simple image programmatically and displaying it 772 ..................................................... Section 138.2 Save an Image to disk 773 ...................................................................................................................... Section 138.3 Setting individual pixels color in BueredImage 773 ........................................................................... Section 138.4 Specifying image rendering quality 774 ................................................................................................ Section 138.5 Creating an image with BueredImage class 776 ............................................................................... Section 138.6 Editing and re-using image with BueredImage 777 ........................................................................... Section 138.7 How to scale a BueredImage 778 ........................................................................................................ Chapter 139 Atomic Types 779 .................................................................................................................................. Section 139.1 Creating Atomic Types 779 ...................................................................................................................... Section 139.2 Motivation for Atomic Types 779 ............................................................................................................ Chapter 140 RSA Encryption 783 ............................................................................................................................. Section 140.1 An example using a hybrid cryptosystem consisting of OAEP and GCM 783 .................................... Chapter 141 Secure objects 788 ................................................................................................................................ Section 141.1 SealedObject javax.crypto.SealedObject 788 ...................................................................................... Section 141.2 SignedObject java.security.SignedObject 788 ..................................................................................... Chapter 142 Security Cryptography 790 ......................................................................................................... Section 142.1 Compute Cryptographic Hashes 790 ...................................................................................................... Section 142.2 Encrypt and Decrypt Data with Public Private Keys 790 .................................................................. Section 142.3 Generate Cryptographically Random Data 791 ................................................................................... Section 142.4 Generate Public Private Key Pairs 791 ................................................................................................ Section 142.5 Compute and Verify Digital Signatures 792 ..........................................................................................", "Chapter 143 Security Cryptography 793 ......................................................................................................... Section 143.1 The JCE 793 ............................................................................................................................................... Section 143.2 Keys and Key Management 793 ............................................................................................................ Section 143.3 Common Java vulnerabilities 793 .......................................................................................................... Section 143.4 Networking Concerns 793 ....................................................................................................................... Section 143.5 Randomness and You 793 ....................................................................................................................... Section 143.6 Hashing and Validation 793 .................................................................................................................... Chapter 144 SecurityManager 795 ......................................................................................................................... Section 144.1 Sandboxing classes loaded by a ClassLoader 795 ............................................................................... Section 144.2 Enabling the SecurityManager 796 ........................................................................................................ Section 144.3 Implementing policy deny rules 796 ...................................................................................................... Chapter 145 JNDI 804 .................................................................................................................................................... Section 145.1 RMI through JNDI 804 .............................................................................................................................. Chapter 146 sun.misc.Unsafe 808 ............................................................................................................................ Section 146.1 Instantiating sun.misc.Unsafe via re\ufb02ection 808 .................................................................................... Section 146.2 Instantiating sun.misc.Unsafe via bootclasspath 808 ........................................................................... Section 146.3 Getting Instance of Unsafe 808 .............................................................................................................. Section 146.4 Uses of Unsafe 809 .................................................................................................................................. Chapter 147 Java Memory Model 810 ................................................................................................................... Section 147.1 Motivation for the Memory Model 810 .................................................................................................... Section 147.2 Happens-before relationships 812 ......................................................................................................... Section 147.3 How to avoid needing to understand the Memory Model 813 ............................................................ Section 147.4 Happens-before reasoning applied to some examples 814 ............................................................... Chapter 148 Java deployment 817 ......................................................................................................................... Section 148.1 Making an executable JAR from the command line 817 ..................................................................... Section 148.2 Creating an UberJAR for an application and its dependencies", "818 .................................................. Section 148.3 Creating JAR, WAR and EAR \ufb01les 819 ................................................................................................... Section 148.4 Introduction to Java Web Start 820 ....................................................................................................... Chapter 149 Java plugin system implementations 823 ............................................................................... Section 149.1 Using URLClassLoader 823 ...................................................................................................................... Chapter 150 JavaBean 827 ......................................................................................................................................... Section 150.1 Basic Java Bean 827 ................................................................................................................................ Chapter 151 Java SE 7 Features 828 ....................................................................................................................... Section 151.1 New Java SE 7 programming language features 828 .......................................................................... Section 151.2 Binary Literals 828 .................................................................................................................................... Section 151.3 The try-with-resources statement 828 ................................................................................................... Section 151.4 Underscores in Numeric Literals 829 ...................................................................................................... Section 151.5 Type Inference for Generic Instance Creation 829 ................................................................................ Section 151.6 Strings in switch Statements 829 ............................................................................................................. Chapter 152 Java SE 8 Features 831 ...................................................................................................................... Section 152.1 New Java SE 8 programming language features 831 ......................................................................... Chapter 153 Dynamic Method Dispatch 832 ....................................................................................................... Section 153.1 Dynamic Method Dispatch - Example Code 832 ................................................................................... Chapter 154 Generating Java Code 835 .............................................................................................................. Section 154.1 Generate POJO From JSON 835 ............................................................................................................. Chapter 155 JShell 836 .................................................................................................................................................. Section 155.1 Editting Snippets 836 ................................................................................................................................ Section 155.2 Entering and Exiting JShell 837 ............................................................................................................... Section 155.3 Expressions 837 ........................................................................................................................................ Section 155.4 Methods and Classes 838 ........................................................................................................................ Section 155.5 Variables 838 ............................................................................................................................................ Chapter 156 Stack-Walking API 839 ........................................................................................................................ Section", "156.1 Print all stack frames of the current thread 839 .................................................................................... Section 156.2 Print current caller class 840 ................................................................................................................... Section 156.3 Showing re\ufb02ection and other hidden frames 840 ................................................................................. Chapter 157 Sockets 842 .............................................................................................................................................. Section 157.1 Read from socket 842 .............................................................................................................................. Chapter 158 Java Sockets 843 .................................................................................................................................. Section 158.1 A simple TCP echo back server 843 ........................................................................................................ Chapter 159 FTP File Transfer Protocol 846 .................................................................................................... Section 159.1 Connecting and Logging Into a FTP Server 846 .................................................................................... Chapter 160 Using Other Scripting Languages in Java 851 ....................................................................... Section 160.1 Evaluating A JavaScript \ufb01le in -scripting mode of nashorn 851 .......................................................... Chapter 161 C Comparison 854 ............................................................................................................................. Section 161.1 Static Class Members 854 ......................................................................................................................... Section 161.2 Classes De\ufb01ned within Other Constructs 854 ........................................................................................ Section 161.3 Pass-by-value Pass-by-reference 856 ................................................................................................ Section 161.4 Inheritance vs Composition 857 .............................................................................................................. Section 161.5 Outcast Downcasting 857 ........................................................................................................................ Section 161.6 Abstract Methods Classes 857 ............................................................................................................. Chapter 162 Audio 859 .................................................................................................................................................... Section 162.1 Play a MIDI \ufb01le 859 .................................................................................................................................... Section 162.2 Play an Audio \ufb01le Looped 860 ................................................................................................................ Section 162.3 Basic audio output 860 ............................................................................................................................ Section 162.4 Bare metal sound 861 .............................................................................................................................. Chapter 163 Java Print Service 863 ........................................................................................................................ Section 163.1 Building the Doc that will be printed", "863 ................................................................................................ Section 163.2 Discovering the available print services 863 ......................................................................................... Section 163.3 De\ufb01ning print request attributes 864 ...................................................................................................... Section 163.4 Listening print job request status change 864 ...................................................................................... Section 163.5 Discovering the default print service 866 .............................................................................................. Section 163.6 Creating a print job from a print service 866 ........................................................................................ Chapter 164 CompletableFuture 868 ..................................................................................................................... Section 164.1 Simple Example of CompletableFuture 868 ........................................................................................... Chapter 165 Runtime Commands 869 .................................................................................................................... Section 165.1 Adding shutdown hooks 869 .................................................................................................................... Chapter 166 Unit Testing 870 ...................................................................................................................................... Section 166.1 What is Unit Testing? 870 ......................................................................................................................... Chapter 167 Asserting 873 ........................................................................................................................................... Section 167.1 Checking arithmetic with assert 873 ....................................................................................................... Chapter 168 Multi-Release JAR Files 874 ............................................................................................................. Section 168.1 Example of a multi-release Jar \ufb01les contents 874 ............................................................................... Section 168.2 Creating a multi-release Jar using the jar tool 874 .............................................................................. Section 168.3 URL of a loaded class inside a multi-release Jar 875 .......................................................................... Chapter 169 Just in Time JIT compiler 877 ...................................................................................................... Section 169.1 Overview 877 ............................................................................................................................................. Chapter 170 Bytecode Modi\ufb01cation 879 ............................................................................................................... Section 170.1 What is Bytecode? 879 ............................................................................................................................. Section 170.2 How to edit jar \ufb01les with ASM 880 .......................................................................................................... Section 170.3 How to load a ClassNode as a Class 882 .............................................................................................. Section 170.4 How", "to rename classes in a jar \ufb01le 883 ................................................................................................. Section 170.5 Javassist Basic 883 .................................................................................................................................. Chapter 171 Disassembling and Decompiling 885 ............................................................................................ Section 171.1 Viewing bytecode with javap 885 ............................................................................................................. Chapter 172 JMX 892 ...................................................................................................................................................... Section 172.1 Simple example with Platform MBean Server 892 ................................................................................ Chapter 173 Java Virtual Machine JVM 896 .................................................................................................... Section 173.1 These are the basics 896 .......................................................................................................................... Chapter 174 XJC 897 ....................................................................................................................................................... Section 174.1 Generating Java code from simple XSD \ufb01le 897 ................................................................................... Chapter 175 JVM Flags 900 ......................................................................................................................................... Section 175.1 -XXaggressive 900 .................................................................................................................................... Section 175.2 -XXallocClearChunks 900 ......................................................................................................................... Section 175.3 -XXallocClearChunkSize 900 .................................................................................................................... Section 175.4 -XXcallPro\ufb01ling 900 .................................................................................................................................. Section 175.5 -XXdisableFatSpin 901 ............................................................................................................................. Section 175.6 -XXdisableGCHeuristics 901 .................................................................................................................... Section 175.7 -XXdumpSize 901 ...................................................................................................................................... Section 175.8 -XXexitOnOutOfMemory 902 ................................................................................................................... Chapter 176 JVM Tool Interface 903 ...................................................................................................................... Section 176.1 Iterate over objects reachable from object Heap 1.0 903 .................................................................. Section 176.2 Get JVMTI environment 905 .................................................................................................................... Section 176.3 Example of initialization inside of AgentOnLoad method 905 .......................................................... Chapter 177 Java Memory Management 907 .................................................................................................... Section 177.1 Setting the Heap, PermGen and Stack sizes 907 ................................................................................... Section 177.2 Garbage collection 908 ............................................................................................................................ Section 177.3 Memory leaks in Java 910 ....................................................................................................................... Section 177.4 Finalization 911 ......................................................................................................................................... Section 177.5", "Manually triggering GC 912 ..................................................................................................................... Chapter 178 Java Performance Tuning 913 ....................................................................................................... Section 178.1 An evidence-based approach to Java performance tuning 913 ........................................................ Section 178.2 Reducing amount of Strings 914 ............................................................................................................ Section 178.3 General approach 914 ............................................................................................................................. Chapter 179 Benchmarks 916 ..................................................................................................................................... Section 179.1 Simple JMH example 916 ......................................................................................................................... Chapter 180 FileUpload to AWS 919 ....................................................................................................................... Section 180.1 Upload \ufb01le to s3 bucket 919 .................................................................................................................... Chapter 181 AppDynamics and TIBCO BusinessWorks Instrumentation for Easy Integration 921 ................................................................................................................................................................... Section 181.1 Example of Instrumentation of all BW Applications in a Single Step for Appdynamics 921 ............. Appendix A Installing Java Standard Edition 922 ........................................................................................ Section A.1 Setting PATH and JAVAHOME after installing on Windows 922 .............................................. Section A.2 Installing a Java JDK on Linux 923 ........................................................................................................... Section A.3 Installing a Java JDK on macOS 925 ........................................................................................................ Section A.4 Installing a Java JDK or JRE on Windows 926 ........................................................................................ Section A.5 Con\ufb01guring and switching Java versions on Linux using alternatives 927 .......................................... Section A.6 What do I need for Java Development 928 ............................................................................................. Section A.7 Selecting an appropriate Java SE release 928 ........................................................................................ Section A.8 Java release and version naming 929 ...................................................................................................... Section A.9 Installing Oracle Java on Linux with latest tar", "\ufb01le 929 ............................................................................ Section A.10 Post-installation checking and con\ufb01guration on Linux 930 ................................................................... Appendix B Java Editions, Versions, Releases and Distributions 933 ................................................... Section B.1 Dierences between Java SE JRE or Java SE JDK distributions 933 .................................................... Section B.2 Java SE Versions 934 .................................................................................................................................. Section B.3 Dierences between Java EE, Java SE, Java ME and JavaFX 935 ....................................................... Appendix C The Classpath 937 .................................................................................................................................. Section C.1 Dierent ways to specify the classpath 937 ............................................................................................. Section C.2 Adding all JARs in a directory to the classpath 937 ................................................................................ Section C.3 Load a resource from the classpath 938 .................................................................................................. Section C.4 Classpath path syntax 938 ......................................................................................................................... Section C.5 Dynamic Classpath 939 .............................................................................................................................. Section C.6 Mapping classnames to pathnames 939 .................................................................................................. Section C.7 The bootstrap classpath 939 ..................................................................................................................... Section C.8 What the classpath means how searches work 940 .............................................................................. Appendix D Resources on classpath 941 .......................................................................................................... Section D.1 Loading default con\ufb01guration 941 ............................................................................................................ Section D.2 Loading an image from a resource 941 ................................................................................................... Section D.3 Finding and reading resources using a classloader 941 ........................................................................ Section D.4 Loading same-name resource from multiple JARs 943 ......................................................................... Credits 944 ............................................................................................................................................................................ You may also like 958 ...................................................................................................................................................... GoalKicker.com Java Notes for Professionals 1About Please feel free", "to share this PDF with anyone for free, latest version of this book can be downloaded from httpsgoalkicker.comJavaBook This Java Notes for Professionals book is compiled from Stack Over\ufb02ow Documentation , the content is written by the beautiful people at Stack Over\ufb02ow. Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise speci\ufb01ed This is an uno\ufb03cial free book created for educational purposes and is not a\ufb03liated with o\ufb03cial Java groups or companys nor Stack Over\ufb02ow. All trademarks and registered trademarks are the property of their respective company owners The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk Please send feedback and corrections to webpetercv.com GoalKicker.com Java Notes for Professionals 2Chapter 1 Getting started with Java Language Java SE Version Code Name End-of-life free1 Release Date Java SE 10 Early Access None future 2018-03-20 Java SE 9 None future 2017-07-27 Java SE 8 Spider future 2014-03-18 Java SE 7 Dolphin 2015-04-14 2011-07-28 Java SE 6 Mustang 2013-04-16 2006-12-23 Java SE 5 Tiger 2009-11-04 2004-10-04 Java SE 1.4", "Merlin prior to 2009-11-04 2002-02-06 Java SE 1.3 Kestrel prior to 2009-11-04 2000-05-08 Java SE 1.2 Playground prior to 2009-11-04 1998-12-08 Java SE 1.1 None prior to 2009-11-04 1997-02-19 Java SE 1.0 Oak prior to 2009-11-04 1996-01-21 Section 1.1 Creating Your First Java Program Create a new \ufb01le in your text editor or IDE named HelloWorld. java . Then paste this code block into the \ufb01le and save public class HelloWorld public static void mainString args System.out.printlnHello, World! Run live on Ideone Note For Java to recognize this as a public class and not throw a compile time error , the \ufb01lename must be the same as the class name HelloWorld in this example with a .java extension. There should also be a public access modi\ufb01er before it. Naming conventions recommend that Java classes begin with an uppercase character, and be in camel case format in which the \ufb01rst letter of each word is capitalized. The conventions recommend against underscores and dollar signs . To compile, open a terminal window and navigate to the directory of HelloWorld. java cd pathtocontaining folder Note cd is the terminal command to change directory. Enter javac followed by the \ufb01le name and extension", "as follows javac HelloWorld. java Its fairly common to get the error javac is not recognized as an internal or external command, operable program or batch file. even when you have installed the JDK and are able to run the program from IDE ex. eclipse etc. Since the path is not added to the environment by default. GoalKicker.com Java Notes for Professionals 3In case you get this on windows, to resolve, \ufb01rst try browsing to your javac.exe path, its most probably in your CProgram FilesJavajdk version number bin . Then try running it with below. CProgram FilesJavajdk version number binjavac HelloWorld. java Previously when we were calling javac it was same as above command. Only in that case your OS knew where javac resided. So lets tell it now, this way you dont have to type the whole path every-time. We would need to add this to our PATH To edit the PATH environment variable in Windows XPVista7810 Control Panel System Advanced system settings Switch to Advanced tab Environment Variables In System Variables, scroll down to select PATH Edit You cannot undo this so be careful. First copy your existing path to notepad. Then to get the exact PATH", "to your javac browse manually to the folder where javac resides and click on the address bar and then copy it. It should look something like cProgram FilesJavajdk1.8.0xxbin In Variable value \ufb01eld, paste this IN FRONT of all the existing directories, followed by a semi-colon . DO NOT DELETE any existing entries. Variable name PATH Variable value cProgram FilesJavajdk1.8.0xxbin Existing Entries... Now this should resolve. For Linux Based systems try here . Note The javac command invokes the Java compiler. The compiler will then generate a bytecode \ufb01le called HelloWorld. class which can be executed in the Java Virtual Machine JVM . The Java programming language compiler, javac , reads source \ufb01les written in the Java programming language and compiles them into bytecode class \ufb01les. Optionally, the compiler can also process annotations found in source and class \ufb01les using the Pluggable Annotation Processing API. The compiler is a command line tool but can also be invoked using the Java Compiler API. To run your program, enter java followed by the name of the class which contains the main method HelloWorld in our example. Note how the .class is omitted java HelloWorld Note The java command runs a Java application.", "This will output to your console Hello, World! You have successfully coded and built your very \ufb01rst Java program! Note In order for Java commands java , javac , etc to be recognized, you will need to make sure A JDK is installed e.g. Oracle , OpenJDK and other sources GoalKicker.com Java Notes for Professionals 4Your environment variables are properly set up You will need to use a compiler javac and an executor java provided by your JVM. To \ufb01nd out which versions you have installed, enter java -version and javac -version on the command line. The version number of your program will be printed in the terminal e.g. 1.8.073 . A closer look at the Hello World program The Hello World program contains a single \ufb01le, which consists of a HelloWorld class de\ufb01nition, a main method, and a statement inside the main method. public class HelloWorld The class keyword begins the class de\ufb01nition for a class named HelloWorld . Every Java application contains at least one class de\ufb01nition Further information about classes. public static void mainString args This is an entry point method de\ufb01ned by its name and signature of public static void mainString from which the JVM", "can run your program. Every Java program should have one. It is public meaning that the method can be called from anywhere mean from outside the program as well. See Visibility for more information on this. static meaning it exists and can be run by itself at the class level without creating an object. void meaning it returns no value. Note This is unlike C and C where a return code such as int is expected Javas way is System.exit. This main method accepts An array typically called args of String s passed as arguments to main function e.g. from command line arguments. Almost all of this is required for a Java entry point method. Non-required parts The name args is a variable name, so it can be called anything you want, although it is typically called args . Whether its parameter type is an array String args or Varargs String... args does not matter because arrays can be passed into varargs. Note A single application may have multiple classes containing an entry point main method. The entry point of the application is determined by the class name passed as an argument to the java command. Inside the main", "method, we see the following statement System.out.printlnHello, World! Lets break down this statement element-by-element Element Purpose Systemthis denotes that the subsequent expression will call upon the System class, from the java.lang package. GoalKicker.com Java Notes for Professionals 5.this is a dot operator. Dot operators provide you access to a classes members1 i.e. its \ufb01elds variables and its methods. In this case, this dot operator allows you to reference the out static \ufb01eld within the System class. outthis is the name of the static \ufb01eld of PrintStream type within the System class containing the standard output functionality. .this is another dot operator. This dot operator provides access to the println method within the out variable. printlnthis is the name of a method within the PrintStream class. This method in particular prints the contents of the parameters into the console and inserts a newline after. this parenthesis indicates that a method is being accessed and not a \ufb01eld and begins the parameters being passed into the println method. Hello, World!this is the String literal that is passed as a parameter, into the println method. The double quotation marks on each end delimit the text as a String. this parenthesis signi\ufb01es the", "closure of the parameters being passed into the println method. this semicolon marks the end of the statement. Note Each statement in Java must end with a semicolon . The method body and class body are then closed. end of main function scope end of class HelloWorld scope Heres another example demonstrating the OO paradigm. Lets model a football team with one yes, one! member. There can be more, but well discuss that when we get to arrays. First, lets de\ufb01ne our Team class public class Team Member member public TeamMember member who is in this Team? this.member member one member is in this Team! Now, lets de\ufb01ne our Member class class Member private String name private String type private int level note the data type here private int rank note the data type here as well public MemberString name, String type, int level, int rank this.name name this.type type this.level level this.rank rank Why do we use private here? Well, if someone wanted to know your name, they should ask you directly, instead of reaching into your pocket and pulling out your Social Security card. This private does something like that it prevents outside entities from accessing your", "variables. You can only return private members through getter functions shown below. GoalKicker.com Java Notes for Professionals 6After putting it all together, and adding the getters and main method as discussed before, we have public class Team Member member public TeamMember member this.member member heres our main method public static void mainString args Member myMember new MemberAurieel , light, 10, 1 Team myTeam new TeammyMember System.out.printlnmyTeam.member.getName System.out.printlnmyTeam.member.getType System.out.printlnmyTeam.member.getLevel System.out.printlnmyTeam.member.getRank class Member private String name private String type private int level private int rank public MemberString name, String type, int level, int rank this.name name this.type type this.level level this.rank rank lets define our getter functions here public String getName what is your name? return this.name my name is ... public String getType what is your type? return this.type my type is ... public int getLevel what is your level? return this.level my level is ... public int getRank what is your rank? return this.rank my rank is Output Aurieel light 10 1 Run on ideone GoalKicker.com Java Notes for Professionals 7Once again, the main method inside the Test class is the entry point to our program. Without the main method, we cannot tell the Java Virtual Machine JVM from", "where to begin execution of the program. 1 - Because the HelloWorld class has little relation to the System class, it can only access public data. GoalKicker.com Java Notes for Professionals 8Chapter 2 Type Conversion Section 2.1 Numeric primitive casting Numeric primitives can be cast in two ways. Implicit casting happens when the source type has smaller range than the target type. Implicit casting byte byteVar 42 short shortVar byteVar int intVar shortVar long longVar intvar float floatVar longVar double doubleVar floatVar Explicit casting has to be done when the source type has larger range than the target type. Explicit casting double doubleVar 42.0d float floatVar float doubleVar long longVar long floatVar int intVar int longVar short shortVar short intVar byte byteVar byte shortVar When casting \ufb02oating point primitives float , double to whole number primitives, the number is rounded down . Section 2.2 Basic Numeric Promotion static void testNumericPromotion char char1 1, char2 2 short short1 1, short2 2 int int1 1, int2 2 float float1 1.0f, float2 2.0f char1 char1 char2 Error Cannot convert from int to char short1 short1 short2 Error Cannot convert from int to short int1 char1 char2 char is promoted to int. int1", "short1 short2 short is promoted to int. int1 char1 short2 both char and short promoted to int. float1 short1 float2 short is promoted to float. int1 int1 int2 int is unchanged. Section 2.3 Non-numeric primitive casting The boolean type cannot be cast tofrom any other primitive type. A char can be cast tofrom any numeric type by using the code-point mappings speci\ufb01ed by Unicode. A char is represented in memory as an unsigned 16-bit integer value 2 bytes, so casting to byte 1 byte will drop 8 of those bits this is safe for ASCII characters. The utility methods of the Character class use int 4 bytes to transfer tofrom code-point values, but a short 2 bytes would also su\ufb03ce for storing a Unicode code-point. int badInt int true Compiler error incompatible types GoalKicker.com Java Notes for Professionals 9char char1 char 65 A byte byte1 byte A 65 short short1 short A 65 int int1 int A 65 char char2 char 8253 byte byte2 byte 61 truncated code-point into the ASCII range short short2 short 8253 int int2 int 8253 Section 2.4 Object casting As with primitives, objects can be cast both explicitly and implicitly. Implicit casting happens when", "the source type extends or implements the target type casting to a superclass or interface. Explicit casting has to be done when the source type is extended or implemented by the target type casting to a subtype. This can produce a runtime exception ClassCastException when the object being cast is not of the target type or the targets subtype. Float floatVar new Float42.0f Number n floatVar Implicit Float implements Number Float floatVar2 Float n Explicit Double doubleVar Double n Throws exception the object is not Double Section 2.5 Testing if an object can be cast using instanceof Java provides the instanceof operator to test if an object is of a certain type, or a subclass of that type. The program can then choose to cast or not cast that object accordingly. Object obj Calendar .getInstance long time 0 ifobj instanceof Calendar time Calendar obj.getTime ifobj instanceof Date time Dateobj.getTime This line will never be reached, obj is not a Date type. GoalKicker.com Java Notes for Professionals 10Chapter 3 Getters and Setters This article discusses getters and setters the standard way to provide access to data in Java classes. Section 3.1 Using a setter or getter to implement a constraint", "Setters and Getters allow for an object to contain private variables which can be accessed and changed with restrictions. For example, public class Person private String name public String getName return name public void setName String name ifname!null name.length2 this.name name In this Person class, there is a single variable name . This variable can be accessed using the getName method and changed using the setNameString method, however, setting a name requires the new name to have a length greater than 2 characters and to not be null. Using a setter method rather than making the variable name public allows others to set the value of name with certain restrictions. The same can be applied to the getter method public String getName ifname.length16 return Name is too large! else return name In the modi\ufb01ed getName method above, the name is returned only if its length is less than or equal to 16. Otherwise, Name is too large is returned. This allows the programmer to create variables that are reachable and modi\ufb01able however they wish, preventing client classes from editing the variables unwantedly. Section 3.2 Why Use Getters and Setters? Consider a basic class containing an object with getters and", "setters in Java public class CountHolder private int count 0 public int getCount return count public void setCount int c count c We cant access the count variable because its private. But we can access the getCount and the setCount int methods because they are public. To some, this might raise the question why introduce the middleman? Why not just simply make they count public? public class CountHolder GoalKicker.com Java Notes for Professionals 11 public int count 0 For all intents and purposes, these two are exactly the same, functionality-wise. The di\ufb00erence between them is the extensibility. Consider what each class says First I have a method that will give you an int value, and a method that will set that value to another int. Second I have an int that you can set and get as you please. These might sound similar, but the \ufb01rst is actually much more guarded in its nature it only lets you interact with its internal nature as it dictates. This leaves the ball in its court it gets to choose how the internal interactions occur. The second has exposed its internal implementation externally, and is now not only prone to external users,", "but, in the case of an API, committed to maintaining that implementation or otherwise releasing a non-backward- compatible API. Lets consider if we want to synchronize access to modifying and accessing the count. In the \ufb01rst, this is simple public class CountHolder private int count 0 public synchronized int getCount return count public synchronized void setCount int c count c but in the second example, this is now nearly impossible without going through and modifying each place where the count variable is referenced. Worse still, if this is an item that youre providing in a library to be consumed by others, you do not have a way of performing that modi\ufb01cation, and are forced to make the hard choice mentioned above. So it begs the question are public variables ever a good thing or, at least, not evil? Im unsure. On one hand, you can see examples of public variables that have stood the test of time IE the out variable referenced in System.out. On the other, providing a public variable gives no bene\ufb01t outside of extremely minimal overhead and potential reduction in wordiness. My guideline here would be that, if youre planning on making a variable public, you", "should judge it against these criteria with extreme prejudice The variable should have no conceivable reason to ever change in its implementation. This is something 1. thats extremely easy to screw up and, even if you do get it right, requirements can change, which is why getterssetters are the common approach. If youre going to have a public variable, this really needs to be thought through, especially if released in a libraryframeworkAPI. The variable needs to be referenced frequently enough that the minimal gains from reducing verbosity2. warrants it. I dont even think the overhead for using a method versus directly referencing should be considered here. Its far too negligible for what Id conservatively estimate to be 99.9 of applications. Theres probably more than I havent considered o\ufb00 the top of my head. If youre ever in doubt, always use getterssetters. Section 3.3 Adding Getters and Setters Encapsulation is a basic concept in OOP. It is about wrapping data and code as a single unit. In this case, it is a good practice to declare the variables as private and then access them through Getters and Setters to view andor modify them. public class Sample GoalKicker.com Java Notes for", "Professionals 12 private String name private int age public int getAge return age public void setAgeint age this.age age public String getName return name public void setName String name this.name name These private variables cannot be accessed directly from outside the class. Hence they are protected from unauthorized access. But if you want to view or modify them, you can use Getters and Setters. getXxx method will return the current value of the variable xxx, while you can set the value of the variable xxx using setXxx. The naming convention of the methods are in example variable is called variableName All non boolean variables getVariableName Getter, The variable name should start with uppercase setVariableName .. Setter, The variable name should start with uppercase boolean variables isVariableName Getter, The variable name should start with uppercase setVariableName ... Setter, The variable name should start with uppercase Public Getters and Setters are part of the Property de\ufb01nition of a Java Bean. GoalKicker.com Java Notes for Professionals 13Chapter 4 Reference Data Types Section 4.1 Dereferencing Dereferencing happens with the . operator Object obj new Object String text obj.toString obj is dereferenced. Dereferencing follows the memory address stored in a reference, to the place", "in memory where the actual object resides. When an object has been found, the requested method is called toString in this case. When a reference has the value null , dereferencing results in a NullPointerException Object obj null obj.toString Throws a NullpointerException when this statement is executed. null indicates the absence of a value, i.e. following the memory address leads nowhere. So there is no object on which the requested method can be called. Section 4.2 Instantiating a reference type Object obj new Object Note the new keyword Where Object is a reference type. obj is the variable in which to store the new reference. Object is the call to a constructor of Object . What happens Space in memory is allocated for the object. The constructor Object is called to initialize that memory space. The memory address is stored in obj, so that it references the newly created object. This is di\ufb00erent from primitives int i 10 Where the actual value 10 is stored in i. GoalKicker.com Java Notes for Professionals 14Chapter 5 Java Compiler - javac Section 5.1 The javac command - getting started Simple example Assuming that the HelloWorld.java contains the following Java source public class", "HelloWorld public static void mainString args System.out.printlnHello world! For an explanation of the above code, please refer to Getting started with Java Language . We can compile the above \ufb01le using this command javac HelloWorld. java This produces a \ufb01le called HelloWorld.class, which we can then run as follows java HelloWorld Hello world ! The key points to note from this example are The source \ufb01lename HelloWorld.java must match the class name in the source \ufb01le ... which is HelloWorld . If 1. they dont match, you will get a compilation error. The bytecode \ufb01lename HelloWorld.class corresponds to the classname. If you were to rename the2. HelloWorld.class, you would get an error when your tried to run it. When running a Java application using java , you supply the classname NOT the bytecode \ufb01lename. 3. Example with packages Most practical Java code uses packages to organize the namespace for classes and reduce the risk of accidental class name collision. If we wanted to declare the HelloWorld class in a package call com.example , the HelloWorld.java would contain the following Java source package com.example public class HelloWorld public static void mainString args System.out.printlnHello world! This source code \ufb01le needs to", "stored in a directory tree whose structure corresponds to the package naming. . the current directory for this example ----com GoalKicker.com Java Notes for Professionals 15 ----example ----HelloWorld. java We can compile the above \ufb01le using this command javac com exampleHelloWorld. java This produces a \ufb01le called comexampleHelloWorld.class i.e. after compilation, the \ufb01le structure should look like this . the current directory for this example ----com ----example ----HelloWorld. java ----HelloWorld. class We can then run the application as follows java com. example.HelloWorld Hello world ! Additional points to note from this example are The directory structure must match the package name structure.1. When you run the class, the full class name must be supplied i.e. com.example.HelloWorld not2. HelloWorld. You dont have to compile and run Java code out of the current directory. We are just doing it here for3. illustration. Compiling multiple \ufb01les at once with javac. If your application consists of multiple source code \ufb01les and most do! you can compile them one at a time. Alternatively, you can compile multiple \ufb01les at the same time by listing the pathnames javac Foo. java Bar.java or using your command shells \ufb01lename wildcard functionality .... javac .java javac com example.java", "javac .java Only works on Zsh or with globstar enabled on your shell This will compile all Java source \ufb01les in the current directory, in the comexample directory, and recursively in child directories respectively. A third alternative is to supply a list of source \ufb01lenames and compiler options as a \ufb01le. For example javac sourcefiles where the sourcefiles \ufb01le contains Foo.java Bar.java GoalKicker.com Java Notes for Professionals 16comexampleHelloWorld. java Note compiling code like this is appropriate for small one-person projects, and for once-o\ufb00 programs. Beyond that, it is advisable to select and use a Java build tool. Alternatively, most programmers use a Java IDE e.g. NetBeans , eclipse , IntelliJ IDEA which o\ufb00ers an embedded compiler and incremental building of projects. Commonly used javac options Here are a few options for the javac command that are likely to be useful to you The -d option sets a destination directory for writing the .class \ufb01les. The -sourcepath option sets a source code search path. The -cp or -classpath option sets the search path for \ufb01nding external and previously compiled classes. For more information on the classpath and how to specify it, refer to the The Classpath Topic. The -version option", "prints the compilers version information. A more complete list of compiler options will be described in a separate example. References The de\ufb01nitive reference for the javac command is the Oracle manual page for javac . Section 5.2 Compiling for a dierent version of Java The Java programming language and its runtime has undergone numerous changes since its release since its initial public release. These changes include Changes in the Java programming language syntax and semantics Changes in the APIs provided by the Java standard class libraries. Changes in the Java bytecode instruction set and class\ufb01le format. With very few exceptions for example the enum keyword, changes to some internal classes, etc, these changes are backwards compatible. A Java program that was compiled using an older version of the Java toolchain will run on a newer version Java platform without recompilation. A Java program that was written in an older version of Java will compile successfully with a new Java compiler. Compiling old Java with a newer compiler If you need to re-compile older Java code on a newer Java platform to run on the newer platform, you generally dont need to give any special compilation \ufb02ags. In a few", "cases e.g. if you had used enum as an identi\ufb01er you could use the -source option to disable the new syntax. For example, given the following class public class OldSyntax private static int enum invalid in Java 5 or later the following is required to compile the class using a Java 5 compiler or later javac -source 1.4 OldSyntax. java Compiling for an older execution platform If you need to compile Java to run on an older Java platforms, the simplest approach is to install a JDK for the oldest GoalKicker.com Java Notes for Professionals 17version you need to support, and use that JDKs compiler in your builds. You can also compile with a newer Java compiler, but there are complicated. First of all, there some important preconditions that must be satis\ufb01ed The code you are compiling must not use Java language constructs that were not available in the version of Java that you are targeting. The code must not depend on standard Java classes, \ufb01elds, methods and so on that were not available in the older platforms. Third party libraries that the code depends must also be built for the older platform and available at compile- time and", "run-time. Given the preconditions are met, you can recompile code for an older platform using the -target option. For example, javac -target 1.4 SomeClass. java will compile the above class to produce bytecodes that are compatible with Java 1.4 or later JVM. In fact, the - source option implies a compatible -target , so javac -source 1.4 ... would have the same e\ufb00ect. The relationship between -source and -target is described in the Oracle documentation. Having said that, if you simply use -target or -source , you will still be compiling against the standard class libraries provided by the compilers JDK. If you are not careful, you can end up with classes with the correct bytecode version, but with dependencies on APIs that are not available. The solution is to use the -bootclasspath option. For example javac -target 1.4 --bootclasspath path tojava1.4rt.jar SomeClass. java will compile against an alternative set of runtime libraries. If the class being compiled has accidental dependencies on newer libraries, this will give you compilation errors. GoalKicker.com Java Notes for Professionals 18Chapter 6 Documenting Java Code Documentation for java code is often generated using javadoc . Javadoc was created by Sun Microsystems for the purpose", "of generating API documentation in HTML format from java source code. Using the HTML format gives the convenience of being able to hyperlink related documents together. Section 6.1 Building Javadocs From the Command Line Many IDEs provide support for generating HTML from Javadocs automatically some build tools Maven and Gradle , for example also have plugins that can handle the HTML creation. However, these tools are not required to generate the Javadoc HTML this can be done using the command line javadoc tool. The most basic usage of the tool is javadoc JavaFile. java Which will generate HTML from the Javadoc comments in JavaFile. java . A more practical use of the command line tool, which will recursively read all java \ufb01les in source-directory , create documentation for package.name and all sub-packages, and place the generated HTML in the docs- directory is javadoc -d docs-directory -subpackages -sourcepath source-directory package.name Section 6.2 Class Documentation All Javadoc comments begin with a block comment followed by an asterisk and end when the block comment does . Optionally, each line can begin with arbitrary whitespace and a single asterisk these are ignored when the documentation \ufb01les are generated. Brief summary of this class,", "ending with a period. It is common to leave a blank line between the summary and further details. The summary everything before the first period is used in the class or package overview section. The following inline tags can be used not an exhaustive list link some.other.class.Documentation for linking to other docs or symbols link some.other.class.Documentation Some Display Name the links appearance can be customized by adding a display name after the doc or symbol locator code code goes here for formatting as code literal foo for interpreting literal text without converting to HTML markup or other tags. Optionally, the following tags may be used at the end of class documentation not an exhaustive list author John Doe version 1.0 since 51015 see some.other.class.Documentation deprecated This class has been replaced by some.other.package.BetterFileReader GoalKicker.com Java Notes for Professionals 19 You can also have custom tags for displaying additional information. Using the custom.NAME tag and the -tag custom.NAMEhtmltagcontext command line option, you can create a custom tag. Example custom tag and generation custom.updated 2.0 Javadoc flag -tag custom.updatedaUpdated in version The above flag will display the value of custom.updated under Updated in version public class FileReader The same tags and format", "used for Classes can be used for Enums and Interfaces as well. Section 6.3 Method Documentation All Javadoc comments begin with a block comment followed by an asterisk and end when the block comment does . Optionally, each line can begin with arbitrary whitespace and a single asterisk these are ignored when the documentation \ufb01les are generated. Brief summary of method, ending with a period. Further description of method and what it does, including as much detail as is appropriate. Inline tags such as code code here, link some.other.Docs, and literal text here can be used. If a method overrides a superclass method, inheritDoc can be used to copy the documentation from the superclass method param stream Describe this parameter. Include as much detail as is appropriate Parameter docs are commonly aligned as here, but this is optional. As with other docs, the documentation before the first period is used as a summary. return Describe the return values. Include as much detail as is appropriate Return type docs are commonly aligned as here, but this is optional. As with other docs, the documentation before the first period is used as a summary. throws IOException Describe when and why this", "exception can be thrown. Exception docs are commonly aligned as here, but this is optional. As with other docs, the documentation before the first period is used as a summary. Instead of throws, exception can also be used. since 2.1.0 see some.other.class.Documentation deprecated Describe why this method is outdated. A replacement can also be specified. public String readInputStream stream throws IOException return null GoalKicker.com Java Notes for Professionals 20Section 6.4 Package Documentation Version Java SE 5 It is possible to create package-level documentation in Javadocs using a \ufb01le called package-info.java . This \ufb01le must be formatted as below. Leading whitespace and asterisks optional, typically present in each line for formatting reason Package documentation goes here any documentation before the first period will be used as a summary. It is common practice to leave a blank line between the summary and the rest of the documentation use this space to describe the package in as much detail as is appropriate. Inline tags such as code code here, link reference.to.other.Documentation, and literal text here can be used in this documentation. package com.example.foo The rest of the file must be empty. In the above case, you must put this \ufb01le package-info.java inside", "the folder of the Java package com.example.foo. Section 6.5 Links Linking to other Javadocs is done with the link tag You can link to the javadoc of an already imported class using link ClassName. You can also use the fully-qualified name, if the class is not already imported link some.other.ClassName You can link to members fields or methods of a class like so link ClassNamesomeMethod link ClassNamesomeMethodWithParametersint, String link ClassNamesomeField link someMethodInThisClass - used to link to members in the current class You can add a label to a linked javadoc like so link ClassNamesomeMethod link text GoalKicker.com Java Notes for Professionals 21With the see tag you can add elements to the See also section. Like param or return the place where they appear is not relevant. The spec says you should write it after return . This method has a nice explanation but you might found further information at the bottom. see ClassNamesomeMethod If you want to add links to external resources you can just use the HTML a tag. You can use it inline anywhere or inside both link and see tags. Wondering how this works? You might want to check this a hrefhttpstackoverflow.comgreat servicea. see a", "hrefhttpstackoverflow.comStack Overflowa Section 6.6 Code snippets inside documentation The canonical way of writing code inside documentation is with the code construct. If you have multiline code wrap inside prepre. The Class TestUtils. p This is an code inlinecode example. p You should wrap it in pre tags when writing multiline code. precode Example example1 new FirstLineExample example1.butYouCanHaveMoreThanOneLine pre p Thanks for reading. class TestUtils Sometimes you may need to put some complex code inside the javadoc comment. The sign is specially problematic. The use of the old code tag alongside the literal construct solves the problem. Usage precode class SomethingTest literal Rule GoalKicker.com Java Notes for Professionals 22 public SingleTestRule singleTestRule new SingleTestRuletest1 literal Test public void test1 only this test will be executed ... codepre class SingleTestRule implements TestRule Section 6.7 Field Documentation All Javadoc comments begin with a block comment followed by an asterisk and end when the block comment does . Optionally, each line can begin with arbitrary whitespace and a single asterisk these are ignored when the documentation \ufb01les are generated. Fields can be documented as well. As with other javadocs, the documentation before the first period is used as a summary, and is usually", "separated from the rest of the documentation by a blank line. Documentation for fields can use inline tags, such as code code here literal text here link other.docs.Here Field documentation can also make use of the following tags since 2.1.0 see some.other.class.Documentation deprecated Describe why this field is outdated public static final String CONSTANTSTRING foo Section 6.8 Inline Code Documentation Apart from the Javadoc documentation code can be documented inline. Single Line comments are started by and may be positioned after a statement on the same line, but not before. public void method single line comment someMethodCall single line comment after statement Multi-Line comments are de\ufb01ned between and . They can span multiple lines and may even been positioned between statements. public void methodObject object GoalKicker.com Java Notes for Professionals 23 multi line comment object inner-line-comment .method JavaDocs are a special form of multi-line comments, starting with . As too many inline comments may decrease readability of code, they should be used sparsely in case the code isnt self-explanatory enough or the design decision isnt obvious. An additional use case for single-line comments is the use of TAGs, which are short, convention driven keywords. Some development environments recognize certain", "conventions for such single-comments. Common examples are TODO FIXME Or issue references, i.e. for Jira PRJ-1234 GoalKicker.com Java Notes for Professionals 24Chapter 7 Command line Argument Processing Parameter Details argsThe command line arguments. Assuming that the main method is invoked by the Java launcher, args will be non-null, and will have no null elements. Section 7.1 Argument processing using GWT ToolBase If you want to parse more complex command-line arguments, e.g. with optional parameters, than the best is to use googles GWT approach. All classes are public available at httpsgwt.googlesource.comgwt2.8.0-beta1devcoresrccomgooglegwtutiltoolsToolBase.java An example for handling the command-line myprogram -dir Documents -port 8888 is public class MyProgramHandler extends ToolBase protected File dir protected int port getters for dir and port ... public MyProgramHandler this.registerHandler new ArgHandlerDir Override public void setDirFile dir this.dir dir this.registerHandler new ArgHandlerInt Override public String getTagArgs return new Stringport Override public void setIntint value this.port value public static void mainString args MyProgramHandler myShell new MyProgramHandler if myShell. processArgs args main program operation System.out.printlnString.formatport d dir s , myShell. getPort, myShell. getDir System.exit1 ArgHandler also has a method isRequired which can be overwritten to say that the command-line argument is required default return is false so that the", "argument is optional. Section 7.2 Processing arguments by hand When the command-line syntax for an application is simple, it is reasonable to do the command argument GoalKicker.com Java Notes for Professionals 25processing entirely in custom code. In this example, we will present a series of simple case studies. In each case, the code will produce error messages if the arguments are unacceptable, and then call System.exit1 to tell the shell that the command has failed. We will assume in each case that the Java code is invoked using a wrapper whose name is myapp. A command with no arguments In this case-study, the command requires no arguments. The code illustrates that args.length gives us the number of command line arguments. public class Main public static void mainString args if args.length 0 System.err.printlnusage myapp System.exit1 Run the application System.out.printlnIt worked A command with two arguments In this case-study, the command requires at precisely two arguments. public class Main public static void mainString args if args.length ! 2 System.err.printlnusage myapp arg1 arg2 System.exit1 Run the application System.out.printlnIt worked args0 , args1 Note that if we neglected to check args.length , the command would crash if the user ran it with too", "few command-line arguments. A command with \ufb02ag options and at least one argument In this case-study, the command has a couple of optional \ufb02ag options, and requires at least one argument after the options. package tommy public class Main public static void mainString args boolean feelMe false boolean seeMe false int index loop for index 0 index args.length index String opt argsindex switch opt case -c seeMe true break case -f GoalKicker.com Java Notes for Professionals 26 feelMe true break default if !opts.isEmpty opts.charAt0 - error Unknown option opt break loop if index args.length error Missing arguments Run the application ... private static void errorString message if message ! null System.err.printlnmessage System.err.printlnusage myapp -f -c arg ... System.exit1 As you can see, processing the arguments and options gets rather cumbersome if the command syntax is complicated. It is advisable to use a command line parsing library see the other examples. GoalKicker.com Java Notes for Professionals 27Chapter 8 The Java Command - java and javaw Section 8.1 Entry point classes A Java entry-point class has a main method with the following signature and modi\ufb01ers public static void mainString args Sidenote because of how arrays work, it can also be String", "args When the java command starts the virtual machine, it loads the speci\ufb01ed entry-point classes and tries to \ufb01nd main . If successful, the arguments from command line are converted to Java String objects and assembled into an array. If main is invoked like this, the array will not be null and wont contain any null entries. A valid entry-point class method must do the following Be named main case-sensitive Be public and static Have a void return type Have a single argument with an array String. The argument must be present and no more than one argument is allowed. Be generic type parameters are not allowed. Have a non-generic, top-level not nested or inner enclosing class It is conventional to declare the class as public but this not strictly necessary. From Java 5 onward, the main methods argument type may be a String varargs instead of a string array. main can optionally throw exceptions, and its parameter can be named anything, but conventionally it is args . JavaFX entry-points From Java 8 onwards the java command can also directly launch a JavaFX application. JavaFX is documented in the JavaFX tag, but a JavaFX entry-point must do the following", "Extend javafx.application .Application Be public and not abstract Not be generic or nested Have an explicit or implicit public no-args constructor Section 8.2 Troubleshooting the java command This example covers common errors with using the java command. Command not found If you get an error message like java command not found when trying to run the java command, this means that there is no java command on your shells command search path. The cause could be GoalKicker.com Java Notes for Professionals 28you dont have a Java JRE or JDK installed at all, you have not updated the PATH environment variable correctly in your shell initialization \ufb01le, or you have not sourced the relevant initialization \ufb01le in the current shell. Refer to Installing Java for the steps that you need to take. Could not \ufb01nd or load main class This error message is output by the java command if it has been unable to \ufb01nd load the entry-point class that you have speci\ufb01ed. In general terms, there are three broad reasons that this can happen You have speci\ufb01ed an entry point class that does not exist. The class exists, but you have speci\ufb01ed it incorrectly. The class exists and you", "have speci\ufb01ed it correctly, but Java cannot it \ufb01nd it because the classpath is incorrect. Here is a procedure to diagnose and solve the problem Find out the full name of the entry-point class.1. If you have source code for a class, then the full name consists of the package name and the simple class name. The instance the Main class is declared in the package com.example.myapp then its full name is com.example.myapp.Main. If you have a compiled class \ufb01le, you can \ufb01nd the class name by running javap on it. If the class \ufb01le is in a directory, you can infer the full class name from the directory names. If the class \ufb01le is in a JAR or ZIP \ufb01le, you can infer the full class name from the \ufb01le path in the JAR or ZIP \ufb01le. Look at the error message from the java command. The message should end with the full class name that 2. java is trying to use. Check that it exactly matches the full classname for the entry-point class. It should not end with .java or .class. It should not contain slashes or any other character that is not legal in a Java", "identi\ufb01er1. The casing of the name should exactly match the full class name. If you are using the correct classname, make sure that the class is actually on the classpath3. Work out the pathname that the classname maps to see Mapping classnames to pathnames Work out what the classpath is see this example Di\ufb00erent ways to specify the classpath Look at each of the JAR and ZIP \ufb01les on the classpath to see if they contain a class with the required pathname. Look at each directory to see if the pathname resolves to a \ufb01le within the directory. If checking the classpath by hand did not \ufb01nd the issue, you could add the -Xdiag and -XshowSettings options. The former lists all classes that are loaded, and the latter prints out settings that include the e\ufb00ective classpath for the JVM. Finally, there are some obscure causes for this problem An executable JAR \ufb01le with a Main-Class attribute that speci\ufb01es a class that does not exist. An executable JAR \ufb01le with an incorrect Class-Path attribute. If you mess up2 the options before the classname, the java command may attempt to interpret one of them GoalKicker.com Java Notes for Professionals 29as the", "classname. If someone has ignored Java style rules and used package or class identi\ufb01ers that di\ufb00er only in letter case, and you are running on a platform that treats letter case in \ufb01lenames as non-signi\ufb01cant. Problems with homoglyphs in class names in the code or on the command line. Main method not found in class name This problem happens when the java command is able to \ufb01nd and load the class that you nominated, but is then unable to \ufb01nd an entry-point method. There are three possible explanations If you are trying to run an executable JAR \ufb01le, then the JARs manifest has an incorrect Main-Class attribute that speci\ufb01es a class that is not a valid entry point class. You have told the java command a class that is not an entry point class. The entry point class is incorrect see Entry point classes for more information. Other Resources What does Could not \ufb01nd or load main class mean? httpdocs.oracle.comjavasetutorialgetStartedproblemsindex.html 1 - From Java 8 and later, the java command will helpfully map a \ufb01lename separator or to a period .. However, this behavior is not documented in the manual pages. 2 - A really obscure case is if", "you copy-and-paste a command from a formatted document where the text editor has used a long hyphen instead of a regular hyphen. Section 8.3 Running a Java application with library dependencies This is a continuation of the main class and executable JAR examples. Typical Java applications consist of an application-speci\ufb01c code, and various reusable library code that you have implemented or that has been implemented by third parties. The latter are commonly referred to as library dependencies, and are typically packaged as JAR \ufb01les. Java is a dynamically bound language. When you run a Java application with library dependencies, the JVM needs to know where the dependencies are so that it can load classes as required. Broadly speaking, there are two ways to deal with this The application and its dependencies can be repackaged into a single JAR \ufb01le that contains all of the required classes and resources. The JVM can be told where to \ufb01nd the dependent JAR \ufb01les via the runtime classpath. For an executable JAR \ufb01le, the runtime classpath is speci\ufb01ed by the Class-Path manifest attribute. Editorial Note This should be described in a separate Topic on the jar command. Otherwise, the runtime classpath needs to", "be supplied using the -cp option or using the CLASSPATH environment variable. For example, suppose that we have a Java application in the myApp.jar \ufb01le whose entry point class is com.example.MyApp . Suppose also that the application depends on library JAR \ufb01les liblibrary1.jar and liblibrary2.jar. We could launch the application using the java command as follows in a command line Alternative 1 preferred GoalKicker.com Java Notes for Professionals 30 java -cp myApp. jarliblibrary1. jarliblibrary2. jar com.example.MyApp Alternative 2 export CLASSPATH myApp.jarliblibrary1. jarliblibrary2. jar java com. example.MyApp On Windows, you would use instead of as the classpath separator, and you would set the local CLASSPATH variable using set rather than export . While a Java developer would be comfortable with that, it is not user friendly. So it is common practice to write a simple shell script or Windows batch \ufb01le to hide the details that the user doesnt need to know about. For example, if you put the following shell script into a \ufb01le called myApp, made it executable, and put it into a directory on the command search path !binbash The myApp wrapper script export DIRusrlibexecmyApp export CLASSPATH DIRmyApp.jar DIRliblibrary1.jar DIRliblibrary2.jar java com.example.MyApp then you could run it", "as follows myApp arg1 arg2 ... Any arguments on the command line will be passed to the Java application via the expansion. You can do something similar with a Windows batch \ufb01le, though the syntax is di\ufb00erent. Section 8.4 Java Options The java command supports a wide range of options All options start with a single hyphen or minus-sign - the GNULinux convention of using -- for long options is not supported. Options must appear before the classname or the -jar jarfile argument to be recognized. Any arguments after them will be treated as arguments to be passed to Java app that is being run. Options that do not start with -X or -XX are standard options. You can rely on all Java implementations1 to support any standard option. Options that start with -X are non-standard options, and may be withdrawn from one Java version to the next. Options that start with -XX are advanced options, and may also be withdrawn. Setting system properties with -D The -Dproperty value option is used to set a property in the system Properties object. This parameter can be repeated to set di\ufb00erent properties. Memory, Stack and Garbage Collector options The main options", "for controlling the heap and stack sizes are documented in Setting the Heap, PermGen and Stack sizes. Editorial note Garbage Collector options should be described in the same topic. GoalKicker.com Java Notes for Professionals 31Enabling and disabling assertions The -ea and -da options respectively enable and disable Java assert checking All assertion checking is disabled by default. The -ea option enables checking of all assertions The -eapackagename ... enables checking of assertions in a package and all subpackages . The -eaclassname ... enables checking of assertions in a class. The -da option disables checking of all assertions The -dapackagename ... disables checking of assertions in a package and all subpackages . The -daclassname ... disables checking of assertions in a class. The -esa option enables checking for all system classes. The -dsa option disables checking for all system classes. The options can be combined. For example. Enable all assertion checking in non -system classes java -ea -dsa MyApp Enable assertions for all classes in a package except for one. java -eacom.wombat.fruitbat ... -dacom.wombat.fruitbat .Brickbat MyApp Note that enabling to assertion checking is liable to alter the behavior of a Java programming. It is liable make the application slower in", "general. It can cause speci\ufb01c methods to take longer to run, which could change timing of threads in a multi-threaded application. It can introduce serendipitous happens-before relations which can cause memory anomalies to disappear. An incorrectly implemented assert statement could have unwanted side-e\ufb00ects. Selecting the VM type The -client and -server options allow you to select between two di\ufb00erent forms of the HotSpot VM The client form is tuned for user applications and o\ufb00ers faster startup. The server form is tuned for long running applications. It takes longer capturing statistic during JVM warm up which allows the JIT compiler to do a better of job of optimizing the native code. By default, the JVM will run in 64bit mode if possible, depending on the capabilities of the platform. The -d32 and - d64 options allow you to select the mode explicitly. 1 - Check the o\ufb03cial manual for the java command. Sometimes a standard option is described as subject to change. Section 8.5 Spaces and other special characters in arguments First of all, the problem of handling spaces in arguments is NOT actually a Java problem. Rather it is a problem that needs to be handled by the command", "shell that you are using when you run a Java program. As an example, let us suppose that we have the following simple program that prints the size of a \ufb01le import java.io.File public class PrintFileSizes GoalKicker.com Java Notes for Professionals 32 public static void mainString args for String name args File file new Filename System.out.printlnSize of file is file.size Now suppose that we want print the size of a \ufb01le whose pathname has spaces in it e.g. homesteveTest File.txt. If we run the command like this java PrintFileSizes homesteveTest File.txt the shell wont know that homesteveTest File.txt is actually one pathname. Instead, it will pass 2 distinct arguments to the Java application, which will attempt to \ufb01nd their respective \ufb01le sizes, and fail because \ufb01les with those paths probably do not exist. Solutions using a POSIX shell POSIX shells include sh as well derivatives such as bash and ksh. If you are using one of these shells, then you can solve the problem by quoting the argument. java PrintFileSizes homesteveTest File.txt The double-quotes around the pathname tell the shell that it should be passed as a single argument. The quotes will be removed when this happens. There are", "a couple of other ways to do this java PrintFileSizes homesteveTest File.txt Single straight quotes are treated like double-quotes except that they also suppress various expansions within the argument. java PrintFileSizes homesteveTest File.txt A backslash escapes the following space, and causes it not to be interpreted as an argument separator. For more comprehensive documentation, including descriptions of how to deal with other special characters in arguments, please refer to the quoting topic in the Bash documentation. Solution for Windows The fundamental problem for Windows is that at the OS level, the arguments are passed to a child process as a single string source . This means that the ultimate responsibility of parsing or re-parsing the command line falls on either program or its runtime libraries. There is lots of inconsistency. In the Java case, to cut a long story short You can put double-quotes around an argument in a java command, and that will allow you to pass arguments with spaces in them. Apparently, the java command itself is parsing the command string, and it gets it more or less right However, when you try to combine this with the use of SET and variable substitution in a batch", "\ufb01le, it gets really complicated as to whether double-quotes get removed. GoalKicker.com Java Notes for Professionals 33The cmd.exe shell apparently has other escaping mechanisms e.g. doubling double-quotes, and using escapes. For more detail, please refer to the Batch-File documentation. Section 8.6 Running an executable JAR \ufb01le Executable JAR \ufb01les are the simplest way to assemble Java code into a single \ufb01le that can be executed. Editorial Note Creation of JAR \ufb01les should be covered by a separate Topic. Assuming that you have an executable JAR \ufb01le with pathname jar-path , you should be able to run it as follows java -jar jar-path If the command requires command-line arguments, add them after the jar-path . For example java -jar jar-path arg1 arg2 arg3 If you need to provide additional JVM options on the java command line, they need to go before the -jar option. Note that a -cp -classpath option will be ignored if you use -jar. The applications classpath is determined by the JAR \ufb01le manifest. Section 8.7 Running a Java applications via a main class When an application has not been packaged as an executable JAR, you need to provide the name of an entry-point class on the", "java command line. Running the HelloWorld class The HelloWorld example is described in Creating a new Java program . It consists of a single class called HelloWorld which satis\ufb01es the requirements for an entry-point. Assuming that the compiled HelloWorld.class \ufb01le is in the current directory, it can be launched as follows java HelloWorld Some important things to note are We must provide the name of the class not the pathname for the .class \ufb01le or the .java \ufb01le. If the class is declared in a package as most Java classes are, then the class name we supply to the java command must be the full classname. For instance if SomeClass is declared in the com.example package, then the full classname will be com.example.SomeClass . Specifying a classpath Unless we are using in the java -jar command syntax, the java command looks for the class to be loaded by searching the classpath see The Classpath. The above command is relying on the default classpath being or including the current directory. We can be more explicit about this by specifying the classpath to be used using the -cp option. java -cp . HelloWorld This says to make the current directory which", "is what . refers to the sole entry on the classpath. GoalKicker.com Java Notes for Professionals 34The -cp is an option that is processed by the java command. All options that are intended for the java command should be before the classname. Anything after the class will be treated as an command line argument for the Java application, and will be passed to application in the String that is passed to the main method. If no -cp option is provided, the java will use the classpath that is given by the CLASSPATH environment variable. If that variable is unset or empty, java uses . as the default classpath. GoalKicker.com Java Notes for Professionals 35Chapter 9 Literals A Java literal is a syntactic element i.e. something you \ufb01nd in the source code of a Java program that represents a value. Examples are 1, 0.333F , false , 39X39 and Hello world n. Section 9.1 Using underscore to improve readability Since Java 7 it has been possible to use one or more underscores for separating groups of digits in a primitive number literal to improve their readability. For instance, these two declarations are equivalent Version Java SE 7 int i1 123456", "int i2 123456 System.out.printlni1 i2 true This can be applied to all primitive number literals as shown below Version Java SE 7 byte color 123 short yearsAnnoDomini 2016 int socialSecurtyNumber 999999999 long creditCardNumber 1234567890123456L float piFourDecimals 3.1415F double piTenDecimals 3.1415926535 This also works using pre\ufb01xes for binary, octal and hexadecimal bases Version Java SE 7 short binary 0b0101 int octal 0777777770 long hexBytes 0xFFECDE5E There are a few rules about underscores which forbid their placement in the following places At the beginning or end of a number e.g. 123 or 123 are not valid Adjacent to a decimal point in a \ufb02oating point literal e.g. 1.23 or 1.23 are not valid Prior to an F or L su\ufb03x e.g. 1.23F or 9999999L are not valid In positions where a string of digits is expected e.g. 0xFFFF is not valid Section 9.2 Hexadecimal, Octal and Binary literals A hexadecimal number is a value in base-16. There are 16 digits, 0-9 and the letters A-F case does not matter. A-F represent 10-15. An octal number is a value in base-8, and uses the digits 0-7. A binary number is a value in base-2, and uses the digits 0 and 1. All", "of these numbers result in the same value, 110 int dec 110 no prefix -- decimal literal int bin 0b1101110 0b prefix -- binary literal int oct 0156 0 prefix -- octal literal GoalKicker.com Java Notes for Professionals 36int hex 0x6E 0x prefix -- hexadecimal literal Note that binary literal syntax was introduced in Java 7. The octal literal can easily be a trap for semantic errors. If you de\ufb01ne a leading 0 to your decimal literals you will get the wrong value int a 0100 Instead of 100, a 64 Section 9.3 Boolean literals Boolean literals are the simplest of the literals in the Java programming language. The two possible boolean values are represented by the literals true and false . These are case-sensitive. For example boolean flag true using the true literal flag false using the false literal Section 9.4 String literals String literals provide the most convenient way to represent string values in Java source code. A String literal consists of An opening double-quote character. Zero or more other characters that are neither a double-quote or a line-break character. A backslash character alters the meaning of subsequent characters see Escape sequences in literals. A closing double-quote", "character. For example Hello world A literal denoting an 11 character String A literal denoting an empty zero length String A literal denoting a String consisting of one double quote character 1t2t3n Another literal with escape sequences Note that a single string literal may not span multiple source code lines. It is a compilation error for a line-break or the end of the source \ufb01le to occur before a literals closing double-quote. For example Jello world Compilation error at the end of the line! Long strings If you need a string that is too long to \ufb01t on a line, the conventional way to express it is to split it into multiple literals and use the concatenation operator to join the pieces. For example String typingPractice The quick brown fox jumped over the lazy dog An expression like the above consisting of string literals and satis\ufb01es the requirements to be a Constant Expression. That means that the expression will be evaluated by the compiler and represented at runtime by a single String object. Interning of string literals GoalKicker.com Java Notes for Professionals 37When class \ufb01le containing string literals is loaded by the JVM, the corresponding String objects are interned", "by the runtime system. This means that a string literal used in multiple classes occupies no more space than if it was used in one class. For more information on interning and the string pool, refer to the String pool and heap storage example in the Strings topic. Section 9.5 The Null literal The Null literal written as null represents the one and only value of the null type. Here are some examples MyClass object null MyClass objects new MyClass new MyClass , null, new MyClass myMethod null if objects ! null Do something The null type is rather unusual. It has no name, so you cannot express it in Java source code. And it has no runtime representation either. The sole purpose of the null type is to be the type of null . It is assignment compatible with all reference types, and can be type cast to any reference type. In the latter case, the cast does not entail a runtime type check. Finally, null has the property that null instanceof SomeReferenceType will evaluate to false , no matter what the type is. Section 9.6 Escape sequences in literals String and character literals provide an escape mechanism", "that allows express character codes that would otherwise not be allowed in the literal. An escape sequence consists of a backslash character followed by one ore more other characters. The same sequences are valid in both character an string literals. The complete set of escape sequences is as follows Escape sequence Meaning Denotes an backslash character Denotes a single-quote character Denotes a double-quote character n Denotes a line feed LF character r Denotes a carriage return CR character t Denotes a horizontal tab HT character f Denotes a form feed FF character b Denotes a backspace BS character octal Denotes a character code in the range 0 to 255. The octal in the above consists of one, two or three octal digits 0 through 7 which represent a number between 0 and 255 decimal. Note that a backslash followed by any other character is an invalid escape sequence. Invalid escape sequences are treated as compilation errors by the JLS. GoalKicker.com Java Notes for Professionals 38Reference JLS 3.10.6. Escape Sequences for Character and String Literals Unicode escapes In addition to the string and character escape sequences described above, Java has a more general Unicode escaping mechanism, as de\ufb01ned in JLS", "3.3. Unicode Escapes . A Unicode escape has the following syntax u hex-digit hex-digit hex-digit hex-digit where hex-digit is one of 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, A, B, C, D, E, F. A Unicode escape is mapped by the Java compiler to a character strictly speaking a 16-bit Unicode code unit , and can be used anywhere in the source code where the mapped character is valid. It is commonly used in character and string literals when you need to represent a non-ASCII character in a literal. Escaping in regexes TBD Section 9.7 Character literals Character literals provide the most convenient way to express char values in Java source code. A character literal consists of An opening single-quote character. A representation of a character. This representation cannot be a single-quote or a line-break character, but it can be an escape sequence introduced by a backslash character see Escape sequences in literals. A closing single-quote character. For example char a a char doubleQuote char singleQuote A line-break in a character literal is a compilation error char newline Compilation error in previous line char newLine n Correct Section 9.8 Decimal", "Integer literals Integer literals provide values that can be used where you need a byte , short , int, long or char instance. This example focuses on the simple decimal forms. Other examples explain how to literals in octal, hexadecimal and binary, and the use of underscores to improve readability. Ordinary integer literals The simplest and most common form of integer literal is a decimal integer literal. For example 0 The decimal number zero type int GoalKicker.com Java Notes for Professionals 39 1 The decimal number one type int 42 The decimal number forty two type int You need to be careful with leading zeros. A leading zero causes an integer literal to be interpreted as octal not decimal. 077 This literal actually means 7 x 8 7 ... or 63 decimal! Integer literals are unsigned. If you see something like -10 or 10, these are actually expressions using the unary - and unary operators. The range of integer literals of this form have an intrinsic type of int, and must fall in the range zero to 231 or 2,147,483,648. Note that 231 is 1 greater than Integer.MAXVALUE . Literals from 0 through to 2147483647 can be used anywhere,", "but it is a compilation error to use 2147483648 without a preceding unary - operator. In other words, it is reserved for expressing the value of Integer.MINVALUE . int max 2147483647 OK int min -2147483648 OK int tooBig 2147483648 ERROR Long integer literals Literals of type long are expressed by adding an L su\ufb03x. For example 0L The decimal number zero type long 1L The decimal number one type long 2147483648L The value of Integer.MAXVALUE 1 long big 2147483648 ERROR long big2 2147483648L OK Note that the distinction between int and long literals is signi\ufb01cant in other places. For example int i 2147483647 long l i 1 Produces a negative value because the operation is performed using 32 bit arithmetic, and the addition overflows long l2 i 1L Produces the intuitively correct value. Reference JLS 3.10.1 - Integer Literals Section 9.9 Floating-point literals Floating point literals provide values that can be used where you need a float or double instance. There are three kinds of \ufb02oating point literal. Simple decimal forms Scaled decimal forms Hexadecimal forms The JLS syntax rules combine the two decimal forms into a single form. We treat them separately for ease of explanation. GoalKicker.com Java", "Notes for Professionals 40There are distinct literal types for float and double literals, expressed using su\ufb03xes. The various forms use letters to express di\ufb00erent things. These letters are case insensitive. Simple decimal forms The simplest form of \ufb02oating point literal consists of one or more decimal digits and a decimal point . and an optional su\ufb03x f, F, d or D. The optional su\ufb03x allows you to specify that the literal is a float f or F or double d or D value. The default when no su\ufb03x is speci\ufb01ed is double . For example 0.0 this denotes zero .0 this also denotes zero 0. this also denotes zero 3.14159 this denotes Pi, accurate to approximately! 5 decimal places. 1.0F a float literal 1.0D a double literal. double is the default if no suffix is given In fact, decimal digits followed by a su\ufb03x is also a \ufb02oating point literal. 1F means the same thing as 1.0F The meaning of a decimal literal is the IEEE \ufb02oating point number that is closest to the in\ufb01nite precision mathematical Real number denoted by the decimal \ufb02oating point form. This conceptual value is converted to IEEE binary \ufb02oating point representation using round", "to nearest . The precise semantics of decimal conversion are speci\ufb01ed in the javadocs for Double.valueOfString and Float.valueOfString, bearing in mind that there are di\ufb00erences in the number syntaxes. Scaled decimal forms Scaled decimal forms consist of simple decimal with an exponent part introduced by an E or e, and followed by a signed integer. The exponent part is a short hand for multiplying the decimal form by a power of ten, as shown in the examples below. There is also an optional su\ufb03x to distinguish float and double literals. Here are some examples 1.0E1 this means 1.0 x 101 ... or 10.0 double 1E-1D this means 1.0 x 10-1 ... or 0.1 double 1.0e10f this means 1.0 x 1010 ... or 10000000000.0 float The size of a literal is limited by the representation float or double . It is a compilation error if the scale factor results in a value that is too large or too small. Hexadecimal forms Starting with Java 6, it is possible to express \ufb02oating point literals in hexadecimal. The hexadecimal form have an analogous syntax to the simple and scaled decimal forms with the following di\ufb00erences Every hexadecimal \ufb02oating point literal starts with", "a zero 0 and then an x or X. 1. The digits of the number but not the exponent part! also include the hexadecimal digits a through f and 2. their uppercase equivalents. The exponent is mandatory , and is introduced by the letter p or P instead of an e or E. The exponent 3. represents a scaling factor that is a power of 2 instead of a power of 10. Here are some examples GoalKicker.com Java Notes for Professionals 410x0.0p0f this is zero expressed in hexadecimal form float 0xff.0p19 this is 255.0 x 219 double Advice since hexadecimal \ufb02oating-point forms are unfamiliar to most Java programmers, it is advisable to use them sparingly. Underscores Starting with Java 7, underscores are permitted within the digit strings in all three forms of \ufb02oating point literal. This applies to the exponent parts as well. See Using underscores to improve readability. Special cases It is a compilation error if a \ufb02oating point literal denotes a number that is too large or too small to represent in the selected representation i.e. if the number would over\ufb02ow to INF or -INF, or under\ufb02ow to 0.0. However, it is legal for a literal to", "represent a non-zero denormalized number. The \ufb02oating point literal syntax does not provide literal representations for IEEE 754 special values such as the INF and NaN values. If you need to express them in source code, the recommended way is to use the constants de\ufb01ned by the java.lang.Float and java.lang.Double e.g. Float.NaN, Float.NEGATIVEINFINITY and Float.POSITIVEINFINITY . GoalKicker.com Java Notes for Professionals 42Chapter 10 Primitive Data Types The 8 primitive data types byte , short , int, long , char , boolean , float , and double are the types that store most raw numerical data in Java programs. Section 10.1 The char primitive A char can store a single 16-bit Unicode character. A character literal is enclosed in single quotes char myChar u char myChar2 5 char myChar3 65 myChar3 A It has a minimum value of u0000 0 in the decimal representation, also called the null character and a maximum value of uffff 65,535. The default value of a char is u0000 . char defaultChar defaultChar u0000 In order to de\ufb01ne a char of value an escape sequence character preceded by a backslash has to be used char singleQuote There are also other escape sequences char tab t", "char backspace b char newline n char carriageReturn r char formfeed f char singleQuote char doubleQuote escaping redundant here would be the same however still allowed char backslash char unicodeChar uXXXX XXXX represents the Unicode-value of the character you want to display You can declare a char of any Unicode character. char heart u2764 System.out.printlnCharacter .toString heart Prints a line containing . It is also possible to add to a char . e.g. to iterate through every lower-case letter, you could do to the following for int i 0 i 26 i char letter char a i System.out.printlnletter Section 10.2 Primitive Types Cheatsheet Table showing size and values range of all primitive types data type numeric representation range of valuesdefault value GoalKicker.com Java Notes for Professionals 43boolean na false and true false byte 8-bit signed -27 to 27 - 1 0 -128 to 127 short 16-bit signed -215 to 215 - 1 0 -32,768 to 32,767 int 32-bit signed -231 to 231 - 1 0 -2,147,483,648 to 2,147,483,647 long 64-bit signed -263 to 263 - 1 0L -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 \ufb02oat 32-bit \ufb02oating point 1.401298464e-45 to 3.402823466e38 positive or negative 0.0F double 64-bit \ufb02oating point4.94065645841246544e-324d to 1.79769313486231570e308d positive or", "negative0.0D char 16-bit unsigned 0 to 216 - 1 0 0 to 65,535 Notes The Java Language Speci\ufb01cation mandates that signed integral types byte through long use binary twos- 1. complement representation, and the \ufb02oating point types use standard IEE 754 binary \ufb02oating point representations. Java 8 and later provide methods to perform unsigned arithmetic operations on int and long . While these 2. methods allow a program to treat values of the respective types as unsigned, the types remain signed types. The smallest \ufb02oating point shown above are subnormal i.e. they have less precision than a normal value. The 3. smallest normal numbers are 1.175494351e 38 and 2.2250738585072014e 308 A char conventionally represents a Unicode UTF-16 code unit . 4. Although a boolean contains just one bit of information, its size in memory varies depending on the Java 5. Virtual Machine implementation see boolean type . Section 10.3 The \ufb02oat primitive A float is a single-precision 32-bit IEEE 754 \ufb02oating point number. By default, decimals are interpreted as doubles. To create a float , simply append an f to the decimal literal. double doubleExample 0.5 without f after digits double float floatExample 0.5f with f after digits float", "float myFloat 92.7f this is a float... float positiveFloat 89.3f it can be positive, float negativeFloat -89.3f or negative float integerFloat 43.0f it can be a whole number not an int float underZeroFloat 0.0549f it can be a fractional value less than 0 Floats handle the \ufb01ve common arithmetical operations addition, subtraction, multiplication, division, and modulus. Note The following may vary slightly as a result of \ufb02oating point errors. Some results have been rounded for clarity and readability purposes i.e. the printed result of the addition example was actually 34.600002. addition float result 37.2f -2.6f result 34.6 subtraction float result 45.1f - 10.3f result 34.8 GoalKicker.com Java Notes for Professionals 44 multiplication float result 26.3f 1.7f result 44.71 division float result 37.1f 4.8f result 7.729166 modulus float result 37.1f 4.8f result 3.4999971 Because of the way \ufb02oating point numbers are stored i.e. in binary form, many numbers dont have an exact representation. float notExact 3.1415926f System.out.printlnnotExact 3.1415925 While using float is \ufb01ne for most applications, neither float nor double should be used to store exact representations of decimal numbers like monetary amounts, or numbers where higher precision is required. Instead, the BigDecimal class should be used. The default value", "of a float is 0.0f. float defaultFloat defaultFloat 0.0f A float is precise to roughly an error of 1 in 10 million. Note Float.POSITIVEINFINITY , Float.NEGATIVEINFINITY , Float.NaN are float values. NaN stands for results of operations that cannot be determined, such as dividing 2 in\ufb01nite values. Furthermore 0f and -0f are di\ufb00erent, but yields true float f1 0f float f2 -0f System.out.printlnf1 f2 true System.out.println1f f1 Infinity System.out.println1f f2 -Infinity System.out.printlnFloat.POSITIVEINFINITY Float.POSITIVEINFINITY NaN Section 10.4 The int primitive A primitive data type such as int holds values directly into the variable that is using it, meanwhile a variable that was declared using Integer holds a reference to the value. According to java API The Integer class wraps a value of the primitive type int in an object. An object of type Integer contains a single \ufb01eld whose type is int. By default, int is a 32-bit signed integer. It can store a minimum value of -231, and a maximum value of 231 - 1. int example -42 int myInt 284 int anotherInt 73 int addedInts myInt anotherInt 284 73 357 int subtractedInts myInt - anotherInt 284 - 73 211 If you need to store a number outside of", "this range, long should be used instead. Exceeding the value range of int leads to an integer over\ufb02ow, causing the value exceeding the range to be added to the opposite site of the range positive becomes negative and vise versa. The value is value - MINVALUE RANGE MINVALUE , or value GoalKicker.com Java Notes for Professionals 45 2147483648 4294967296 - 2147483648 int demo 2147483647 maximum positive integer System.out.printlndemo prints 2147483647 demo demo 1 leads to an integer overflow System.out.printlndemo prints -2147483648 The maximum and minimum values of int can be found at int high Integer.MAXVALUE high 2147483647 int low Integer.MINVALUE low -2147483648 The default value of an int is 0 int defaultInt defaultInt 0 Section 10.5 Converting Primitives In Java, we can convert between integer values and \ufb02oating-point values. Also, since every character corresponds to a number in the Unicode encoding, char types can be converted to and from the integer and \ufb02oating-point types. boolean is the only primitive datatype that cannot be converted to or from any other primitive datatype. There are two types of conversions widening conversion and narrowing conversion . A widening conversion is when a value of one datatype is converted to a value of", "another datatype that occupies more bits than the former. There is no issue of data loss in this case. Correspondingly, A narrowing conversion is when a value of one datatype is converted to a value of another datatype that occupies fewer bits than the former. Data loss can occur in this case. Java performs widening conversions automatically. But if you want to perform a narrowing conversion if you are sure that no data loss will occur, then you can force Java to perform the conversion using a language construct known as a cast . Widening Conversion int a 1 double d a valid conversion to double, no cast needed widening Narrowing Conversion double d 18.96 int b d invalid conversion to int, will throw a compile-time error int b int d valid conversion to int, but result is truncated gets rounded down This is type-casting Now, b 18 Section 10.6 Memory consumption of primitives vs. boxed primitives Primitive Boxed Type Memory Size of primitive boxed boolean Boolean 1 byte 16 bytes byte Byte 1 byte 16 bytes short Short 2 bytes 16 bytes GoalKicker.com Java Notes for Professionals 46char Char 2 bytes 16 bytes int Integer 4 bytes 16", "bytes long Long 8 bytes 16 bytes \ufb02oat Float 4 bytes 16 bytes double Double 8 bytes 16 bytes Boxed objects always require 8 bytes for type and memory management, and because the size of objects is always a multiple of 8, boxed types all require 16 bytes total . In addition , each usage of a boxed object entails storing a reference which accounts for another 4 or 8 bytes, depending on the JVM and JVM options. In data-intensive operations, memory consumption can have a major impact on performance. Memory consumption grows even more when using arrays a float5 array will require only 32 bytes whereas a Float5 storing 5 distinct non-null values will require 112 bytes total on 64 bit without compressed pointers, this increases to 152 bytes. Boxed value caches The space overheads of the boxed types can be mitigated to a degree by the boxed value caches. Some of the boxed types implement a cache of instances. For example, by default, the Integer class will cache instances to represent numbers in the range -128 to 127. This does not, however, reduce the additional cost arising from the additional memory indirection. If you create an instance", "of a boxed type either by autoboxing or by calling the static valueOfprimitive method, the runtime system will attempt to use a cached value. If your application uses a lot of values in the range that is cached, then this can substantially reduce the memory penalty of using boxed types. Certainly, if you are creating boxed value instances by hand, it is better to use valueOf rather than new. The new operation always creates a new instance. If, however, the majority of your values are not in the cached range, it can be faster to call new and save the cache lookup. Section 10.7 The double primitive A double is a double-precision 64-bit IEEE 754 \ufb02oating point number. double example -7162.37 double myDouble 974.21 double anotherDouble 658.7 double addedDoubles myDouble anotherDouble 315.51 double subtractedDoubles myDouble - anotherDouble 1632.91 double scientificNotationDouble 1.2e-3 0.0012 Because of the way \ufb02oating point numbers are stored, many numbers dont have an exact representation. double notExact 1.32 - 0.42 result should be 0.9 System.out.printlnnotExact 0.9000000000000001 While using double is \ufb01ne for most applications, neither float nor double should be used to store precise numbers such as currency. Instead, the BigDecimal class should be used The", "default value of a double is 0.0d public double defaultDouble defaultDouble 0.0 GoalKicker.com Java Notes for Professionals 47Note Double.POSITIVEINFINITY , Double.NEGATIVEINFINITY , Double.NaN are double values. NaN stands for results of operations that cannot be determined, such as dividing 2 in\ufb01nite values. Furthermore 0d and -0d are di\ufb00erent, but yields true double d1 0d double d2 -0d System.out.printlnd1 d2 true System.out.println1d d1 Infinity System.out.println1d d2 -Infinity System.out.printlnDouble.POSITIVEINFINITY Double.POSITIVEINFINITY NaN Section 10.8 The long primitive By default, long is a 64-bit signed integer in Java 8, it can be either signed or unsigned. Signed, it can store a minimum value of -263, and a maximum value of 263 - 1, and unsigned it can store a minimum value of 0 and a maximum value of 264 - 1 long example -42 long myLong 284 long anotherLong 73 an L must be appended to the end of the number, because by default, numbers are assumed to be the int type. Appending an L makes it a long as 549755813888 2 39 is larger than the maximum value of an int 231 - 1, L must be appended long bigNumber 549755813888L long addedLongs myLong anotherLong 284 73 357 long subtractedLongs myLong -", "anotherLong 284 - 73 211 The maximum and minimum values of long can be found at long high Long.MAXVALUE high 9223372036854775807L long low Long.MINVALUE low -9223372036854775808L The default value of a long is 0L long defaultLong defaultLong 0L Note letter L appended at the end of long literal is case insensitive, however it is good practice to use capital as it is easier to distinct from digit one 2L 2l true Warning Java caches Integer objects instances from the range -128 to 127. The reasoning is explained here httpsblogs.oracle.comdarcyentryboxingandcachesintegervalueof The following results can be found Long val1 127L Long val2 127L System.out.printlnval1 val2 true Long val3 128L Long val4 128L GoalKicker.com Java Notes for Professionals 48System.out.printlnval3 val4 false To properly compare 2 Object Long values, use the following codeFrom Java 1.7 onward Long val3 128L Long val4 128L System.out.printlnObjects. equalval3, val4 true Comparing a primitive long to an Object long will not result in a false negative like comparing 2 objects with does. Section 10.9 The boolean primitive A boolean can store one of two values, either true or false boolean foo true System.out.printlnfoo foo foo true boolean bar false System.out.printlnbar bar bar false boolean notFoo !foo System.out.printlnnotFoo notFoo", "notFoo false boolean fooAndBar foo bar System.out.printlnfooAndBar fooAndBar fooAndBar false boolean fooOrBar foo bar System.out.printlnfooOrBar fooOrBar fooOrBar true boolean fooXorBar foo bar System.out.printlnfooXorBar fooXorBar fooXorBar true The default value of a boolean is false boolean defaultBoolean defaultBoolean false Section 10.10 The byte primitive A byte is a 8-bit signed integer. It can store a minimum value of -27 -128, and a maximum value of 27 - 1 127 byte example -36 byte myByte 96 byte anotherByte 7 byte addedBytes byte myByte anotherByte 103 byte subtractedBytes byte myBytes - anotherByte 89 The maximum and minimum values of byte can be found at byte high Byte.MAXVALUE high 127 byte low Byte.MINVALUE low -128 The default value of a byte is 0 GoalKicker.com Java Notes for Professionals 49byte defaultByte defaultByte 0 Section 10.11 Negative value representation Java and most other languages store negative integral numbers in a representation called 2s complement notation. For a unique binary representation of a data type using n bits, values are encoded like this The least signi\ufb01cant n-1 bits store a positive integral number x in integral representation. Most signi\ufb01cant value stores a bit vith value s. The value repesented by those bits is x - s", "2n-1 i.e. if the most signi\ufb01cant bit is 1, then a value that is just by 1 larger than the number you could represent with the other bits 2n-2 2n-3 ... 21 20 2n-1 - 1 is subtracted allowing a unique binary representation for each value from - 2n-1 s 1 x 0 to 2n-1 - 1 s 0 x 2n-1 - 1. This also has the nice side e\ufb00ect, that you can add the binary representations as if they were positive binary numbers v1 x1 - s1 2n-1 v2 x2 - s2 2n-1 s1s2x1 x2 over\ufb02ow addition result 00No x1 x2 v1 v2 00Yes too large to be represented with data type over\ufb02ow 01Nox1 x2 - 2n-1 x1 x2 - s2 2n-1 v1 v2 01Yesx1 x2 mod 2n-1 x1 x2 - 2n-1 v1 v2 10 see above swap summands 11No too small to be represented with data type x1 x2 - 2n -2n-1 under\ufb02ow 11Yesx1 x2 mod 2n-1 - 2n-1 x1 x2 - 2n-1 - 2n-1 x1 - s1 2n-1 x2 - s2 2n-1 v1 v2 Note that this fact makes \ufb01nding binary representation of the additive inverse i.e. the negative value easy Observe that adding the bitwise", "complement to the number results in all bits being 1. Now add 1 to make value over\ufb02ow and you get the neutral element 0 all bits 0. So the negative value of a number i can be calculated using ignoring possible promotion to int here i 1 Example taking the negative value of 0 byte The result of negating 0, is 11111111 . Adding 1 gives a value of 100000000 9 bits. Because a byte can only store 8 bits, the leftmost value is truncated, and the result is 00000000 Original Process Result 0 00000000 Negate -0 11111111 11111111 Add 1 to binary 100000000 100000000 Truncate to 8 bits 00000000 -0 equals 0 GoalKicker.com Java Notes for Professionals 50Section 10.12 The short primitive A short is a 16-bit signed integer. It has a minimum value of -215 -32,768, and a maximum value of 215 1 32,767 short example -48 short myShort 987 short anotherShort 17 short addedShorts short myShort anotherShort 1,004 short subtractedShorts short myShort - anotherShort 970 The maximum and minimum values of short can be found at short high Short.MAXVALUE high 32767 short low Short.MINVALUE low -32768 The default value of a short is 0 short defaultShort", "defaultShort 0 GoalKicker.com Java Notes for Professionals 51Chapter 11 Strings Strings java.lang.String are pieces of text stored in your program. Strings are not a primitive data type in Java , however, they are very common in Java programs. In Java, Strings are immutable, meaning that they cannot be changed. Click here for a more thorough explanation of immutability. Section 11.1 Comparing Strings In order to compare Strings for equality, you should use the String objects equals or equalsIgnoreCase methods. For example, the following snippet will determine if the two instances of String are equal on all characters String firstString Test123 String secondString Test 123 if firstString. equalssecondString Both Strings have the same content. Live demo This example will compare them, independent of their case String firstString Test123 String secondString TEST123 if firstString. equalsIgnoreCase secondString Both Strings are equal, ignoring the case of the individual characters. Live demo Note that equalsIgnoreCase does not let you specify a Locale . For instance, if you compare the two words Taki and TAKI in English they are equal however, in Turkish they are di\ufb00erent in Turkish, the lowercase I is \u0131. For cases like this, converting both strings to lowercase or uppercase with", "Locale and then comparing with equals is the solution. String firstString Taki String secondString TAKI System.out.printlnfirstString. equalsIgnoreCase secondString prints true Locale locale Locale.forLanguageTag tr-TR System.out.printlnfirstString. toLowerCase locale.equals secondString. toLowerCase locale prints false Live demo Do not use the operator to compare Strings Unless you can guarantee that all strings have been interned see below, you should not use the or ! GoalKicker.com Java Notes for Professionals 52operators to compare Strings. These operators actually test references, and since multiple String objects can represent the same String, this is liable to give the wrong answer. Instead, use the String.equalsObject method, which will compare the String objects based on their values. For a detailed explanation, please refer to Pitfall using to compare strings. Comparing Strings in a switch statement Version Java SE 7 As of Java 1.7, it is possible to compare a String variable to literals in a switch statement. Make sure that the String is not null, otherwise it will always throw a NullPointerException . Values are compared using String.equals , i.e. case sensitive. String stringToSwitch A switch stringToSwitch case a System.out.printlna break case A System.out.printlnA the code goes here break case B System.out.printlnB break default break Live demo Comparing", "Strings with constant values When comparing a String to a constant value, you can put the constant value on the left side of equals to ensure that you wont get a NullPointerException if the other String is null . baz.equalsfoo While foo.equalsbaz will throw a NullPointerException if foo is null , baz.equalsfoo will evaluate to false . Version Java SE 7 A more readable alternative is to use Objects. equals, which does a null check on both parameters Objects. equalsfoo, baz. Note It is debatable as to whether it is better to avoid NullPointerExceptions in general, or let them happen and then \ufb01x the root cause see here and here. Certainly, calling the avoidance strategy best practice is not justi\ufb01able. String orderings The String class implements Comparable String with the String.compareTo method as described at the start of this example. This makes the natural ordering of String objects case-sensitive order. The String class provide a Comparator String constant called CASEINSENSITIVEORDER suitable for case-insensitive sorting. GoalKicker.com Java Notes for Professionals 53Comparing with interned Strings The Java Language Speci\ufb01cation JLS 3.10.6 states the following Moreover, a string literal always refers to the same instance of class String . This is because", "string literals - or, more generally, strings that are the values of constant expressions - are interned so as to share unique instances, using the method String.intern . This means it is safe to compare references to two string literals using . Moreover, the same is true for references to String objects that have been produced using the String.intern method. For example String strObj new StringHello! String str Hello! The two string references point two strings that are equal if strObj.equalsstr System.out.printlnThe strings are equal The two string references do not point to the same object if strObj ! str System.out.printlnThe strings are not the same object If we intern a string that is equal to a given literal, the result is a string that has the same reference as the literal. String internedStr strObj. intern if internedStr str System.out.printlnThe interned string and the literal are the same object Behind the scenes, the interning mechanism maintains a hash table that contains all interned strings that are still reachable . When you call intern on a String , the method looks up the object in the hash table If the string is found, then that value is returned as the", "interned string. Otherwise, a copy of the string is added to the hash table and that string is returned as the interned string. It is possible to use interning to allow strings to be compared using . However, there are signi\ufb01cant problems with doing this see Pitfall - Interning strings so that you can use is a bad idea for details. It is not recommended in most cases. Section 11.2 Changing the case of characters within a String The String type provides two methods for converting strings between upper case and lower case toUpperCase to convert all characters to upper case toLowerCase to convert all characters to lower case These methods both return the converted strings as new String instances the original String objects are not modi\ufb01ed because String is immutable in Java. See this for more on immutability Immutability of Strings in Java String string This is a Random String GoalKicker.com Java Notes for Professionals 54String upper string. toUpperCase String lower string. toLowerCase System.out.printlnstring prints This is a Random String System.out.printlnlower prints this is a random string System.out.printlnupper prints THIS IS A RANDOM STRING Non-alphabetic characters, such as digits and punctuation marks, are una\ufb00ected by these methods. Note", "that these methods may also incorrectly deal with certain Unicode characters under certain conditions. Note These methods are locale-sensitive , and may produce unexpected results if used on strings that are intended to be interpreted independent of the locale. Examples are programming language identi\ufb01ers, protocol keys, and HTML tags. For instance, TITLE.toLowerCase in a Turkish locale returns t\u0131tle, where \u0131 u0131 is the LATIN SMALL LETTER DOTLESS I character. To obtain correct results for locale insensitive strings, pass Locale.ROOT as a parameter to the corresponding case converting method e.g. toLowerCase Locale.ROOT or toUpperCase Locale.ROOT. Although using Locale.ENGLISH is also correct for most cases, the language invariant way is Locale.ROOT . A detailed list of Unicode characters that require special casing can be found on the Unicode Consortium website . Changing case of a speci\ufb01c character within an ASCII string To change the case of a speci\ufb01c character of an ASCII string following algorithm can be used Steps Declare a string.1. Input the string.2. Convert the string into a character array.3. Input the character that is to be searched.4. Search for the character into the character array.5. If found,check if the character is lowercase or uppercase.6. If Uppercase, add 32", "to the ASCII code of the character. If Lowercase, subtract 32 from the ASCII code of the character. Change the original character from the Character array.7. Convert the character array back into the string.8. Voila, the Case of the character is changed. An example of the code for the algorithm is Scanner scanner new Scanner System.in System.out.printlnEnter the String String s scanner. next char a s.toCharArray System.out.printlnEnter the character you are looking for System.out.printlns String c scanner. next char d c.charAt0 for int i 0 i s.length i if ai d if d a d z d - 32 GoalKicker.com Java Notes for Professionals 55 else if d A d Z d 32 a i d break s String.valueOfa System.out.printlns Section 11.3 Finding a String Within Another String To check whether a particular String a is being contained in a String b or not, we can use the method String.contains with the following syntax b.contains a Return true if a is contained in b, false otherwise The String.contains method can be used to verify if a CharSequence can be found in the String. The method looks for the String a in the String b in a case-sensitive way. String", "str1 Hello World String str2 Hello String str3 helLO System.out.printlnstr1.contains str2 prints true System.out.printlnstr1.contains str3 prints false Live Demo on Ideone To \ufb01nd the exact position where a String starts within another String, use String.indexOf String s this is a long sentence int i s.indexOfi the first i in String is at index 2 int j s.indexOflong the index of the first occurrence of long in s is 10 int k s.indexOfz k is -1 because z was not found in String s int h s.indexOfLoNg h is -1 because LoNg was not found in String s Live Demo on Ideone The String.indexOf method returns the \ufb01rst index of a char or String in another String . The method returns -1 if it is not found. Note The String.indexOf method is case sensitive. Example of search ignoring the case String str1 Hello World String str2 wOr str1.indexOfstr2 -1 str1.toLowerCase .contains str2.toLowerCase true str1.toLowerCase .indexOfstr2.toLowerCase 6 Live Demo on Ideone GoalKicker.com Java Notes for Professionals 56Section 11.4 String pool and heap storage Like many Java objects, all String instances are created on the heap, even literals. When the JVM \ufb01nds a String literal that has no equivalent reference in the", "heap, the JVM creates a corresponding String instance on the heap and it also stores a reference to the newly created String instance in the String pool. Any other references to the same String literal are replaced with the previously created String instance in the heap. Lets look at the following example class Strings public static void main String args String a alpha String b alpha String c new Stringalpha All three strings are equivalent System.out.printlna.equalsb b.equalsc Although only a and b reference the same heap object System.out.printlna b System.out.printlna ! c System.out.printlnb ! c The output of the above is true true true true GoalKicker.com Java Notes for Professionals 57When we use double quotes to create a String, it \ufb01rst looks for String with same value in the String pool, if found it just returns the reference else it creates a new String in the pool and then returns the reference. However using new operator, we force String class to create a new String object in heap space. We can use intern method to put it into the pool or refer to other String object from string pool having same value. The String pool itself is also created", "on the heap. Version Java SE 7 Before Java 7, String literals were stored in the runtime constant pool in the method area of PermGen , that had a \ufb01xed size. The String pool also resided in PermGen . Version Java SE 7 RFC 6962931 In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap known as the young and old generations, along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small di\ufb00erences in heap usage due to this change, but larger applications that load many classes or make heavy use of the String.intern method will see more signi\ufb01cant di\ufb00erences. Section 11.5 Splitting Strings You can split a String on a particular delimiting character or a Regular Expression, you can use the String.split method that has the following signature public String splitString regex Note that delimiting character or regular expression gets removed from the resulting", "String Array. Example using delimiting character String lineFromCsvFile MickeyBolton12345121216 String dataCells lineFromCsvFile. split Result is dataCells Mickey, Bolton, 12345, 121216 Example using regular expression String lineFromInput What do you need from me? String words lineFromInput. splits one or more space chars Result is words What, do, you, need, from, me? You can even directly split a String literal String firstNames Mickey, Frank, Alicia, Tom .split, Result is firstNames Mickey, Frank, Alicia, Tom GoalKicker.com Java Notes for Professionals 58Warning Do not forget that the parameter is always treated as a regular expression. aaa.bbb .split. This returns an empty array In the previous example . is treated as the regular expression wildcard that matches any character, and since every character is a delimiter, the result is an empty array. Splitting based on a delimiter which is a regex meta-character The following characters are considered special aka meta-characters in regex - ! ? . To split a string based on one of the above delimiters, you need to either escape them using or use Pattern. quote Using Pattern. quote String s abc String regex Pattern. quote String arr s.splitregex Escaping the special characters String s abc String arr s.split Split removes empty", "values splitdelimiter by default removes trailing empty strings from result array. To turn this mechanism o\ufb00 we need to use overloaded version of splitdelimiter, limit with limit set to negative value like String split data.split, -1 splitregex internally returns result of splitregex, 0. The limit parameter controls the number of times the pattern is applied and therefore a\ufb00ects the length of the resulting array. If the limit n is greater than zero then the pattern will be applied at most n - 1 times, the arrays length will be no greater than n, and the arrays last entry will contain all input beyond the last matched delimiter. If n is negative, then the pattern will be applied as many times as possible and the array can have any length. If n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded. Splitting with a StringTokenizer Besides the split method Strings can also be split using a StringTokenizer . StringTokenizer is even more restrictive than String.split, and also a bit harder to use. It is essentially designed for pulling out tokens delimited by a", "\ufb01xed set of characters given as a String . Each character will act as a separator. Because of this restriction, its about twice as fast as String.split. Default set of characters are empty spaces tnrf . The following example will print out each word separately. GoalKicker.com Java Notes for Professionals 59String str the lazy fox jumped over the brown fence StringTokenizer tokenizer new StringTokenizer str while tokenizer. hasMoreTokens System.out.printlntokenizer. nextToken This will print out the lazy fox jumped over the brown fence You can use di\ufb00erent character sets for separation. String str jumped over In this case character u and e will be used as delimiters StringTokenizer tokenizer new StringTokenizer str, ue while tokenizer. hasMoreTokens System.out.printlntokenizer. nextToken This will print out j mp d ov r Section 11.6 Joining Strings with a delimiter Version Java SE 8 An array of strings can be joined using the static method String.join String elements foo, bar, foobar String singleString String.join , elements System.out.printlnsingleString Prints foo bar foobar Similarly, theres an overloaded String.join method for Iterable s. To have a \ufb01ne-grained control over joining, you may use StringJoiner class StringJoiner sj new StringJoiner , , , The last two arguments are optional, they", "define prefix and suffix for the result string sj.addfoo sj.addbar sj.addfoobar System.out.printlnsj Prints foo, bar, foobar GoalKicker.com Java Notes for Professionals 60To join a stream of strings, you may use the joining collector StreamString stringStream Stream. offoo, bar, foobar String joined stringStream. collectCollectors. joining, System.out.printlnjoined Prints foo, bar, foobar Theres an option to de\ufb01ne pre\ufb01x and su\ufb03x here as well StreamString stringStream Stream. offoo, bar, foobar String joined stringStream. collectCollectors. joining, , , System.out.printlnjoined Prints foo, bar, foobar Section 11.7 String concatenation and StringBuilders String concatenation can be performed using the operator. For example String s1 a String s2 b String s3 c String s s1 s2 s3 abc Normally a compiler implementation will perform the above concatenation using methods involving a StringBuilder under the hood. When compiled, the code would look similar to the below StringBuilder sb new StringBuilder a String s sb.appendb.appendc.toString StringBuilder has several overloaded methods for appending di\ufb00erent types, for example, to append an int instead of a String . For example, an implementation can convert String s1 a String s2 b String s s1 s2 2 ab2 to the following StringBuilder sb new StringBuilder a String s sb.appendb.append2.toString The above examples illustrate a simple", "concatenation operation that is e\ufb00ectively done in a single place in the code. The concatenation involves a single instance of the StringBuilder . In some cases, a concatenation is carried out in a cumulative way such as in a loop String result forint i 0 i array.length i result extractElement arrayi return result In such cases, the compiler optimization is usually not applied, and each iteration will create a new StringBuilder object. This can be optimized by explicitly transforming the code to use a single StringBuilder StringBuilder result new StringBuilder forint i 0 i array.length i result. appendextractElement arrayi GoalKicker.com Java Notes for Professionals 61 return result. toString A StringBuilder will be initialized with an empty space of only 16 characters. If you know in advance that you will be building larger strings, it can be bene\ufb01cial to initialize it with su\ufb03cient size in advance, so that the internal bu\ufb00er does not need to be resized StringBuilder buf new StringBuilder 30 Default is 16 characters buf.append0123456789 buf.append0123456789 Would cause a reallocation of the internal buffer otherwise String result buf.toString Produces a 20-chars copy of the string If you are producing many strings, it is advisable to reuse StringBuilder s", "StringBuilder buf new StringBuilder 100 for int i 0 i 100 i buf. setLength 0 Empty buffer buf. appendThis is line .appendi.appendn outputfile. writebuf.toString If and only if multiple threads are writing to the same bu\ufb00er, use StringBu\ufb00er , which is a synchronized version of StringBuilder . But because usually only a single thread writes to a bu\ufb00er, it is usually faster to use StringBuilder without synchronization. Using concat method String string1 Hello String string2 world String string3 string1. concatstring2 Hello world This returns a new string that is string1 with string2 added to it at the end. You can also use the concat method with string literals, as in My name is .concatBuyya Section 11.8 Substrings String s this is an example String a s.substring 11 a will hold the string starting at character 11 until the end example String b s.substring 5, 10 b will hold the string starting at character 5 and ending right before character 10 is an String b s.substring 5, b.length-3 b will hold the string starting at character 5 ending right before b s lenght is out of 3 is an exam Substrings may also be applied to slice and addreplace character", "into its original String. For instance, you faced a Chinese date containing Chinese characters but you want to store it as a well format Date String. String datestring 2015 \u5e7411\u670817\u65e5 datestring datestring. substring 0, 4 - datestring. substring 5,7 - datestring. substring 8,10 Result will be 2015-11-17 The substring method extracts a piece of a String . When provided one parameter, the parameter is the start and GoalKicker.com Java Notes for Professionals 62the piece extends until the end of the String . When given two parameters, the \ufb01rst parameter is the starting character and the second parameter is the index of the character right after the end the character at the index is not included. An easy way to check is the subtraction of the \ufb01rst parameter from the second should yield the expected length of the string. Version Java SE 7 In JDK 7u6 versions the substring method instantiates a String that shares the same backing char as the original String and has the internal offset and count \ufb01elds set to the result start and length. Such sharing may cause memory leaks, that can be prevented by calling new Strings.substring ... to force creation of a copy, after", "which the char can be garbage collected. Version Java SE 7 From JDK 7u6 the substring method always copies the entire underlying char array, making the complexity linear compared to the previous constant one but guaranteeing the absence of memory leaks at the same time. Section 11.9 Platform independent new line separator Since the new line separator varies from platform to platform e.g. n on Unix-like systems or rn on Windows it is often necessary to have a platform-independent way of accessing it. In Java it can be retrieved from a system property System.getProperty line.separator Version Java SE 7 Because the new line separator is so commonly needed, from Java 7 on a shortcut method returning exactly the same result as the code above is available System.lineSeparator Note Since it is very unlikely that the new line separator changes during the programs execution, it is a good idea to store it in in a static \ufb01nal variable instead of retrieving it from the system property every time it is needed. When using String.format , use n rather than n or rn to output a platform independent new line separator. System.out.printlnString.formatline 1 s.nline 2 sn , lines0,lines1 Section 11.10 Reversing", "Strings There are a couple ways you can reverse a string to make it backwards. StringBuilderStringBu\ufb00er1. String code code System.out.printlncode StringBuilder sb new StringBuilder code code sb.reverse.toString System.out.printlncode Char array2. GoalKicker.com Java Notes for Professionals 63String code code System.out.printlncode char array code.toCharArray for int index 0, mirroredIndex array.length - 1 index mirroredIndex index, mirroredIndex -- char temp arrayindex array index arraymirroredIndex array mirroredIndex temp print reversed System.out.printlnnew Stringarray Section 11.11 Adding toString method for custom objects Suppose you have de\ufb01ned the following Person class public class Person String name int age public Person int age, String name this.age age this.name name If you instantiate a new Person object Person person new Person25, John and later in your code you use the following statement in order to print the object System.out.printlnperson.toString Live Demo on Ideone youll get an output similar to the following Person7ab89d This is the result of the implementation of the toString method de\ufb01ned in the Object class, a superclass of Person . The documentation of Object.toString states The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character , and the unsigned", "hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of getClass .getName Integer.toHexString hashCode So, for meaningful output, youll have to override the toString method Override GoalKicker.com Java Notes for Professionals 64public String toString return My name is this.name and my age is this.age Now the output will be My name is John and my age is 25 You can also write System.out.printlnperson Live Demo on Ideone In fact, println implicitly invokes the toString method on the object. Section 11.12 Remove Whitespace from the Beginning and End of a String The trim method returns a new String with the leading and trailing whitespace removed. String s new String Hello World!! String t s.trim t Hello World!! If you trim a String that doesnt have any whitespace to remove, you will be returned the same String instance. Note that the trim method has its own notion of whitespace , which di\ufb00ers from the notion used by the Character .isWhitespace method All ASCII control characters with codes U0000 to U0020 are considered whitespace and are removed by trim. This includes U0020 SPACE , U0009 CHARACTER TABULATION , U000A LINE", "FEED and U000D CARRIAGE RETURN characters, but also the characters like U0007 BELL . Unicode whitespace like U00A0 NO-BREAK SPACE or U2003 EM SPACE are not recognized by trim. Section 11.13 Case insensitive switch Version Java SE 7 switch itself can not be parameterised to be case insensitive, but if absolutely required, can behave insensitive to the input string by using toLowerCase or toUpperCase switch myString. toLowerCase case case1 ... break case case2 ... break Beware Locale might a\ufb00ect how changing cases happen! GoalKicker.com Java Notes for Professionals 65Care must be taken not to have any uppercase characters in the labels - those will never get executed! Section 11.14 Replacing parts of Strings Two ways to replace by regex or by exact match. Note the original String object will be unchanged, the return value holds the changed String. Exact match Replace single character with another single character String replace char oldChar, char newChar Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar. String s popcorn System.out.printlns.replacep,W Result WoWcorn Replace sequence of characters with another sequence of characters String replace CharSequence target, CharSequence replacement Replaces each substring of this string that matches the", "literal target sequence with the speci\ufb01ed literal replacement sequence. String s metal petal et al. System.out.printlns.replaceetal,etallica Result metallica petallica et al. Regex Note the grouping uses the character to reference the groups, like 1. Replace all matches String replaceAll String regex, String replacement Replaces each substring of this string that matches the given regular expression with the given replacement. String s spiral metal petal et al. System.out.printlns.replaceAll wetal ,1lica Result GoalKicker.com Java Notes for Professionals 66spiral metallica petallica et al. Replace \ufb01rst match only String replaceFirst String regex, String replacement Replaces the \ufb01rst substring of this string that matches the given regular expression with the given replacement String s spiral metal petal et al. System.out.printlns.replaceAll wetal ,1lica Result spiral metallica petal et al. Section 11.15 Getting the length of a String In order to get the length of a String object, call the length method on it. The length is equal to the number of UTF-16 code units chars in the string. String str Hello, World! System.out.printlnstr.length Prints out 13 Live Demo on Ideone A char in a String is UTF-16 value. Unicode codepoints whose values are 0x1000 for example, most emojis use two char positions. To count the", "number of Unicode codepoints in a String, regardless of whether each codepoint \ufb01ts in a UTF-16 char value, you can use the codePointCount method int length str.codePointCount 0, str.length You can also use a Stream of codepoints, as of Java 8 int length str.codePoints .count Section 11.16 Getting the nth character in a String String str My String System.out.printlnstr.charAt0 M System.out.printlnstr.charAt1 y System.out.printlnstr.charAt2 System.out.printlnstr.charAtstr.length-1 Last character g To get the nth character in a string, simply call charAtn on a String , where n is the index of the character you would like to retrieve NOTE index n is starting at 0, so the \ufb01rst element is at n0. Section 11.17 Counting occurrences of a substring or GoalKicker.com Java Notes for Professionals 67character in a string countMatches method from org.apache.commons.lang3.StringUtils is typically used to count occurrences of a substring or character in a String import org.apache.commons.lang3.StringUtils String text One fish, two fish, red fish, blue fish count occurrences of a substring String stringTarget fish int stringOccurrences StringUtils. countMatches text, stringTarget 4 count occurrences of a char char charTarget , int charOccurrences StringUtils. countMatches text, charTarget 3 Otherwise for does the same with standard Java APIs you could use Regular", "Expressions import java.util.regex.Matcher import java.util.regex.Pattern String text One fish, two fish, red fish, blue fish System.out.printlncountStringInString fish, text prints 4 System.out.printlncountStringInString ,, text prints 3 public static int countStringInString String search, String text Pattern pattern Pattern. compilesearch Matcher matcher pattern. matchertext int stringOccurrences 0 while matcher. find stringOccurrences return stringOccurrences GoalKicker.com Java Notes for Professionals 68Chapter 12 StringBuer Introduction to Java StringBu\ufb00er class. Section 12.1 String Buer class Key Points used to created mutable modi\ufb01able string. Mutable Which can be changed. is thread-safe i.e. multiple threads cannot access it simultaneously. Methods public synchronized StringBu\ufb00er appendString s public synchronized StringBu\ufb00er insertint o\ufb00set, String s public synchronized StringBu\ufb00er replaceint startIndex, int endIndex, String str public synchronized StringBu\ufb00er deleteint startIndex, int endIndex public synchronized StringBu\ufb00er reverse public int capacity public void ensureCapacityint minimumCapacity public char charAtint index public int length public String substringint beginIndex public String substringint beginIndex, int endIndex Example Showing di\ufb00erence between String and String Bu\ufb00er implementation class Test public static void mainString args String str study str.concattonight System.out.printlnstr Output study StringBuffer strB new StringBuffer study strB.appendtonight System.out.printlnstrB Output studytonight GoalKicker.com Java Notes for Professionals 69Chapter 13 StringBuilder Java StringBuilder class is used to create mutable modi\ufb01able string. The Java", "StringBuilder class is same as StringBu\ufb00er class except that it is non-synchronized. It is available since JDK 1.5. Section 13.1 Comparing StringBuer, StringBuilder, Formatter and StringJoiner The StringBuffer , StringBuilder , Formatter and StringJoiner classes are Java SE utility classes that are primarily used for assembling strings from other information The StringBuffer class has been present since Java 1.0, and provides a variety of methods for building and modifying a bu\ufb00er containing a sequence of characters. The StringBuilder class was added in Java 5 to address performance issues with the original StringBuffer class. The APIs for the two clases are essentially the same. The main di\ufb00erence between StringBuffer and StringBuilder is that the former is thread-safe and synchronized and the latter is not. This example shows how StringBuilder is can be used int one 1 String color red StringBuilder sb new StringBuilder sb.appendOne.appendone.append, Color .appendcolor.appendn System.out.printsb Prints One1, Colourred followed by an ASCII newline. The StringBuffer class is used the same way just change StringBuilder to StringBuffer in the above The StringBuffer and StringBuilder classes are suitable for both assembling and modifying strings i.e they provide methods for replacing and removing characters as well as adding them in various.", "The remining two classes are speci\ufb01c to the task of assembling strings. The Formatter class was added in Java 5, and is loosely modeled on the sprintf function in the C standard library. It takes a format string with embedded format speci\ufb01ers and a sequences of other arguments, and generates a string by converting the arguments into text and substituting them in place of the format speci\ufb01ers. The details of the format speci\ufb01ers say how the arguments are converted into text. The StringJoiner class was added in Java 8. It is a special purpose formatter that succinctly formats a sequence of strings with separators between them. It is designed with a \ufb02uent API, and can be used with Java 8 streams. Here are some typical examples of Formatter usage This does the same thing as the StringBuilder example above int one 1 String color red Formatter f new Formatter System.out.printf.formatOned, coloursn , one, color Prints One1, Colourred followed by the platforms line separator The same thing using the String.format convenience method System.out.printString.formatOned, colorsn , one, color GoalKicker.com Java Notes for Professionals 70The StringJoiner class is not ideal for the above task, so here is an example of a formatting", "an array of strings. StringJoiner sj new StringJoiner , , , for String s new StringA, B, C sj.adds System.out.printlnsj Prints A, B, C The use-cases for the 4 classes can be summarized StringBuilder suitable for any string assembly OR string modi\ufb01cation task. StringBuffer use only when you require a thread-safe version of StringBuilder . Formatter provides much richer string formatting functionality, but is not as e\ufb03cient as StringBuilder . This is because each call to Formatter. format... entails parsing the format string, creating and populate a varargs array, and autoboxing any primitive type arguments. StringJoiner provides succinct and e\ufb03cient formatting of a sequence of strings with separators, but is not suitable for other formatting tasks. Section 13.2 Repeat a String n times Problem Create a String containing n repetitions of a String s. The trivial approach would be repeatedly concatenating the String final int n ... final String s ... String result for int i 0 i n i result s This creates n new string instances containing 1 to n repetitions of s resulting in a runtime of Os.length n\u00b2 Os.length 12...n-1n. To avoid this StringBuilder should be used, which allows creating the String in Os.length n", "instead final int n ... final String s ... StringBuilder builder new StringBuilder for int i 0 i n i builder. appends String result builder. toString GoalKicker.com Java Notes for Professionals 71Chapter 14 String Tokenizer The java.util.StringTokenizer class allows you to break a string into tokens. It is simple way to break string. The set of delimiters the characters that separate tokens may be speci\ufb01ed either at creation time or on a per- token basis. Section 14.1 StringTokenizer Split by space import java.util.StringTokenizer public class Simple public static void mainString args StringTokenizer st new StringTokenizer apple ball cat dog , while st.hasMoreTokens System.out.printlnst.nextToken Output apple ball cat dog Section 14.2 StringTokenizer Split by comma , public static void mainString args StringTokenizer st new StringTokenizer apple,ball cat,dog , , while st.hasMoreTokens System.out.printlnst.nextToken Output apple ball cat dog GoalKicker.com Java Notes for Professionals 72Chapter 15 Splitting a string into \ufb01xed length parts Section 15.1 Break a string up into substrings all of a known length The trick is to use a look-behind with the regex G, which means end of previous match String parts str.split?G.8 The regex matches 8 characters after the end of the last match. Since in this case", "the match is zero-width, we could more simply say 8 characters after the last match. Conveniently, G is initialized to start of input, so it works for the \ufb01rst part of the input too. Section 15.2 Break a string up into substrings all of variable length Same as the known length example, but insert the length into regex int length 5 String parts str.split?G. length GoalKicker.com Java Notes for Professionals 73Chapter 16 Date Class Parameter Explanation No parameter Creates a new Date object using the allocation time to the nearest millisecond long dateCreates a new Date object with the time set to the number of milliseconds since the epoch January 1, 1970, 000000 GMT Section 16.1 Convert java.util.Date to java.sql.Date java.util.Date to java.sql.Date conversion is usually necessary when a Date object needs to be written in a database. java.sql.Date is a wrapper around millisecond value and is used by JDBC to identify an SQL DATE type In the below example, we use the java.util.Date constructor, that creates a Date object and initializes it to represent time to the nearest millisecond. This date is used in the convertjava.util.Date utilDate method to return a java.sql.Date object Example public class UtilToSqlConversion public", "static void mainString args java. util.Date utilDate new java.util.Date System.out.printlnjava.util.Date is utilDate java. sql.Date sqlDate convert utilDate System.out.printlnjava.sql.Date is sqlDate DateFormat df new SimpleDateFormat ddMMYYYY - hhmmss System.out.printlndateFormated date is df.formatutilDate private static java.sql.Date convert java.util.Date uDate java. sql.Date sDate new java.sql.DateuDate.getTime return sDate Output java.util.Date is Fri Jul 22 144035 IST 2016 java.sql.Date is 2016-07-22 dateFormated date is 22072016 - 024035 java.util.Date has both date and time information, whereas java.sql.Date only has date information Section 16.2 A basic date output Using the following code with the format string yyyyMMdd hhmm.ss, we will receive the following output 20160419 1145.36 GoalKicker.com Java Notes for Professionals 74 define the format to use String formatString yyyyMMdd hhmm.ss get a current date object Date date Calendar .getInstance .getTime create the formatter SimpleDateFormat simpleDateFormat new SimpleDateFormat formatString format the date String formattedDate simpleDateFormat. formatdate print it System.out.printlnformattedDate single-line version of all above code System.out.printlnnew SimpleDateFormat yyyyMMdd hhmm.ss .formatCalendar .getInstance .getTime Section 16.3 Java 8 LocalDate and LocalDateTime objects Date and LocalDate objects cannot be exactly converted between each other since a Date object represents both a speci\ufb01c day and time, while a LocalDate object does not contain time or timezone information. However, it can", "be useful to convert between the two if you only care about the actual date information and not the time information. Creates a LocalDate Create a default date LocalDate lDate LocalDate. now Creates a date from values lDate LocalDate. of2017, 12, 15 create a date from string lDate LocalDate. parse2017-12-15 creates a date from zone LocalDate. nowZoneId.systemDefault Creates a LocalDateTime Create a default date time LocalDateTime lDateTime LocalDateTime. now Creates a date time from values lDateTime LocalDateTime. of2017, 12, 15, 11, 30 create a date time from string lDateTime LocalDateTime. parse2017-12-05T113030 create a date time from zone LocalDateTime. nowZoneId.systemDefault LocalDate to Date and vice-versa Date date Date.fromInstant. now ZoneId defaultZoneId ZoneId. systemDefault GoalKicker.com Java Notes for Professionals 75 Date to LocalDate LocalDate localDate date.toInstant .atZonedefaultZoneId .toLocalDate LocalDate to Date Date.fromlocalDate. atStartOfDay defaultZoneId .toInstant LocalDateTime to Date and vice-versa Date date Date.fromInstant. now ZoneId defaultZoneId ZoneId. systemDefault Date to LocalDateTime LocalDateTime localDateTime date.toInstant .atZonedefaultZoneId .toLocalDateTime LocalDateTime to Date Date out Date.fromlocalDateTime. atZonedefaultZoneId .toInstant Section 16.4 Creating a Speci\ufb01c Date While the Java Date class has several constructors, youll notice that most are deprecated. The only acceptable way of creating a Date instance directly is either by using the empty constructor", "or passing in a long number of milliseconds since standard base time. Neither are handy unless youre looking for the current date or have another Date instance already in hand. To create a new date, you will need a Calendar instance. From there you can set the Calendar instance to the date that you need. Calendar c Calendar .getInstance This returns a new Calendar instance set to the current time. Calendar has many methods for mutating its date and time or setting it outright. In this case, well set it to a speci\ufb01c date. c.set1974, 6, 2, 8, 0, 0 Date d c.getTime The getTime method returns the Date instance that we need. Keep in mind that the Calendar set methods only set one or more \ufb01elds, they do not set them all. That is, if you set the year, the other \ufb01elds remain unchanged. PITFALL In many cases, this code snippet ful\ufb01lls its purpose, but keep in mind that two important parts of the datetime are not de\ufb01ned. the 1974, 6, 2, 8, 0, 0 parameters are interpreted within the default timezone, de\ufb01ned somewhere else, the milliseconds are not set to zero, but \ufb01lled from the system clock", "at the time the Calendar instance is created. Section 16.5 Converting Date to a certain String format format from SimpleDateFormat class helps to convert a Date object into certain format String object by using the supplied pattern string . Date today new Date GoalKicker.com Java Notes for Professionals 76SimpleDateFormat dateFormat new SimpleDateFormat dd-MMM-yy pattern is specified here System.out.printlndateFormat. formattoday 25-Feb-16 Patterns can be applied again by using applyPattern dateFormat. applyPattern dd-MM-yyyy System.out.printlndateFormat. formattoday 25-02-2016 dateFormat. applyPattern dd-MM-yyyy HHmmss E System.out.printlndateFormat. formattoday 25-02-2016 061433 Thu Note Here mm small letter m denotes minutes and MM capital M denotes month. Pay careful attention when formatting years capital Y Y indicates the week in the year while lower-case y y indicates the year. Section 16.6 LocalTime To use just the time part of a Date use LocalTime. You can instantiate a LocalTime object in a couple ways LocalTime time LocalTime. now 1. time LocalTime. MIDNIGHT 2. time LocalTime. NOON 3. time LocalTime. of12, 12, 45 4. LocalTime also has a built in toString method that displays the format very nicely. System.out.printlntime you can also get, add and subtract hours, minutes, seconds, and nanoseconds from the LocalTime object i.e. time.plusMinutes 1 time.getMinutes time.minusMinutes", "1 You can turn it into a Date object with the following code LocalTime lTime LocalTime. now Instant instant lTime.atDateLocalDate. ofAYEAR, AMONTH, ADAY . atZoneZoneId.systemDefault .toInstant Date time Date.frominstant this class works very nicely within a timer class to simulate an alarm clock. Section 16.7 Convert formatted string representation of date to Date object This method can be used to convert a formatted string representation of a date into a Date object. Parses the date using the given format. param formattedDate the formatted date string param dateFormat the date format which was used to create the string. return the date public static Date parseDate String formattedDate, String dateFormat Date date null GoalKicker.com Java Notes for Professionals 77 SimpleDateFormat objDf new SimpleDateFormat dateFormat try date objDf.parseformattedDate catch ParseException e Do what ever needs to be done with exception. return date Section 16.8 Creating Date objects Date date new Date System.out.printlndate Thu Feb 25 050359 IST 2016 Here this Date object contains the current date and time when this object was created. Calendar calendar Calendar .getInstance calendar. set90, Calendar .DECEMBER , 11 Date myBirthDate calendar. getTime System.out.printlnmyBirthDate Mon Dec 31 000000 IST 1990 Date objects are best created through a Calendar", "instance since the use of the data constructors is deprecated and discouraged. To do se we need to get an instance of the Calendar class from the factory method. Then we can set year, month and day of month by using numbers or in case of months constants provided py the Calendar class to improve readability and reduce errors. calendar. set90, Calendar .DECEMBER , 11, 8, 32, 35 Date myBirthDatenTime calendar. getTime System.out.printlnmyBirthDatenTime Mon Dec 31 083235 IST 1990 Along with date, we can also pass time in the order of hour, minutes and seconds. Section 16.9 Comparing Date objects Calendar, Date, and LocalDate Version Java SE 8 before, after, compareTo and equals methods Use of Calendar and Date objects final Date today new Date final Calendar calendar Calendar .getInstance calendar. set1990, Calendar .NOVEMBER , 1, 0, 0, 0 Date birthdate calendar. getTime final Calendar calendar2 Calendar .getInstance calendar2. set1990, Calendar .NOVEMBER , 1, 0, 0, 0 Date samebirthdate calendar2. getTime Before example System.out.printfIs 1tF before 2tF? 3bn , today, birthdate, Boolean.valueOftoday.beforebirthdate System.out.printfIs 1tF before 1tF? 3bn , today, today, Boolean.valueOftoday.beforetoday System.out.printfIs 2tF before 1tF? 3bn , today, birthdate, Boolean.valueOfbirthdate. beforetoday After example System.out.printfIs 1tF after 2tF? 3bn ,", "today, birthdate, GoalKicker.com Java Notes for Professionals 78Boolean.valueOftoday.afterbirthdate System.out.printfIs 1tF after 1tF? 3bn , today, birthdate, Boolean.valueOftoday.aftertoday System.out.printfIs 2tF after 1tF? 3bn , today, birthdate, Boolean.valueOfbirthdate. aftertoday Compare example System.out.printfCompare 1tF to 2tF 3dn , today, birthdate, Integer.valueOftoday.compareTo birthdate System.out.printfCompare 1tF to 1tF 3dn , today, birthdate, Integer.valueOftoday.compareTo today System.out.printfCompare 2tF to 1tF 3dn , today, birthdate, Integer.valueOfbirthdate. compareTo today Equal example System.out.printfIs 1tF equal to 2tF? 3bn , today, birthdate, Boolean.valueOftoday.equalsbirthdate System.out.printfIs 1tF equal to 2tF? 3bn , birthdate, samebirthdate, Boolean.valueOfbirthdate. equalssamebirthdate System.out.printf Because birthdate.getTime - 1d is different from samebirthdate.getTime - 2d, there are millisecondes!n , Long.valueOfbirthdate. getTime, Long.valueOfsamebirthdate. getTime Clear ms from calendars calendar. clearCalendar .MILLISECOND calendar2. clearCalendar .MILLISECOND birthdate calendar. getTime samebirthdate calendar2. getTime System.out.printfIs 1tF equal to 2tF after clearing ms? 3bn , birthdate, samebirthdate, Boolean.valueOfbirthdate. equalssamebirthdate Version Java SE 8 isBefore, isAfter, compareTo and equals methods Use of LocalDate final LocalDate now LocalDate. now final LocalDate birthdate2 LocalDate. of2012, 6, 30 final LocalDate birthdate3 LocalDate. of2012, 6, 30 Hours, minutes, second and nanoOfsecond can also be configured with an other class LocalDateTime LocalDateTime.ofyear, month, dayOfMonth, hour, minute, second, nanoOfSecond isBefore example System.out.printfIs 1tF before 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.isBefore birthdate2 System.out.printfIs 1tF", "before 1tF? 3bn , now, birthdate2, Boolean.valueOfnow.isBefore now System.out.printfIs 2tF before 1tF? 3bn , now, birthdate2, Boolean.valueOfbirthdate2. isBefore now isAfter example System.out.printfIs 1tF after 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.isAfterbirthdate2 System.out.printfIs 1tF after 1tF? 3bn , now, birthdate2, Boolean.valueOfnow.isAfternow System.out.printfIs 2tF after 1tF? 3bn , now, birthdate2, Boolean.valueOfbirthdate2. isAfternow compareTo example System.out.printfCompare 1tF to 2tF 3dn , now, birthdate2, Integer.valueOfnow.compareTo birthdate2 GoalKicker.com Java Notes for Professionals 79System.out.printfCompare 1tF to 1tF 3dn , now, birthdate2, Integer.valueOfnow.compareTo now System.out.printfCompare 2tF to 1tF 3dn , now, birthdate2, Integer.valueOfbirthdate2. compareTo now equals example System.out.printfIs 1tF equal to 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.equalsbirthdate2 System.out.printfIs 1tF to 2tF? 3bn , birthdate2, birthdate3, Boolean.valueOfbirthdate2. equalsbirthdate3 isEqual example System.out.printfIs 1tF equal to 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.isEqualbirthdate2 System.out.printfIs 1tF to 2tF? 3bn , birthdate2, birthdate3, Boolean.valueOfbirthdate2. isEqualbirthdate3 Date comparison before Java 8 Before Java 8, dates could be compared using java.util.Calendar and java.util.Date classes. Date class o\ufb00ers 4 methods to compare dates afterDate when beforeDate when compareToDate anotherDate equalsObject obj after , before , compareTo and equals methods compare the values returned by getTime method for each date. compareTo method returns positive integer. Value greater than 0 when the Date is after the Date argument", "Value greater than 0 when the Date is before the Date argument Value equals to 0 when the Date is equal to the Date argument equals results can be surprising as shown in the example because values, like milliseconds, are not initialize with the same value if not explicitly given. Since Java 8 With Java 8 a new Object to work with Date is available java.time.LocalDate . LocalDate implements ChronoLocalDate , the abstract representation of a date where the Chronology, or calendar system, is pluggable. To have the date time precision the Object java.time.LocalDateTime has to be used. LocalDate and LocalDateTime use the same methods name for comparing. Comparing dates using a LocalDate is di\ufb00erent from using ChronoLocalDate because the chronology, or calendar system are not taken in account the \ufb01rst one. Because most application should use LocalDate , ChronoLocalDate is not included in examples. Further reading here . Most applications should declare method signatures, \ufb01elds and variables as LocalDate, not thisChronoLocalDate interface. LocalDate has 5 methods to compare dates GoalKicker.com Java Notes for Professionals 80isAfterChronoLocalDate other isBeforeChronoLocalDate other isEqualChronoLocalDate other compareToChronoLocalDate other equalsObject obj In case of LocalDate parameter, isAfter , isBefore , isEqual , equals and compareTo", "now use this method int compareTo0 LocalDate otherDate int cmp year - otherDate. year if cmp 0 cmp month - otherDate. month if cmp 0 cmp day - otherDate. day return cmp equals method check if the parameter reference equals the date \ufb01rst whereas isEqual directly calls compareTo0 . In case of an other class instance of ChronoLocalDate the dates are compared using the Epoch Day . The Epoch Day count is a simple incrementing count of days where day 0 is 1970-01-01 ISO. Section 16.10 Converting String into Date parse from SimpleDateFormat class helps to convert a String pattern into a Date object. DateFormat dateFormat DateFormat .getDateInstance DateFormat .SHORT, Locale.US String dateStr 02252016 input String Date date dateFormat. parsedateStr System.out.printlndate.getYear 116 There are 4 di\ufb00erent styles for the text format, SHORT , MEDIUM this is the default, LONG and FULL , all of which depend on the locale. If no locale is speci\ufb01ed, the system default locale is used. Style Locale.US Locale.France SHORT 63009 300609 MEDIUM Jun 30, 2009 30 juin 2009 LONG June 30, 2009 30 juin 2009 FULL Tuesday, June 30, 2009 mardi 30 juin 2009 Section 16.11 Time Zones and java.util.Date A java.util.Date object does", "not have a concept of time zone. There is no way to set a timezone for a Date There is no way to change the timezone of a Date object A Date object created with the new Date default constructor will be initialised with the current time in the system default timezone However, it is possible to display the date represented by the point in time described by the Date object in a di\ufb00erent time zone using e.g. java.text.SimpleDateFormat Date date new Date GoalKicker.com Java Notes for Professionals 81print default time zone System.out.printlnTimeZone .getDefault .getDisplayName SimpleDateFormat sdf new SimpleDateFormat yyyy-MM-dd HHmmss note time zone not in format! print date in the original time zone System.out.printlnsdf.formatdate current time in London sdf.setTimeZone TimeZone .getTimeZone EuropeLondon System.out.printlnsdf.formatdate Output Central European Time 2016-07-21 225056 2016-07-21 215056 GoalKicker.com Java Notes for Professionals 82Chapter 17 Dates and Time java.time. Section 17.1 Calculate Dierence between 2 LocalDates Use LocalDate and ChronoUnit LocalDate d1 LocalDate. of2017, 5, 1 LocalDate d2 LocalDate. of2017, 5, 18 now, since the method between of the ChronoUnit enumerator takes 2 Temporal s as parameters so you can pass without a problem the LocalDate instances long days ChronoUnit. DAYS.betweend1, d2 System.out.println days Section", "17.2 Date and time Date and time without time zone information LocalDateTime dateTime LocalDateTime. of2016, Month. JULY, 27, 8, 0 LocalDateTime now LocalDateTime. now LocalDateTime parsed LocalDateTime. parse2016-07-27T070000 Date and time with time zone information ZoneId zoneId ZoneId. ofUTC2 ZonedDateTime dateTime ZonedDateTime. of2016, Month. JULY, 27, 7, 0, 0, 235, zoneId ZonedDateTime composition ZonedDateTime. oflocalDate, localTime, zoneId ZonedDateTime now ZonedDateTime. now Default time zone ZonedDateTime parsed ZonedDateTime. parse2016-07-27T0700000100EuropeStockholm Date and time with o\ufb00set information i.e. no DST changes taken into account ZoneOffset zoneOffset ZoneOffset. ofHours2 OffsetDateTime dateTime OffsetDateTime. of2016, 7, 27, 7, 0, 0, 235, zoneOffset OffsetDateTime composition OffsetDateTime. oflocalDate, localTime, zoneOffset OffsetDateTime now OffsetDateTime. now Offset taken from the default ZoneId OffsetDateTime parsed OffsetDateTime. parse2016-07-27T0700000200 Section 17.3 Operations on dates and times LocalDate tomorrow LocalDate. now.plusDays 1 LocalDateTime anHourFromNow LocalDateTime. now.plusHours 1 Long daysBetween java.time.temporal .ChronoUnit .DAYS.betweenLocalDate. now, LocalDate. now.plusDays 3 3 Duration duration Duration. betweenInstant. now, ZonedDateTime. parse2016-07-27T0700000100EuropeStockholm Section 17.4 Instant Represents an instant in time. Can be thought of as a wrapper around a Unix timestamp. Instant now Instant. now Instant epoch1 Instant. ofEpochMilli 0 GoalKicker.com Java Notes for Professionals 83Instant epoch2 Instant. parse1970-01-01T000000Z java.time.temporal .ChronoUnit .MICROS.betweenepoch1, epoch2 0 Section 17.5 Usage of various classes of", "Date Time API Following example also have explanation required for understanding example within it. import java.time.Clock import java.time.Duration import java.time.Instant import java.time.LocalDate import java.time.LocalDateTime import java.time.LocalTime import java.time.ZoneId import java.time.ZonedDateTime import java.util.TimeZone public class SomeMethodsExamples Has the methods of the class link LocalDateTime public static void checkLocalDateTime LocalDateTime localDateTime LocalDateTime. now System.out.printlnLocal Date time using static now method localDateTime LocalDateTime ldt1 LocalDateTime. nowZoneId.ofZoneId.SHORTIDS . getAET System.out . printlnLOCAL TIME USING nowZoneId zoneId method ldt1 LocalDateTime ldt2 LocalDateTime. nowClock.systemZoneId . ofZoneId.SHORTIDS .getPST System.out . printlnLocal TIME USING nowClock.systemZoneId.of ldt2 System.out . printlnFollowing is a static map in ZoneId class which has mapping of short timezone names to their Actual timezone names System.out.printlnZoneId.SHORTIDS This has the methods of the class link LocalDate public static void checkLocalDate LocalDate localDate LocalDate. now System.out.printlnGives date without Time using now method. localDate LocalDate localDate2 LocalDate. nowZoneId.ofZoneId.SHORTIDS . getECT System.out . printlnnow is overridden to take ZoneID as parametere using this we can get the same date under different timezones. localDate2 GoalKicker.com Java Notes for Professionals 84 This has the methods of abstract class link Clock. Clock can be used for time which has time with link TimeZone. public static void checkClock Clock clock Clock.systemUTC Represents", "time according to ISO 8601 System.out.printlnTime using Clock class clock.instant This has the link Instant class methods. public static void checkInstant Instant instant Instant. now System.out.printlnInstant using now method instant Instant ins1 Instant. nowClock.systemUTC System.out.printlnInstants using nowClock clock ins1 This class checks the methods of the link Duration class. public static void checkDuration toString converts the duration to PTnHnMnS format according to ISO 8601 standard. If a field is zero its ignored. P is the duration designator historically called period placed at the start of the duration representation. Y is the year designator that follows the value for the number of years. M is the month designator that follows the value for the number of months. W is the week designator that follows the value for the number of weeks. D is the day designator that follows the value for the number of days. T is the time designator that precedes the time components of the representation. H is the hour designator that follows the value for the number of hours. M is the minute designator that follows the value for the number of minutes. S is the second designator that follows the value for the number of seconds.", "System.out.printlnDuration. ofDays2 Shows Local time without date. It doesnt store or represenet a date and time. Instead its a representation of Time like clock on the wall. public static void checkLocalTime LocalTime localTime LocalTime. now System.out.printlnLocalTime localTime GoalKicker.com Java Notes for Professionals 85 A date time with Time zone details in ISO-8601 standards. public static void checkZonedDateTime ZonedDateTime zonedDateTime ZonedDateTime. nowZoneId . ofZoneId.SHORTIDS .getCST System.out.printlnzonedDateTime Section 17.6 Date Time Formatting Before Java 8, there was DateFormat and SimpleDateFormat classes in the package java.text and this legacy code will be continued to be used for sometime. But, Java 8 o\ufb00ers a modern approach to handling Formatting and Parsing. In formatting and parsing \ufb01rst you pass a String object to DateTimeFormatter , and in turn use it for formatting or parsing. import java.time. import java.time.format. class DateTimeFormat public static void mainString args Parsing String pattern d-MM-yyyy HHmm DateTimeFormatter dtF1 DateTimeFormatter. ofPattern pattern LocalDateTime ldp1 LocalDateTime. parse2014-03-25T0130 , Default format ldp2 LocalDateTime. parse15-05-2016 1355 ,dtF1 Custom format System.out.printlnldp1 n ldp2 Will be printed in Default format Formatting DateTimeFormatter dtF2 DateTimeFormatter. ofPattern EEE d, MMMM, yyyy HHmm DateTimeFormatter dtF3 DateTimeFormatter. ISOLOCALDATETIME LocalDateTime ldtf1 LocalDateTime. now System.out.printlnldtf1.formatdtF2 nldtf1.formatdtF3 An important notice, instead of using", "Custom patterns, it is good practice to use prede\ufb01ned formatters. Your code look more clear and usage of ISO8061 will de\ufb01nitely help you in the long run. Section 17.7 Simple Date Manipulations Get the current date. LocalDate. now Get yesterdays date. GoalKicker.com Java Notes for Professionals 86LocalDate y LocalDate. now.minusDays 1 Get tomorrows date LocalDate t LocalDate. now.plusDays 1 Get a speci\ufb01c date. LocalDate t LocalDate. of1974, 6, 2, 8, 30, 0, 0 In addition to the plus and minus methods, there are a set of with methods that can be used to set a particular \ufb01eld on a LocalDate instance. LocalDate. now.withMonth 6 The example above returns a new instance with the month set to June this di\ufb00ers from java.util.Date where setMonth was indexed a 0 making June 5. Because LocalDate manipulations return immutable LocalDate instances, these methods may also be chained together. LocalDate ld LocalDate. now.plusDays 1.plusYears 1 This would give us tomorrows date one year from now. GoalKicker.com Java Notes for Professionals 87Chapter 18 LocalTime Method Output LocalTime. of13, 12, 11 131211 LocalTime. MIDNIGHT 0000 LocalTime. NOON 1200 LocalTime. now Current time from system clock LocalTime. MAX The maximum supported local time 235959.999999999 LocalTime. MIN The", "minimum supported local time 0000 LocalTime. ofSecondOfDay 84399 235959 , Obtains Time from second-of-day value LocalTime. ofNanoOfDay 2000000000 000002 , Obtains Time from nanos-of-day value Section 18.1 Amount of time between two LocalTime There are two equivalent ways to calculate the amount of time unit between two LocalTime 1 through untilTemporal, TemporalUnit method and through 2 TemporalUnit. betweenTemporal, Temporal . import java.time.LocalTime import java.time.temporal.ChronoUnit public class AmountOfTime public static void mainString args LocalTime start LocalTime. of1, 0, 0 hour, minute, second LocalTime end LocalTime. of2, 10, 20 hour, minute, second long halfDays1 start.untilend, ChronoUnit. HALFDAYS 0 long halfDays2 ChronoUnit. HALFDAYS .betweenstart, end 0 long hours1 start.untilend, ChronoUnit. HOURS 1 long hours2 ChronoUnit. HOURS.betweenstart, end 1 long minutes1 start.untilend, ChronoUnit. MINUTES 70 long minutes2 ChronoUnit. MINUTES.betweenstart, end 70 long seconds1 start.untilend, ChronoUnit. SECONDS 4220 long seconds2 ChronoUnit. SECONDS.betweenstart, end 4220 long millisecs1 start.untilend, ChronoUnit. MILLIS 4220000 long millisecs2 ChronoUnit. MILLIS.betweenstart, end 4220000 long microsecs1 start.untilend, ChronoUnit. MICROS 4220000000 long microsecs2 ChronoUnit. MICROS.betweenstart, end 4220000000 long nanosecs1 start.untilend, ChronoUnit. NANOS 4220000000000 long nanosecs2 ChronoUnit. NANOS.betweenstart, end 4220000000000 Using others ChronoUnit will be thrown UnsupportedTemporalTypeException. The following methods are examples thereof. long days1 start.untilend, ChronoUnit. DAYS long days2 ChronoUnit. DAYS.betweenstart, end GoalKicker.com", "Java Notes for Professionals 88Section 18.2 Intro LocalTime is an immutable class and thread-safe, used to represent time, often viewed as hour-min-sec. Time is represented to nanosecond precision. For example, the value 1345.30.123456789 can be stored in a LocalTime. This class does not store or represent a date or time-zone. Instead, it is a description of the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an o\ufb00set or time- zone. This is a value based class, equals method should be used for comparisons. Fields MAX - The maximum supported LocalTime, 235959.999999999. MIDNIGHT, MIN, NOON Important Static Methods now, nowClock clock, nowZoneId zone, parseCharSequence text Important Instance Methods isAfterLocalTime other, isBeforeLocalTime other, minusTemporalAmount amountToSubtract, minuslong amountToSubtract, TemporalUnit unit, plusTemporalAmount amountToAdd, pluslong amountToAdd, TemporalUnit unit ZoneId zone ZoneId. ofAsiaKolkata LocalTime now LocalTime. now LocalTime now1 LocalTime. nowzone LocalTime then LocalTime. parse041640 Di\ufb00erence in time can be calculated in any of following ways long timeDiff Duration. betweennow, now1 .toMinutes long timeDiff1 java.time.temporal .ChronoUnit .MINUTES.betweennow2, now1 You can also addsubtract hours, minutes or seconds from any object of LocalTime. minusHourslong hoursToSubtract, minusMinuteslong hoursToMinutes, minusNanoslong nanosToSubtract, minusSecondslong secondsToSubtract, plusHourslong hoursToSubtract, plusMinuteslong", "hoursToMinutes, plusNanoslong nanosToSubtract, plusSecondslong secondsToSubtract now.plusHours 1L now1.minusMinutes 20L Section 18.3 Time Modi\ufb01cation You can add hours, minutes, seconds and nanoseconds LocalTime time LocalTime. now LocalTime addHours time.plusHours 5 Add 5 hours LocaLTime addMinutes time.plusMinutes 15 Add 15 minutes LocalTime addSeconds time.plusSeconds 30 Add 30 seconds LocalTime addNanoseconds time.plusNanos 150000000 Add 150.000.000ns 150ms Section 18.4 Time Zones and their time dierence import java.time.LocalTime GoalKicker.com Java Notes for Professionals 89import java.time.ZoneId import java.time.temporal.ChronoUnit public class Test public static void mainString args ZoneId zone1 ZoneId. ofEuropeBerlin ZoneId zone2 ZoneId. ofBrazilEast LocalTime now LocalTime. now LocalTime now1 LocalTime. nowzone1 LocalTime now2 LocalTime. nowzone2 System.out.printlnCurrent Time now System.out.printlnBerlin Time now1 System.out.printlnBrazil Time now2 long minutesBetween ChronoUnit. MINUTES.betweennow2, now1 System.out.printlnMinutes Between Berlin and Brazil minutesBetween mins GoalKicker.com Java Notes for Professionals 90Chapter 19 BigDecimal The BigDecimal class provides operations for arithmetic add, subtract, multiply, divide, scale manipulation, rounding, comparison, hashing, and format conversion. The BigDecimal represents immutable, arbitrary-precision signed decimal numbers. This class shall be used in a necessity of high-precision calculation. Section 19.1 Comparing BigDecimals The method compareTo should be used to compare BigDecimals BigDecimal a new BigDecimal 5 a.compareTo new BigDecimal 0 a is greater, returns 1 a.compareTo new BigDecimal 5 a", "is equal, returns 0 a.compareTo new BigDecimal 10 a is less, returns -1 Commonly you should not use the equals method since it considers two BigDecimals equal only if they are equal in value and also scale BigDecimal a new BigDecimal 5 a.equalsnew BigDecimal 5 value and scale are equal, returns true a.equalsnew BigDecimal 5.00 value is equal but scale is not, returns false Section 19.2 Using BigDecimal instead of \ufb02oat Due to way that the \ufb02oat type is represented in computer memory, results of operations using this type can be inaccurate - some values are stored as approximations. Good examples of this are monetary calculations. If high precision is necessary, other types should be used. e.g. Java 7 provides BigDecimal. import java.math.BigDecimal public class FloatTest public static void mainString args float accountBalance 10000.00f System.out.printlnOperations using float System.out.println1000 operations for 1.99 forint i 0 i1000 i accountBalance - 1.99f System.out.printlnString.formatAccount balance after float operations f , accountBalance BigDecimal accountBalanceTwo new BigDecimal 10000.00 System.out.printlnOperations using BigDecimal System.out.println1000 operations for 1.99 BigDecimal operation new BigDecimal 1.99 forint i 0 i1000 i accountBalanceTwo accountBalanceTwo. subtract operation System.out.printlnString.formatAccount balance after BigDecimal operations f , accountBalanceTwo Output of this program is GoalKicker.com Java Notes", "for Professionals 91Operations using float 1000 operations for 1.99 Account balance after float operations 8009,765625 Operations using BigDecimal 1000 operations for 1.99 Account balance after BigDecimal operations 8010,000000 For a starting balance of 10000.00, after 1000 operations for 1.99, we expect the balance to be 8010.00. Using the \ufb02oat type gives us an answer around 8009.77, which is unacceptably imprecise in the case of monetary calculations. Using BigDecimal gives us the proper result. Section 19.3 BigDecimal.valueOf The BigDecimal class contains an internal cache of frequently used numbers e.g. 0 to 10. The BigDecimal.valueOf methods are provided in preference to constructors with similar type parameters i.e. in the below example a is preferred to b. BigDecimal a BigDecimal .valueOf10L Returns cached Object reference BigDecimal b new BigDecimal 10L Does not return cached Object reference BigDecimal a BigDecimal .valueOf20L Does not return cached Object reference BigDecimal b new BigDecimal 20L Does not return cached Object reference BigDecimal a BigDecimal .valueOf15.15 Preferred way to convert a double or float into a BigDecimal, as the value returned is equal to that resulting from constructing a BigDecimal from the result of using Double.toStringdouble BigDecimal b new BigDecimal 15.15 Return unpredictable result Section 19.4 Mathematical", "operations with BigDecimal This example shows how to perform basic mathematical operations using BigDecimals. 1.Addition BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result a b BigDecimal result a.addb System.out.printlnresult Result 12 2.Subtraction BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result a - b BigDecimal result a.subtract b System.out.printlnresult Result -2 GoalKicker.com Java Notes for Professionals 923.Multiplication When multiplying two BigDecimal s the result is going to have scale equal to the sum of the scales of operands. BigDecimal a new BigDecimal 5.11 BigDecimal b new BigDecimal 7.221 Equivalent to result a b BigDecimal result a.multiply b System.out.printlnresult Result 36.89931 To change the scale of the result use the overloaded multiply method which allows passing MathContext - an object describing the rules for operators, in particular the precision and rounding mode of the result. For more information about available rounding modes please refer to the Oracle Documentation. BigDecimal a new BigDecimal 5.11 BigDecimal b new BigDecimal 7.221 MathContext returnRules new MathContext 4, RoundingMode. HALFDOWN Equivalent to result a b BigDecimal result a.multiply b, returnRules System.out.printlnresult Result 36.90 4.Division Division is a bit more complicated than the other arithmetic operations, for", "instance consider the below example BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 BigDecimal result a.divideb System.out.printlnresult We would expect this to give something similar to 0.7142857142857143, but we would get Result java.lang.ArithmeticException Non-terminating decimal expansion no exact representable decimal result. This would work perfectly well when the result would be a terminating decimal say if I wanted to divide 5 by 2, but for those numbers which upon dividing would give a non terminating result we would get an ArithmeticException . In the real world scenario, one cannot predict the values that would be encountered during the division, so we need to specify the Scale and the Rounding Mode for BigDecimal division. For more information on the Scale and Rounding Mode, refer the Oracle Documentation . For example, I could do BigDecimal a new BigDecimal 5 GoalKicker.com Java Notes for Professionals 93BigDecimal b new BigDecimal 7 Equivalent to result a b Upto 10 Decimal places and Round HALFUP BigDecimal result a.divideb,10,RoundingMode. HALFUP System.out.printlnresult Result 0.7142857143 5.Remainder or Modulus BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result a b BigDecimal result a.remainder b System.out.printlnresult Result 5 6.Power BigDecimal a new BigDecimal 5", "Equivalent to result a10 BigDecimal result a.pow10 System.out.printlnresult Result 9765625 7.Max BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result MAXa,b BigDecimal result a.maxb System.out.printlnresult Result 7 8.Min BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result MINa,b BigDecimal result a.minb System.out.printlnresult Result 5 9.Move Point To Left GoalKicker.com Java Notes for Professionals 94BigDecimal a new BigDecimal 5234.49843776 Moves the decimal point to 2 places left of current position BigDecimal result a.movePointLeft 2 System.out.printlnresult Result 52.3449843776 10.Move Point To Right BigDecimal a new BigDecimal 5234.49843776 Moves the decimal point to 3 places right of current position BigDecimal result a.movePointRight 3 System.out.printlnresult Result 5234498.43776 There are many more options and combination of parameters for the above mentioned examples For instance, there are 6 variations of the divide method, this set is a non-exhaustive list and covers a few basic examples. Section 19.5 Initialization of BigDecimals with value zero, one or ten BigDecimal provides static properties for the numbers zero, one and ten. Its good practise to use these instead of using the actual numbers BigDecimal .ZERO BigDecimal .ONE BigDecimal .TEN By using the static properties, you avoid an unnecessary instantiation, also youve", "got a literal in your code instead of a magic number. Bad example BigDecimal bad0 new BigDecimal 0 BigDecimal bad1 new BigDecimal 1 BigDecimal bad10 new BigDecimal 10 Good Example BigDecimal good0 BigDecimal .ZERO BigDecimal good1 BigDecimal .ONE BigDecimal good10 BigDecimal .TEN Section 19.6 BigDecimal objects are immutable If you want to calculate with BigDecimal you have to use the returned value because BigDecimal objects are immutable BigDecimal a new BigDecimal 42.23 BigDecimal b new BigDecimal 10.001 a.addb a will still be 42.23 GoalKicker.com Java Notes for Professionals 95BigDecimal c a.addb c will be 52.231 GoalKicker.com Java Notes for Professionals 96Chapter 20 BigInteger The BigInteger class is used for mathematical operations involving large integers with magnitudes too large for primitive data types. For example 100-factorial is 158 digits - much larger than a long can represent. BigInteger provides analogues to all of Javas primitive integer operators, and all relevant methods from java.lang.Math as well as few other operations. Section 20.1 Initialization The java.math.BigInteger class provides operations analogues to all of Javas primitive integer operators and for all relevant methods from java.lang.Math . As the java.math package is not automatically made available you may have to import java.math.BigInteger before you", "can use the simple class name. To convert long or int values to BigInteger use long longValue Long.MAXVALUE BigInteger valueFromLong BigInteger .valueOflongValue or, for integers int intValue Integer.MINVALUE negative BigInteger valueFromInt BigInteger .valueOfintValue which will widen the intValue integer to long, using sign bit extension for negative values, so that negative values will stay negative. To convert a numeric String to BigInteger use String decimalString -1 BigInteger valueFromDecimalString new BigInteger decimalString Following constructor is used to translate the String representation of a BigInteger in the speci\ufb01ed radix into a BigInteger . String binaryString 10 int binaryRadix 2 BigInteger valueFromBinaryString new BigInteger binaryString , binaryRadix Java also supports direct conversion of bytes to an instance of BigInteger . Currently only signed and unsigned big endian encoding may be used byte bytes new byte byte 0x80 BigInteger valueFromBytes new BigInteger bytes This will generate a BigInteger instance with value -128 as the \ufb01rst bit is interpreted as the sign bit. byte unsignedBytes new byte byte 0x80 int sign 1 positive BigInteger valueFromUnsignedBytes new BigInteger sign, unsignedBytes This will generate a BigInteger instance with value 128 as the bytes are interpreted as unsigned number, and the sign is explicitly set to 1,", "a positive number. There are prede\ufb01ned constants for common values GoalKicker.com Java Notes for Professionals 97BigInteger .ZERO value of 0. BigInteger .ONE value of 1. BigInteger .TEN value of 10. Theres also BigInteger .TWO value of 2, but you cant use it in your code because its private . Section 20.2 BigInteger Mathematical Operations Examples BigInteger is in an immutable object, so you need to assign the results of any mathematical operation, to a new BigInteger instance. Addition 10 10 20 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 10 BigInteger sum value1. addvalue2 System.out.printlnsum output 20 Subtraction 10 - 9 1 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 9 BigInteger sub value1. subtract value2 System.out.printlnsub output 1 Division 10 5 2 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 5 BigInteger div value1. dividevalue2 System.out.printlndiv output 2 Division 174 4 BigInteger value1 new BigInteger 17 BigInteger value2 new BigInteger 4 BigInteger div value1. dividevalue2 System.out.printlndiv output 4 GoalKicker.com Java Notes for Professionals 98Multiplication 10 5 50 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 5 BigInteger mul value1. multiply value2 System.out.printlnmul output 50 Power 10 3 1000 BigInteger value1 new BigInteger 10 BigInteger", "power value1. pow3 System.out.printlnpower output 1000 Remainder 10 6 4 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 6 BigInteger power value1. remainder value2 System.out.printlnpower output 4 GCD Greatest Common Divisor GCD for 12and 18 is 6. BigInteger value1 new BigInteger 12 BigInteger value2 new BigInteger 18 System.out.printlnvalue1.gcdvalue2 Output 6 Maximum of two BigIntegers BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 11 System.out.printlnvalue1.maxvalue2 Output 11 Minimum of two BigIntegers GoalKicker.com Java Notes for Professionals 99BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 11 System.out.printlnvalue1.minvalue2 Output 10 Section 20.3 Comparing BigIntegers You can compare BigIntegers same as you compare String or other objects in Java. For example BigInteger one BigInteger .valueOf1 BigInteger two BigInteger .valueOf2 ifone.equalstwo System.out.printlnEqual else System.out.printlnNot Equal Output Not Equal Note In general, do not use use the operator to compare BigIntegers operator compares references i.e. whether two values refer to the same object equals method compares the content of two BigIntegers. For example, BigIntegers should not be compared in the following way if firstBigInteger secondBigInteger Only checks for reference equality, not content equality! Doing so may lead to unexpected behavior, as the operator only checks for reference equality. If both BigIntegers contain", "the same content, but do not refer to the same object, this will fail. Instead, compare BigIntegers using the equals methods, as explained above. You can also compare your BigInteger to constant values like 0,1,10. for example BigInteger reallyBig BigInteger .valueOf1 ifBigInteger .ONE.equalsreallyBig code when they are equal. You can also compare two BigIntegers by using compareTo method, as following compareTo returns 3 values. GoalKicker.com Java Notes for Professionals 1000 When both are equal . 1 When \ufb01rst is greater than second the one in brackets. -1 When \ufb01rst is less than second. BigInteger reallyBig BigInteger .valueOf10 BigInteger reallyBig1 BigInteger .valueOf100 ifreallyBig. compareTo reallyBig1 0 code when both are equal. else ifreallyBig. compareTo reallyBig1 1 code when reallyBig is greater than reallyBig1. else ifreallyBig. compareTo reallyBig1 -1 code when reallyBig is less than reallyBig1. Section 20.4 Binary Logic Operations on BigInteger BigInteger supports the binary logic operations that are available to Number types as well. As with all operations they are implemented by calling a method. Binary Or BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9 val1.orval2 Output 11 which is equivalent to 10 9 Binary And BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9", "val1.andval2 Output 8 which is equivalent to 10 9 Binary Xor BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9 val1.xorval2 Output 3 which is equivalent to 10 9 RightShift BigInteger val1 new BigInteger 10 GoalKicker.com Java Notes for Professionals 101val1.shiftRight 1 the argument be an Integer Output 5 equivalent to 10 1 LeftShift BigInteger val1 new BigInteger 10 val1.shiftLeft 1 here parameter should be Integer Output 20 equivalent to 10 1 Binary Inversion Not BigInteger val1 new BigInteger 10 val1.not Output 5 NAND And-Not BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9 val1.andNotval2 Output 7 Section 20.5 Generating random BigIntegers The BigInteger class has a constructor dedicated to generate random BigIntegers , given an instance of java.util.Random and an int that speci\ufb01es how many bits will the BigInteger have. Its usage is quite simple - when you call the constructor BigInteger int, Random like this BigInteger randomBigInt new BigInteger bitCount, sourceOfRandomness then youll end up with a BigInteger whose value is between 0 inclusive and 2 bitCount exclusive. This also means that new BigInteger 2147483647 , sourceOfRandomness may return all positive BigInteger s given enough time. What will the sourceOfRandomness be is up to you.", "For example, a new Random is good enough in most cases new BigInteger 32, new Random If youre willing to give up speed for higher-quality random numbers, you can use a new httpsdocs.oracle.comjavase8docsapijavasecuritySecureRandom.html relnofollow noreferrerSecureRandom instead GoalKicker.com Java Notes for Professionals 102import java.security.SecureRandom somewhere in the code... new BigInteger 32, new SecureRandom You can even implement an algorithm on-the-\ufb02y with an anonymous class! Note that rolling out your own RNG algorithm will end you up with low quality randomness , so always be sure to use an algorithm that is proven to be decent unless you want the resulting BigInteger s to be predictable. new BigInteger 32, new Random int seed 0 Override protected int nextint bits seed 22695477 seed 1 2147483647 Values shamelessly stolen from httpsen.wikipedia.orgwikiLinearcongruentialgeneratorParametersincommonuse relnofollow noreferrerWikipedia return seed GoalKicker.com Java Notes for Professionals 103Chapter 21 NumberFormat Section 21.1 NumberFormat Di\ufb00erent countries have di\ufb00erent number formats and considering this we can have di\ufb00erent formats using Locale of java. Using locale can help in formatting Locale locale new Localeen, IN NumberFormat numberFormat NumberFormat .getInstance locale using above format you can perform various tasks Format Number1. numberFormat. format10000000.99 Format Currency2. NumberFormat currencyFormat NumberFormat .getCurrencyInstance locale currencyFormat. format10340.999 Format Percentage3.", "NumberFormat percentageFormat NumberFormat .getPercentInstance locale percentageFormat. format10929.999 Control Number of Digits4. numberFormat. setMinimumIntegerDigits int digits numberFormat. setMaximumIntegerDigits int digits numberFormat. setMinimumFractionDigits int digits numberFormat. setMaximumFractionDigits int digits GoalKicker.com Java Notes for Professionals 104Chapter 22 Bit Manipulation Section 22.1 Checking, setting, clearing, and toggling individual bits. Using long as bit mask Assuming we want to modify bit n of an integer primitive, i byte, short, char, int, or long i 1 n ! 0 checks bit n i 1 n sets bit n to 1 i 1 n sets bit n to 0 i 1 n toggles the value of bit n Using longintshortbyte as a bit mask public class BitMaskExample private static final long FIRSTBIT 1L 0 private static final long SECONDBIT 1L 1 private static final long THIRDBIT 1L 2 private static final long FOURTHBIT 1L 3 private static final long FIFTHBIT 1L 4 private static final long BIT55 1L 54 public static void mainString args checkBitMask FIRSTBIT THIRDBIT FIFTHBIT BIT55 private static void checkBitMask long bitmask System.out.printlnFIRSTBIT bitmask FIRSTBIT ! 0 System.out.printlnSECONDBIT bitmask SECONDBIT ! 0 System.out.printlnTHIRDBIT bitmask THIRDBIT ! 0 System.out.printlnFOURThBIT bitmask FOURTHBIT ! 0 System.out.printlnFIFTHBIT bitmask FIFTHBIT ! 0 System.out.printlnBIT55 bitmask BIT55 ! 0 Prints", "FIRSTBIT true SECONDBIT false THIRDBIT true FOURThBIT false FIFTHBIT true BIT55 true which matches that mask we passed as checkBitMask parameter FIRSTBIT THIRDBIT FIFTHBIT BIT55 . Section 22.2 java.util.BitSet class Since 1.7 theres a java.util.BitSet class that provides simple and user-friendly bit storage and manipulation interface final BitSet bitSet new BitSet8 by default all bits are unset IntStream. range0, 8.filteri - i 2 0.forEachbitSetset 0, 2, 4, 6 bitSet.set3 0, 2, 3, 4, 6 GoalKicker.com Java Notes for Professionals 105bitSet.set3, false 0, 2, 4, 6 final boolean b bitSet. get3 b false bitSet.flip6 0, 2, 4 bitSet.set100 0, 2, 4, 100 - expands automatically BitSet implements Clonable and Serializable , and under the hood all bit values are stored in long words \ufb01eld, that expands automatically. It also supports whole-set logical operations and, or, xor, andNot bitSet.andnew BitSet8 bitSet.ornew BitSet8 bitSet.xornew BitSet8 bitSet.andNotnew BitSet8 Section 22.3 Checking if a number is a power of 2 If an integer x is a power of 2, only one bit is set, whereas x-1 has all bits set after that. For example 4 is 100 and 3 is 011 as binary number, which satis\ufb01es the aforementioned condition. Zero is not a power", "of 2 and has to be checked explicitly. boolean isPowerOfTwo int x return x ! 0 x x - 1 0 Usage for Left and Right Shift Lets suppose, we have three kind of permissions, READ , WRITE and EXECUTE . Each permission can range from 0 to 7. Let s assume 4 bit number system RESOURCE READ WRITE EXECUTE 12 bit number RESOURCE 0100 0110 0101 4 6 5 12 bit number How can we get the 12 bit number permissions, set on above 12 bit number? 0100 0110 0101 0000 0000 0111 0000 0000 0101 5 So, this is how we can get the EXECUTE permissions of the RESOURCE . Now, what if we want to get READ permissions of the RESOURCE ? 0100 0110 0101 0111 0000 0000 GoalKicker.com Java Notes for Professionals 1060100 0000 0000 1024 Right? You are probably assuming this? But, permissions are resulted in 1024. We want to get only READ permissions for the resource. Don t worry, that s why we had the shift operators. If we see, READ permissions are 8 bits behind the actual result, so if apply some shift operator, which will bring READ permissions to the very", "right of the result? What if we do 0100 0000 0000 8 0000 0000 0100 Because it s a positive number so replaced with 0 s, if you don t care about sign, just use unsigned right shift operator We now actually have the READ permissions which is 4. Now, for example, we are given READ , WRITE , EXECUTE permissions for a RESOURCE , what can we do to make permissions for this RESOURCE ? Lets \ufb01rst take the example of binary permissions. Still assuming 4 bit number system READ 0001 WRITE 0100 EXECUTE 0110 If you are thinking that we will simply do READ WRITE EXECUTE , you are somewhat right but not exactly. See, what will happen if we will perform READ WRITE EXECUTE 0001 0100 0110 0111 But permissions are actually being represented in our example as 0001 0100 0110 So, in order to do this, we know that READ is placed 8 bits behind, WRITE is placed 4 bits behind and PERMISSIONS is placed at the last. The number system being used for RESOURCE permissions is actually 12 bit in our example. It canwill be di\ufb00erent in di\ufb00erent systems. READ 8 WRITE 4 EXECUTE", "0000 0000 0001 8 READ 0001 0000 0000 Left shift by 8 bits 0000 0000 0100 4 WRITE 0000 0100 0000 Left shift by 4 bits 0000 0000 0001 EXECUTE Now if we add the results of above shifting, it will be something like GoalKicker.com Java Notes for Professionals 1070001 0000 0000 READ 0000 0100 0000 WRITE 0000 0000 0001 EXECUTE 0001 0100 0001 PERMISSIONS Section 22.4 Signed vs unsigned shift In Java, all number primitives are signed. For example, an int always represent values from -231 - 1, 231, keeping the \ufb01rst bit to sign the value - 1 for negative value, 0 for positive. Basic shift operators and are signed operators. They will conserve the sign of the value. But it is common for programmers to use numbers to store unsigned values . For an int, it means shifting the range to 0, 232 - 1, to have twice as much value as with a signed int. For those power users, the bit for sign as no meaning. Thats why Java added , a left-shift operator, disregarding that sign bit. initial value 4 100 signed left -shift 4 1 8 1000 signed right -shift 4 1 2", "10 unsigned right -shift 4 1 2 10 initial value -4 11111111111111111111111111111100 signed left -shift -4 1 -8 11111111111111111111111111111000 signed right -shift -4 1 -2 11111111111111111111111111111110 unsigned right -shift -4 1 2147483646 1111111111111111111111111111110 Why is there no ? This comes from the intended de\ufb01nition of right-shift. As it \ufb01lls the emptied places on the left, there are no decision to take regarding the bit of sign. As a consequence, there is no need for 2 di\ufb00erent operators. See this question for a more detailled answer. Section 22.5 Expressing the power of 2 For expressing the power of 2 2n of integers, one may use a bitshift operation that allows to explicitly specify the n. The syntax is basically int pow2 1n Examples int twoExp4 14 24 int twoExp5 15 25 int twoExp6 16 26 ... int twoExp31 131 231 This is especially useful when de\ufb01ning constant values that should make it apparent, that a power of 2 is used, GoalKicker.com Java Notes for Professionals 108instead of using hexadecimal or decimal values. int twoExp4 0x10 hexadecimal int twoExp5 0x20 hexadecimal int twoExp6 64 decimal ... int twoExp31 -2147483648 is that a power of 2? A simple method to calculate the", "int power of 2 would be int pow2int exp return 1exp Section 22.6 Packing unpacking values as bit fragments It is common for memory performance to compress multiple values into a single primitive value. This may be useful to pass various information into a single variable. For example, one can pack 3 bytes - such as color code in RGB - into an single int. Packing the values Raw bytes as input byte b byte0x65, byte0xFF, byte0x31 Packed in big endian x 0x65FF31 int x b0 0xFF 16 Red b1 0xFF 8 Green b2 0xFF 0 Blue Packed in little endian y 0x31FF65 int y b0 0xFF 0 b1 0xFF 8 b2 0xFF 16 Unpacking the values Raw int32 as input int x 0x31FF65 Unpacked in big endian 0x65, 0xFF, 0x31 byte c bytex 16, bytex 8, bytex 0xFF Unpacked in little endian 0x31, 0xFF, 0x65 byte d bytex 0xFF, bytex 8, bytex 16 GoalKicker.com Java Notes for Professionals 109Chapter 23 Arrays Parameter Details ArrayType Type of the array. This can be primitive int, long , byte or Objects String , MyObject , etc. index Index refers to the position of a certain Object in an array. lengthEvery array,", "when being created, needs a set length speci\ufb01ed. This is either done when creating an empty array new int3 or implied when specifying values 1, 2, 3. Arrays allow for the storage and retrieval of an arbitrary quantity of values. They are analogous to vectors in mathematics. Arrays of arrays are analogous to matrices, and act as multidimensional arrays. Arrays can store any data of any type primitives such as int or reference types such as Object . Section 23.1 Creating and Initializing Arrays Basic cases int numbers1 new int3 Array for 3 int values, default value is 0 int numbers2 1, 2, 3 Array literal of 3 int values int numbers3 new int 1, 2, 3 Array of 3 int values initialized int numbers4 1, 2 , 3, 4, 5 Jagged array literal int numbers5 new int5 Jagged array, one dimension 5 long int numbers6 new int54 Multidimensional array 5x4 Arrays may be created using any primitive or reference type. float boats new float5 Array of five 32-bit floating point numbers. double header new double 4.56, 332.267, 7.0, 0.3367, 10.0 Array of five 64-bit floating point numbers. String theory new String a, b, c Array of three strings", "reference type. Object dArt new Object new Object, We love Stack Overflow. , new Integer3 Array of three Objects reference type. For the last example, note that subtypes of the declared array type are allowed in the array. Arrays for user de\ufb01ned types can also be built similar to primitive types UserDefinedClass udType new UserDefinedClass 5 Arrays, Collections, and Streams Version Java SE 1.2 Parameters require objects, not primitives Auto-boxing happening for int 127 here Integer initial 127, Integer.valueOf 42 ListInteger toList Arrays.asList initial Fixed size! Note Works with all collections Integer fromCollection toList. toArray new IntegertoList.size Java doesnt allow you to create an array of a parameterized type ListString list new ArrayList String2 Compilation error! Version Java SE 8 Streams - JDK 8 StreamInteger toStream Arrays.stream initial Integer fromStream toStream. toArray Integernew Intro GoalKicker.com Java Notes for Professionals 110An array is a data structure that holds a \ufb01xed number of primitive values or references to object instances. Each item in an array is called an element, and each element is accessed by its numerical index. The length of an array is established when the array is created int size 42 int array new intsize The size of an", "array is \ufb01xed at runtime when initialized. It cannot be changed after initialization. If the size must be mutable at runtime, a Collection class such as ArrayList should be used instead. ArrayList stores elements in an array and supports resizing by allocating a new array and copying elements from the old array. If the array is of a primitive type, i.e. int array1 1,2,3 int array2 new int10 the values are stored in the array itself. In the absence of an initializer as in array2 above, the default value assigned to each element is 0 zero. If the array type is an object reference, as in SomeClassOrInterface array new SomeClassOrInterface 10 then the array contains references to objects of type SomeClassOrInterface . Those references can refer to an instance of SomeClassOrInterface or any subclass for classes or implementing class for interfaces of SomeClassOrInterface . If the array declaration has no initializer then the default value of null is assigned to each element. Because all arrays are int-indexed, the size of an array must be speci\ufb01ed by an int. The size of the array cannot be speci\ufb01ed as a long long size 23L int array new intsize Compile-time error incompatible", "types possible lossy conversion from long to int Arrays use a zero-based index system, which means indexing starts at 0 and ends at length - 1. For example, the following image represents an array with size 10. Here, the \ufb01rst element is at index 0 and the last element is at index 9, instead of the \ufb01rst element being at index 1 and the last element at index 10 see \ufb01gure below. Accesses to elements of arrays are done in constant time . That means accessing to the \ufb01rst element of the array has the same cost in time of accessing the second element, the third element and so on. Java o\ufb00ers several ways of de\ufb01ning and initializing arrays, including literal and constructor notations. When GoalKicker.com Java Notes for Professionals 111declaring arrays using the new Typelength constructor, each element will be initialized with the following default values 0 for primitive numerical types byte , short , int, long , float , and double . u0000 null character for the char type. false for the boolean type. null for reference types . Creating and initializing primitive type arrays int array1 new int 1, 2, 3 Create an array with new", "operator and array initializer. int array2 1, 2, 3 Shortcut syntax with array initializer. int array3 new int3 Equivalent to 0, 0, 0 int array4 null The array itself is an object, so it can be set as null. When declaring an array, will appear as part of the type at the beginning of the declaration after the type name, or as part of the declarator for a particular variable after variable name, or both int array5 equivalent to int array5 int a, b, c equivalent to int a int b int c int a, b equivalent to int a int b int a, b, c Compilation Error, because is not part of the type at beginning of the declaration, rather it is before b. The same rules apply when declaring a method that returns an array int foo ... equivalent to int foo ... In the following example, both declarations are correct and can compile and run without any problems. However, both the Java Coding Convention and the Google Java Style Guide discourage the form with brackets after the variable name the brackets identify the array type and should appear with the type designation . The same should", "be used for method return signatures. float array and int foo ... are discouraged float array and int foo ... are encouraged The discouraged type is meant to accommodate transitioning C users , who are familiar with the syntax for C which has the brackets after the variable name. In Java, it is possible to have arrays of size 0 int array new int0 Compiles and runs fine. int array2 Equivalent syntax. However, since its an empty array, no elements can be read from it or assigned to it array0 1 Throws java.lang.ArrayIndexOutOfBoundsException. int i array20 Also throws ArrayIndexOutOfBoundsException. Such empty arrays are typically useful as return values, so that the calling code only has to worry about dealing with an array, rather than a potential null value that may lead to a NullPointerException . The length of an array must be a non-negative integer int array new int-1 Throws java.lang.NegativeArraySizeException GoalKicker.com Java Notes for Professionals 112The array size can be determined using a public \ufb01nal \ufb01eld called length System.out.printlnarray.length Prints 0 in this case. Note array.length returns the actual size of the array and not the number of array elements which were assigned a value, unlike ArrayList .size", "which returns the number of array elements which were assigned a value. Creating and initializing multi-dimensional arrays The simplest way to create a multi-dimensional array is as follows int a new int23 It will create two three-length int arrays a0 and a1. This is very similar to the classical, C-style initialization of rectangular multi-dimensional arrays. You can create and initialize at the same time int a 1, 2, 3, 4, 5, 6 Unlike C , where only rectangular multi-dimensional arrays are supported, inner arrays do not need to be of the same length, or even de\ufb01ned int a 1, 2, 3, null Here, a0 is a one-length int array, whereas a1 is a two-length int array and a2 is null . Arrays like this are called jagged arrays or ragged arrays, that is, they are arrays of arrays. Multi-dimensional arrays in Java are implemented as arrays of arrays, i.e. arrayijk is equivalent to arrayijk. Unlike C , the syntax arrayi,j is not supported in Java. Multidimensional array representation in Java Source - Live on Ideone Creating and initializing reference type arrays String array6 new String Laurel , Hardy Create an array with new operator and array initializer. String array7", "Laurel , Hardy Shortcut syntax with array GoalKicker.com Java Notes for Professionals 113 initializer. String array8 new String3 null, null, null String array9 null null Live on Ideone In addition to the String literals and primitives shown above, the shortcut syntax for array initialization also works with canonical Object types Object array10 new Object, new Object Because arrays are covariant, a reference type array can be initialized as an array of a subclass, although an ArrayStoreException will be thrown if you try to set an element to something other than a String Object array11 new String foo, bar, baz array111 qux fine array111 new StringBuilder throws ArrayStoreException The shortcut syntax cannot be used for this because the shortcut syntax would have an implicit type of Object. An array can be initialized with zero elements by using String emptyArray new String0. For example, an array with zero length like this is used for Creating an Array from a Collection when the method needs the runtime type of an object. In both primitive and reference types, an empty array initialization for example String array8 new String3 will initialize the array with the default value for each data type . Creating and", "initializing generic type arrays In generic classes, arrays of generic types cannot be initialized like this due to type erasure public class MyGenericClass T private T a public MyGenericClass a new T5 Compile time error generic array creation Instead, they can be created using one of the following methods note that these will generate unchecked warnings By creating an Object array, and casting it to the generic type 1. a T new Object5 This is the simplest method, but since the underlying array is still of type Object, this method does not provide type safety. Therefore, this method of creating an array is best used only within the generic class - not exposed publicly. By using Array.newInstance with a class parameter 2. public MyGenericClass ClassT clazz a T Array.newInstance clazz, 5 GoalKicker.com Java Notes for Professionals 114 Here the class of T has to be explicitly passed to the constructor. The return type of Array.newInstance is always Object . However, this method is safer because the newly created array is always of type T, and therefore can be safely externalized. Filling an array after initialization Version Java SE 1.2 Arrays.fill can be used to \ufb01ll an array with the", "same value after initialization Arrays.fillarray8, abc abc, abc, abc Live on Ideone fill can also assign a value to each element of the speci\ufb01ed range of the array Arrays.fillarray8, 1, 2, aaa Placing aaa from index 1 to 2. Live on Ideone Version Java SE 8 Since Java version 8, the method setAll , and its Concurrent equivalent parallelSetAll , can be used to set every element of an array to generated values. These methods are passed a generator function which accepts an index and returns the desired value for that position. The following example creates an integer array and sets all of its elements to their respective index value int array new int5 Arrays.setAllarray, i - i The array becomes 0, 1, 2, 3, 4 . Live on Ideone Separate declaration and initialization of arrays The value of an index for an array element must be a whole number 0, 1, 2, 3, 4, ... and less than the length of the array indexes are zero-based. Otherwise, an ArrayIndexOutOfBoundsException will be thrown int array9 Array declaration - uninitialized array9 new int3 Initialize array - 0, 0, 0 array90 10 Set index 0 value - 10, 0, 0 array91", "20 Set index 1 value - 10, 20, 0 array92 30 Set index 2 value - 10, 20, 30 Arrays may not be re-initialized with array initializer shortcut syntax It is not possible to re-initialize an array via a shortcut syntax with an array initializer since an array initializer can only be speci\ufb01ed in a \ufb01eld declaration or local variable declaration, or as a part of an array creation expression. However, it is possible to create a new array and assign it to the variable being used to reference the old array. While this results in the array referenced by that variable being re-initialized, the variable contents are a completely new array. To do this, the new operator can be used with an array initializer and assigned to the array variable First initialization of array int array new int 1, 2, 3 GoalKicker.com Java Notes for Professionals 115 Prints 1 2 3 . for int i array System.out.printi Re-initializes array to a new int array. array new int 4, 5, 6 Prints 4 5 6 . for int i array System.out.printi array 1, 2, 3, 4 Compile-time error! Cant re-initialize an array via shortcut syntax with array initializer. Live", "on Ideone Section 23.2 Creating a List from an Array The Arrays.asList method can be used to return a \ufb01xed-size List containing the elements of the given array. The resulting List will be of the same parameter type as the base type of the array. String stringArray foo, bar, baz ListString stringList Arrays.asListstringArray Note This list is backed by a view of the original array, meaning that any changes to the list will change the array and vice versa. However, changes to the list that would change its size and hence the array length will throw an exception. To create a copy of the list, use the constructor of java.util.ArrayList taking a Collection as an argument Version Java SE 5 String stringArray foo, bar, baz ListString stringList new ArrayList StringArrays.asListstringArray Version Java SE 7 In Java SE 7 and later, a pair of angle brackets empty set of type arguments can be used, which is called the Diamond. The compiler can determine the type arguments from the context. This means the type information can be left out when calling the constructor of ArrayList and it will be inferred automatically during compilation. This is called Type Inference which is a", "part of Java Generics. Using Arrays.asList String stringArray foo, bar, baz ListString stringList new ArrayList Arrays.asListstringArray Using ArrayList.addAll String stringArray foo, bar, baz ArrayList String list new ArrayList list.addAllArrays.asListstringArray Using Collections.addAll String stringArray foo, bar, baz ArrayList String list new ArrayList Collections .addAlllist, stringArray GoalKicker.com Java Notes for Professionals 116A point worth noting about the Diamond is that it cannot be used with Anonymous Classes. Version Java SE 8 Using Streams int ints 1, 2, 3 ListInteger list Arrays.streamints.boxed.collectCollectors. toList String stringArray foo, bar, baz ListObject list Arrays.streamstringArray .collectCollectors. toList Important notes related to using Arrays.asList method This method returns List , which is an instance of ArraysArrayList static inner class of Arrays and not java.util.ArrayList . The resulting List is of \ufb01xed-size. That means, adding or removing elements is not supported and will throw an UnsupportedOperationException stringList. addsomething throws java.lang.UnsupportedOperationException A new List can be created by passing an array-backed List to the constructor of a new List . This creates a new copy of the data, which has changeable size and that is not backed by the original array ListString modifiableList new ArrayList Arrays.asListfoo, bar Calling T ListT asListT... a on a primitive array, such as an", "int, will produce a Listint whose only element is the source primitive array instead of the actual elements of the source array. The reason for this behavior is that primitive types cannot be used in place of generic type parameters, so the entire primitive array replaces the generic type parameter in this case. In order to convert a primitive array to a List , \ufb01rst of all, convert the primitive array to an array of the corresponding wrapper type i.e. call Arrays.asList on an Integer instead of an int. Therefore, this will print false int arr 1, 2, 3 primitive array of int System.out.printlnArrays.asListarr.contains 1 View Demo On the other hand, this will print true Integer arr 1, 2, 3 object array of Integer wrapper for int System.out.printlnArrays.asListarr.contains 1 View Demo This will also print true , because the array will be interpreted as an Integer System.out.printlnArrays.asList1,2,3.contains 1 View Demo GoalKicker.com Java Notes for Professionals 117Section 23.3 Creating an Array from a Collection Two methods in java.util.Collection create an array from a collection Object toArray T T toArrayT a Object toArray can be used as follows Version Java SE 5 SetString set new HashSet String set.addred set.addblue although set", "is a SetString, toArray returns an Object not a String Object objectArray set.toArray T T toArrayT a can be used as follows Version Java SE 5 SetString set new HashSet String set.addred set.addblue The array does not need to be created up front with the correct size. Only the array type matters. If the size is wrong, a new array will be created with the same type. String stringArray set.toArraynew String0 If you supply an array of the same size as collection or bigger, it will be populated with collection values and returned new array wont be allocated String stringArray2 set.toArraynew Stringset.size The di\ufb00erence between them is more than just having untyped vs typed results. Their performance can di\ufb00er as well for details please read this performance analysis section Object toArray uses vectorized arraycopy , which is much faster than the type-checked arraycopy used in T toArray T a. T toArray new Tnon-zero-size needs to zero-out the array at runtime, while T toArray new T0 does not. Such avoidance makes the latter call faster than the former. Detailed analysis here Arrays of Wisdom of the Ancients . Version Java SE 8 Starting from Java SE 8, where the concept", "of Stream has been introduced, it is possible to use the Stream produced by the collection in order to create a new Array using the Stream.toArray method. String strings list.stream.toArrayStringnew Examples taken from two answers 1, 2 to Converting ArrayList to String in Java on Stack Over\ufb02ow. Section 23.4 Multidimensional and Jagged Arrays It is possible to de\ufb01ne an array with more than one dimension. Instead of being accessed by providing a single index, a multidimensional array is accessed by specifying an index for each dimension. GoalKicker.com Java Notes for Professionals 118The declaration of multidimensional array can be done by adding for each dimension to a regular array declaration. For instance, to make a 2-dimensional int array, add another set of brackets to the declaration, such as int. This continues for 3-dimensional arrays int and so forth. To de\ufb01ne a 2-dimensional array with three rows and three columns int rows 3 int columns 3 int table new introwscolumns The array can be indexed and assign values to it with this construct. Note that the unassigned values are the default values for the type of an array, in this case 0 for int. table00 0 table01 1 table02 2 It", "is also possible to instantiate a dimension at a time, and even make non-rectangular arrays. These are more commonly referred to as jagged arrays . int nonRect new int4 It is important to note that although it is possible to de\ufb01ne any dimension of jagged array, its preceding level must be de\ufb01ned. valid String employeeGraph new String30 invalid int unshapenMatrix new int10 also invalid int misshapenGrid new int10010 How Multidimensional Arrays are represented in Java Image source httpmath.hws.edueckcs124javanotes3c8s5.html GoalKicker.com Java Notes for Professionals 119Jagged array literal intialization Multidimensional arrays and jagged arrays can also be initialized with a literal expression. The following declares and populates a 2x3 int array int table 1, 2, 3, 4, 5, 6 Note Jagged subarrays may also be null . For instance, the following code declares and populates a two dimensional int array whose \ufb01rst subarray is null , second subarray is of zero length, third subarray is of one length and the last subarray is a two length array int table null, , 1, 1,2 For multidimensional array it is possible to extract arrays of lower-level dimension by their indices int arr new int333 int arr1 arr0 get first 3x3-dimensional array from arr", "int arr2 arr10 get first 3-dimensional array from arr1 int arr3 arr0 error cannot convert from int to int Section 23.5 ArrayIndexOutOfBoundsException The ArrayIndexOutOfBoundsException is thrown when a non-existing index of an array is being accessed. Arrays are zero-based indexed, so the index of the \ufb01rst element is 0 and the index of the last element is the array capacity minus 1 i.e. array.length - 1. Therefore, any request for an array element by the index i has to satisfy the condition 0 i array.length , otherwise the ArrayIndexOutOfBoundsException will be thrown. The following code is a simple example where an ArrayIndexOutOfBoundsException is thrown. String people new String Carol, Andy An array will be created people0 Carol people1 Andy Notice no item on index 2. Trying to access it triggers the exception System.out.printlnpeople2 throws an ArrayIndexOutOfBoundsException. Output Exception in thread main java.lang.ArrayIndexOutOfBoundsException 2 at your.package.path.methodYourClass.java15 Note that the illegal index that is being accessed is also included in the exception 2 in the example this information could GoalKicker.com Java Notes for Professionals 120be useful to \ufb01nd the cause of the exception. To avoid this, simply check that the index is within the limits of the array int index 2", "if index 0 index people. length System.out.printlnpeopleindex Section 23.6 Array Covariance Object arrays are covariant, which means that just as Integer is a subclass of Number , Integer is a subclass of Number. This may seem intuitive, but can result in surprising behavior Integer integerArray 1, 2, 3 Number numberArray integerArray valid Number firstElement numberArray 0 valid numberArray 0 4L throws ArrayStoreException at runtime Although Integer is a subclass of Number, it can only hold Integer s, and trying to assign a Long element throws a runtime exception. Note that this behavior is unique to arrays, and can be avoided by using a generic List instead ListInteger integerList Arrays.asList1, 2, 3 ListNumber numberList integerList compile error List? extends Number numberList integerList Number firstElement numberList. get0 numberList.set0, 4L compile error Its not necessary for all of the array elements to share the same type, as long as they are a subclass of the arrays type interface I class A implements I class B implements I class C implements I I array10 new I new A, new B, new C Create an array with new operator and array initializer. I array11 new A, new B, new C Shortcut syntax with array", "initializer. I array12 new I3 null, null, null I array13 new A new A, new A Works because A implements I. Object array14 new Object Hello, World! , 3.14159, 42 Create an array with new operator and array initializer. Object array15 new A, 64, My String Shortcut syntax with array initializer. GoalKicker.com Java Notes for Professionals 121Section 23.7 Arrays to Stream Version Java SE 8 Converting an array of objects to Stream String arr new String str1, str2, str3 StreamString stream Arrays.streamarr Converting an array of primitives to Stream using Arrays.stream will transform the array to a primitive specialization of Stream int intArr 1, 2, 3 IntStream intStream Arrays.streamintArr You can also limit the Stream to a range of elements in the array. The start index is inclusive and the end index is exclusive int values 1, 2, 3, 4 IntStream intStream Arrays.streamvalues, 2, 4 A method similar to Arrays.stream appears in the Stream class Stream.of. The di\ufb00erence is that Stream.of uses a varargs parameter, so you can write something like StreamInteger intStream Stream. of1, 2, 3 StreamString stringStream Stream. of1, 2, 3 StreamDouble doubleStream Stream. ofnew Double1.0, 2.0 Section 23.8 Iterating over arrays You can iterate over arrays", "either by using enhanced for loop aka foreach or by using array indices int array new int10 using indices read and write for int i 0 i array.length i array i i Version Java SE 5 extended for read only for int e array System.out.printlne It is worth noting here that there is no direct way to use an Iterator on an Array, but through the Arrays library it can be easily converted to a list to obtain an Iterable object. For boxed arrays use Arrays.asList Integer boxed 1, 2, 3 Iterable Integer boxedIt Arrays.asListboxed list-backed iterable Iterator Integer fromBoxed1 boxedIt. iterator For primitive arrays using java 8 use streams speci\ufb01cally in this example - Arrays.stream - IntStream int primitives 1, 2, 3 GoalKicker.com Java Notes for Professionals 122IntStream primitiveStream Arrays.streamprimitives list-backed iterable PrimitiveIterator. OfInt fromPrimitive1 primitiveStream. iterator If you cant use streams no java 8, you can choose to use googles guava library Iterable Integer fromPrimitive2 Ints.asListprimitives In two-dimensional arrays or more, both techniques can be used in a slightly more complex fashion. Example int array new int1010 for int indexOuter 0 indexOuter array.length indexOuter for int indexInner 0 indexInner arrayindexOuter .length indexInner array indexOuter indexInner indexOuter indexInner", "Version Java SE 5 for int numbers array for int value numbers System.out.printlnvalue It is impossible to set an Array to any non-uniform value without using an index based loop. Of course you can also use while or do-while loops when iterating using indices. One note of caution when using array indices, make sure the index is between 0 and array.length - 1 both inclusive. Dont make hard coded assumptions on the array length otherwise you might break your code if the array length changes but your hard coded values dont. Example int numbers 1, 2, 3, 4 public void incrementNumbers DO THIS for int i 0 i numbers. length i numbers i 1 or this numbersi numbersi 1 or numbersi DONT DO THIS for int i 0 i 4 i numbers i 1 Its also best if you dont use fancy calculations to get the index but use the index to iterate and if you need di\ufb00erent values calculate those. Example public void fillArrayWithDoubleIndex int array DO THIS for int i 0 i array.length i array i i 2 GoalKicker.com Java Notes for Professionals 123 DONT DO THIS int doubleLength array.length 2 for int i 0 i doubleLength", "i 2 array i 2 i Accessing Arrays in reverse order int array 0, 1, 1, 2, 3, 5, 8, 13 for int i array.length - 1 i 0 i-- System.out.printlnarrayi Using temporary Arrays to reduce code repetition Iterating over a temporary array instead of repeating code can make your code cleaner. It can be used where the same operation is performed on multiple variables. we want to print out all of these String name Margaret int eyeCount 16 double height 50.2 int legs 9 int arms 5 copy-paste approach System.out.printlnname System.out.printlneyeCount System.out.printlnheight System.out.printlnlegs System.out.printlnarms temporary array approach forObject attribute new Objectname, eyeCount, height, legs, arms System.out.printlnattribute using only numbers fordouble number new doubleeyeCount, legs, arms, height System.out.printlnMath.sqrtnumber Keep in mind that this code should not be used in performance-critical sections, as an array is created every time the loop is entered, and that primitive variables will be copied into the array and thus cannot be modi\ufb01ed. Section 23.9 Arrays to a String Version Java SE 5 Since Java 1.5 you can get a String representation of the contents of the speci\ufb01ed array without iterating over its every element. Just use Arrays.toString Object or Arrays.deepToString Object for multidimentional arrays", "int arr 1, 2, 3, 4, 5 System.out.printlnArrays.toString arr 1, 2, 3, 4, 5 GoalKicker.com Java Notes for Professionals 124int arr 1, 2, 3, 4, 5, 6, 7, 8, 9 System.out.printlnArrays.deepToString arr 1, 2, 3, 4, 5, 6, 7, 8, 9 Arrays.toString method uses Object.toString method to produce String values of every item in the array, beside primitive type array, it can be used for all type of arrays. For instance public class Cat implicitly extends Object Override public String toString return CAT! Cat arr new Cat, new Cat System.out.printlnArrays.toString arr CAT!, CAT! If no overridden toString exists for the class, then the inherited toString from Object will be used. Usually the output is then not very useful, for example public class Dog implicitly extends Object Dog arr new Dog System.out.printlnArrays.toString arr Dog17ed40e0 Section 23.10 Sorting arrays Sorting arrays can be easily done with the Arrays api. import java.util.Arrays creating an array with integers int array 7, 4, 2, 1, 19 this is the sorting part just one function ready to be used Arrays.sortarray prints 1, 2, 4, 7, 19 System.out.printlnArrays.toString array Sorting String arrays String is not a numeric data, it de\ufb01nes its own order which is called", "lexicographic order, also known as alphabetic order. When you sort an array of String using sort method, it sorts array into natural order de\ufb01ned by Comparable interface, as shown below Increasing Order String names John, Steve, Shane, Adam, Ben System.out.printlnString array before sorting Arrays.toString names Arrays.sortnames System.out.printlnString array after sorting in ascending order Arrays.toString names Output GoalKicker.com Java Notes for Professionals 125String array before sorting John, Steve, Shane, Adam, Ben String array after sorting in ascending order Adam, Ben, John, Shane, Steve Decreasing Order Arrays.sortnames, 0, names. length, Collections .reverseOrder System.out.printlnString array after sorting in descending order Arrays.toString names Output String array after sorting in descending order Steve, Shane, John, Ben, Adam Sorting an Object array In order to sort an object array, all elements must implement either Comparable or Comparator interface to de\ufb01ne the order of the sorting. We can use either sortObject method to sort an object array on its natural order, but you must ensure that all elements in the array must implement Comparable . Furthermore, they must be mutually comparable as well, for example e1.compareTo e2 must not throw a ClassCastException for any elements e1 and e2 in the array. Alternatively you can sort an", "Object array on custom order using sortT, Comparator method as shown in following example. How to Sort Object Array in Java using Comparator and Comparable Course courses new Course4 courses0 new Course101, Java, 200 courses1 new Course201, Ruby, 300 courses2 new Course301, Python , 400 courses3 new Course401, Scala, 500 System.out.printlnObject array before sorting Arrays.toString courses Arrays.sortcourses System.out.printlnObject array after sorting in natural order Arrays.toString courses Arrays.sortcourses, new Course. PriceComparator System.out.printlnObject array after sorting by price Arrays.toString courses Arrays.sortcourses, new Course. NameComparator System.out.printlnObject array after sorting by name Arrays.toString courses Output Object array before sorting 101 Java200 , 201 Ruby300 , 301 Python400 , 401 Scala500 Object array after sorting in natural order 101 Java200 , 201 Ruby300 , 301 Python400 , 401 Scala500 Object array after sorting by price 101 Java200 , 201 Ruby300 , 301 Python400 , 401 Scala500 Object array after sorting by name 101 Java200 , 301 Python400 , 201 Ruby300 , 401 Scala500 GoalKicker.com Java Notes for Professionals 126Section 23.11 Getting the Length of an Array Arrays are objects which provide space to store up to its size of elements of speci\ufb01ed type. An arrays size can not be modi\ufb01ed after the array is", "created. int arr1 new int0 int arr2 new int2 int arr3 new int1, 2, 3, 4 int arr4 1, 2, 3, 4, 5, 6, 7 int len1 arr1.length 0 int len2 arr2.length 2 int len3 arr3.length 4 int len4 arr4.length 7 The length \ufb01eld in an array stores the size of an array. It is a final \ufb01eld and cannot be modi\ufb01ed. This code shows the di\ufb00erence between the length of an array and amount of objects an array stores. public static void mainString args Integer arr new Integer 1,2,3,null,5,null,7,null,null,null,11,null,13 int arrayLength arr.length int nonEmptyElementsCount 0 for int i0 iarrayLength i Integer arrElt arri if arrElt ! null nonEmptyElementsCount System.out.printlnArray arr has a length of arrayLength n and it contains nonEmptyElementsCount non-empty values Result Array arr has a length of 13 and it contains 7 non-empty values Section 23.12 Finding an element in an array There are many ways \ufb01nd the location of a value in an array. The following example snippets all assume that the array is one of the following String strings new String A, B, C int ints new int 1, 2, 3, 4 In addition, each one sets index or index2 to either the index", "of required element, or -1 if the element is not present. Using Arrays.binarySearch for sorted arrays only int index Arrays.binarySearch strings, A int index2 Arrays.binarySearch ints, 1 GoalKicker.com Java Notes for Professionals 127Using a Arrays.asList for non-primitive arrays only int index Arrays.asListstrings.indexOfA int index2 Arrays.asListints.indexOf1 compilation error Using a Stream Version Java SE 8 int index IntStream. range0, strings. length . filteri - A.equalsstringsi . findFirst . orElse-1 If not present, gives us -1. Similar for an array of primitives Linear search using a loop int index -1 for int i 0 i array.length i if A.equalsarrayi index i break Similar for an array of primitives Linear search using 3rd-party libraries such as org.apache.commons int index org.apache.commons.lang3.ArrayUtils .contains strings, A int index2 org.apache.commons.lang3.ArrayUtils .contains ints, 1 Note Using a direct linear search is more e\ufb03cient than wrapping in a list. Testing if an array contains an element The examples above can be adapted to test if the array contains an element by simply testing to see if the index computed is greater or equal to zero. Alternatively, there are also some more concise variations boolean isPresent Arrays.asListstrings.contains A Version Java SE 8 boolean isPresent StreamString.ofstrings.anyMatch x - A.equalsx boolean", "isPresent false for String s strings if A.equalss isPresent true break boolean isPresent org.apache.commons.lang3.ArrayUtils .contains ints, 4 Section 23.13 How do you change the size of an array? The simple answer is that you cannot do this. Once an array has been created, its size cannot be changed. Instead, an array can only be resized by creating a new array with the appropriate size and copying the elements from the existing array to the new one. String listOfCities new String3 array created with size 3. listOfCities 0 New York GoalKicker.com Java Notes for Professionals 128listOfCities 1 London listOfCities 2 Berlin Suppose for example that a new element needs to be added to the listOfCities array de\ufb01ned as above. To do this, you will need to create a new array with size 4,1. copy the existing 3 elements of the old array to the new array at o\ufb00sets 0, 1 and 2, and2. add the new element to the new array at o\ufb00set 3.3. There are various ways to do the above. Prior to Java 6, the most concise way was String newArray new StringlistOfCities. length 1 System.arraycopy listOfCities, 0, newArray, 0, listOfCities. length newArray listOfCities. length Sydney From Java", "6 onwards, the Arrays.copyOf and Arrays.copyOfRange methods can do this more simply String newArray Arrays.copyOflistOfCities, listOfCities. length 1 newArray listOfCities. length Sydney For other ways to copy an array, refer to the following example. Bear in mind that you need an array copy with a di\ufb00erent length to the original when resizing. Copying arrays A better alternatives to array resizing There two major drawbacks with resizing an array as described above It is ine\ufb03cient. Making an array bigger or smaller involves copying many or all of the existing array elements, and allocating a new array object. The larger the array, the more expensive it gets. You need to be able to update any live variables that contain references to the old array. One alternative is to create the array with a large enough size to start with. This is only viable if you can determine that size accurately before allocating the array . If you cannot do that, then the problem of resizing the array arises again. The other alternative is to use a data structure class provided by the Java SE class library or a third-party library. For example, the Java SE collections framework provides a number of", "implementations of the List , Set and Map APIs with di\ufb00erent runtime properties. The ArrayList class is closest to performance characteristics of a plain array e.g. ON lookup, O1 get and set, ON random insertion and deletion while providing more e\ufb03cient resizing without the reference update problem. The resize e\ufb03ciency for ArrayList comes from its strategy of doubling the size of the backing array on each resize. For a typical use-case, this means that you only resize occasionally. When you amortize over the lifetime of the list, the resize cost per insert is O1. It may be possible to use the same strategy when resizing a plain array. Section 23.14 Converting arrays between primitives and boxed types Sometimes conversion of primitive types to boxed types is necessary. To convert the array, its possible to use streams in Java 8 and above GoalKicker.com Java Notes for Professionals 129Version Java SE 8 int primitiveArray 1, 2, 3, 4 Integer boxedArray Arrays.streamprimitiveArray .boxed.toArrayIntegernew With lower versions it can be by iterating the primitive array and explicitly copying it to the boxed array Version Java SE 8 int primitiveArray 1, 2, 3, 4 Integer boxedArray new IntegerprimitiveArray. length for int i 0 i", "primitiveArray. length i boxedArray i primitiveArray i Each element is autoboxed here Similarly, a boxed array can be converted to an array of its primitive counterpart Version Java SE 8 Integer boxedArray 1, 2, 3, 4 int primitiveArray Arrays.streamboxedArray .mapToInt IntegerintValue .toArray Version Java SE 8 Integer boxedArray 1, 2, 3, 4 int primitiveArray new intboxedArray. length for int i 0 i boxedArray. length i primitiveArray i boxedArray i Each element is outboxed here Section 23.15 Remove an element from an array Java doesnt provide a direct method in java.util.Arrays to remove an element from an array. To perform it, you can either copy the original array to a new one without the element to remove or convert your array to another structure allowing the removal. Using ArrayList You can convert the array to a java.util.List , remove the element and convert the list back to an array as follows String array new Stringfoo, bar, baz ListString list new ArrayList Arrays.asListarray list.removefoo Creates a new array with the same size as the list and copies the list elements to it. array list.toArraynew Stringlist.size System.out.printlnArrays.toString array bar, baz Using System.arraycopy System.arraycopy can be used to make a copy of the", "original array and remove the element you want. Below an example int array new int 1, 2, 3, 4 Original array. int result new intarray.length - 1 Array which will contain the result. int index 1 Remove the value 2. GoalKicker.com Java Notes for Professionals 130 Copy the elements at the left of the index. System.arraycopy array, 0, result, 0, index Copy the elements at the right of the index. System.arraycopy array, index 1, result, index, array. length - index - 1 System.out.printlnArrays.toString result 1, 3, 4 Using Apache Commons Lang To easily remove an element, you can use the Apache Commons Lang library and especially the static method removeElement of the class ArrayUtils . Below an example int array new int1,2,3,4 array ArrayUtils. removeElement array, 2 remove first occurrence of 2 System.out.printlnArrays.toString array 1, 3, 4 Section 23.16 Comparing arrays for equality Array types inherit their equals and hashCode implementations from java.lang.Object, so equals will only return true when comparing against the exact same array object. To compare arrays for equality based on their values, use java.util.Arrays.equals , which is overloaded for all array types. int a new int1, 2, 3 int b new int1, 2, 3 System.out.printlna.equalsb", "prints false because a and b refer to different objects System.out.printlnArrays.equalsa, b prints true because the elements of a and b have the same values When the element type is a reference type, Arrays.equals calls equals on the array elements to determine equality. In particular, if the element type is itself an array type, identity comparison will be used. To compare multidimensional arrays for equality, use Arrays.deepEquals instead as below int a 1, 2, 3 int b 1, 2, 3 Object aObject a aObject contains one element Object bObject b bObject contains one element System.out.printlnArrays.equalsaObject, bObject false System.out.printlnArrays.deepEquals aObject, bObject true Because sets and maps use equals and hashCode , arrays are generally not useful as set elements or map keys. Either wrap them in a helper class that implements equals and hashCode in terms of the array elements, or convert them to List instances and store the lists. Section 23.17 Copying arrays Java provides several ways to copy an array. for loop int a 4, 1, 3, 2 int b new inta.length for int i 0 i a.length i bi ai GoalKicker.com Java Notes for Professionals 131Note that using this option with an Object array instead of primitive", "array will \ufb01ll the copy with reference to the original content instead of copy of it. Object.clone Since arrays are Object s in Java, you can use Object.clone. int a 4, 1, 3, 2 int b a.clone 4, 1, 3, 2 Note that the Object.clone method for an array performs a shallow copy , i.e. it returns a reference to a new array which references the same elements as the source array. Arrays.copyOf java.util.Arrays provides an easy way to perform the copy of an array to another. Here is the basic usage int a 4, 1, 3, 2 int b Arrays.copyOfa, a.length 4, 1, 3, 2 Note that Arrays.copyOf also provides an overload which allows you to change the type of the array Double doubles 1.0, 2.0, 3.0 Number numbers Arrays.copyOfdoubles, doubles. length, Number.class System.arraycopy public static void arraycopy Object src, int srcPos, Object dest, int destPos, int length Copies an array from the speci\ufb01ed source array, beginning at the speci\ufb01ed position, to the speci\ufb01ed position of the destination array. Below an example of use int a 4, 1, 3, 2 int b new inta.length System.arraycopy a, 0, b, 0, a.length 4, 1, 3, 2 Arrays.copyOfRange Mainly used to", "copy a part of an Array, you can also use it to copy whole array to another as below int a 4, 1, 3, 2 int b Arrays.copyOfRange a, 0, a.length 4, 1, 3, 2 Section 23.18 Casting Arrays Arrays are objects, but their type is de\ufb01ned by the type of the contained objects. Therefore, one cannot just cast A to T, but each A member of the speci\ufb01c A must be cast to a T object. Generic example public static T, A T castArray T target, A array for int i 0 i array.length i target i T arrayi GoalKicker.com Java Notes for Professionals 132 return target Thus, given an A array T target new Tarray.Length target castArray target, array Java SE provides the method Arrays.copyOforiginal, newLength, newType for this purpose Double doubles 1.0, 2.0, 3.0 Number numbers Arrays.copyOfdoubles, doubles. length, Number.class GoalKicker.com Java Notes for Professionals 133Chapter 24 Collections The collections framework in java.util provides a number of generic classes for sets of data with functionality that cant be provided by regular arrays. Collections framework contains interfaces for Collection O, with main sub-interfaces ListO and SetO, and mapping collection MapK,V. Collections are the root interface and are", "being implemented by many other collection frameworks. Section 24.1 Removing items from a List within a loop It is tricky to remove items from a list while within a loop, this is due to the fact that the index and length of the list gets changed. Given the following list, here are some examples that will give an unexpected result and some that will give the correct result. ListString fruits new ArrayList String fruits.addApple fruits.addBanana fruits.addStrawberry INCORRECT Removing in iteration of for statement Skips Banana The code sample will only print Apple and Strawberry . Banana is skipped because it moves to index 0 once Apple is deleted, but at the same time i gets incremented to 1. for int i 0 i fruits. size i System.out.println fruits.geti if Apple.equalsfruits.geti fruits. removei Removing in the enhanced for statement Throws Exception Because of iterating over collection and modifying it at the same time. Throws java.util.ConcurrentModi\ufb01cationException for String fruit fruits System.out.printlnfruit if Apple.equalsfruit fruits. removefruit CORRECT Removing in while loop using an Iterator Iterator String fruitIterator fruits. iterator whilefruitIterator. hasNext String fruit fruitIterator. next System.out.printlnfruit if Apple.equalsfruit GoalKicker.com Java Notes for Professionals 134 fruitIterator. remove The Iterator interface has a remove", "method built in just for this case. However, this method is marked as optional in the documentation, and it might throw an UnsupportedOperationException . Throws UnsupportedOperationException - if the remove operation is not supported by this iterator Therefore, it is advisable to check the documentation to make sure this operation is supported in practice, unless the collection is an immutable one obtained through a 3rd party library or the use of one of the Collections .unmodifiable ... method, the operation is almost always supported. While using an Iterator a ConcurrentModificationException is thrown when the modCount of the List is changed from when the Iterator was created. This could have happened in the same thread or in a multi-threaded application sharing the same list. A modCount is an int variable which counts the number of times this list has been structurally modi\ufb01ed. A structural change essentially means an add or remove operation being invoked on Collection object changes made by Iterator are not counted. When the Iterator is created, it stores this modCount and on every iteration of the List checks if the current modCount is same as and when the Iterator was created. If there is a change in", "the modCount value it throws a ConcurrentModificationException . Hence for the above-declared list, an operation like below will not throw any exception Iterator String fruitIterator fruits. iterator fruits.set0, Watermelon whilefruitIterator. hasNext System.out.printlnfruitIterator. next But adding a new element to the List after initializing an Iterator will throw a ConcurrentModificationException Iterator String fruitIterator fruits. iterator fruits.addWatermelon whilefruitIterator. hasNext System.out.printlnfruitIterator. next ConcurrentModificationException here Iterating backwards for int i fruits.size - 1 i 0 i-- System.out.println fruits.geti if Apple.equalsfruits.geti fruits. removei This does not skip anything. The downside of this approach is that the output is reverse. However, in most cases where you remove items that will not matter. You should never do this with LinkedList . Iterating forward, adjusting the loop index for int i 0 i fruits. size i System.out.println fruits.geti GoalKicker.com Java Notes for Professionals 135 if Apple.equalsfruits.geti fruits. removei i -- This does not skip anything. When the ith element is removed from the List , the element originally positioned at index i1 becomes the new ith element. Therefore, the loop can decrement i in order for the next iteration to process the next element, without skipping. Using a should-be-removed list ArrayList shouldBeRemoved new ArrayList for String str", "currentArrayList if condition shouldBeRemoved. addstr currentArrayList. removeAll shouldBeRemoved This solution enables the developer to check if the correct elements are removed in a cleaner way. Version Java SE 8 In Java 8 the following alternatives are possible. These are cleaner and more straight forward if the removing does not have to happen in a loop. Filtering a Stream A List can be streamed and \ufb01ltered. A proper \ufb01lter can be used to remove all undesired elements. ListString filteredList fruits. stream.filterp - !Apple.equalsp.collectCollectors. toList Note that unlike all the other examples here, this example produces a new List instance and keeps the original List unchanged. Using removeIf Saves the overhead of constructing a stream if all that is needed is to remove a set of items. fruits.removeIf p - Apple.equalsp Section 24.2 Constructing collections from existing data Standard Collections Java Collections framework A simple way to construct a List from individual data values is to use java.utils.Arrays method Arrays.asList ListString data Arrays.asListab, bc, cd, ab, bc, cd All standard collection implementations provide constructors that take another collection as an argument adding all elements to the new collection at the time of construction ListString list new ArrayList data will add data", "as is SetString set1 new HashSet data will add data keeping only unique values GoalKicker.com Java Notes for Professionals 136SortedSet String set2 new TreeSet data will add data keeping unique values and sorting SetString set3 new LinkedHashSet data will add data keeping only unique values and preserving the original order Google Guava Collections framework Another great framework is Google Guava that is amazing utility class providing convenience static methods for construction of di\ufb00erent types of standard collections Lists and Sets import com.google.common.collect.Lists import com.google.common.collect.Sets ... ListString list1 Lists.newArrayList ab, bc, cd ListString list2 Lists.newArrayList data SetString set4 Sets.newHashSet data SortedSet String set5 Sets.newTreeSet bc, cd, ab, bc, cd Mapping Collections Java Collections framework Similarly for maps, given a MapString, Object map a new map can be constructed with all elements as follows MapString, Object map1 new HashMap map SortedMap String, Object map2 new TreeMap map Apache Commons Collections framework Using Apache Commons you can create Map using array in ArrayUtils. toMap as well as MapUtils. toMap import org.apache.commons.lang3.ArrayUtils ... Taken from org.apache.commons.lang.ArrayUtilstoMap JavaDoc Create a Map mapping colors. Map colorMap MapUtils. toMapnew String RED, FF0000 , GREEN, 00FF00 , BLUE, 0000FF Each element of the array must be either", "a Map.Entry or an Array, containing at least two elements, where the \ufb01rst element is used as key and the second as value. Google Guava Collections framework Utility class from Google Guava framework is named Maps import com.google.common.collect.Maps ... void howToCreateMapsMethod Function ? super K,V valueFunction, Iterable K keys1, Set K keys2, SortedSet K keys3 ImmutableMap K, V map1 toMapkeys1, valueFunction Immutable copy Map K, V map2 asMapkeys2, valueFunction Live Map view SortedMap K, V map3 toMapkeys3, valueFunction Live Map view Version Java SE 8 GoalKicker.com Java Notes for Professionals 137Using Stream , Stream.ofxyz, abc.collectCollectors. toList or Arrays.streamxyz, abc.collectCollectors. toList Section 24.3 Declaring an ArrayList and adding objects We can create an ArrayList following the List interface List aListOfFruits new ArrayList Version Java SE 5 ListString aListOfFruits new ArrayList String Version Java SE 7 ListString aListOfFruits new ArrayList Now, use the method add to add a String aListOfFruits. addMelon aListOfFruits. addStrawberry In the above example, the ArrayList will contain the String Melon at index 0 and the String Strawberry at index 1. Also we can add multiple elements with addAllCollection ? extends E c method ListString aListOfFruitsAndVeggies new ArrayList String aListOfFruitsAndVeggies. addOnion aListOfFruitsAndVeggies. addAllaListOfFruits Now Onion is placed at", "0 index in aListOfFruitsAndVeggies , Melon is at index 1 and Strawberry is at index 2. Section 24.4 Iterating over Collections Iterating over List ListString names new ArrayList Arrays.asListClementine , Duran, Mike Version Java SE 8 names.forEachSystem.outprintln If we need parallelism use names.parallelStream .forEachSystem.outprintln Version Java SE 5 for String name names System.out.printlnname Version Java SE 5 for int i 0 i names.size i System.out.printlnnames.geti Version Java SE 1.2 GoalKicker.com Java Notes for Professionals 138Creates ListIterator which supports both forward as well as backward traversel ListIterator String listIterator names.listIterator Iterates list in forward direction whilelistIterator. hasNext System.out.printlnlistIterator. next Iterates list in backward direction once reaches the last element from above iterator in forward direction whilelistIterator. hasPrevious System.out.printlnlistIterator. previous Iterating over Set SetString names new HashSet Arrays.asListClementine , Duran, Mike Version Java SE 8 names.forEachSystem.outprintln Version Java SE 5 for Iterator String iterator names.iterator iterator. hasNext System.out.printlniterator. next for String name names System.out.printlnname Version Java SE 5 Iterator iterator names.iterator while iterator. hasNext System.out.printlniterator. next Iterating over Map MapInteger, String names new HashMap names.put1, Clementine names.put2, Duran names.put3, Mike Version Java SE 8 names.forEachkey, value - System.out.printlnKey key Value value Version Java SE 5 for Map.EntryInteger, String entry names.entrySet System.out.printlnentry.getKey", "System.out.printlnentry.getValue Iterating over only keys for Integer key names.keySet System.out.printlnkey Iterating over only values for String value names.values System.out.printlnvalue Version Java SE 5 Iterator entries names.entrySet .iterator while entries. hasNext Map.Entry entry Map.Entry entries. next System.out.printlnentry.getKey System.out.printlnentry.getValue GoalKicker.com Java Notes for Professionals 139 Section 24.5 Immutable Empty Collections Sometimes it is appropriate to use an immutable empty collection. The Collections class provides methods to get such collections in an e\ufb03cient way ListString anEmptyList Collections .emptyList MapInteger, Date anEmptyMap Collections .emptyMap SetNumber anEmptySet Collections .emptySet These methods are generic and will automatically convert the returned collection to the type it is assigned to. That is, an invocation of e.g. emptyList can be assigned to any type of List and likewise for emptySet and emptyMap . The collections returned by these methods are immutable in that they will throw UnsupportedOperationException if you attempt to call methods which would change their contents add, put, etc.. These collections are primarily useful as substitutes for empty method results or other default values, instead of using null or creating objects with new. Section 24.6 Sub Collections List subListint fromIndex, int toIndex Here fromIndex is inclusive and toIndex is exclusive. List list new ArrayList List list1", "list.subListfromIndex,toIndex If the list doesnt exist in the give range, it throws IndexOutofBoundException.1. What ever changes made on the list1 will impact the same changes in the list.This is called backed collections.2. If the fromnIndex is greater than the toIndex fromIndex toIndex it throws IllegalArgumentException.3. Example ListString list new ArrayList String ListString list new ArrayList String list.addHello1 list.addHello2 System.out.printlnBefore Sublist list ListString list2 list.subList0, 1 list2.addHello3 System.out.printlnAfter sublist changes list Output Before Sublist Hello1, Hello2 After sublist changes Hello1, Hello3, Hello2 Set subSetfromIndex,toIndex Here fromIndex is inclusive and toIndex is exclusive. Set set new TreeSet GoalKicker.com Java Notes for Professionals 140Set set1 set.subSetfromIndex,toIndex The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Map subMapfromKey,toKey fromKey is inclusive and toKey is exclusive Map map new TreeMap Map map1 map.getfromKey,toKey If fromKey is greater than toKey or if this map itself has a restricted range, and fromKey or toKey lies outside the bounds of the range then it throws IllegalArgumentException. All the collections support backed collections means changes made on the sub collection will have same change on the main collection. Section 24.7 Unmodi\ufb01able Collection Sometimes its not a good practice expose an", "internal collection since it can lead to a malicious code vulnerability due to its mutable characteristic. In order to provide read-only collections java provides its unmodi\ufb01able versions. An unmodi\ufb01able collection is often a copy of a modi\ufb01able collection which guarantees that the collection itself cannot be altered. Attempts to modify it will result in an UnsupportedOperationException exception. It is important to notice that objects which are present inside the collection can still be altered. import java.util.ArrayList import java.util.Collections import java.util.List public class MyPojoClass private ListInteger intList new ArrayList public void addValueToIntList Integer value intList. addvalue public ListInteger getIntList return Collections .unmodifiableList intList The following attempt to modify an unmodi\ufb01able collection will throw an exception import java.util.List public class App public static void mainString args MyPojoClass pojo new MyPojoClass pojo. addValueToIntList 42 List Integer list pojo.getIntList list. add69 GoalKicker.com Java Notes for Professionals 141output Exception in thread main java.lang.UnsupportedOperationException at java.util.CollectionsUnmodifiableCollection.addCollections.java1055 at App.mainApp.java12 Section 24.8 Pitfall concurrent modi\ufb01cation exceptions This exception occurs when a collection is modi\ufb01ed while iterating over it using methods other than those provided by the iterator object. For example, we have a list of hats and we want to remove all those that have ear \ufb02aps", "ListIHat hats new ArrayList hats.addnew Ushanka that one has ear flaps hats.addnew Fedora hats.addnew Sombrero for IHat hat hats if hat.hasEarFlaps hats. removehat If we run this code, ConcurrentModi\ufb01cationException will be raised since the code modi\ufb01es the collection while iterating it. The same exception may occur if one of the multiple threads working with the same list is trying to modify the collection while others iterate over it. Concurrent modi\ufb01cation of collections in multiple threads is a natural thing, but should be treated with usual tools from the concurrent programming toolbox such as synchronization locks, special collections adopted for concurrent modi\ufb01cation, modifying the cloned collection from initial etc. Section 24.9 Removing matching items from Lists using Iterator Above I noticed an example to remove items from a List within a Loop and I thought of another example that may come in handy this time using the Iterator interface. This is a demonstration of a trick that might come in handy when dealing with duplicate items in lists that you want to get rid of. Note This is only adding on to the Removing items from a List within a loop example So lets de\ufb01ne our lists as usual String", "names James,Smith,Sonny,Huckle ,Berry,Finn,Allan List String nameList new ArrayList Create a List from an Array nameList. addAllArrays.asListnames String removeNames Sonny,Huckle ,Berry List String removeNameList new ArrayList Create a List from an Array removeNameList. addAllArrays.asListremoveNames The following method takes in two Collection objects and performs the magic of removing the elements in our removeNameList that match with elements in nameList . GoalKicker.com Java Notes for Professionals 142private static void removeNames Collection String collection1, Collection String collection2 get Iterator. Iterator String iterator collection1. iterator Loop while collection has items whileiterator. hasNext if collection2. contains iterator. next iterator. remove remove the current Name or Item Calling the method and passing in the nameList and the removeNameList as follows removeNames nameList,removeNameList Will produce the following output Array List before removing names James Smith Sonny Huckle Berry Finn Allan Array List after removing names James Smith Finn Allan A simple neat use for Collections that may come in handy to remove repeating elements within lists. Section 24.10 Join lists Following ways can be used for joining lists without modifying source lists. First approach. Has more lines but easy to understand ListString newList new ArrayList String newList. addAlllistOne newList. addAlllistTwo Second approach. Has one less line", "but less readable. ListString newList new ArrayList StringlistOne newList. addAlllistTwo Third approach. Requires third party Apache commons-collections library. ListUtils. unionlistOne,listTwo Version Java SE 8 Using Streams the same can be achieved by ListString newList Stream. concatlistOne. stream, listTwo. stream.collectCollectors. toList References. Interface List Section 24.11 Creating your own Iterable structure for use with Iterator or for-each loop To ensure that our collection can be iterated using iterator or for-each loop, we have to take care of following steps The stu\ufb00 we want to iterate upon has to be Iterable and expose iterator . 1. Design a java.util.Iterator by overriding hasNext, next and remove. 2. GoalKicker.com Java Notes for Professionals 143I have added a simple generic linked list implementation below that uses above entities to make the linked list iterable. package org.algorithms.linkedlist import java.util.Iterator import java.util.NoSuchElementException public class LinkedList T implements Iterable T NodeT head, current private static class NodeT T data NodeT next NodeT data this.data data public LinkedList T data head new Nodedata public Iterator T iterator return new LinkedListIterator private class LinkedListIterator implements Iterator T NodeT node head Override public boolean hasNext return node ! null Override public T next if !hasNext throw new NoSuchElementException NodeT prevNode", "node node node.next return prevNode. data Override public void remove throw new UnsupportedOperationException Removal logic not implemented. public void addT data Node current head GoalKicker.com Java Notes for Professionals 144 while current. next ! null current current. next current. next new Nodedata class App public static void mainString args LinkedList Integer list new LinkedList 1 list.add2 list.add4 list.add3 Test 1 System.out.printlnusing Iterator Iterator Integer itr list.iterator while itr.hasNext Integer i itr.next System.out.printi Test 2 System.out.printlnnnusing for-each for Integer data list System.out.printdata Output using Iterator 1 2 4 3 using for-each 1 2 4 3 This will run in Java 7. You can make it run on Java 5 and Java 6 also by substituting LinkedList Integer list new LinkedList 1 with LinkedList Integer list new LinkedList Integer1 or just any other version by incorporating the compatible changes. Section 24.12 Collections and Primitive Values Collections in Java only work for objects. I.e. there is no Mapint, int in Java. Instead, primitive values need to be boxed into objects, as in MapInteger, Integer . Java auto-boxing will enable transparent use of these collections MapInteger, Integer map new HashMap GoalKicker.com Java Notes for Professionals 145map.put1, 17 Automatic boxing of int to Integer", "objects int a map.get1 Automatic unboxing. Unfortunately, the overhead of this is substantial . A HashMapInteger, Integer will require about 72 bytes per entry e.g. on 64-bit JVM with compressed pointers, and assuming integers larger than 256, and assuming 50 load of the map. Because the actual data is only 8 bytes, this yields a massive overhead. Furthermore, it requires two level of indirection Map - Entry - Value it is unnecessarily slow. There exist several libraries with optimized collections for primitive data types that require only 16 bytes per entry at 50 load, i.e. 4x less memory, and one level of indirection less, that can yield substantial performance bene\ufb01ts when using large collections of primitive values in Java. GoalKicker.com Java Notes for Professionals 146Chapter 25 Lists A list is an ordered collection of values. In Java, lists are part of the Java Collections Framework . Lists implement the java.util.List interface, which extends java.util.Collection . Section 25.1 Sorting a generic list The Collections class o\ufb00ers two standard static methods to sort a list sortListT list applicable to lists where T extends Comparable ? super T, and sortListT list, Comparator ? super T c applicable to lists of any type.", "Applying the former requires amending the class of list elements being sorted, which is not always possible. It might also be undesirable as although it provides the default sorting, other sorting orders may be required in di\ufb00erent circumstances, or sorting is just a one o\ufb00 task. Consider we have a task of sorting objects that are instances of the following class public class User public final Long id public final String username public UserLong id, String username this.id id this.username username Override public String toString return String.formatsd, username, id In order to use Collections .sortListUser list we need to modify the User class to implement the Comparable interface. For example public class User implements Comparable User public final Long id public final String username public UserLong id, String username this.id id this.username username Override public String toString return String.formatsd, username, id Override The natural ordering for User objects is by the id field. public int compareTo User o return id.compareTo o.id GoalKicker.com Java Notes for Professionals 147Aside many standard Java classes such as String , Long , Integer implement the Comparable interface. This makes lists of those elements sortable by default, and simpli\ufb01es implementation of compare or compareTo in", "other classes. With the modi\ufb01cation above, the we can easily sort a list of User objects based on the classes natural ordering . In this case, we have de\ufb01ned that to be ordering based on id values. For example ListUser users Lists.newArrayList new User33L, A, new User25L, B, new User28L, Collections .sortusers System.out.printusers B25, C28, A33 However, suppose that we wanted to sort User objects by name rather than by id. Alternatively, suppose that we had not been able to change the class to make it implement Comparable . This is where the sort method with the Comparator argument is useful Collections .sortusers, new Comparator User Override Order two User objects based on their names. public int compare User left, User right return left.username .compareTo right.username System.out.printusers A33, B25, C28 Version Java SE 8 In Java 8 you can use a lambda instead of an anonymous class. The latter reduces to a one-liner Collections .sortusers, l, r - l.username .compareTo r.username Further, there Java 8 adds a default sort method on the List interface, which simpli\ufb01es sorting even more. users.sortl, r - l.username .compareTo r.username Section 25.2 Convert a list of integers to a list of strings ListInteger nums", "Arrays.asList1, 2, 3 ListString strings nums.stream .mapObjecttoString .collectCollectors. toList That is Create a stream from the list1. Map each element using ObjecttoString 2. Collect the String values into a List using Collectors. toList 3. Section 25.3 Classes implementing List - Pros and Cons The List interface is implemented by di\ufb00erent classes. Each of them has its own way for implementing it with di\ufb00erent strategies and providing di\ufb00erent pros and cons. GoalKicker.com Java Notes for Professionals 148Classes implementing List These are all of the public classes in Java SE 8 that implement the java.util.List interface Abstract Classes1. AbstractList AbstractSequentialList Concrete Classes2. ArrayList AttributeList CopyOnWriteArrayList LinkedList RoleList RoleUnresolvedList Stack Vector Pros and Cons of each implementation in term of time complexity ArrayList public class ArrayList E extends AbstractList E implements ListE, RandomAccess, Cloneable , Serializable ArrayList is a resizable-array implementation of the List interface. Storing the list into an array, ArrayList provides methods in addition to the methods implementing the List interface for manipulating the size of the array. Initialize ArrayList of Integer with size 100 ListInteger myList new ArrayList Integer100 Constructs an empty list with the specified initial capacity. - PROS The size, isEmpty, get, set, iterator, and listIterator operations", "run in constant time. So getting and setting each element of the List has the same time cost int e1 myList. get0 int e2 myList. get10 All the same constant cost O1 myList.set2,10 - CONS Being implemented with an array static structure adding elements over the size of the array has a big cost due to the fact that a new allocation need to be done for all the array. However, from documentation The add operation runs in amortized constant time, that is, adding n elements requires On time Removing an element requires On time. AttributeList GoalKicker.com Java Notes for Professionals 149On coming CopyOnWriteArrayList On coming LinkedList public class LinkedList E extends AbstractSequentialList E implements ListE, DequeE, Cloneable , Serializable LinkedList is implemented by a doubly-linked list a linked data structure that consists of a set of sequentially linked records called nodes. Iitialize LinkedList of Integer ListInteger myList new LinkedList Integer Constructs an empty list. - PROS Adding or removing an element to the front of the list or to the end has constant time. myList.add10 myList.add0,2 constant time O1 myList.remove - CONS From documentation Operations that index into the list will traverse the list from the beginning or", "the end, whichever is closer to the speci\ufb01ed index. Operations such as myList.get10 myList.add11,25 worst case done in On2 myList.set15,35 RoleList On coming RoleUnresolvedList On coming Stack On coming GoalKicker.com Java Notes for Professionals 150Vector On coming Section 25.4 Finding common elements between 2 lists Suppose you have two lists A and B, and you need to \ufb01nd the elements that exist in both lists. You can do it by just invoking the method List.retainAll . Example public static void mainString args List Integer numbersA new ArrayList List Integer numbersB new ArrayList numbersA. addAllArrays.asListnew Integer 1, 3, 4, 7, 5, 2 numbersB. addAllArrays.asListnew Integer 13, 32, 533, 3, 4, 2 System.out.printlnA numbersA System.out.printlnB numbersB List Integer numbersC new ArrayList numbersC. addAllnumbersA numbersC. retainAll numbersB System.out.printlnList A numbersA System.out.printlnList B numbersB System.out.printlnCommon elements between A and B numbersC Section 25.5 In-place replacement of a List element This example is about replacing a List element while ensuring that the replacement element is at the same position as the element that is replaced. This can be done using these methods setint index, T type int indexOfT type Consider an ArrayList containing the elements Program starting!, Hello world! and Goodbye world! ListString strings", "new ArrayList String strings. addProgram starting! strings. addHello world! strings. addGoodbye world! If we know the index of the element we want to replace, we can simply use set as follows strings. set1, Hi world If we dont know the index, we can search for it \ufb01rst. For example int pos strings. indexOfGoodbye world! if pos 0 GoalKicker.com Java Notes for Professionals 151 strings. setpos, Goodbye cruel world! Notes The set operation will not cause a ConcurrentModificationException . 1. The set operation is fast O1 for ArrayList but slow ON for a LinkedList . 2. An indexOf search on an ArrayList or LinkedList is slow ON . 3. Section 25.6 Making a list unmodi\ufb01able The Collections class provides a way to make a list unmodi\ufb01able ListString ls new ArrayList String ListString unmodifiableList Collections .unmodifiableList ls If you want an unmodi\ufb01able list with one item you can use ListString unmodifiableList Collections .singletonList Only string in the list Section 25.7 Moving objects around in the list The Collections class allows for you to move objects around in the list using various methods ls is the List Reversing a list Collections .reversels Rotating positions of elements in a list The rotate method", "requires an integer argument. This is how many spots to move it along the line by. An example of this is below ListString ls new ArrayList String ls.add how ls.add are ls.add you? ls.addhello, Collections .rotatels, 1 forString line ls System.out.printline System.out.println This will print hello, how are you? Shu\ufb04ing elements around in a list Using the same list above, we can shu\ufb04e the elements in a list Collections .shufflels We can also give it a java.util.Random object that it uses to randomly place objects in spots Random random new Random12 Collections .shufflels, random GoalKicker.com Java Notes for Professionals 152Section 25.8 Creating, Adding and Removing element from an ArrayList ArrayList is one of the inbuilt data structures in Java. It is a dynamic array where the size of the data structure not needed to be declared \ufb01rst for storing elements Objects. It extends AbstractList class and implements List interface. An ArrayList can contain duplicate elements where it maintains insertion order. It should be noted that the class ArrayList is non-synchronized, so care should be taken when handling concurrency with ArrayList . ArrayList allows random access because array works at the index basis. Manipulation is slow in ArrayList because of", "shifting that often occurs when an element is removed from the array list. An ArrayList can be created as follows ListT myArrayList new ArrayList Where T Generics is the type that will be stored inside ArrayList . The type of the ArrayList can be any Object. The type cant be a primitive type use their wrapper classes instead. To add an element to the ArrayList , use add method myArrayList. addelement Or to add item to a certain index myArrayList. addindex, element index of the element should be an int starting from 0 To remove an item from the ArrayList , use the remove method myArrayList. removeelement Or to remove an item from a certain index myArrayList. removeindex index of the element should be an int starting from 0 Section 25.9 Creating a List Giving your list a type To create a list you need a type any class, e.g. String . This is the type of your List . The List will only store objects of the speci\ufb01ed type. For example ListString strings Can store string1 , hello world! , goodbye , etc, but it cant store 9.2, however ListDouble doubles Can store 9.2, but not hello world!", ". Initialising your list If you try to add something to the lists above you will get a NullPointerException, because strings and doubles GoalKicker.com Java Notes for Professionals 153both equal null! There are two ways to initialise a list Option 1 Use a class that implements List List is an interface, which means that does not have a constructor, rather methods that a class must override. ArrayList is the most commonly used List , though LinkedList is also common. So we initialise our list like this ListString strings new ArrayList String or ListString strings new LinkedList String Version Java SE 7 Starting from Java SE 7, you can use a diamond operator ListString strings new ArrayList or ListString strings new LinkedList Option 2 Use the Collections class The Collections class provides two useful methods for creating Lists without a List variable emptyList returns an empty list. singletonList T creates a list of type T and adds the element speci\ufb01ed. And a method which uses an existing List to \ufb01ll data in addAllL, T... adds all the speci\ufb01ed elements to the list passed as the \ufb01rst parameter. Examples import java.util.List import java.util.Collections ListInteger l Collections.emptyList ListInteger l1 Collections.singletonList42 Collections.addAlll1, 1,", "2, 3 Section 25.10 Positional Access Operations The List API has eight methods for positional access operations addT type addint index, T type removeObject o removeint index getint index setint index, E element int indexOf Object o int lastIndexOf Object o So, if we have a List GoalKicker.com Java Notes for Professionals 154ListString strings new ArrayList String And we wanted to add the strings Hello world! and Goodbye world! to it, we would do it as such strings. addHello world! strings. addGoodbye world! And our list would contain the two elements. Now lets say we wanted to add Program starting! at the front of the list. We would do this like this strings. add0, Program starting! NOTE The \ufb01rst element is 0. Now, if we wanted to remove the Goodbye world! line, we could do it like this strings. removeGoodbye world! And if we wanted to remove the \ufb01rst line which in this case would be Program starting!, we could do it like this strings. remove0 Note Adding and removing list elements modify the list, and this can lead to a ConcurrentModificationException 1. if the list is being iterated concurrently. Adding and removing elements can be O1 or ON", "depending on the list class, the method used, and 2. whether you are adding removing an element at the start, the end, or in the middle of the list. In order to retrieve an element of the list at a speci\ufb01ed position you can use the E getint index method of the List API. For example strings. get0 will return the \ufb01rst element of the list. You can replace any element at a speci\ufb01ed position by using the setint index, E element . For example strings. set0,This is a replacement This will set the String This is a replacement as the \ufb01rst element of the list. Note The set method will overwrite the element at the position 0. It will not add the new String at the position 0 and push the old one to the position 1. The int indexOf Object o returns the position of the \ufb01rst occurrence of the object passed as argument. If there are no occurrences of the object in the list then the -1 value is returned. In continuation of the previous example if you call strings. indexOfThis is a replacement the 0 is expected to be returned as we set the String", "This is a replacement in the position 0 of our list. In case where there are more than one occurrence in the list when int indexOf Object o is called then as mentioned GoalKicker.com Java Notes for Professionals 155the index of the \ufb01rst occurrence will be returned. By calling the int lastIndexOf Object o you can retrieve the index of the last occurrence in the list. So if we add another This is a replacement strings. addThis is a replacement strings. lastIndexOf This is a replacement This time the 1 will be returned and not the 0 Section 25.11 Iterating over elements in a list For the example, lets say that we have a List of type String that contains four elements hello, , how , are , you? The best way to iterate over each element is by using a for-each loop public void printEachElement ListString list forString s list System.out.printlns Which would print hello, how are you? To print them all in the same line, you can use a StringBuilder public void printAsLine ListString list StringBuilder builder new StringBuilder forString s list builder. appends System.out.printlnbuilder. toString Will print hello, how are you ? Alternatively, you can use", "element indexing as described in Accessing element at ith Index from ArrayList to iterate a list. Warning this approach is ine\ufb03cient for linked lists. Section 25.12 Removing elements from list B that are present in the list A Lets suppose you have 2 Lists A and B, and you want to remove from B all the elements that you have in A the method in this case is List.removeAll Collection c Example GoalKicker.com Java Notes for Professionals 156public static void mainString args List Integer numbersA new ArrayList List Integer numbersB new ArrayList numbersA. addAllArrays.asListnew Integer 1, 3, 4, 7, 5, 2 numbersB. addAllArrays.asListnew Integer 13, 32, 533, 3, 4, 2 System.out.printlnA numbersA System.out.printlnB numbersB numbersB. removeAll numbersA System.out.printlnB cleared numbersB this will print A 1, 3, 4, 7, 5, 2 B 13, 32, 533, 3, 4, 2 B cleared 13, 32, 533 GoalKicker.com Java Notes for Professionals 157Chapter 26 Sets Section 26.1 Initialization A Set is a Collection that cannot contain duplicate elements. It models the mathematical set abstraction. Set have its implementation in various classes like HashSet , TreeSet , LinkedHashSet . For example HashSet SetT set new HashSet T Here T can be String , Integer or", "any other object . HashSet allows for quick lookup of O1 but does not sort the data added to it and loses the insertion order of items. TreeSet It stores data in a sorted manner sacri\ufb01cing some speed for basic operations which take Olgn. It does not maintain the insertion order of items. TreeSetT sortedSet new TreeSet T LinkedHashSet It is a linked list implementation of HashSet Once can iterate over the items in the order they were added. Sorting is not provided for its contents. O1 basic operations are provided, however there is higher cost than HashSet in maintaining the backing linked list. LinkedHashSet T linkedhashset new LinkedHashSet T Section 26.2 Basics of Set What is a Set? A set is a data structure which contains a set of elements with an important property that no two elements in the set are equal. Types of Set HashSet A set backed by a hash table actually a HashMap instance 1. Linked HashSet A Set backed by Hash table and linked list, with predictable iteration order 2. TreeSet A NavigableSet implementation based on a TreeMap. 3. Creating a set SetInteger set new HashSet Integer Creates an empty Set of Integers", "SetInteger linkedHashSet new LinkedHashSet Integer Creates a empty Set of Integers, with predictable iteration order Adding elements to a Set GoalKicker.com Java Notes for Professionals 158Elements can be added to a set using the add method set.add12 - Adds element 12 to the set set.add13 - Adds element 13 to the set Our set after executing this method set 12,13 Delete all the elements of a Set set.clear Removes all objects from the collection. After this set will be set Check whether an element is part of the Set Existence of an element in the set can be checked using the contains method set.contains 0 Returns true if a specified object is an element within the set. Output False Check whether a Set is empty isEmpty method can be used to check whether a Set is empty. set.isEmpty Returns true if the set has no elements Output True Remove an element from the Set set.remove0 Removes first occurrence of a specified object from the collection Check the Size of the Set set.size Returns the number of elements in the collection Output 0 Section 26.3 Types and Usage of Sets Generally, sets are a type of collection which stores unique", "values. Uniqueness is determined by the equals and hashCode methods. Sorting is determined by the type of set. HashSet - Random Sorting Version Java SE 7 SetString set new HashSet set.addBanana GoalKicker.com Java Notes for Professionals 159set.addBanana set.addApple set.addStrawberry Set Elements Strawberry, Banana, Apple LinkedHashSet - Insertion Order Version Java SE 7 SetString set new LinkedHashSet set.addBanana set.addBanana set.addApple set.addStrawberry Set Elements Banana, Apple, Strawberry TreeSet - By compareTo or Comparator Version Java SE 7 SetString set new TreeSet set.addBanana set.addBanana set.addApple set.addStrawberry Set Elements Apple, Banana, Strawberry Version Java SE 7 SetString set new TreeSet string1, string2 - string2. compareTo string1 set.addBanana set.addBanana set.addApple set.addStrawberry Set Elements Strawberry, Banana, Apple Section 26.4 Create a list from an existing Set Using a new List ListString list new ArrayList StringlistOfElements Using List.addAll method SetString set new HashSet String set. addfoo set. addboo List String list new ArrayList String list. addAllset Using Java 8 Steam API ListString list set.stream.collectCollectors. toList Section 26.5 Eliminating duplicates using Set Suppose you have a collection elements , and you want to create another collection containing the same elements but with all duplicates eliminated GoalKicker.com Java Notes for Professionals 160Collection Type noDuplicates new HashSet Typeelements Example", "ListString names new ArrayList Arrays.asListJohn, Marco, Jenny, Emily, Jenny, Emily, John SetString noDuplicates new HashSet names System.out.printlnnoDuplicates noDuplicates Output noDuplicates Marco, Emily, John, Jenny Section 26.6 Declaring a HashSet with values You can create a new class that inherits from HashSet SetString h new HashSet String adda addb One line solution SetString h new HashSet StringArrays.asLista, b Using guava Sets.newHashSet a, b, c Using Streams SetString set3 Stream. ofa, b, c.collecttoSet GoalKicker.com Java Notes for Professionals 161Chapter 27 List vs Set What are di\ufb00erences between List and Set collection at the top level and How to choose when to use List in java and when to use Set in Java Section 27.1 List vs Set import java.util.ArrayList import java.util.HashSet import java.util.List import java.util.Set public class SetAndListExample public static void main String args System.out.printlnList example ..... List list new ArrayList list. add1 list. add2 list. add3 list. add4 list. add1 for String temp list System.out.printlntemp System.out.printlnSet example ..... Set String set new HashSet String set. add1 set. add2 set. add3 set. add4 set. add1 set. add2 set. add5 for String temp set System.out.printlntemp Output List example ..... 1 2 3 4 1 Set example ..... 3 2 10 5 4", "GoalKicker.com Java Notes for Professionals 162Chapter 28 Maps The java.util.Map interface represents a mapping between keys and their values. A map cannot contain duplicate keys and each key can map to at most one value. Since Map is an interface, then you need to instantiate a concrete implementation of that interface in order to use it there are several Map implementations, and mostly used are the java.util.HashMap and java.util.TreeMap Section 28.1 Iterating Map Entries Eciently This section provides code and benchmarks for ten unique example implementations which iterate over the entries of a MapInteger, Integer and generate the sum of the Integer values. All of the examples have an algorithmic complexity of \u0398n, however, the benchmarks are still useful for providing insight on which implementations are more e\ufb03cient in a real world environment. Implementation using Iterator with Map.Entry 1. Iterator Map.EntryInteger, Integer it map.entrySet .iterator while it.hasNext Map.EntryInteger, Integer pair it.next sum pair.getKey pair.getValue Implementation using for with Map.Entry 2. for Map.EntryInteger, Integer pair map.entrySet sum pair.getKey pair.getValue Implementation using Map.forEach Java 8 3. map. forEachk, v - sum0 k v Implementation using Map.keySet with for 4. for Integer key map.keySet sum key map.getkey Implementation using Map.keySet with Iterator", "5. Iterator Integer it map.keySet.iterator while it.hasNext Integer key it.next sum key map.getkey Implementation using for with Iterator and Map.Entry 6. for Iterator Map.EntryInteger, Integer entries map. entrySet .iterator entries. hasNext Map.EntryInteger, Integer entry entries. next sum entry.getKey entry.getValue Implementation using Stream.forEach Java 8 7. GoalKicker.com Java Notes for Professionals 163 map. entrySet .stream.forEache - sum e.getKey e.getValue Implementation using Stream.forEach with Stream.parallel Java 8 8. map. entrySet . stream . parallel . forEache - sum e.getKey e.getValue Implementation using IterableMap from Apache Collections 9. MapIterator Integer, Integer mit iterableMap. mapIterator while mit.hasNext sum mit.next it.getValue Implementation using MutableMap from Eclipse Collections 10. mutableMap. forEachKeyValue key, value - sum key value Performance Tests Code available on Github Test Environment Windows 8.1 64-bit, Intel i7-4790 3.60GHz, 16 GB Average Performance of 10 Trials 100 elements Best 308 21 nsop 1. Benchmark Score Error Units test3UsingForEachAndJava8 308 21 nsop test10UsingEclipseMutableMap 309 9 nsop test1UsingWhileAndMapEntry 380 14 nsop test6UsingForAndIterator 387 16 nsop test2UsingForEachAndMapEntry 391 23 nsop test7UsingJava8StreamAPI 510 14 nsop test9UsingApacheIterableMap 524 8 nsop test4UsingKeySetAndForEach 816 26 nsop test5UsingKeySetAndIterator 863 25 nsop test8UsingJava8StreamAPIParallel 5552 185 nsop Average Performance of 10 Trials 10000 elements Best 37.606 0.790 \u03bcsop 2. Benchmark Score Error Units", "test10UsingEclipseMutableMap 37606 790 nsop test3UsingForEachAndJava8 50368 887 nsop test6UsingForAndIterator 50332 507 nsop test2UsingForEachAndMapEntry 51406 1032 nsop test1UsingWhileAndMapEntry 52538 2431 nsop test7UsingJava8StreamAPI 54464 712 nsop test4UsingKeySetAndForEach 79016 25345 nsop test5UsingKeySetAndIterator 91105 10220 nsop test8UsingJava8StreamAPIParallel 112511 365 nsop test9UsingApacheIterableMap 125714 1935 nsop Average Performance of 10 Trials 100000 elements Best 1184.767 332.968 \u03bcsop 3. Benchmark Score Error Units GoalKicker.com Java Notes for Professionals 164test1UsingWhileAndMapEntry 1184.767 332.968 \u03bcsop test10UsingEclipseMutableMap 1191.735 304.273 \u03bcsop test2UsingForEachAndMapEntry 1205.815 366.043 \u03bcsop test6UsingForAndIterator 1206.873 367.272 \u03bcsop test8UsingJava8StreamAPIParallel 1485.895 233.143 \u03bcsop test5UsingKeySetAndIterator 1540.281 357.497 \u03bcsop test4UsingKeySetAndForEach 1593.342 294.417 \u03bcsop test3UsingForEachAndJava8 1666.296 126.443 \u03bcsop test7UsingJava8StreamAPI 1706.676 436.867 \u03bcsop test9UsingApacheIterableMap 3289.866 1445.564 \u03bcsop A Comparison of Performance Variations Respective to Map Size4. x Size of Map fx Benchmark Score \u03bcsop 100 600 1100 1600 2100 --------------------------------------------------- 10 0.333 1.631 2.752 5.937 8.024 3 0.309 1.971 4.147 8.147 10.473 6 0.372 2.190 4.470 8.322 10.531 1 0.405 2.237 4.616 8.645 10.707 Tests 2 0.376 2.267 4.809 8.403 10.910 fx 7 0.473 2.448 5.668 9.790 12.125 9 0.565 2.830 5.952 13.22 16.965 4 0.808 5.012 8.813 13.939 17.407 5 0.81 5.104 8.533 14.064 17.422 8 5.173 12.499 17.351 24.671 30.403 Section 28.2 Usage of HashMap HashMap is an implementation of the Map interface", "that provides a Data Structure to store data in Key-Value pairs. 1. Declaring HashMap MapKeyType, ValueType myMap new HashMap KeyType, ValueType GoalKicker.com Java Notes for Professionals 165KeyType and ValueType must be valid types in Java, such as - String, Integer, Float or any custom class like Employee, Student etc.. For Example MapString,Integer myMap new HashMap String,Integer 2. Putting values in HashMap. To put a value in the HashMap, we have to call put method on the HashMap object by passing the Key and the Value as parameters. myMap.putkey1, 1 myMap.putkey2, 2 If you call the put method with the Key that already exists in the Map, the method will override its value and return the old value. 3. Getting values from HashMap. For getting the value from a HashMap you have to call the get method, by passing the Key as a parameter. myMap.getkey1 return 1 class Integer If you pass a key that does not exists in the HashMap, this method will return null 4. Check whether the Key is in the Map or not. myMap.containsKey varKey 5. Check whether the Value is in the Map or not. myMap.containsValue varValue The above methods will return a boolean value", "true or false if key, value exists in the Map or not. Section 28.3 Using Default Methods of Map from Java 8 Examples of using Default Methods introduced in Java 8 in Map interface Using getOrDefault 1. Returns the value mapped to the key, or if the key is not present, returns the default value MapInteger, String map new HashMap map.put1, First element map.get1 First element map.get2 null map.getOrDefault 2, Default element Default element Using forEach 2. Allows to perform the operation speci\ufb01ed in the action on each Map Entry MapInteger, String map new HashMap Integer, String map.put1, one map.put2, two map.put3, three GoalKicker.com Java Notes for Professionals 166 map.forEachkey, value - System.out.printlnKey key Value value Key 1 Value one Key 2 Value two Key 3 Value three Using replaceAll 3. Will replace with new-value only if key is present MapString, Integer map new HashMap String, Integer map.putjohn, 20 map.putpaul, 30 map.putpeter, 40 map.replaceAll key,value -value10 john30, paul40, peter50 Using putIfAbsent 4. Key-Value pair is added to the map, if the key is not present or mapped to null MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 map. putIfAbsent kelly, 50", "john20, paul30, peter40, kelly50 Using remove 5. Removes the key only if its associated with the given value MapString, Integer map new HashMap String, Integer map.putjohn, 20 map.putpaul, 30 map.putpeter, 40 map.removepeter,40 john30, paul40 Using replace 6. If the key is present then the value is replaced by new-value. If the key is not present, does nothing. MapString, Integer map new HashMap String, Integer map.putjohn, 20 map.putpaul, 30 map.putpeter, 40 map.replacepeter,50 john20, paul30, peter50 map.replacejack,60 john20, paul30, peter50 Using computeIfAbsent 7. This method adds an entry in the Map. the key is speci\ufb01ed in the function and the value is the result of the application of the mapping function MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 GoalKicker.com Java Notes for Professionals 167 map. computeIfAbsent kelly, k-map.getjohn10 john20, paul30, peter40, kelly30 map. computeIfAbsent peter, k-map.getjohn10 john20, paul30, peter40, kelly30 peter already present Using computeIfPresent 8. This method adds an entry or modi\ufb01es an existing entry in the Map. Does nothing if an entry with that key is not present MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 map. computeIfPresent kelly, k,v-v10 john20, paul30,", "peter40 kelly not present map. computeIfPresent peter, k,v-v10 john20, paul30, peter50 peter present, so increase the value Using compute 9. This method replaces the value of a key by the newly computed value MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 map. computepeter, k,v-v50 john20, paul30, peter90 Increase the value Using merge 10. Adds the key-value pair to the map, if key is not present or value for the key is null Replaces the value with the newly computed value, if the key is present Key is removed from the map , if new value computed is null MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 Adds the key-value pair to the map, if key is not present or value for the key is null map. mergekelly, 50 , k,v-map.getjohn10 john20, paul30, peter40, kelly50 Replaces the value with the newly computed value, if the key is present map. mergepeter, 50 , k,v-map.getjohn10 john20, paul30, peter30, kelly50 Key is removed from the map , if new value computed is null map. mergepeter, 30 , k,v-map.getnancy john20, paul30, kelly50 Section 28.4 Iterating through the contents", "of a Map Maps provide methods which let you access the keys, values, or key-value pairs of the map as collections. You can iterate through these collections. Given the following map for example MapString, Integer repMap new HashMap repMap.putJon Skeet , 927654 repMap.putBalusC , 708826 repMap.putDarin Dimitrov , 715567 Iterating through map keys GoalKicker.com Java Notes for Professionals 168for String key repMap. keySet System.out.printlnkey Prints Darin Dimitrov Jon Skeet BalusC keySet provides the keys of the map as a Set. Set is used as the keys cannot contain duplicate values. Iterating through the set yields each key in turn. HashMaps are not ordered, so in this example the keys may be returned in any order. Iterating through map values for Integer value repMap. values System.out.printlnvalue Prints 715567 927654 708826 values returns the values of the map as a Collection . Iterating through the collection yields each value in turn. Again, the values may be returned in any order. Iterating through keys and values together for Map.EntryString, Integer entry repMap. entrySet System.out.printfs d n, entry. getKey, entry. getValue Prints Darin Dimitrov 715567 Jon Skeet 927654 BalusC 708826 entrySet returns a collection of Map.Entry objects. Map.Entry gives access to the key", "and value for each entry. Section 28.5 Merging, combine and composing Maps Use putAll to put every member of one map into another. Keys already present in the map will have their corresponding values overwritten. MapString, Integer numbers new HashMap numbers. putOne, 1 GoalKicker.com Java Notes for Professionals 169numbers. putThree, 3 MapString, Integer othernumbers new HashMap othernumbers. putTwo, 2 othernumbers. putThree, 4 numbers. putAllothernumbers This yields the following mapping in numbers One - 1 Two - 2 Three - 4 old value 3 was overwritten by new value 4 If you want to combine values instead of overwriting them, you can use Map.merge , added in Java 8, which uses a user-provided BiFunction to merge values for duplicate keys. merge operates on individual keys and values, so youll need to use a loop or Map.forEach . Here we concatenate strings for duplicate keys for Map.EntryString, Integer e othernumbers. entrySet numbers. mergee.getKey, e.getValue , Integersum or instead of the above loop othernumbers. forEachk, v - numbers. mergek, v, Integersum If you want to enforce the constraint there are no duplicate keys, you can use a merge function that throws an AssertionError mapA.forEachk, v - mapB. mergek, v, v1, v2 -", "throw new AssertionError duplicate values for key k Composing MapX,Y and MapY,Z to get MapX,Z If you want to compose two mappings, you can do it as follows MapString, Integer map1 new HashMap String, Integer map1. putkey1, 1 map1. putkey2, 2 map1. putkey3, 3 MapInteger, Double map2 new HashMap Integer, Double map2. put1, 1.0 map2. put2, 2.0 map2. put3, 3.0 MapString, Double map3 new new HashMap String, Double map1. forEachkey,value -map3.putkey,map2. getvalue This yields the following mapping key1 - 1.0 key2 - 2.0 key3 - 3.0 Section 28.6 Add multiple items We can use V putK key,V value GoalKicker.com Java Notes for Professionals 170Associates the speci\ufb01ed value with the speci\ufb01ed key in this map optional operation. If the map previously contained a mapping for the key, the old value is replaced by the speci\ufb01ed value. String currentVal MapInteger, String map new TreeMap currentVal map.put1, First element. System.out.printlncurrentVal Will print null currentVal map.put2, Second element. System.out.printlncurrentVal Will print null yet again currentVal map.put2, This will replace Second element System.out.printlncurrentVal will print Second element. System.out.printlnmap.size Will print 2 as key having value 2 was replaced. MapInteger, String map2 new HashMap map2.put2, Element 2 map2.put3, Element 3 map.putAllmap2 System.out.printlnmap.size Output 3 To", "add many items you can use an inner classes like this MapInteger, String map new HashMap This is now an anonymous inner class with an unnamed instance constructor put5, high put4, low put1, too slow Keep in mind that creating an anonymous inner class is not always e\ufb03cient and can lead to memory leaks so when possible, use an initializer block instead static MapInteger, String map new HashMap static Now no inner classes are created so we can avoid memory leaks put5, high put4, low put1, too slow The example above makes the map static. It can also be used in a non-static context by removing all occurrences of static . In addition to that most implementations support putAll , which can add all entries in one map to another like this another. putAllone GoalKicker.com Java Notes for Professionals 171Section 28.7 Creating and Initializing Maps Introduction Maps stores keyvalue pairs, where each key has an associated value. Given a particular key, the map can look up the associated value very quickly. Maps , also known as associate array, is an object that stores the data in form of keys and values. In Java, maps are represented using Map interface", "which is not an extension of the collection interface. Way 1 J2SE 5.0 Map map new HashMap map.putname, A map.putaddress , Malviya-Nagar map.putcity, Jaipur System.out.printlnmap Way 2 J2SE 5.0 style use of generics MapString, Object map new HashMap map.putname, A map.putaddress , Malviya-Nagar map.putcity, Jaipur System.out.printlnmap Way 3 MapString, Object map new HashMap String, Object put name, A put address , Malviya-Nagar put city, Jaipur System.out.printlnmap Way 4 MapString, Object map new TreeMap String, Object map. putname, A map. putaddress , Malviya-Nagar map. putcity, Jaipur System.out.printlnmap Way 5 Java 8 final MapString, String map Arrays.streamnew String name, A , address , Malviya-Nagar , city, jaipur , .collectCollectors. toMapm - m0, m - m1 System.out.printlnmap GoalKicker.com Java Notes for Professionals 172Way 6 This way for initial a map in outside the function final static MapString, String map static map new HashMap String, String map. puta, b map. putc, d Way 7 Creating an immutable single key-value map. Immutable single key-value map MapString, String singletonMap Collections .singletonMap key, value Please note, that it is impossible to modify such map . Any attemts to modify the map will result in throwing the UnsupportedOperationException. Immutable single key-value pair MapString, String singletonMap Collections .singletonMap", "key, value singletonMap. putnewKey , newValue will throw UnsupportedOperationException singletonMap. putAllnew HashMap will throw UnsupportedOperationException singletonMap. removekey will throw UnsupportedOperationException singletonMap. replacekey, value, newValue will throw UnsupportedOperationException and etc Section 28.8 Check if key exists MapString, String num new HashMap num.putone, first if num.containsKey one System.out.printlnnum.getone first Maps can contain null values For maps, one has to be carrefull not to confuse containing a key with having a value. For example, HashMap s can contain null which means the following is perfectly normal behavior MapString, String map new HashMap map.putone, null if map.containsKey one System.out.printlnThis prints ! This line is reached if map.getone ! null System.out.printlnThis is never reached ! This line is never reached More formally, there is no guarantee that map.contains key map.getkey!null Section 28.9 Add an element Addition1. GoalKicker.com Java Notes for Professionals 173MapInteger, String map new HashMap map.put1, First element. System.out.printlnmap.get1 Output First element. Override2. MapInteger, String map new HashMap map.put1, First element. map.put1, New element. System.out.printlnmap.get1 Output New element. HashMap is used as an example. Other implementations that implement the Map interface may be used as well. Section 28.10 Clear the map MapInteger, String map new HashMap map.put1, First element. map.put2, Second element. map.put3,", "Third element. map.clear System.out.printlnmap.size 0 Section 28.11 Use custom object as key Before using your own object as key you must override hashCode and equals method of your object. In simple case you would have something like class MyKey private String name MyKey String name this.name name Override public boolean equalsObject obj ifobj instanceof MyKey return this.name.equalsMyKeyobj.name return false Override public int hashCode return this.name.hashCode hashCode will decide which hash bucket the key belongs to and equals will decide which object inside that hash bucket. GoalKicker.com Java Notes for Professionals 174Without these method, the reference of your object will be used for above comparison which will not work unless you use the same object reference every time. GoalKicker.com Java Notes for Professionals 175Chapter 29 LinkedHashMap LinkedHashMap class is Hash table and Linked list implementation of the Map interface, with predictable iteration order. It inherits HashMap class and implements the Map interface. The important points about Java LinkedHashMap class are A LinkedHashMap contains values based on the key. It contains only unique elements. It may have one null key and multiple null values. It is same as HashMap instead maintains insertion order. Section 29.1 Java LinkedHashMap class Key Points Is", "Hash table and Linked list implementation of the Map interface, with predictable iteration order. inherits HashMap class and implements the Map interface. contains values based on the key. only unique elements. may have one null key and multiple null values. same as HashMap instead maintains insertion order. Methods void clear. boolean containsKeyObject key. Object getObject key. protected boolean removeEldestEntryMap.Entry eldest Example public static void mainString arg LinkedHashMap String, String lhm new LinkedHashMap String, String lhm. putRamesh , Intermediate lhm. putShiva, B-Tech lhm. putSantosh , B-Com lhm. putAsha, Msc lhm. putRaghu, M-Tech Set set lhm.entrySet Iterator i set.iterator while i.hasNext Map.Entry me Map.Entry i.next System.out.printlnme.getKey me.getValue System.out.printlnThe Key Contains lhm.containsKey Shiva System.out.printlnThe value to the corresponding to key lhm.getAsha GoalKicker.com Java Notes for Professionals 176Chapter 30 WeakHashMap Concepts of weak Hashmap Section 30.1 Concepts of WeakHashmap Key Points Implementation of Map. stores only weak references to its keys. Weak References The objects that are referenced only by weak references are garbage collected eagerly the GC wont wait until it needs memory in that case. Di\ufb00erence between Hashmap and WeakHashMap If the Java memory manager no longer has a strong reference to the object speci\ufb01ed as a key, then the entry", "in the map will be removed in WeakHashMap. Example public class WeakHashMapTest public static void mainString args Map hashMap new HashMap Map weakHashMap new WeakHashMap String keyHashMap new StringkeyHashMap String keyWeakHashMap new StringkeyWeakHashMap hashMap. putkeyHashMap, Ankita weakHashMap. putkeyWeakHashMap, Atul System.gc System.out.printlnBefore hash map value hashMap. getkeyHashMap and weak hash map valueweakHashMap. getkeyWeakHashMap keyHashMap null keyWeakHashMap null System.gc System.out.printlnAfter hash map value hashMap. getkeyHashMap and weak hash map valueweakHashMap. getkeyWeakHashMap Size di\ufb00erences HashMap vs WeakHashMap Calling size method on HashMap object will return the same number of key-value pairs. size will decrease only if remove method is called explicitly on the HashMap object. Because the garbage collector may discard keys at anytime, a WeakHashMap may behave as though an unknown thread is silently removing entries. So it is possible for the size method to return smaller values over time.So, in WeakHashMap size decrease happens automatically . GoalKicker.com Java Notes for Professionals 177Chapter 31 SortedMap Introduction to sorted Map. Section 31.1 Introduction to sorted Map Keypoint SortedMap interface extends Map. entries are maintained in an ascending key order. Methods of sorted Map Comparator comparator . Object \ufb01rstKey . SortedMap headMapObject end. Object lastKey . SortedMap subMapObject start, Object end. SortedMap tailMapObject", "start. Example public static void mainString args Create a hash map TreeMap tm new TreeMap Put elements to the map tm. putZara, new Double3434.34 tm. putMahnaz , new Double123.22 tm. putAyan, new Double1378.00 tm. putDaisy, new Double99.22 tm. putQadir, new Double-19.08 Get a set of the entries Set set tm.entrySet Get an iterator Iterator i set.iterator Display elements whilei.hasNext Map.Entry me Map.Entryi.next System.out.printme.getKey System.out.printlnme.getValue System.out.println Deposit 1000 into Zaras account double balance Doubletm.getZara.doubleValue tm. putZara, new Doublebalance 1000 System.out.printlnZaras new balance tm.getZara GoalKicker.com Java Notes for Professionals 178Chapter 32 TreeMap and TreeSet TreeMap and TreeSet are basic Java collections added in Java 1.2. TreeMap is a mutable , ordered , Map implementation. Similarly, TreeSet is a mutable , ordered Set implementation. TreeMap is implemented as a Red-Black tree, which provides Olog n access times. TreeSet is implemented using a TreeMap with dummy values. Both collections are not thread-safe. Section 32.1 TreeMap of a simple Java type First, we create an empty map, and insert some elements into it Version Java SE 7 TreeMapInteger, String treeMap new TreeMap Version Java SE 7 TreeMapInteger, String treeMap new TreeMap Integer, String treeMap. put10, ten treeMap. put4, four treeMap. put1, one treeSet. put12,", "twelve Once we have a few elements in the map, we can perform some operations System.out.printlntreeMap. firstEntry Prints 1one System.out.printlntreeMap. lastEntry Prints 12twelve System.out.printlntreeMap. size Prints 4, since there are 4 elemens in the map System.out.printlntreeMap. get12 Prints twelve System.out.printlntreeMap. get15 Prints null, since the key is not found in the map We can also iterate over the map elements using either an Iterator, or a foreach loop. Note that the entries are printed according to their natural ordering , not the insertion order Version Java SE 7 for EntryInteger, String entry treeMap. entrySet System.out.printentry prints 1one 4four 10ten 12twelve Iterator EntryInteger, String iter treeMap. entrySet .iterator while iter.hasNext System.out.printiter.next prints 1one 4four 10ten 12twelve Section 32.2 TreeSet of a simple Java Type First, we create an empty set, and insert some elements into it Version Java SE 7 TreeSetInteger treeSet new TreeSet Version Java SE 7 TreeSetInteger treeSet new TreeSet Integer treeSet. add10 treeSet. add4 treeSet. add1 GoalKicker.com Java Notes for Professionals 179treeSet. add12 Once we have a few elements in the set, we can perform some operations System.out.printlntreeSet. first Prints 1 System.out.printlntreeSet. last Prints 12 System.out.printlntreeSet. size Prints 4, since there are 4 elemens in the set", "System.out.printlntreeSet. contains 12 Prints true System.out.printlntreeSet. contains 15 Prints false We can also iterate over the map elements using either an Iterator, or a foreach loop. Note that the entries are printed according to their natural ordering , not the insertion order Version Java SE 7 for Integer i treeSet System.out.printi prints 1 4 10 12 Iterator Integer iter treeSet. iterator while iter.hasNext System.out.printiter.next prints 1 4 10 12 Section 32.3 TreeMapTreeSet of a custom Java type Since TreeMap s and TreeSet s maintain keyselements according to their natural ordering . Therefor TreeMap keys and TreeSet elements have to comparable to one another. Say we have a custom Person class public class Person private int id private String firstName, lastName private Date birthday ... Constuctors, getters, setters and various methods If we store it as-is in a TreeSet or a Key in a TreeMap TreeSetPerson2 set ... set.addnew Person1,first,last,Date.fromInstant. now Then wed run into an Exception such as this one Exception in thread main java.lang.ClassCastException Person cannot be cast to java.lang.Comparable at java. util.TreeMap.compareTreeMap.java1294 at java. util.TreeMap.putTreeMap.java538 at java. util.TreeSet.addTreeSet.java255 To \ufb01x that, lets assume that we want to order Person instances based on the order of their ids", "private int id. We could do it in one of two ways One solution is to modify Person so it would implement the Comparable interface 1. GoalKicker.com Java Notes for Professionals 180public class Person implements Comparable Person private int id private String firstName, lastName private Date birthday ... Constuctors, getters, setters and various methods Override public int compareTo Person o return Integer.comparethis.id, o.id Compare by id Another solution is to provide the TreeSet with a Comparator 2. Version Java SE 8 TreeSetPerson treeSet new TreeSet personA, personB - Integer.comparepersonA. getId, personB. getId TreeSetPerson treeSet new TreeSet new Comparator Person Override public int compare Person personA, Person personB return Integer.comparepersonA. getId, personB. getId However, there are two caveats to both approaches Its very important not to modify any \ufb01elds used for ordering once an instance has been inserted into a 1. TreeSet TreeMap . In the above example, if we change the id of a person thats already inserted into the collection, we might run into unexpected behavior. Its important to implement the comparison properly and consistently. As per the Javadoc 2. The implementor must ensure sgnx.compareTo y -sgny.compareTo x for all x and y. This implies that x.compareTo y", "must throw an exception i\ufb00 y.compareTo x throws an exception. The implementor must also ensure that the relation is transitive x.compareTo y0 y.compareTo z0 implies x.compareTo z0. Finally, the implementor must ensure that x.compareTo y0 implies that sgnx.compareTo z sgny.compareTo z, for all z. Section 32.4 TreeMap and TreeSet Thread Safety TreeMap and TreeSet are not thread-safe collections, so care must be taken to ensure when used in multi-threaded programs. Both TreeMap and TreeSet are safe when read, even concurrently, by multiple threads. So if they have been created and populated by a single thread say, at the start of the program, and only then read, but not modi\ufb01ed by multiple threads, theres no reason for synchronization or locking. However, if read and modi\ufb01ed concurrently, or modi\ufb01ed concurrently by more than one thread, the collection might throw a ConcurrentModi\ufb01cationException or behave unexpectedly. In these cases, its imperative to synchronizelock access to the collection using one of the following approaches GoalKicker.com Java Notes for Professionals 181Using Collections .synchronizedSorted .. 1. SortedSet Integer set Collections .synchronizedSortedSet new TreeSet Integer SortedMap Integer,String map Collections .synchronizedSortedMap new TreeMapInteger,String This will provide a SortedSet SortedMap implementation backed by the actual collection, and synchronized on", "some mutex object. Note that this will synchronize all read and write access to the collection on a single lock, so even concurrent reads would not be possible. By manually synchronizing on some object, like the collection itself2. TreeSet Integer set new TreeSet ... Thread 1 synchronized set set. add4 ... Thread 2 synchronized set set. remove5 By using a lock, such as a ReentrantReadWriteLock 3. TreeSet Integer set new TreeSet ReentrantReadWriteLock lock new ReentrantReadWriteLock ... Thread 1 lock.writeLock .lock set.add4 lock.writeLock .unlock ... Thread 2 lock.readLock .lock set.contains 5 lock.readLock .unlock As opposed to the previous synchronization methods, using a ReadWriteLock allows multiple threads to read from the map concurrently. GoalKicker.com Java Notes for Professionals 182Chapter 33 Queues and Deques Section 33.1 The usage of the PriorityQueue PriorityQueue is a data structure. Like SortedSet , PriorityQueue sorts also its elements based on their priorities. The elements, which have a higher priority, comes \ufb01rst. The type of the PriorityQueue should implement comparable or comparator interface, whose methods decides the priorities of the elements of the data structure. The type of the PriorityQueue is Integer. PriorityQueue Integer queue new PriorityQueue Integer The elements are added to the PriorityQueue queue.addAll Arrays.asList", "9, 2, 3, 1, 3, 8 The PriorityQueue sorts the elements by using compareTo method of the Integer Class The head of this queue is the least element with respect to the specified ordering System.out.println queue The Output 1, 2, 3, 9, 3, 8 queue.remove System.out.println queue The Output 2, 3, 3, 9, 8 queue.remove System.out.println queue The Output 3, 8, 3, 9 queue.remove System.out.println queue The Output 3, 8, 9 queue.remove System.out.println queue The Output 8, 9 queue.remove System.out.println queue The Output 9 queue.remove System.out.println queue The Output Section 33.2 Deque A Deque is a double ended queue which means that a elements can be added at the front or the tail of the queue. The queue only can add elements to the tail of a queue. The Deque inherits the Queue interface which means the regular methods remain, however the Deque interface o\ufb00ers additional methods to be more \ufb02exible with a queue. The additional methods really speak for them self if you know how a queue works, since those methods are intended to add more \ufb02exibility Method Brief description getFirst Gets the \ufb01rst item of the head of the queue without removing it. getLast Gets the \ufb01rst", "item of the tail of the queue without removing it. addFirst E eAdds an item to the head of the queue addLastE eAdds an item to the tail of the queue removeFirst Removes the \ufb01rst item at the head of the queue removeLast Removes the \ufb01rst item at the tail of the queue Of course the same options for offer , poll and peek are available, however they do not work with exceptions but rather with special values. There is no point in showing what they do here. Adding and Accessing Elements To add elements to the tail of a Deque you call its add method. You can also use the addFirst and addLast methods, which add elements to the head and tail of the deque. GoalKicker.com Java Notes for Professionals 183DequeString dequeA new LinkedList dequeA.addelement 1 add element at tail dequeA.addFirst element 2 add element at head dequeA.addLastelement 3 add element at tail You can peek at the element at the head of the queue without taking the element out of the queue. This is done via the element method. You can also use the getFirst and getLast methods, which return the \ufb01rst and last element in the", "Deque . Here is how that looks String firstElement0 dequeA. element String firstElement1 dequeA. getFirst String lastElement dequeA. getLast Removing Elements To remove elements from a deque, you call the remove, removeFirst and removeLast methods. Here are a few examples String firstElement dequeA. remove String firstElement dequeA. removeFirst String lastElement dequeA. removeLast Section 33.3 Stacks What is a Stack? In Java, Stacks are a LIFO Last In, First Out Data structure for objects. Stack API Java contains a Stack API with the following methods Stack Creates an empty Stack isEmpty Is the Stack Empty? Return Type Boolean pushItem item push an item onto the stack pop removes item from top of stack Return Type Item size returns of items in stack Return Type Int Example import java.util. public class StackExample public static void mainString args Stack st new Stack System.out.printlnstack st st. push10 System.out.println10 was pushed to the stack System.out.printlnstack st st. push15 System.out.println15 was pushed to the stack System.out.printlnstack st st. push80 System.out.println80 was pushed to the stack System.out.printlnstack st GoalKicker.com Java Notes for Professionals 184 st. pop System.out.println80 was popped from the stack System.out.printlnstack st st. pop System.out.println15 was popped from the stack System.out.printlnstack st st. pop", "System.out.println10 was popped from the stack System.out.printlnstack st ifst.isEmpty System.out.printlnempty stack This returns stack 10 was pushed to the stack stack 10 15 was pushed to the stack stack 10, 15 80 was pushed to the stack stack 10, 15, 80 80 was popped from the stack stack 10, 15 15 was popped from the stack stack 10 10 was popped from the stack stack empty stack Section 33.4 BlockingQueue A BlockingQueue is an interface, which is a queue that blocks when you try to dequeue from it and the queue is empty, or if you try to enqueue items to it and the queue is already full. A thread trying to dequeue from an empty queue is blocked until some other thread inserts an item into the queue. A thread trying to enqueue an item in a full queue is blocked until some other thread makes space in the queue, either by dequeuing one or more items or clearing the queue completely. BlockingQueue methods come in four forms, with di\ufb00erent ways of handling operations that cannot be satis\ufb01ed immediately, but may be satis\ufb01ed at some point in the future one throws an exception, the second returns a special", "value either null or false, depending on the operation, the third blocks the current thread inde\ufb01nitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. Operation Throws Exception Special Value Blocks Times out Insert add o\ufb00ere pute o\ufb00ere, time, unit Remove remove poll take polltime, unit Examine element peek NA NA A BlockingQueue can be bounded or unbounded . A bounded BlockingQueue is one which is initialized with initial GoalKicker.com Java Notes for Professionals 185capacity. BlockingQueue String bQueue new ArrayBlockingQueue String2 Any calls to a put method will be blocked if the size of the queue is equal to the initial capacity de\ufb01ned. An unbounded Queue is one which is initialized without capacity, actually by default it initialized with Integer.MAXVALUE. Some common implementations of BlockingQueue are ArrayBlockingQueue1. LinkedBlockingQueue2. PriorityBlockingQueue3. Now lets look at an example of ArrayBlockingQueue BlockingQueue String bQueue new ArrayBlockingQueue 2 bQueue.putThis is entry 1 System.out.printlnEntry one done bQueue.putThis is entry 2 System.out.printlnEntry two done bQueue.putThis is entry 3 System.out.printlnEntry three done This will print Entry one done Entry two done And the thread will be blocked after the second output. Section 33.5 LinkedList as a FIFO", "Queue The java.util.LinkedList class, while implementing java.util.List is a general-purpose implementation of java.util.Queue interface too operating on a FIFO First In, First Out principle. In the example below, with offer method, the elements are inserted into the LinkedList . This insertion operation is called enqueue . In the while loop below, the elements are removed from the Queue based on FIFO. This operation is called dequeue . QueueString queue new LinkedList String queue.offer first element queue.offer second element queue.offer third element queue.offer fourth. element queue.offer fifth. element while !queue.isEmpty System.out.println queue.poll The output of this code is first element GoalKicker.com Java Notes for Professionals 186second element third element fourth element fifth element As seen in the output, the \ufb01rst inserted element \ufb01rst element is removed \ufb01rstly, second element is removed in the second place etc. Section 33.6 Queue Interface Basics A Queue is a collection for holding elements prior to processing. Queues typically, but not necessarily, order elements in a FIFO \ufb01rst-in-\ufb01rst-out manner. Head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. The Queue Interface", "public interface QueueE extends Collection E boolean addE e boolean offerE e E remove E poll E element E peek Each Queue method exists in two forms one throws an exception if the operation fails other returns a special value if the operation fails either null or false depending on the operation. Type of operation Throws exception Returns special value Insert adde offere Remove remove poll Examine element peek GoalKicker.com Java Notes for Professionals 187Chapter 34 Dequeue Interface A Deque is linear collection that supports element insertion and removal at both ends. The name deque is short for double ended queue and is usually pronounced deck. Most Deque implementations place no \ufb01xed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no \ufb01xed size limit. The Deque interface is a richer abstract data type than both Stack and Queue because it implements both stacks and queues at same time Section 34.1 Adding Elements to Deque Deque deque new LinkedList Adding element at tail deque.addItem1 Adding element at head deque.addFirst Item2 Adding element at tail deque.addLastItem3 Section 34.2 Removing Elements from Deque Retrieves and removes the head of the", "queue represented by this deque Object headItem deque.remove Retrieves and removes the first element of this deque. Object firstItem deque.removeFirst Retrieves and removes the last element of this deque. Object lastItem deque.removeLast Section 34.3 Retrieving Element without Removing Retrieves, but does not remove, the head of the queue represented by this deque Object headItem deque.element Retrieves, but does not remove, the first element of this deque. Object firstItem deque.getFirst Retrieves, but does not remove, the last element of this deque. Object lastItem deque.getLast Section 34.4 Iterating through Deque Using Iterator Iterator iterator deque.iterator whileiterator. hasNext String Item String iterator. next Using For Loop GoalKicker.com Java Notes for Professionals 188forObject object deque String Item String object GoalKicker.com Java Notes for Professionals 189Chapter 35 Enums Java enums declared using the enum keyword are shorthand syntax for sizable quantities of constants of a single class. Section 35.1 Declaring and using a basic enum Enum can be considered to be syntax sugar for a sealed class that is instantiated only a number of times known at compile-time to de\ufb01ne a set of constants. A simple enum to list the di\ufb00erent seasons would be declared as follows public enum Season WINTER, SPRING, SUMMER, FALL", "While the enum constants dont necessarily need to be in all-caps, it is Java convention that names of constants are entirely uppercase, with words separated by underscores. You can declare an Enum in its own \ufb01le This enum is declared in the Season.java file. public enum Season WINTER, SPRING, SUMMER, FALL But you can also declare it inside another class public class Day private Season season public String getSeason return season. name public void setSeason String season this.season Season. valueOfseason This enum is declared inside the Day.java file and cannot be accessed outside because its declared as private. private enum Season WINTER, SPRING, SUMMER, FALL GoalKicker.com Java Notes for Professionals 190 Finally, you cannot declare an Enum inside a method body or constructor public class Day Constructor public Day Illegal. Compilation error enum Season WINTER, SPRING, SUMMER, FALL public void aSimpleMethod Legal. You can declare a primitive or an Object inside a method. Compile! int primitiveInt 42 Illegal. Compilation error. enum Season WINTER, SPRING, SUMMER, FALL Season season Season. SPRING Duplicate enum constants are not allowed public enum Season WINTER, WINTER, Compile Time Error Duplicate Constants SPRING, SUMMER, FALL Every constant of enum is public , static and final", "by default. As every constant is static , they can be accessed directly using the enum name. Enum constants can be passed around as method parameters public static void display Season s System.out.printlns.name name is a built-in method that gets the exact name of the enum constant displaySeason.WINTER Prints out WINTER GoalKicker.com Java Notes for Professionals 191You can get an array of the enum constants using the values method. The values are guaranteed to be in declaration order in the returned array Season seasons Season. values Note this method allocates a new array of values each time it is called. To iterate over the enum constants public static void enumIterate for Season s Season. values System.out.printlns.name You can use enums in a switch statement public static void enumSwitchExample Season s switchs case WINTER System.out.printlnIts pretty cold break case SPRING System.out.printlnIts warming up break case SUMMER System.out.printlnIts pretty hot break case FALL System.out.printlnIts cooling down break You can also compare enum constants using Season.FALL Season. WINTER false Season.SPRING Season. SPRING true Another way to compare enum constants is by using equals as below, which is considered bad practice as you can easily fall into pitfalls as follows Season.FALL.equalsSeason.FALL true Season.FALL.equalsSeason.WINTER", "false Season.FALL.equalsFALL false and no compiler error Furthermore, although the set of instances in the enum cannot be changed at run-time, the instances themselves are not inherently immutable because like any other class, an enum can contain mutable \ufb01elds as is demonstrated below. public enum MutableExample A, B private int count 0 public void increment GoalKicker.com Java Notes for Professionals 192 count public void print System.out.printlnThe count of name is count Usage MutableExample. A.print Outputs 0 MutableExample. A.increment MutableExample. A.print Outputs 1 -- weve changed a field MutableExample. B.print Outputs 0 -- another instance remains unchanged However, a good practice is to make enum instances immutable, i.e. when they either dont have any additional \ufb01elds or all such \ufb01elds are marked as final and are immutable themselves. This will ensure that for a lifetime of the application an enum wont leak any memory and that it is safe to use its instances across all threads. Enums implicitly implement Serializable and Comparable because the Enum class does public abstract class EnumE extends EnumE extends Object implements Comparable E, Serializable Section 35.2 Enums with constructors An enum cannot have a public constructor however, private constructors are acceptable constructors for enums are", "package-private by default public enum Coin PENNY 1, NICKEL 5, DIME10, QUARTER 25 usual names for US coins note that the above parentheses and the constructor arguments match private int value Coin int value this.value value public int getValue return value int p Coin.NICKEL.getValue the int value will be 5 It is recommended that you keep all \ufb01elds private and provide getter methods, as there are a \ufb01nite number of instances for an enum. If you were to implement an Enum as a class instead, it would look like this public class CoinT extends CoinT implements Comparable T, Serializable public static final Coin PENNY new Coin1 public static final Coin NICKEL new Coin5 public static final Coin DIME new Coin10 public static final Coin QUARTER new Coin25 private int value GoalKicker.com Java Notes for Professionals 193 private Coinint value this.value value public int getValue return value int p Coin.NICKEL.getValue the int value will be 5 Enum constants are technically mutable, so a setter could be added to change the internal structure of an enum constant. However, this is considered very bad practice and should be avoided. Best practice is to make Enum \ufb01elds immutable, with final public enum Coin", "PENNY 1, NICKEL 5, DIME10, QUARTER 25 private final int value Coin int value this.value value ... You may de\ufb01ne multiple constructors in the same enum. When you do, the arguments you pass in your enum declaration decide which constructor is called public enum Coin PENNY 1, true, NICKEL 5, false, DIME10, QUARTER 25 private final int value private final boolean isCopperColored Coin int value thisvalue, false Coin int value, boolean isCopperColored this.value value this.isCopperColored isCopperColored ... Note All non-primitive enum \ufb01elds should implement Serializable because the Enum class does. Section 35.3 Enums with Abstract Methods Enums can de\ufb01ne abstract methods, which each enum member is required to implement. enum Action DODGE GoalKicker.com Java Notes for Professionals 194 public boolean execute Player player return player. isAttacking , ATTACK public boolean execute Player player return player. hasWeapon , JUMP public boolean execute Player player return player. getCoordinates .equalsnew Coordinates 0, 0 public abstract boolean execute Player player This allows for each enum member to de\ufb01ne its own behaviour for a given operation, without having to switch on types in a method in the top-level de\ufb01nition. Note that this pattern is a short form of what is typically achieved using polymorphism", "andor implementing interfaces. Section 35.4 Implements Interface This is an enum that is also a callable function that tests String inputs against precompiled regular expression patterns. import java.util.function.Predicate import java.util.regex.Pattern enum RegEx implements Predicate String UPPER A-Z , LOWERa-z , NUMERIC -?0-9 private final Pattern pattern private RegExfinal String pattern this.pattern Pattern. compilepattern Override public boolean testfinal String input return this.pattern.matcherinput.matches public class Main public static void mainString args System.out.printlnRegEx.UPPER.testABC System.out.printlnRegEx.LOWER.testabc System.out.printlnRegEx.NUMERIC.test111 Each member of the enum can also implement the method import java.util.function.Predicate GoalKicker.com Java Notes for Professionals 195enum Acceptor implements Predicate String NULL Override public boolean testString s return s null , EMPTY Override public boolean testString s return s.equals , NULLOREMPTY Override public boolean testString s return NULL.tests EMPTY.tests public class Main public static void mainString args System.out.printlnAcceptor. NULL.testnull true System.out.printlnAcceptor. EMPTY.test true System.out.printlnAcceptor. NULLOREMPTY .test false Section 35.5 Implement Singleton pattern with a single- element enum Enum constants are instantiated when an enum is referenced for the \ufb01rst time. Therefore, that allows to implement Singleton software design pattern with a single-element enum. public enum Attendant INSTANCE private Attendant perform some initialization routine public void sayHello System.out.printlnHello! public class Main public static void mainString... args Attendant.", "INSTANCE .sayHello instantiated at this point According to E\ufb00ective Java book by Joshua Bloch, a single-element enum is the best way to implement a singleton. This approach has following advantages thread safety guarantee of single instantiation out-of-the-box serialization And as shown in the section implements interface this singleton might also implement one or more interfaces. GoalKicker.com Java Notes for Professionals 196Section 35.6 Using methods and static blocks An enum can contain a method, just like any class. To see how this works, well declare an enum like this public enum Direction NORTH, SOUTH, EAST, WEST Lets have a method that returns the enum in the opposite direction public enum Direction NORTH, SOUTH, EAST, WEST public Direction getOpposite switch this case NORTH return SOUTH case SOUTH return NORTH case WEST return EAST case EAST return WEST default This will never happen return null This can be improved further through the use of \ufb01elds and static initializer blocks public enum Direction NORTH, SOUTH, EAST, WEST private Direction opposite public Direction getOpposite return opposite static NORTH. opposite SOUTH SOUTH. opposite NORTH WEST. opposite EAST EAST. opposite WEST In this example, the opposite direction is stored in a private instance \ufb01eld opposite ,", "which is statically initialized the \ufb01rst time a Direction is used. In this particular case because NORTH references SOUTH and conversely, we cannot use Enums with constructors here Constructors NORTHSOUTH, SOUTHNORTH, EASTWEST, WESTEAST would be more elegant and would allow opposite to be declared final , but would be self-referential and therefore are not allowed. Section 35.7 Zero instance enum enum Util No instances GoalKicker.com Java Notes for Professionals 197 public static int clampint min, int max, int i return Math.minMath.maxi, min, max other utility methods... Just as enum can be used for singletons 1 instance classes, it can be used for utility classes 0 instance classes. Just make sure to terminate the empty list of enum constants with a . See the question Zero instance enum vs private constructors for preventing instantiation for a discussion on pros and cons compared to private constructors. Section 35.8 Enum as a bounded type parameter When writing a class with generics in java, it is possible to ensure that the type parameter is an enum. Since all enums extend the Enum class, the following syntax may be used. public class HolderT extends EnumT public final T value public HolderT init this.value init", "In this example, the type T must be an enum. Section 35.9 Documenting enums Not always the enum name is clear enough to be understood. To document an enum , use standard javadoc United States coins public enum Coins One-cent coin, commonly known as a penny, is a unit of currency equaling one-hundredth of a United States dollar PENNY 1, A nickel is a five-cent coin equaling five-hundredth of a United States dollar NICKEL 5, The dime is a ten-cent coin refers to one tenth of a United States dollar DIME 10, The quarter is a US coin worth 25 cents, one-fourth of a United States dollar GoalKicker.com Java Notes for Professionals 198 QUARTER 25 private int value Coins int value this.value value public int getValue return value Section 35.10 Enum constant speci\ufb01c body In an enum it is possible to de\ufb01ne a speci\ufb01c behavior for a particular constant of the enum which overrides the default behavior of the enum , this technique is known as constant speci\ufb01c body . Suppose three piano students - John, Ben and Luke - are de\ufb01ned in an enum named PianoClass , as follows enum PianoClass JOHN, BEN, LUKE public String getSex return", "Male public String getLevel return Beginner And one day two other students arrive - Rita and Tom - with a sex Female and level Intermediate that do not match the previous ones enum PianoClass2 JOHN, BEN, LUKE, RITA, TOM public String getSex return Male issue, Rita is a female public String getLevel return Beginner issue, Tom is an intermediate student so that simply adding the new students to the constant declaration, as follows, is not correct PianoClass2 tom PianoClass2. TOM PianoClass2 rita PianoClass2. RITA System.out.printlntom.getLevel prints Beginner - wrong Toms not a beginner System.out.printlnrita.getSex prints Male - wrong Ritas not a male Its possible to de\ufb01ne a speci\ufb01c behavior for each of the constant, Rita and Tom, which overrides the PianoClass2 default behavior as follows enum PianoClass3 JOHN, BEN, LUKE, RITA Override GoalKicker.com Java Notes for Professionals 199 public String getSex return Female , TOM Override public String getLevel return Intermediate public String getSex return Male public String getLevel return Beginner and now Toms level and Ritas sex are as they should be PianoClass3 tom PianoClass3. TOM PianoClass3 rita PianoClass3. RITA System.out.printlntom.getLevel prints Intermediate System.out.printlnrita.getSex prints Female Another way to de\ufb01ne content speci\ufb01c body is by using constructor, for", "instance enum Friend MATMale, JOHN Male, JANE Female private String gender Friend String gender this.gender gender public String getGender return this.gender and usage Friend mat Friend. MAT Friend john Friend. JOHN Friend jane Friend. JANE System.out.printlnmat.getGender Male System.out.printlnjohn.getGender Male System.out.printlnjane.getGender Female Section 35.11 Getting the values of an enum Each enum class contains an implicit static method named values. This method returns an array containing all values of that enum. You can use this method to iterate over the values. It is important to note however that this method returns a new array every time it is called. GoalKicker.com Java Notes for Professionals 200public enum Day MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY Print out all the values in this enum. public static void printAllDays forDay day Day.values System.out.printlnday.name If you need a Set you can use EnumSet. allOfDay.class as well. Section 35.12 Enum Polymorphism Pattern When a method need to accept an extensible set of enum values, the programmer can apply polymorphism like on a normal class by creating an interface which will be used anywere where the enum s shall be used public interface ExtensibleEnum String name This way, any enum tagged by implementing the interface can", "be used as a parameter, allowing the programmer to create a variable amount of enum s that will be accepted by the method. This can be useful, for example, in APIs where there is a default unmodi\ufb01able enum and the user of these APIs want to extend the enum with more values. A set of default enum values can be de\ufb01ned as follows public enum DefaultValues implements ExtensibleEnum VALUEONE, VALUETWO Additional values can then be de\ufb01ned like this public enum ExtendedValues implements ExtensibleEnum VALUETHREE, VALUEFOUR Sample which shows how to use the enums - note how printEnum accepts values from both enum types private void printEnum ExtensibleEnum val System.out.printlnval.name printEnum DefaultValues. VALUEONE VALUEONE printEnum DefaultValues. VALUETWO VALUETWO printEnum ExtendedValues. VALUETHREE VALUETHREE printEnum ExtendedValues. VALUEFOUR VALUEFOUR Note This pattern does not prevent you from rede\ufb01ning enum values, which are already de\ufb01ned in one enum, in another enum. These enum values would be di\ufb00erent instances then. Also, it is not possible to use switch-on-enum since all we have is the interface, not the real enum . GoalKicker.com Java Notes for Professionals 201Section 35.13 Compare and Contains for Enum values Enums contains only constants and can be compared directly with . So,", "only reference check is needed, no need to use .equals method. Moreover, if .equals used incorrectly, may raise the NullPointerException while thats not the case with check. enum Day GOOD, AVERAGE, WORST public class Test public static void mainString args Day day null if day.equalsDay.GOOD NullPointerException! System.out.printlnGood Day! if day Day.GOOD Always use to compare enum System.out.printlnGood Day! To group, complement, range the enum values we have EnumSet class which contains di\ufb00erent methods. EnumSetrange To get subset of enum by range de\ufb01ned by two endpoints EnumSetof Set of speci\ufb01c enums without any range. Multiple overloaded of methods are there. EnumSetcomplementOf Set of enum which is complement of enum values provided in method parameter enum Page A1, A2, A3, A4, A5, A6, A7, A8, A9, A10 public class Test public static void mainString args EnumSet Page range EnumSet. rangePage.A1, Page.A5 if range.contains Page.A4 System.out.printlnRange contains A4 EnumSet Page of EnumSet. ofPage.A1, Page.A5, Page.A3 if of.contains Page.A1 System.out.printlnOf contains A1 Section 35.14 Get enum constant by name Say we have an enum DayOfWeek GoalKicker.com Java Notes for Professionals 202enum DayOfWeek SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY An enum is compiled with a built-in static valueOf method which can be used", "to lookup a constant by its name String dayName DayOfWeek. SUNDAY.name assert dayName. equalsSUNDAY DayOfWeek day DayOfWeek. valueOfdayName assert day DayOfWeek. SUNDAY This is also possible using a dynamic enum type ClassDayOfWeek enumType DayOfWeek. class DayOfWeek day Enum.valueOfenumType, SUNDAY assert day DayOfWeek. SUNDAY Both of these valueOf methods will throw an IllegalArgumentException if the speci\ufb01ed enum does not have a constant with a matching name. The Guava library provides a helper method Enums.getIfPresent that returns a Guava Optional to eliminate explicit exception handling DayOfWeek defaultDay DayOfWeek. SUNDAY DayOfWeek day Enums.valueOfDayOfWeek. class, INVALID .ordefaultDay assert day DayOfWeek. SUNDAY Section 35.15 Enum with properties \ufb01elds In case we want to use enum with more information and not just as constant values, and we want to be able to compare two enums. Consider the following example public enum Coin PENNY 1, NICKEL 5, DIME10, QUARTER 25 private final int value Coin int value this.value value public boolean isGreaterThan Coin other return this.value other.value Here we de\ufb01ned an Enum called Coin which represent its value. With the method isGreaterThan we can compare two enum s Coin penny Coin.PENNY Coin dime Coin.DIME System.out.printlnpenny.isGreaterThan dime prints false GoalKicker.com Java Notes for Professionals 203System.out.printlndime.isGreaterThan penny prints", "true Section 35.16 Convert enum to String Sometimes you want to convert your enum to a String, there are two ways to do that. Assume we have public enum Fruit APPLE, ORANGE, STRAWBERRY, BANANA, LEMON, GRAPEFRUIT So how do we convert something like Fruit.APPLE to APPLE ? Convert using name name is an internal method in enum that returns the String representation of the enum, the return String represents exactly how the enum value was de\ufb01ned. For example System.out.printlnFruit.BANANA.name BANANA System.out.printlnFruit.GRAPEFRUIT .name GRAPEFRUIT Convert using toString toString is, by default , overridden to have the same behavior as name However, toString is likely overridden by developers to make it print a more user friendly String Dont use toString if you want to do checking in your code, name is much more stable for that. Only use toString when you are going to output the value to logs or stdout or something By default System.out.printlnFruit.BANANA.toString BANANA System.out.printlnFruit.GRAPEFRUIT .toString GRAPEFRUIT Example of being overridden System.out.printlnFruit.BANANA.toString Banana System.out.printlnFruit.GRAPEFRUIT .toString Grape Fruit Section 35.17 Enums with static \ufb01elds If your enum class is required to have static \ufb01elds, keep in mind they are created after the enum values themselves. That means, the following", "code will result in a NullPointerException enum Example ONE1, TWO2 static MapString, Integer integers new HashMap private Example int value GoalKicker.com Java Notes for Professionals 204 integers. putthis.name, value A possible way to \ufb01x this enum Example ONE1, TWO2 static MapString, Integer integers private Example int value putValue this.name, value private static void putValue String name, int value if integers null integers new HashMap integers. putname, value Do not initialize the static \ufb01eld enum Example ONE1, TWO2 after initialisisation integers is null!! static MapString, Integer integers null private Example int value putValue this.name, value private static void putValue String name, int value if integers null integers new HashMap integers. putname, value !!this may lead to null poiner exception!! public int getValue return Example. integers .getthis.name initialisisation create the enum values as side e\ufb00ect putValue called that initializes integers the static values are set integers null is executed after the enums so the content of integers is lost GoalKicker.com Java Notes for Professionals 205Chapter 36 Enum Map Java EnumMap class is the specialized Map implementation for enum keys. It inherits Enum and AbstractMap classes. the Parameters for java.util.EnumMap class. K It is the type of keys maintained by this map.", "V It is the type of mapped values. Section 36.1 Enum Map Book Example import java.util. class Book int id String name,author,publisher int quantity public Bookint id, String name, String author, String publisher, int quantity this.id id this.name name this.author author this.publisher publisher this.quantity quantity public class EnumMapExample Creating enum public enum Key One, Two, Three public static void mainString args EnumMap Key, Book map new EnumMap Key, BookKey.class Creating Books Book b1new Book101,Let us C ,Yashwant Kanetkar ,BPB,8 Book b2new Book102,Data Communications Networking ,Forouzan ,Mc Graw Hill ,4 Book b3new Book103,Operating System ,Galvin ,Wiley,6 Adding Books to Map map. putKey.One, b1 map. putKey.Two, b2 map. putKey.Three, b3 Traversing EnumMap forMap.EntryKey, Book entrymap.entrySet Book bentry.getValue System.out.printlnb.id b.name b.author b.publisher b.quantity GoalKicker.com Java Notes for Professionals 206Chapter 37 EnumSet class Java EnumSet class is the specialized Set implementation for use with enum types. It inherits AbstractSet class and implements the Set interface. Section 37.1 Enum Set Example import java.util. enum days SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY public class EnumSetExample public static void mainString args Setdays set EnumSet. ofdays.TUESDAY, days.WEDNESDAY Traversing elements Iterator days iter set.iterator while iter.hasNext System.out.printlniter.next GoalKicker.com Java Notes for Professionals 207Chapter 38 Enum starting with", "number Java does not allow the name of enum to start with number like 100A, 25K. In that case, we can append the code with underscore or any allowed pattern and make check of it. Section 38.1 Enum with name at beginning public enum BookCode 10A Simon Haykin , Communication System , 42B Stefan Hakins , A Brief History of Time , E1Sedra Smith , Electronics Circuits private String author private String title BookCode String author, String title this.author author this.title title public String getName String name name if name.charAt0 name name.substring 1, name.length return name public static BookCode of String code if Character .isDigitcode.charAt0 code code return BookCode. valueOfcode GoalKicker.com Java Notes for Professionals 208Chapter 39 Hashtable Hashtable is a class in Java collections which implements Map interface and extends the Dictionary Class Contains only unique elements and its synchronized Section 39.1 Hashtable import java.util. public class HashtableDemo public static void mainString args create and populate hash table Hashtable Integer, String map new Hashtable Integer, String map.put101,C Language map.put102, Domain map.put104, Databases System.out.printlnValues before remove map Remove value for key 102 map.remove102 System.out.printlnValues after remove map GoalKicker.com Java Notes for Professionals 209Chapter 40 Operators Operators in Java programming", "language are special symbols that perform speci\ufb01c operations on one, two, or three operands, and then return a result. Section 40.1 The IncrementDecrement Operators -- Variables can be incremented or decremented by 1 using the and -- operators, respectively. When the and -- operators follow variables, they are called post-increment and post-decrement respectively. int a 10 a a now equals 11 a-- a now equals 10 again When the and -- operators precede the variables the operations are called pre-increment and pre-decrement respectively. int x 10 --x x now equals 9 x x now equals 10 If the operator precedes the variable, the value of the expression is the value of the variable after being incremented or decremented. If the operator follows the variable, the value of the expression is the value of the variable prior to being incremented or decremented. int x10 System.out.printlnx x x x x x outputs x10 x10 x11 System.out.printlnx x x x x x outputs x11 x12 x12 System.out.printlnx x x x-- x x outputs x12 x12 x11 System.out.printlnx x x --x x x outputs x11 x10 x10 Be careful not to overwrite post-increments or decrements. This happens if you use a post-indecrement operator", "at the end of an expression which is reassigned to the indecremented variable itself. The indecrement will not have an e\ufb00ect. Even though the variable on the left hand side is incremented correctly, its value will be immediately overwritten with the previously evaluated result from the right hand side of the expression int x 0 x x 1 x x 0 1 1 do not do this - the last increment has no effect bug! System.out.printlnx prints 2 not 3! Correct int x 0 x x 1 x evaluates to x 0 1 1 x adds 1 System.out.printlnx prints 3 Section 40.2 The Conditional Operator ? Syntax GoalKicker.com Java Notes for Professionals 210condition-to-evaluate ? statement-executed-on-true statement-executed-on-false As shown in the syntax, the Conditional Operator also known as the Ternary Operator1 uses the ? question mark and colon characters to enable a conditional expression of two possible outcomes. It can be used to replace longer if-else blocks to return one of two values based on condition. result testCondition ? value1 value2 Is equivalent to if testCondition result value1 else result value2 It can be read as If testCondition is true, set result to value1 otherwise, set result to value2 .", "For example get absolute value using conditional operator a -10 int absValue a 0 ? -a a System.out.printlnabs absValue prints abs 10 Is equivalent to get absolute value using ifelse loop a -10 int absValue if a 0 absValue -a else absValue a System.out.printlnabs absValue prints abs 10 Common Usage You can use the conditional operator for conditional assignments like null checking. String x y ! null ? y.toString where y is an object This example is equivalent to String x if y ! null x y.toString Since the Conditional Operator has the second-lowest precedence, above the Assignment Operators, there is rarely a need for use parenthesis around the condition , but parenthesis is required around the entire Conditional Operator construct when combined with other operators no parenthesis needed for expressions in the 3 parts GoalKicker.com Java Notes for Professionals 21110 a a 19 ? b 5 b 7 parenthesis required 7 a 0 ? 2 5 Conditional operators nesting can also be done in the third part, where it works more like chaining or like a switch statement. a ? a is true b ? a is false, b is true c ? a and b are false,", "c is true a, b, and c are false Operator precedence can be illustrated with parenthesis a ? x b ? y c ? z w Footnote 1 - Both the Java Language Speci\ufb01cation and the Java Tutorial call the ? operator the Conditional Operator . The Tutorial says that it is also known as the Ternary Operator as it is currently the only ternary operator de\ufb01ned by Java. The Conditional Operator terminology is consistent with C and C and other languages with an equivalent operator. Section 40.3 The Bitwise and Logical Operators , , , The Java language provides 4 operators that perform bitwise or logical operations on integer or boolean operands. The complement operator is a unary operator that performs a bitwise or logical inversion of the bits of one operand see JLS 15.15.5. . The AND operator is a binary operator that performs a bitwise or logical and of two operands see JLS 15.22.2. . The OR operator is a binary operator that performs a bitwise or logical inclusive or of two operands see JLS 15.22.2. . The XOR operator is a binary operator that performs a bitwise or logical exclusive or of two operands see", "JLS 15.22.2. . The logical operations performed by these operators when the operands are booleans can be summarized as follows ABAA B A B A B 0010 0 0 0110 1 1 1000 1 1 1101 1 0 Note that for integer operands, the above table describes what happens for individual bits. The operators actually operate on all 32 or 64 bits of the operand or operands in parallel. Operand types and result types. The usual arithmetic conversions apply when the operands are integers. Common use-cases for the bitwise operators The operator is used to reverse a boolean value, or change all the bits in an integer operand. GoalKicker.com Java Notes for Professionals 212The operator is used for masking out some of the bits in an integer operand. For example int word 0b00101010 int mask 0b00000011 Mask for masking out all but the bottom two bits of a word int lowBits word mask - 0b00000010 int highBits word mask - 0b00101000 The operator is used to combine the truth values of two operands. For example int word2 0b01011111 Combine the bottom 2 bits of word1 with the top 30 bits of word2 int combined word mask word2 mask -", "0b01011110 The operator is used for toggling or \ufb02ipping bits int word3 0b00101010 int word4 word3 mask - 0b00101001 For more examples of the use of the bitwise operators, see Bit Manipulation Section 40.4 The String Concatenation Operator The symbol can mean three distinct operators in Java If there is no operand before the , then it is the unary Plus operator. If there are two operands, and they are both numeric. then it is the binary Addition operator. If there are two operands, and at least one of them is a String , then it it the binary Concatenation operator. In the simple case, the Concatenation operator joins two strings to give a third string. For example String s1 a String String s2 This is s1 s2 contains This is a String When one of the two operands is not a string, it is converted to a String as follows An operand whose type is a primitive type is converted as if by calling toString on the boxed value. An operand whose type is a reference type is converted by calling the operands toString method. If the operand is null , or if the toString method returns null", ", then the string literal null is used instead. For example int one 1 String s3 One is one s3 contains One is 1 String s4 null is null s4 contains null is null String s5 1 is new int1 s5 contains something like is Ixxxxxxxx The explanation for the s5 example is that the toString method on array types is inherited from java.lang.Object , and the behavior is to produce a string that consists of the type name, and the objects identity hashcode. The Concatenation operator is speci\ufb01ed to create a new String object, except in the case where the expression is a Constant Expression. In the latter case, the expression is evaluated at compile type, and its runtime value is GoalKicker.com Java Notes for Professionals 213equivalent to a string literal. This means that there is no runtime overhead in splitting a long string literal like this String typing The quick brown fox jumped over the lazy dog constant expression Optimization and e\ufb03ciency As noted above, with the exception of constant expressions, each string concatenation expression creates a new String object. Consider this code public String starsint count String res for int i 0 i count i res", "res return res In the method above, each iteration of the loop will create a new String that is one character longer than the previous iteration. Each concatenation copies all of the characters in the operand strings to form the new String . Thus, starsN will create N new String objects, and throw away all but the last one, copy N N 1 2 characters, and generate ON2 bytes of garbage. This is very expensive for large N. Indeed, any code that concatenates strings in a loop is liable to have this problem. A better way to write this would be as follows public String starsint count Create a string builder with capacity count StringBuilder sb new StringBuilder count for int i 0 i count i sb. append return sb.toString Ideally, you should set the capacity of the StringBuilder , but if this is not practical, the class will automatically grow the backing array that the builder uses to hold characters. Note the implementation expands the backing array exponentially. This strategy keeps that amount of character copying to a ON rather than ON2. Some people apply this pattern to all string concatenations. However, this is unnecessary because the JLS", "allows a Java compiler to optimize string concatenations within a single expression. For example String s1 ... String s2 ... String test Hello s1 . Welcome to s2 n will typically be optimized by the bytecode compiler to something like this StringBuilder tmp new StringBuilder tmp.appendHello tmp.appends1 null ? null s1 tmp.appendWelcome to GoalKicker.com Java Notes for Professionals 214tmp.appends2 null ? null s2 tmp.appendn String test tmp.toString The JIT compiler may optimize that further if it can deduce that s1 or s2 cannot be null . But note that this optimization is only permitted within a single expression. In short, if you are concerned about the e\ufb03ciency of string concatenations Do hand-optimize if you are doing repeated concatenation in a loop or similar. Dont hand-optimize a single concatenation expression. Section 40.5 The Arithmetic Operators , -, , , The Java language provides 7 operators that perform arithmetic on integer and \ufb02oating point values. There are two operators The binary addition operator adds one number to another one. There is also a binary operator that performs string concatenation. That is described in a separate example. The unary plus operator does nothing apart from triggering numeric promotion see below There are", "two - operators The binary subtraction operator subtracts one number from another one. The unary minus operator is equivalent to subtracting its operand from zero. The binary multiply operator multiplies one number by another. The binary divide operator divides one number by another. The binary remainder1 operator calculates the remainder when one number is divided by another. 1. This is often incorrectly referred to as the modulus operator. Remainder is the term that is used by the JLS. Modulus and remainder are not the same thing. Operand and result types, and numeric promotion The operators require numeric operands and produce numeric results. The operand types can be any primitive numeric type i.e. byte , short , char , int, long , float or double or any numeric wrapper type de\ufb01ne in java.lang i.e. Byte , Character , Short , Integer , Long , Float or Double . The result type is determined base on the types of the operand or operands, as follows If either of the operands is a double or Double , then the result type is double . Otherwise, if either of the operands is a float or Float , then the result type is float", ". Otherwise, if either of the operands is a long or Long , then the result type is long . Otherwise, the result type is int. This covers byte , short and char operands as well as int. The result type of the operation determines how the arithmetic operation is performed, and how the operands are handled If the result type is double , the operands are promoted to double , and the operation is performed using 64- bit double precision binary IEE 754 \ufb02oating point arithmetic. If the result type is float , the operands are promoted to float , and the operation is performed using 32-bit single precision binary IEE 754 \ufb02oating point arithmetic. If the result type is long , the operands are promoted to long , and the operation is performed using 64-bit signed twos-complement binary integer arithmetic. If the result type is int, the operands are promoted to int, and the operation is performed using 32-bit signed twos-complement binary integer arithmetic. GoalKicker.com Java Notes for Professionals 215Promotion is performed in two stages If the operand type is a wrapper type, the operand value is unboxed to a value of the corresponding primitive type. If", "necessary, the primitive type is promoted to the required type Promotion of integers to int or long is loss-less. Promotion of float to double is loss-less. Promotion of an integer to a \ufb02oating point value can lead to loss of precision. The conversion is performed using IEE 768 round-to-nearest semantics. The meaning of division The operator divides the left-hand operand n the dividend and the right-hand operand d the divisor and produces the result q the quotient . Java integer division rounds towards zero. The JLS Section 15.17.2 speci\ufb01es the behavior of Java integer division as follows The quotient produced for operands n and d is an integer value q whose magnitude is as large as possible while satisfying d q n. Moreover, q is positive when n d and n and d have the same sign, but q is negative when n d and n and d have opposite signs. There are a couple of special cases If the n is MINVALUE , and the divisor is -1, then integer over\ufb02ow occurs and the result is MINVALUE . No exception is thrown in this case. If d is 0, then ArithmeticException is thrown. Java \ufb02oating point division has", "more edge cases to consider. However the basic idea is that the result q is the value that is closest to satisfying d . q n. Floating point division will never result in an exception. Instead, operations that divide by zero result in an INF and NaN values see below. The meaning of remainder Unlike C and C, the remainder operator in Java works with both integer and \ufb02oating point operations. For integer cases, the result of a b is de\ufb01ned to be the number r such that a b b r is equal to a, where , and are the appropriate Java integer operators. This applies in all cases except when b is zero. That case, remainder results in an ArithmeticException . It follows from the above de\ufb01nition that a b can be negative only if a is negative, and it be positive only if a is positive. Moreover, the magnitude of a b is always less than the magnitude of b. Floating point remainder operation is a generalization of the integer case. The result of a b is the remainder r is de\ufb01ned by the mathematical relation r a - b q where q is an integer,", "it is negative only if a b is negative an positive only if a b is positive, and its magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of a and b. GoalKicker.com Java Notes for Professionals 216Floating point remainder can produce INF and NaN values in edge-cases such as when b is zero see below. It will not throw an exception. Important note The result of a \ufb02oating-point remainder operation as computed by is not the same as that produced by the remainder operation de\ufb01ned by IEEE 754. The IEEE 754 remainder may be computed using the Math.IEEEremainder library method. Integer Over\ufb02ow Java 32 and 64 bit integer values are signed and use twos-complement binary representation. For example, the range of numbers representable as 32 bit int -231 through 231 - 1. When you add, subtract or multiple two N bit integers N 32 or 64, the result of the operation may be too large to represent as an N bit integer. In this case, the operation leads to integer over\ufb02ow , and the result can be computed as follows The mathematical operation is performed to give a intermediate twos-complement representation of", "the entire number. This representation will be larger than N bits. The bottom 32 or 64 bits of the intermediate representation are used as the result. It should be noted that integer over\ufb02ow does not result in exceptions under any circumstances. Floating point INF and NAN values Java uses IEE 754 \ufb02oating point representations for float and double . These representations have some special values for representing values that fall outside of the domain of Real numbers The in\ufb01nite or INF values denote numbers that are too large. The INF value denote numbers that are too large and positive. The -INF value denote numbers that are too large and negative. The inde\ufb01nite not a number or NaN denote values resulting from meaningless operations. The INF values are produced by \ufb02oating operations that cause over\ufb02ow, or by division by zero. The NaN values are produced by dividing zero by zero, or computing zero remainder zero. Surprisingly, it is possible perform arithmetic using INF and NaN operands without triggering exceptions. For example Adding INF and a \ufb01nite value gives INF. Adding INF and INF gives INF. Adding INF and -INF gives NaN. Dividing by INF gives either 0.0 or -0.0. All", "operations with one or more NaN operands give NaN. For full details, please refer to the relevant subsections of JLS 15 . Note that this is largely academic. For typical calculations, an INF or NaN means that something has gone wrong e.g. you have incomplete or incorrect input data, or the calculation has been programmed incorrectly. Section 40.6 The Shift Operators , and The Java language provides three operator for performing bitwise shifting on 32 and 64 bit integer values. These GoalKicker.com Java Notes for Professionals 217are all binary operators with the \ufb01rst operand being the value to be shifted, and the second operand saying how far to shift. The or left shift operator shifts the value given by the \ufb01rst operand leftwards by the number of bit positions given by the second operand. The empty positions at the right end are \ufb01lled with zeros. The or arithmetic shift operator shifts the value given by the \ufb01rst operand rightwards by the number of bit positions given by the second operand. The empty positions at the left end are \ufb01lled by copying the left-most bit. This process is known as sign extension . The or logical right shift operator shifts", "the value given by the \ufb01rst operand rightwards by the number of bit positions given by the second operand. The empty positions at the left end are \ufb01lled with zeros. Notes These operators require an int or long value as the \ufb01rst operand, and produce a value with the same type as 1. the \ufb01rst operand. You will need to use an explicit type cast when assigning the result of a shift to a byte , short or char variable. If you use a shift operator with a \ufb01rst operand that is a byte , char or short , it is promoted to an int and the 2. operation produces an int. The second operand is reduced modulo the number of bits of the operation to give the amount of the shift. For 3. more about the mod mathematical concept , see Modulus examples. The bits that are shifted o\ufb00 the left or right end by the operation are discarded. Java does not provide a4. primitive rotate operator. The arithmetic shift operator is equivalent dividing a twos complement number by a power of 2.5. The left shift operator is equivalent multiplying a twos complement number by a power of", "2.6. The following table will help you see the e\ufb00ects of the three shift operators. The numbers have been expressed in binary notation to aid vizualization. Operand1 Operand2 0b0000000000001011 0 0b0000000000001011 0b0000000000001011 0b0000000000001011 0b0000000000001011 1 0b0000000000010110 0b0000000000000101 0b0000000000000101 0b0000000000001011 2 0b0000000000101100 0b0000000000000010 0b0000000000000010 0b0000000000001011 28 0b1011000000000000 0b0000000000000000 0b0000000000000000 0b0000000000001011 31 0b1000000000000000 0b0000000000000000 0b0000000000000000 0b0000000000001011 32 0b0000000000001011 0b0000000000001011 0b0000000000001011 ... ... ... ... ... 0b1000000000001011 0 0b1000000000001011 0b1000000000001011 0b1000000000001011 0b1000000000001011 1 0b0000000000010110 0b1100000000000101 0b0100000000000101 0b1000000000001011 2 0b0000000000101100 0b1110000000000010 0b00100000000000100 0b1000000000001011 31 0b1000000000000000 0b1111111111111111 0b0000000000000001 There examples of the user of shift operators in Bit manipulation Section 40.7 The Instanceof Operator This operator checks whether the object is of a particular classinterface type. instanceof operator is written as GoalKicker.com Java Notes for Professionals 218 Object reference variable instanceof classinterface type Example public class Test public static void mainString args String name Buyya following will return true since name is type of String boolean result name instanceof String System.out.println result This would produce the following result true This operator will still return true if the object being compared is the assignment compatible with the type on the right. Example class Vehicle public class Car extends Vehicle public static void mainString args Vehicle", "a new Car boolean result a instanceof Car System.out.println result This would produce the following result true Section 40.8 The Assignment Operators , , -, , , , , , , , and The left hand operand for these operators must be a either a non-\ufb01nal variable or an element of an array. The right hand operand must be assignment compatible with the left hand operand. This means that either the types must be the same, or the right operand type must be convertible to the left operands type by a combination of boxing, unboxing or widening. For complete details refer to JLS 5.2 . The precise meaning of the operation and assign operators is speci\ufb01ed by JLS 15.26.2 as A compound assignment expression of the form E1 op E2 is equivalent to E1 T E1 op E2, where T is the type of E1, except that E1 is evaluated only once. Note that there is an implicit type-cast before the \ufb01nal assignment. 1. GoalKicker.com Java Notes for Professionals 219The simple assignment operator assigns the value of the right hand operand to the left hand operand. Example c a b will add the value of a b to the", "value of c and assign it to c 2. The add and assign operator adds the value of right hand operand to the value of the left hand operand and assigns the result to left hand operand. If the left hand operand has type String , then this a concatenate and assign operator. Example c a is roughly the same as c c a 3. - The subtract and assign operator subtracts the value of the right operand from the value of the left hand operand and assign the result to left hand operand. Example c - a is roughly the same as c c - a 4. The multiply and assign operator multiplies the value of the right hand operand by the value of the left hand operand and assign the result to left hand operand. . Example c a is roughly the same as c c a 5. The divide and assign operator divides the value of the right hand operand by the value of the left hand operand and assign the result to left hand operand. Example c a is roughly the same as c c a 6. The modulus and assign operator calculates the modulus", "of the value of the right hand operand by the value of the left hand operand and assign the result to left hand operand. Example c a is roughly the same as c c a 7. The left shift and assign operator. Example c 2 is roughly the same as c c 2 GoalKicker.com Java Notes for Professionals 2208. The arithmetic right shift and assign operator. Example c 2 is roughly the same as c c 2 9. The logical right shift and assign operator. Example c 2 is roughly the same as c c 2 10. The bitwise and and assign operator. Example c 2 is roughly the same as c c 2 11. The bitwise or and assign operator. Example c 2 is roughly the same as c c 2 12. The bitwise exclusive or and assign operator. Example c 2 is roughly the same as c c 2 Section 40.9 The conditional-and and conditional-or Operators and Java provides a conditional-and and a conditional-or operator, that both take one or two operands of type boolean and produce a boolean result. These are - the conditional-AND operator, - the conditional-OR operators. The evaluation of left-expr right-expr is equivalent", "to the following pseudo-code boolean L evaluate left-expr if L return evaluate right-expr else short-circuit the evaluation of the 2nd operand expression return false GoalKicker.com Java Notes for Professionals 221 The evaluation of left-expr right-expr is equivalent to the following pseudo-code boolean L evaluate left-expr if !L return evaluate right-expr else short-circuit the evaluation of the 2nd operand expression return true As the pseudo-code above illustrates, the behavior of the short-circuit operators are equivalent to using if else statements. Example - using as a guard in an expression The following example shows the most common usage pattern for the operator. Compare these two versions of a method to test if a supplied Integer is zero. public boolean isZeroInteger value return value 0 public boolean isZeroInteger value return value ! null value 0 The \ufb01rst version works in most cases, but if the value argument is null , then a NullPointerException will be thrown. In the second version we have added a guard test. The value ! null value 0 expression is evaluated by \ufb01rst performing the value ! null test. If the null test succeeds i.e. it evaluates to true then the value 0 expression is evaluated. If the", "null test fails, then the evaluation of value 0 is skipped short-circuited, and we dont get a NullPointerException . Example - using to avoid a costly calculation The following example shows how can be used to avoid a relatively costly calculation public boolean verifyint value, boolean needPrime return !needPrime isPrime value public boolean verifyint value, boolean needPrime return !needPrime isPrime value In the \ufb01rst version, both operands of the will always be evaluated, so the expensive isPrime method will be called unnecessarily. The second version avoids the unnecessary call by using instead of . Section 40.10 The Relational Operators , , , The operators , , and are binary operators for comparing numeric types. The meaning of the operators is as GoalKicker.com Java Notes for Professionals 222you would expect. For example, if a and b are declared as any of byte , short , char , int, long , float , double or the corresponding boxed types - a b tests if the value of a is less than the value of b. - a b tests if the value of a is less than or equal to the value of b. - a b tests if the value", "of a is greater than the value of b. - a b tests if the value of a is greater than or equal to the value of b. The result type for these operators is boolean in all cases. Relational operators can be used to compare numbers with di\ufb00erent types. For example int i 1 long l 2 if i l System.out.printlni is smaller Relational operators can be used when either or both numbers are instances of boxed numeric types. For example Integer i 1 1 is autoboxed to an Integer Integer j 2 2 is autoboxed to an Integer if i j System.out.printlni is smaller The precise behavior is summarized as follows If one of the operands is a boxed type, it is unboxed.1. If either of the operands now a byte , short or char , it is promoted to an int. 2. If the types of the operands are not the same, then the operand with the smaller type is promoted to the3. larger type. The comparison is performed on the resulting int, long , float or double values. 4. You need to be careful with relational comparisons that involve \ufb02oating point numbers Expressions that compute", "\ufb02oating point numbers often incur rounding errors due to the fact that the computer \ufb02oating-point representations have limited precision. When comparing an integer type and a \ufb02oating point type, the conversion of the integer to \ufb02oating point can also lead to rounding errors. Finally, Java does bit support the use of relational operators with any types other than the ones listed above. For example, you cannot use these operators to compare strings, arrays of numbers, and so on. Section 40.11 The Equality Operators , ! The and ! operators are binary operators that evaluate to true or false depending on whether the operands are equal. The operator gives true if the operands are equal and false otherwise. The ! operator gives false if the operands are equal and true otherwise. These operators can be used operands with primitive and reference types, but the behavior is signi\ufb01cantly di\ufb00erent. According to the JLS, there are actually three distinct sets of these operators The Boolean and ! operators. The Numeric and ! operators. GoalKicker.com Java Notes for Professionals 223The Reference and ! operators. However, in all cases, the result type of the and ! operators is boolean . The Numeric and !", "operators When one or both of the operands of an or ! operator is a primitive numeric type byte , short , char , int, long , float or double , the operator is a numeric comparison. The second operand must be either a primitive numeric type, or a boxed numeric type. The behavior other numeric operators is as follows If one of the operands is a boxed type, it is unboxed.1. If either of the operands now a byte , short or char , it is promoted to an int. 2. If the types of the operands are not the same, then the operand with the smaller type is promoted to the3. larger type. The comparison is then carried out as follows4. If the promoted operands are int or long then the values are tested to see if they are identical. If the promoted operands are float or double then the two versions of zero 0.0 and -0.0 are treated as equal a NaN value is treated as not equals to anything, and other values are equal if their IEEE 754 representations are identical. Note you need to be careful when using and ! to compare \ufb02oating point", "values. The Boolean and ! operators If both operands are boolean , or one is boolean and the other is Boolean , these operators the Boolean and ! operators. The behavior is as follows If one of the operands is a Boolean , it is unboxed. 1. The unboxed operands are tested and the boolean result is calculated according to the following truth table2. A BA B A ! B false false true false false true false true true false false true true true true false There are two pitfalls that make it advisable to use and ! sparingly with truth values If you use or ! to compare two Boolean objects, then the Reference operators are used. This may give an unexpected result see Pitfall using to compare primitive wrappers objects such as Integer The operator can easily be mistyped as . For most operand types, this mistake leads to a compilation error. However, for boolean and Boolean operands the mistake leads to incorrect runtime behavior see Pitfall - Using to test a boolean The Reference and ! operators If both operands are object references, the and ! operators test if the two operands refer to the same", "object . This often not what you want. To test if two objects are equal by value , the .equals method should be used instead. GoalKicker.com Java Notes for Professionals 224String s1 We are equal String s2 new StringWe are equal s1.equalss2 true WARNING - dont use or ! with String values s1 s2 false Warning using and ! to compare String values is incorrect in most cases see httpstackover\ufb02ow.comdocumentationjava4388java-pitfalls16290using-to-compare-strings . A similar problem applies to primitive wrapper types see httpstackover\ufb02ow.comdocumentationjava4388java-pitfalls8996using-to-compare-primitive-wrappers-objects -such-as-integer . About the NaN edge-cases JLS 15.21.1 states the following If either operand is NaN, then the result of is false but the result of ! is true . Indeed, the test x ! x is true if and only if the value of x is NaN. This behavior is to most programmers unexpected. If you test if a NaN value is equal to itself, the answer is No it isnt!. In other words, is not re\ufb02exive for NaN values. However, this is not a Java oddity, this behavior is speci\ufb01ed in the IEEE 754 \ufb02oating-point standards, and you will \ufb01nd that it is implemented by most modern programming languages. For more information, see httpstackover\ufb02ow.coma1573715139985 ... noting", "that this is written by someone who was in the room when the decisions were made! Section 40.12 The Lambda operator - From Java 8 onwards, the Lambda operator - is the operator used to introduce a Lambda Expression. There are two common syntaxes, as illustrated by these examples Version Java SE 8 a - a 1 a lambda that adds one to its argument a - return a 1 an equivalent lambda using a block. A lambda expression de\ufb01nes an anonymous function, or more correctly an instance of an anonymous class that implements a functional interface . This example is included here for completeness. Refer to the Lambda Expressions topic for the full treatment. GoalKicker.com Java Notes for Professionals 225Chapter 41 Constructors While not required, constructors in Java are methods recognized by the compiler to instantiate speci\ufb01c values for the class which may be essential to the role of the object. This topic demonstrates proper usage of Java class constructors. Section 41.1 Default Constructor The default for constructors is that they do not have any arguments. In case you do not specify any constructor, the compiler will generate a default constructor for you. This means the following two", "snippets are semantically equivalent public class TestClass private String test public class TestClass private String test public TestClass The visibility of the default constructor is the same as the visibility of the class. Thus a class de\ufb01ned package- privately has a package-private default constructor However, if you have non-default constructor, the compiler will not generate a default constructor for you. So these are not equivalent public class TestClass private String test public TestClass String arg public class TestClass private String test public TestClass public TestClass String arg Beware that the generated constructor performs no non-standard initialization. This means all \ufb01elds of your class will have their default value, unless they have an initializer. public class TestClass private String testData public TestClass testData Test Constructors are called like this GoalKicker.com Java Notes for Professionals 226TestClass testClass new TestClass Section 41.2 Call parent constructor Say you have a Parent class and a Child class. To construct a Child instance always requires some Parent constructor to be run at the very gebinning of the Child constructor. We can select the Parent constructor we want by explicitly calling super... with the appropriate arguments as our \ufb01rst Child constructor statement. Doing this saves us", "time by reusing the Parent classes constructor instead of rewriting the same code in the Child classes constructor. Without super... method implicitly, the no-args version super is called invisibly class Parent private String name private int age public Parent necessary because we call super without arguments public ParentString tName, int tAge name tName age tAge This does not even compile, because name and age are private, making them invisible even to the child class. class Child extends Parent public Child compiler implicitly calls super here name John age 42 With super method class Parent private String name private int age public ParentString tName, int tAge name tName age tAge class Child extends Parent public Child superJohn, 42 explicit super-call Note Calls to another constructor chaining or the super constructor MUST be the \ufb01rst statement inside the constructor. If you call the super... constructor explicitly, a matching parent constructor must exist thats straightforward, isnt it?. GoalKicker.com Java Notes for Professionals 227If you dont call any super... constructor explicitly, your parent class must have a no-args constructor - and this can be either written explicitly or created as a default by the compiler if the parent class doesnt provide any constructor.", "class Parent public ParentString tName, int tAge class Child extends Parent public Child The class Parent has no default constructor, so, the compiler cant add super in the Child constructor. This code will not compile. You must change the constructors to \ufb01t both sides, or write your own super call, like that class Child extends Parent public Child super,0 Section 41.3 Constructor with Arguments Constructors can be created with any kinds of arguments. public class TestClass private String testData public TestClass String testData this.testData testData Called like this TestClass testClass new TestClass Test Data A class can have multiple constructors with di\ufb00erent signatures. To chain constructor calls call a di\ufb00erent constructor of the same class when instantiating use this. public class TestClass private String testData public TestClass String testData this.testData testData public TestClass thisTest testData defaults to Test Called like this TestClass testClass1 new TestClass Test Data GoalKicker.com Java Notes for Professionals 228TestClass testClass2 new TestClass GoalKicker.com Java Notes for Professionals 229Chapter 42 Object Class Methods and Constructor This documentation page is for showing details with example about java class constructors and about Object Class Methods which are automatically inherited from the superclass Object of any newly created class.", "Section 42.1 hashCode method When a Java class overrides the equals method, it should override the hashCode method as well. As de\ufb01ned in the methods contract Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modi\ufb01ed. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equalsObject method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the equalsObject method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. Hash codes are used in hash implementations such as HashMap , HashTable , and HashSet . The result of the hashCode function determines the bucket in which an object will be put. These hash implementations are", "more e\ufb03cient if the provided hashCode implementation is good. An important property of good hashCode implementation is that the distribution of the hashCode values is uniform. In other words, there is a small probability that numerous instances will be stored in the same bucket. An algorithm for computing a hash code value may be similar to the following public class Foo private int field1, field2 private String field3 public Fooint field1, int field2, String field3 this.field1 field1 this.field2 field2 this.field3 field3 Override public boolean equalsObject obj if this obj return true if obj null getClass ! obj.getClass return false Foo f Foo obj return field1 f.field1 field2 f.field2 field3 null ? f.field3 null field3. equalsf.field3 GoalKicker.com Java Notes for Professionals 230 Override public int hashCode int hash 1 hash 31 hash field1 hash 31 hash field2 hash 31 hash field3 null ? 0 field3. hashCode return hash Using Arrays.hashCode as a short cut Version Java SE 1.2 In Java 1.2 and above, instead of developing an algorithm to compute a hash code, one can be generated using java.util.ArrayshashCode by supplying an Object or primitives array containing the \ufb01eld values Override public int hashCode return Arrays.hashCode new Object field1, field2,", "field3 Version Java SE 7 Java 1.7 introduced the java.util.Objects class which provides a convenience method, hashObject... objects, that computes a hash code based on the values of the objects supplied to it. This method works just like java.util.ArrayshashCode . Override public int hashCode return Objects. hashfield1, field2, field3 Note this approach is ine\ufb03cient, and produces garbage objects each time your custom hashCode method is called A temporary Object is created. In the Objects. hash version, the array is created by the varargs mechanism. If any of the \ufb01elds are primitive types, they must be boxed and that may create more temporary objects. The array must be populated. The array must iterated by the Arrays.hashCode or Objects. hash method. The calls to Object.hashCode that Arrays.hashCode or Objects. hash has to make probably cannot be inlined. Internal caching of hash codes Since the calculation of an objects hash code can be expensive, it can be attractive to cache the hash code value within the object the \ufb01rst time that it is calculated. For example public final class ImmutableArray private int array private volatile int hash 0 public ImmutableArray int initial array initial. clone Other methods GoalKicker.com Java Notes for Professionals", "231 Override public boolean equalsObject obj ... Override public int hashCode int h hash if h 0 h Arrays.hashCode array hash h return h This approach trades o\ufb00 the cost of repeatedly calculating the hash code against the overhead of an extra \ufb01eld to cache the hash code. Whether this pays o\ufb00 as a performance optimization will depend on how often a given object is hashed looked up and other factors. You will also notice that if the true hashcode of an ImmutableArray happens to be zero one chance in 232, the cache is ine\ufb00ective. Finally, this approach is much harder to implement correctly if the object we are hashing is mutable. However, there are bigger concerns if hash codes change see the contract above. Section 42.2 toString method The toString method is used to create a String representation of an object by using the object s content. This method should be overridden when writing your class. toString is called implicitly when an object is concatenated to a string as in hello anObject . Consider the following public class User private String firstName private String lastName public UserString firstName, String lastName this.firstName firstName this.lastName lastName Override public String toString", "return firstName lastName public static void mainString args User user new UserJohn, Doe System.out.printlnuser.toString Prints John Doe Here toString from Object class is overridden in the User class to provide meaningful data regarding the object when printing it. When using println, the objects toString method is implicitly called. Therefore, these statements do the GoalKicker.com Java Notes for Professionals 232same thing System.out.printlnuser toString is implicitly called on user System.out.printlnuser.toString If the toString is not overridden in the above mentioned User class, System.out.printlnuser may return User659e0bfd or a similar String with almost no useful information except the class name. This will be because the call will use the toString implementation of the base Java Object class which does not know anything about the User classs structure or business rules. If you want to change this functionality in your class, simply override the method. Section 42.3 equals method TLDR tests for reference equality whether they are the same object .equals tests for value equality whether they are logically equal equals is a method used to compare two objects for equality. The default implementation of the equals method in the Object class returns true if and only if both references are pointing to", "the same instance. It therefore behaves the same as comparison by . public class Foo int field1, field2 String field3 public Fooint i, int j, String k field1 i field2 j field3 k public static void mainString args Foo foo1 new Foo0, 0, bar Foo foo2 new Foo0, 0, bar System.out.printlnfoo1.equalsfoo2 prints false Even though foo1 and foo2 are created with the same \ufb01elds, they are pointing to two di\ufb00erent objects in memory. The default equals implementation therefore evaluates to false . To compare the contents of an object for equality, equals has to be overridden. public class Foo int field1, field2 String field3 public Fooint i, int j, String k field1 i field2 j field3 k Override GoalKicker.com Java Notes for Professionals 233 public boolean equalsObject obj if this obj return true if obj null getClass ! obj.getClass return false Foo f Foo obj return field1 f.field1 field2 f.field2 field3 null ? f.field3 null field3. equalsf.field3 Override public int hashCode int hash 1 hash 31 hash this.field1 hash 31 hash this.field2 hash 31 hash field3 null ? 0 field3. hashCode return hash public static void mainString args Foo foo1 new Foo0, 0, bar Foo foo2 new Foo0, 0,", "bar System.out.printlnfoo1.equalsfoo2 prints true Here the overridden equals method decides that the objects are equal if their \ufb01elds are the same. Notice that the hashCode method was also overwritten. The contract for that method states that when two objects are equal, their hash values must also be the same. Thats why one must almost always override hashCode and equals together. Pay special attention to the argument type of the equals method. It is Object obj , not Foo obj . If you put the latter in your method, that is not an override of the equals method. When writing your own class, you will have to write similar logic when overriding equals and hashCode . Most IDEs can automatically generate this for you. An example of an equals implementation can be found in the String class, which is part of the core Java API. Rather than comparing pointers, the String class compares the content of the String . Version Java SE 7 Java 1.7 introduced the java.util.Objects class which provides a convenience method, equals , that compares two potentially null references, so it can be used to simplify implementations of the equals method. Override public boolean equalsObject obj if", "this obj return true if obj null getClass ! obj.getClass return false GoalKicker.com Java Notes for Professionals 234 Foo f Foo obj return field1 f.field1 field2 f.field2 Objects. equalsfield3, f. field3 Class Comparison Since the equals method can run against any object, one of the \ufb01rst things the method often does after checking for null is to check if the class of the object being compared matches the current class. Override public boolean equalsObject obj ...check for null if getClass ! obj.getClass return false ...compare fields This is typically done as above by comparing the class objects. However, that can fail in a few special cases which may not be obvious. For example, some frameworks generate dynamic proxies of classes and these dynamic proxies are actually a di\ufb00erent class. Here is an example using JPA. Foo detachedInstance ... Foo mergedInstance entityManager. mergedetachedInstance if mergedInstance. equalsdetachedInstance Can never get here if equality is tested with getClass as mergedInstance is a proxy subclass of Foo One mechanism to work around that limitation is to compare classes using instanceof Override public final boolean equalsObject obj if !obj instanceof Foo return false ...compare fields However, there are a few pitfalls that must be", "avoided when using instanceof . Since Foo could potentially have other subclasses and those subclasses might override equals you could get into a case where a Foo is equal to a FooSubclass but the FooSubclass is not equal to Foo. Foo foo new Foo7 FooSubclass fooSubclass new FooSubclass 7, false foo.equalsfooSubclass true fooSubclass. equalsfoo false This violates the properties of symmetry and transitivity and thus is an invalid implementation of the equals method. As a result, when using instanceof , a good practice is to make the equals method final as in the above example. This will ensure that no subclass overrides equals and violates key assumptions. Section 42.4 wait and notify methods wait and notify work in tandem when one thread calls wait on an object, that thread will block until another thread calls notify or notifyAll on that same object. GoalKicker.com Java Notes for Professionals 235See Also waitnotify package com.example.examples.object import java.util.concurrent.atomic.AtomicBoolean public class WaitAndNotify public static void mainString args throws InterruptedException final Object obj new Object AtomicBoolean aHasFinishedWaiting new AtomicBoolean false Thread threadA new ThreadThread A public void run System.out.printlnA1 Could print before or after B1 System.out.printlnA2 Thread A is about to start waiting... try synchronized", "obj wait must be in a synchronized block execution of thread A stops until obj.notify is called obj. wait System.out.printlnA3 Thread A has finished waiting. Guaranteed to happen after B3 catch InterruptedException e System.out.printlnThread A was interrupted while waiting finally aHasFinishedWaiting. settrue Thread threadB new ThreadThread B public void run System.out.printlnB1 Could print before or after A1 System.out.printlnB2 Thread B is about to wait for 10 seconds for int i 0 i 10 i try Thread.sleep1000 sleep for 1 second catch InterruptedException e System.err.printlnThread B was interrupted from waiting System.out.printlnB3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. while !aHasFinishedWaiting. get synchronized obj notify ONE thread which has called obj.wait obj. notify threadA. start threadB. start threadA. join threadB. join GoalKicker.com Java Notes for Professionals 236 System.out.printlnFinished! Some example output A1 Could print before or after B1 B1 Could print before or after A1 A2 Thread A is about to start waiting... B2 Thread B is about to wait for 10 seconds B3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. A3 Thread A has finished waiting. Guaranteed to happen after B3 Finished! B1 Could print before", "or after A1 B2 Thread B is about to wait for 10 seconds A1 Could print before or after B1 A2 Thread A is about to start waiting... B3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. A3 Thread A has finished waiting. Guaranteed to happen after B3 Finished! A1 Could print before or after B1 A2 Thread A is about to start waiting... B1 Could print before or after A1 B2 Thread B is about to wait for 10 seconds B3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. A3 Thread A has finished waiting. Guaranteed to happen after B3 Finished! Section 42.5 getClass method The getClass method can be used to \ufb01nd the runtime class type of an object. See the example below public class User private long userID private String name public Userlong userID, String name this.userID userID this.name name public class SpecificUser extends User private String specificUserID public SpecificUser String specificUserID, long userID, String name superuserID, name this.specificUserID specificUserID public static void mainString args User user new User879745, John SpecificUser specificUser new SpecificUser 1AAAA, 877777, Jim User anotherSpecificUser new SpecificUser 1BBBB, 812345, Jenny", "System.out.printlnuser.getClass Prints class User GoalKicker.com Java Notes for Professionals 237 System.out.printlnspecificUser. getClass Prints class SpecificUser System.out.printlnanotherSpecificUser. getClass Prints class SpecificUser The getClass method will return the most speci\ufb01c class type, which is why when getClass is called on anotherSpecificUser , the return value is class SpecificUser because that is lower down the inheritance tree than User . It is noteworthy that, while the getClass method is declared as public final native Class? getClass The actual static type returned by a call to getClass is Class? extends T where T is the static type of the object on which getClass is called. i.e. the following will compile Class? extends String cls .getClass Section 42.6 clone method The clone method is used to create and return a copy of an object. This method arguable should be avoided as it is problematic and a copy constructor or some other approach for copying should be used in favour of clone. For the method to be used all classes calling the method must implement the Cloneable interface. The Cloneable interface itself is just a tag interface used to change the behaviour of the native clone method which checks if the calling objects class implements", "Cloneable . If the caller does not implement this interface a CloneNotSupportedException will be thrown. The Object class itself does not implement this interface so a CloneNotSupportedException will be thrown if the calling object is of class Object . For a clone to be correct it should be independent of the object it is being cloned from, therefore it may be necessary to modify the object before it gets returned. This means to essentially create a deep copy by also copying any of the mutable objects that make up the internal structure of the object being cloned. If this is not implemented correctly the cloned object will not be independent and have the same references to the mutable objects as the object that it was cloned from. This would result in inconsistent behaviour as any changes to those in one would a\ufb00ect the other. class Foo implements Cloneable int w String x float y Date z public Foo clone try Foo result new Foo copy primitives by value result. w this.w immutable objects like String can be copied by reference result. x this.x The fields y and z refer to a mutable objects clone them recursively. if this.y !", "null GoalKicker.com Java Notes for Professionals 238 result. y this.y.clone if this.z ! null result. z this.z.clone Done, return the new object return result catch CloneNotSupportedException e in case any of the cloned mutable fields do not implement Cloneable throw new AssertionError e Section 42.7 Object constructor All constructors in Java must make a call to the Object constructor. This is done with the call super. This has to be the \ufb01rst line in a constructor. The reason for this is so that the object can actually be created on the heap before any additional initialization is performed. If you do not specify the call to super in a constructor the compiler will put it in for you. So all three of these examples are functionally identical with explicit call to super constructor public class MyClass public MyClass super with implicit call to super constructor public class MyClass public MyClass empty with implicit constructor public class MyClass What about Constructor-Chaining? It is possible to call other constructors as the \ufb01rst instruction of a constructor. As both the explicit call to a super constructor and the call to another constructor have to be both \ufb01rst instructions, they are mutually exclusive.", "public class MyClass GoalKicker.com Java Notes for Professionals 239 public MyClass int size doSomethingWith size public MyClass Collection ? initialValues thisinitialValues. size addInitialValues initialValues Calling new MyClassArrays.asLista, b, c will call the second constructor with the List-argument, which will in turn delegate to the \ufb01rst constructor which will delegate implicitly to super and then call addInitialValues int size with the second size of the list. This is used to reduce code duplication where multiple constructors need to do the same work. How do I call a speci\ufb01c constructor? Given the example above, one can either call new MyClass argument or new MyClass argument , 0. In other words, much like method overloading, you just call the constructor with the parameters that are necessary for your chosen constructor. What will happen in the Object class constructor? Nothing more than would happen in a sub-class that has a default empty constructor minus the call to super. The default empty constructor can be explicitly de\ufb01ned but if not the compiler will put it in for you as long as no other constructors are already de\ufb01ned. How is an Object then created from the constructor in Object? The actual creation of objects is", "down to the JVM. Every constructor in Java appears as a special method named init which is responsible for instance initializing. This init method is supplied by the compiler and because init is not a valid identi\ufb01er in Java, it cannot be used directly in the language. How does the JVM invoke this init method? The JVM will invoke the init method using the invokespecial instruction and can only be invoked on uninitialized class instances. For more information take a look at the JVM speci\ufb01cation and the Java Language Speci\ufb01cation Special Methods JVM - JVMS - 2.9 Constructors - JLS - 8.8 Section 42.8 \ufb01nalize method This is a protected and non-static method of the Object class. This method is used to perform some \ufb01nal operations GoalKicker.com Java Notes for Professionals 240or clean up operations on an object before it gets removed from the memory. According to the doc, this method gets called by the garbage collector on an object when garbage collection determines that there are no more references to the object. But there are no guarantees that finalize method would gets called if the object is still reachable or no Garbage Collectors run when the object become", "eligible. Thats why its better not rely on this method. In Java core libraries some usage examples could be found, for instance in FileInputStream .java protected void finalize throws IOException if fd ! null fd ! FileDescriptor .in if fd is shared, the references in FileDescriptor will ensure that finalizer is only called when safe to do so. All references using the fd have become unreachable. We can call close close In this case its the last chance to close the resource if that resource has not been closed before. Generally its considered bad practice to use finalize method in applications of any kind and should be avoided. Finalizers are not meant for freeing resources e.g., closing \ufb01les. The garbage collector gets called when if! the system runs low on heap space. You cant rely on it to be called when the system is running low on \ufb01le handles or, for any other reason. The intended use-case for \ufb01nalizers is for an object that is about to be reclaimed to notify some other object about its impending doom. A better mechanism now exists for that purpose---the java.lang.ref.WeakReference T class. If you think you need write a finalize method, then", "you should look into whether you can solve the same problem using WeakReference instead. If that wont solve your problem, then you may need to re-think your design on a deeper level. For further reading here is an Item about finalize method from E\ufb00ective Java book by Joshua Bloch. GoalKicker.com Java Notes for Professionals 241Chapter 43 Annotations In Java, an annotation is a form of syntactic metadata that can be added to Java source code. It provides data about a program that is not part of the program itself. Annotations have no direct e\ufb00ect on the operation of the code they annotate. Classes, methods, variables, parameters and packages are allowed to be annotated. Section 43.1 The idea behind Annotations The Java Language Speci\ufb01cation describes Annotations as follows An annotation is a marker which associates information with a program construct, but has no e\ufb00ect at run time. Annotations may appear before types or declarations. It is possible for them to appear in a place where they could apply to both a type or a declaration. What exactly an annotation applies to is governed by the meta-annotation Target . See De\ufb01ning annotation types for more information. Annotations are used for a", "multitude of purposes. Frameworks like Spring and Spring-MVC make use of annotations to de\ufb01ne where Dependencies should be injected or where requests should be routed. Other frameworks use annotations for code-generation. Lombok and JPA are prime examples, that use annotations to generate Java and SQL code. This topic aims to provide a comprehensive overview of How to de\ufb01ne your own Annotations? What Annotations does the Java Language provide? How are Annotations used in practice? Section 43.2 De\ufb01ning annotation types Annotation types are de\ufb01ned with interface . Parameters are de\ufb01ned similar to methods of a regular interface. interface MyAnnotation String param1 boolean param2 int param3 array parameter Default values interface MyAnnotation String param1 default someValue boolean param2 default true int param3 default Meta-Annotations Meta-annotations are annotations that can be applied to annotation types. Special prede\ufb01ned meta-annotation de\ufb01ne how annotation types can be used. GoalKicker.com Java Notes for Professionals 242Target The Target meta-annotation restricts the types the annotation can be applied to. TargetElementType. METHOD interface MyAnnotation this annotation can only be applied to methods Multiple values can be added using array notation, e.g. TargetElementType. FIELD, ElementType. TYPE Available Values ElementType target example usage on target element ANNOTATIONTYPE annotation typesRetention RetentionPolicy. RUNTIME", "terface MyAnnotation CONSTRUCTOR constructors MyAnnotation lic MyClass FIELD \ufb01elds, enum constants XmlAttribute vate int count LOCALVARIABLEvariable declarations inside methodsfor LoopVariable int i 0 i 100 i Unused String resultVariable PACKAGEpackage in package- info.java Deprecated kage very.old METHOD methods XmlElement lic int getCount ... PARAMETERmethodconstructor parameterspublic Rectangle NamedArgwidth double width, NamedArgheight double height ... TYPE classes, interfaces, enums XmlRootElement lic class Report Version Java SE 8 ElementType target example usage on target element TYPEPARAMETER Type parameter declarations public MyAnnotation T void fT t TYPEUSE Use of a type Object o 42ing s MyAnnotation String o Retention The Retention meta-annotation de\ufb01nes the annotation visibility during the applications compilation process or execution. By default, annotations are included in .class \ufb01les, but are not visible at runtime. To make an annotation accessible at runtime, RetentionPolicy. RUNTIME has to be set on that annotation. Retention RetentionPolicy. RUNTIME interface MyAnnotation this annotation can be accessed with reflections at runtime Available values RetentionPolicy E\ufb00ect CLASS The annotation is available in the .class \ufb01le, but not at runtime RUNTIME The annotation is available at runtime and can be accessed via re\ufb02ection SOURCEThe annotation is available at compile time, but not added to the .class \ufb01les. The annotation", "can be used e.g. by an annotation processor. Documented The Documented meta-annotation is used to mark annotations whose usage should be documented by API documentation generators like javadoc . It has no values. With Documented , all classes that use the annotation will list it on their generated documentation page. Without Documented , its not possible to see which classes use the GoalKicker.com Java Notes for Professionals 243annotation in the documentation. Inherited The Inherited meta-annotation is relevant to annotations that are applied to classes. It has no values. Marking an annotation as Inherited alters the way that annotation querying works. For a non-inherited annotation, the query only examines the class being examined. For an inherited annotation, the query will also check the super-class chain recursively until an instance of the annotation is found. Note that only the super-classes are queried any annotations attached to interfaces in the classes hierarchy will be ignored. Repeatable The Repeatable meta-annotation was added in Java 8. It indicates that multiple instances of the annotation can be attached to the annotations target. This meta-annotation has no values. Section 43.3 Runtime annotation checks via re\ufb02ection Javas Re\ufb02ection API allows the programmer to perform various checks and", "operations on class \ufb01elds, methods and annotations during runtime. However, in order for an annotation to be at all visible at runtime, the RetentionPolicy must be changed to RUNTIME , as demonstrated in the example below interface MyDefaultAnnotation Retention RetentionPolicy. RUNTIME interface MyRuntimeVisibleAnnotation public class AnnotationAtRuntimeTest MyDefaultAnnotation static class RuntimeCheck1 MyRuntimeVisibleAnnotation static class RuntimeCheck2 public static void mainString args Annotation annotationsByType RuntimeCheck1. class.getAnnotations Annotation annotationsByType2 RuntimeCheck2. class.getAnnotations System.out.printlndefault retention Arrays.toString annotationsByType System.out.printlnruntime retention Arrays.toString annotationsByType2 Section 43.4 Built-in annotations The Standard Edition of Java comes with some annotations prede\ufb01ned. You do not need to de\ufb01ne them by yourself and you can use them immediately. They allow the compiler to enable some fundamental checking of methods, GoalKicker.com Java Notes for Professionals 244classes and code. Override This annotation applies to a method and says that this method must override a superclass method or implement an abstract superclass method de\ufb01nition. If this annotation is used with any other kind of method, the compiler will throw an error. Concrete superclass public class Vehicle public void drive System.out.printlnI am driving class Car extends Vehicle Fine Override public void drive System.out.prinlnBrrrm, brrm Abstract class abstract class Animal public abstract void makeNoise class Dog extends Animal", "Fine Override public void makeNoise System.out.prinlnWoof Does not work class Logger1 public void logString logString System.out.prinlnlogString class Logger2 This will throw compile-time error. Logger2 is not a subclass of Logger1. log method is not overriding anything Override public void logString logString System.out.printlnLog 2 logString The main purpose is to catch mistyping, where you think you are overriding a method, but are actually de\ufb01ning a new one. class Vehicle GoalKicker.com Java Notes for Professionals 245 public void drive System.out.printlnI am driving class Car extends Vehicle Compiler error. dirve is not the correct method name to override. Override public void dirve System.out.prinlnBrrrm, brrm Note that the meaning of Override has changed over time In Java 5, it meant that the annotated method had to override a non-abstract method declared in the superclass chain. From Java 6 onward, it is also satis\ufb01ed if the annotated method implements an abstract method declared in the classes superclass interface hierarchy. This can occasionally cause problems when back-porting code to Java 5. Deprecated This marks the method as deprecated. There can be several reasons for this the API is \ufb02awed and is impractical to \ufb01x, usage of the API is likely to lead to errors, the", "API has been superseded by another API, the API is obsolete, the API is experimental and is subject to incompatible changes, or any combination of the above. The speci\ufb01c reason for deprecation can usually be found in the documentation of the API. The annotation will cause the compiler to emit an error if you use it. IDEs may also highlight this method somehow as deprecated class ComplexAlgorithm Deprecated public void oldSlowUnthreadSafeMethod stuff here public void quickThreadSafeMethod client code should use this instead SuppressWarnings In almost all cases, when the compiler emits a warning, the most appropriate action is to \ufb01x the cause. In some instances Generics code using untype-safe pre-generics code, for example this may not be possible and its better to suppress those warnings that you expect and cannot \ufb01x, so you can more clearly see unexpected warnings. GoalKicker.com Java Notes for Professionals 246This annotation can be applied to a whole class, method or line. It takes the category of warning as a parameter. SuppressWarnings deprecation public class RiddledWithWarnings several methods calling deprecated code here SuppressWarning finally public boolean checkData method calling return from within finally block It is better to limit the scope of the annotation as", "much as possible, to prevent unexpected warnings also being suppressed. For example, con\ufb01ning the scope of the annotation to a single-line ComplexAlgorithm algorithm new ComplexAlgorithm SuppressWarnings deprecation algoritm. slowUnthreadSafeMethod we marked this method deprecated in an example above SuppressWarnings unsafe ListInteger list getUntypeSafeList old library returns, non-generic List containing only integers The warnings supported by this annotation may vary from compiler to compiler. Only the unchecked and deprecation warnings are speci\ufb01cally mentioned in the JLS. Unrecognized warning types will be ignored. SafeVarargs Because of type erasure, void methodT... t will be converted to void methodObject t meaning that the compiler is not always able to verify that the use of varargs is type-safe. For instance private static T void generatesVarargsWarning T... lists There are instances where the use is safe, in which case you can annotate the method with the SafeVarargs annotation to suppress the warning. This obviously hides the warning if your use is unsafe too. FunctionalInterface This is an optional annotation used to mark a FunctionalInterface. It will cause the compiler to complain if it does not conform to the FunctionalInterface spec has a single abstract method FunctionalInterface public interface ITrade public boolean checkTrade t FunctionalInterface public", "interface Predicate T boolean testT t Section 43.5 Compile time processing using annotation processor This example demonstrates how to do compile time checking of an annotated element. The annotation GoalKicker.com Java Notes for Professionals 247The Setter annotation is a marker can be applied to methods. The annotation will be discarded during compilation not be available afterwards. package annotation import java.lang.annotation.ElementType import java.lang.annotation.Retention import java.lang.annotation.RetentionPolicy import java.lang.annotation.Target Retention RetentionPolicy. SOURCE TargetElementType. METHOD public interface Setter The annotation processor The SetterProcessor class is used by the compiler to process the annotations. It checks, if the methods annotated with the Setter annotation are public , non-static methods with a name starting with set and having a uppercase letter as 4th letter. If one of these conditions isnt met, a error is written to the Messager . The compiler writes this to stderr, but other tools could use this information di\ufb00erently. E.g. the NetBeans IDE allows the user specify annotation processors that are used to display error messages in the editor. package annotation.processor import annotation.Setter import java.util.Set import javax.annotation.processing.AbstractProcessor import javax.annotation.processing.Messager import javax.annotation.processing.ProcessingEnvironment import javax.annotation.processing.RoundEnvironment import javax.annotation.processing.SupportedAnnotationTypes import javax.annotation.processing.SupportedSourceVersion import javax.lang.model.SourceVersion import javax.lang.model.element.Element import javax.lang.model.element.ElementKind import javax.lang.model.element.ExecutableElement import javax.lang.model.element.Modifier import javax.lang.model.element.TypeElement import javax.tools.Diagnostic", "SupportedAnnotationTypes annotation.Setter SupportedSourceVersion SourceVersion. RELEASE8 public class SetterProcessor extends AbstractProcessor private Messager messager Override public boolean process Set? extends TypeElement annotations, RoundEnvironment roundEnv get elements annotated with the Setter annotation Set ? extends Element annotatedElements roundEnv. getElementsAnnotatedWith Setter.class for Element element annotatedElements if element. getKind ElementKind. METHOD only handle methods as targets checkMethod ExecutableElement element dont claim annotations to allow other processors to process them return false GoalKicker.com Java Notes for Professionals 248 private void checkMethod ExecutableElement method check for valid name String name method. getSimpleName .toString if !name.startsWith set printError method, setter name must start with set else if name.length 3 printError method, the method name must contain more than just set else if Character .isLowerCase name.charAt3 if method.getParameters .size ! 1 printError method, character following set must be upper case check, if setter is public if !method.getModifiers .contains Modifier .PUBLIC printError method, setter must be public check, if method is static if method.getModifiers .contains Modifier .STATIC printError method, setter must not be static private void printError Element element, String message messager. printMessage Diagnostic. Kind.ERROR, message, element Override public void initProcessingEnvironment processingEnvironment super.initprocessingEnvironment get messager for printing errors messager processingEnvironment. getMessager Packaging To be applied by the compiler,", "the annotation processor needs to be made available to the SPI see ServiceLoader. To do this a text \ufb01le META-INFservices javax.annotation .processing .Processor needs to be added to the jar \ufb01le containing the annotation processor and the annotation in addition to the other \ufb01les. The \ufb01le needs to include the fully quali\ufb01ed name of the annotation processor, i.e. it should look like this annotation. processor .SetterProcessor Well assume the jar \ufb01le is called AnnotationProcessor. jar below. Example annotated class The following class is example class in the default package with the annotations being applied to the correct elements according to the retention policy. However only the annotation processor only considers the second method a valid annotation target. import annotation.Setter GoalKicker.com Java Notes for Professionals 249public class AnnotationProcessorTest Setter private void setValue String value Setter public void setString String value Setter public static void mainString args Using the annotation processor with javac If the annotation processor is discovered using the SPI, it is automatically used to process annotated elements. E.g. compiling the AnnotationProcessorTest class using javac -cp AnnotationProcessor. jar AnnotationProcessorTest. java yields the following output AnnotationProcessorTest.java6 error setter must be public private void setValueString value AnnotationProcessorTest.java12 error setter name must", "start with set public static void mainString args 2 errors instead of compiling normally. No .class \ufb01le is created. This could be prevented by specifying the -procnone option for javac . You could also forgo the usual compilation by specifying -proconly instead. IDE integration Netbeans Annotation processors can be used in the NetBeans editor. To do this the annotation processor needs to be speci\ufb01ed in the project settings go to Project Properties Build Compiling 1. add check marks for Enable Annotation Processing and Enable Annotation Processing in Editor 2. click Add next to the annotation processor list 3. in the popup that appears enter the fully quali\ufb01ed class name of the annotation processor and click Ok. 4. Result GoalKicker.com Java Notes for Professionals 250 Section 43.6 Repeating Annotations Until Java 8, two instances of the same annotation could not be applied to a single element. The standard workaround was to use a container annotation holding an array of some other annotation Author.java Retention RetentionPolicy. RUNTIME public interface Author String value Authors.java Retention RetentionPolicy. RUNTIME public interface Authors Author value Test.java Authors Author Mary, Author Sam public class Test public static void mainString args Author authors Test.class.getAnnotation Authors. class.value for", "Author author authors System.out.printlnauthor.value Output Mary Sam Version Java SE 8 Java 8 provides a cleaner, more transparent way of using container annotations, using the Repeatable annotation. First we add this to the Author class Repeatable Authors. class This tells Java to treat multiple Author annotations as though they were surrounded by the Authors container. We can also use Class.getAnnotationsByType to access the Author array by its own class, instead of through its GoalKicker.com Java Notes for Professionals 251container AuthorMary AuthorSam public class Test public static void mainString args Author authors Test.class.getAnnotationsByType Author.class for Author author authors System.out.printlnauthor.value Output Mary Sam Section 43.7 Inherited Annotations By default class annotations do not apply to types extending them. This can be changed by adding the Inherited annotation to the annotation de\ufb01nition Example Consider the following 2 Annotations Inherited TargetElementType. TYPE Retention RetentionPolicy. RUNTIME public interface InheritedAnnotationType and TargetElementType. TYPE Retention RetentionPolicy. RUNTIME public interface UninheritedAnnotationType If three classes are annotated like this UninheritedAnnotationType class A InheritedAnnotationType class B extends A class C extends B running this code System.out.printlnnew A.getClass .getAnnotation InheritedAnnotationType. class System.out.printlnnew B.getClass .getAnnotation InheritedAnnotationType. class System.out.printlnnew C.getClass .getAnnotation InheritedAnnotationType. class System.out.println System.out.printlnnew A.getClass .getAnnotation UninheritedAnnotationType. class GoalKicker.com Java Notes", "for Professionals 252System.out.printlnnew B.getClass .getAnnotation UninheritedAnnotationType. class System.out.printlnnew C.getClass .getAnnotation UninheritedAnnotationType. class will print a result similar to this depending on the packages of the annotation null InheritedAnnotationType InheritedAnnotationType UninheritedAnnotationType null null Note that annotations can only be inherited from classes, not interfaces. Section 43.8 Getting Annotation values at run-time You can fetch the current properties of the Annotation by using Re\ufb02ection to fetch the Method or Field or Class which has an Annotation applied to it, and then fetching the desired properties. Retention RetentionPolicy. RUNTIME interface MyAnnotation String key default foo String value default bar class AnnotationExample Put the Annotation on the method, but leave the defaults MyAnnotation public void testDefaults throws Exception Using reflection, get the public method testDefaults, which is this method with no args Method method AnnotationExample. class.getMethod testDefaults , null Fetch the Annotation that is of type MyAnnotation from the Method MyAnnotation annotation MyAnnotation method.getAnnotation MyAnnotation. class Print out the settings of the Annotation print annotation Put the Annotation on the method, but override the settings MyAnnotation keybaz, valuebuzz public void testValues throws Exception Using reflection, get the public method testValues, which is this method with no args Method method AnnotationExample. class.getMethod testValues ,", "null Fetch the Annotation that is of type MyAnnotation from the Method MyAnnotation annotation MyAnnotation method.getAnnotation MyAnnotation. class Print out the settings of the Annotation print annotation public void printMyAnnotation annotation Fetch the MyAnnotation key value properties, and print them out System.out.printlnannotation. key annotation. value public static void mainString args GoalKicker.com Java Notes for Professionals 253 AnnotationExample example new AnnotationExample try example. testDefaults example. testValues catch Exception e Shouldnt throw any Exceptions System.err.printlnException e.getClass .getName - e.getMessage e. printStackTrace System.err The output will be foo bar baz buzz Section 43.9 Annotations for this and receiver parameters When Java annotations were \ufb01rst introduced there was no provision for annotating the target of an instance method or the hidden constructor parameter for an inner classes constructor. This was remedied in Java 8 with addition of receiver parameter declarations see JLS 8.4.1 . The receiver parameter is an optional syntactic device for an instance method or an inner classs constructor. For an instance method, the receiver parameter represents the object for which the method is invoked. For an inner classs constructor, the receiver parameter represents the immediately enclosing instance of the newly constructed object. Either way, the receiver parameter exists solely to", "allow the type of the represented object to be denoted in source code, so that the type may be annotated. The receiver parameter is not a formal parameter more precisely, it is not a declaration of any kind of variable 4.12.3, it is never bound to any value passed as an argument in a method invocation expression or quali\ufb01ed class instance creation expression, and it has no e\ufb00ect whatsoever at run time. The following example illustrates the syntax for both kinds of receiver parameter public class Outer public class Inner public Inner Outer this ... public void doItInner this ... The sole purpose of receiver parameters is to allow you to add annotations. For example, you might have a custom annotation IsOpen whose purpose is to assert that a Closeable object has not been closed when a method is called. For example public class MyResource extends Closeable public void updateIsOpen MyResource this, int value ... GoalKicker.com Java Notes for Professionals 254 public void close ... At one level, the IsOpen annotation on this could simply serve as documentation. However, we could potentially do more. For example An annotation processor could insert a runtime check that this is not in", "closed state when update is called. A code checker could perform a static code analysis to \ufb01nd cases where this could be closed when update is called. Section 43.10 Add multiple annotation values An Annotation parameter can accept multiple values if it is de\ufb01ned as an array. For example the standard annotation SuppressWarnings is de\ufb01ned like this public interface SuppressWarnings String value The value parameter is an array of Strings. You can set multiple values by using a notation similar to Array initializers SuppressWarnings unused SuppressWarnings unused , javadoc If you only need to set a single value, the brackets can be omitted SuppressWarnings unused GoalKicker.com Java Notes for Professionals 255Chapter 44 Immutable Class Immutable objects are instances whose state doesn t change after it has been initialized. For example, String is an immutable class and once instantiated its value never changes. Section 44.1 Example without mutable refs public final class Color final private int red final private int green final private int blue private void checkint red, int green, int blue if red 0 red 255 green 0 green 255 blue 0 blue 255 throw new IllegalArgumentException public Colorint red, int green, int blue check red, green, blue", "this.red red this.green green this.blue blue public Color invert return new Color255 - red, 255 - green, 255 - blue Section 44.2 What is the advantage of immutability? The advantage of immutability comes with concurrency. It is di\ufb03cult to maintain correctness in mutable objects, as multiple threads could be trying to change the state of the same object, leading to some threads seeing a di\ufb00erent state of the same object, depending on the timing of the reads and writes to the said object. By having an immutable object, one can ensure that all threads that are looking at the object will be seeing the same state, as the state of an immutable object will not change. Section 44.3 Rules to de\ufb01ne immutable classes The following rules de\ufb01ne a simple strategy for creating immutable objects. Dont provide setter methods - methods that modify \ufb01elds or objects referred to by \ufb01elds.1. Make all \ufb01elds \ufb01nal and private.2. Dont allow subclasses to override methods. The simplest way to do this is to declare the class as \ufb01nal. A3. more sophisticated approach is to make the constructor private and construct instances in factory methods. If the instance \ufb01elds include references to mutable objects,", "dont allow those objects to be changed4. Dont provide methods that modify the mutable objects.5. Dont share references to the mutable objects. Never store references to external, mutable objects passed to6. the constructor if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods. GoalKicker.com Java Notes for Professionals 256Section 44.4 Example with mutable refs In this case class Point is mutable and some user can modify state of object of this class. class Point private int x, y public Pointint x, int y this.x x this.y y public int getX return x public void setXint x this.x x public int getY return y public void setYint y this.y y ... public final class ImmutableCircle private final Point center private final double radius public ImmutableCircle Point center, double radius we create new object here because it shouldnt be changed this.center new Pointcenter.getX, center. getY this.radius radius GoalKicker.com Java Notes for Professionals 257Chapter 45 Immutable Objects Section 45.1 Creating an immutable version of a type using defensive copying Some basic types and classes in Java are fundamentally mutable. For example, all array types", "are mutable, and so are classes like java.util.Data . This can be awkward in situations where an immutable type is mandated. One way to deal with this is to create an immutable wrapper for the mutable type. Here is a simple wrapper for an array of integers public class ImmutableIntArray private final int array public ImmutableIntArray int array this.array array.clone public int getValue return this.clone This class works by using defensive copying to isolate the mutable state the int from any code that might mutate it The constructor uses clone to create a distinct copy of the parameter array. If the caller of the constructor subsequent changed the parameter array, it would not a\ufb00ect the state of the ImmutableIntArray . The getValue method also uses clone to create the array that is returned. If the caller were to change the result array, it would not a\ufb00ect the state of the ImmutableIntArray . We could also add methods to ImmutableIntArray to perform read-only operations on the wrapped array e.g. get its length, get the value at a particular index, and so on. Note that an immutable wrapper type implemented this way is not type compatible with the original type. You", "cannot simply substitute the former for the latter. Section 45.2 The recipe for an immutable class An immutable object is an object whose state cannot be changed. An immutable class is a class whose instances are immutable by design, and implementation. The Java class which is most commonly presented as an example of immutability is java.lang.String . The following is a stereotypical example public final class Person private final String name private final String ssn SSN social security number public PersonString name, String ssn this.name name this.ssn ssn GoalKicker.com Java Notes for Professionals 258 public String getName return name public String getSSN return ssn A variation on this is to declare the constructor as private and provide a public static factory method instead. The standard recipe for an immutable class is as follows All properties must be set in the constructors or factory methods. There should be no setters. If it is necessary to include setters for interface compatibility reasons, they should either do nothing or throw an exception. All properties should be declared as private and final . For all properties that are references to mutable types the property should be initialized with a deep copy of the", "value passed via the constructor, and the propertys getter should return a deep copy of the property value. The class should be declared as final to prevent someone creating a mutable subclass of an immutable class. A couple of other things to note Immutability does not prevent object from being nullable e.g. null can be assigned to a String variable. If an immutable classes properties are declared as final , instances are inherently thread-safe. This makes immutable classes a good building block for implementing multi-threaded applications. Section 45.3 Typical design \ufb02aws which prevent a class from being immutable Using some setters, without setting all needed properties in the constructors public final class Person example of a bad immutability private final String name private final String surname public PersonString name this.name name public String getName return name public String getSurname return surname public void setSurname String surname this.surname surname Its easy to show that Person class is not immutable Person person new PersonJoe person.setSurname Average NOT OK, change surname field after creation To \ufb01x it, simply delete setSurname and refactor the constructor as follows public PersonString name, String surname this.name name this.surname surname GoalKicker.com Java Notes for Professionals 259 Not", "marking instance variables as private and \ufb01nal Take a look at the following class public final class Person public String name public PersonString name this.name name public String getName return name The following snippet shows that the above class is not immutable Person person new PersonAverage Joe person.name Magic Mike not OK, new name for person after creation To \ufb01x it, simply mark name property as private and final . Exposing a mutable object of the class in a getter Take a look at the following class import java.util.List import java.util.ArrayList public final class Names private final ListString names public NamesListString names this.names new ArrayList Stringnames public ListString getNames return names public int size return names.size Names class seems immutable at the \ufb01rst sight, but it is not as the following code shows ListString namesList new ArrayList String namesList. addAverage Joe Names names new NamesnamesList System.out.printlnnames.size 1, only containing Average Joe namesList names.getNames namesList. addMagic Mike System.out.printlnnames.size 2, NOT OK, now names also contains Magic Mike This happened because a change to the reference List returned by getNames can modify the actual list of Names . To \ufb01x this, simply avoid returning references that reference classs mutable objects either", "by making defensive copies, as follows GoalKicker.com Java Notes for Professionals 260public ListString getNames return new ArrayList Stringthis.names copies elements or by designing getters in way that only other immutable objects and primitives are returned, as follows public String getName int index return names.getindex public int size return names.size Injecting constructor with objects that can be modi\ufb01ed outside the immutable class This is a variation of the previous \ufb02aw. Take a look at the following class import java.util.List public final class NewNames private final ListString names public NamesListString names this.names names public String getName int index return names.getindex public int size return names.size As Names class before, also NewNames class seems immutable at the \ufb01rst sight, but it is not, in fact the following snippet proves the contrary ListString namesList new ArrayList String namesList. addAverage Joe NewNames names new NewNames namesList System.out.printlnnames.size 1, only containing Average Joe namesList. addMagic Mike System.out.printlnnames.size 2, NOT OK, now names also contains Magic Mike To \ufb01x this, as in the previous \ufb02aw, simply make defensive copies of the object without assigning it directly to the immutable class, i.e. constructor can be changed as follows public NamesListString names this.names new ArrayList Stringnames Letting the", "methods of the class being overridden Take a look at the following class public class Person private final String name public PersonString name this.name name public String getName return name GoalKicker.com Java Notes for Professionals 261 Person class seems immutable at the \ufb01rst sight, but suppose a new subclass of Person is de\ufb01ned public class MutablePerson extends Person private String newName public MutablePerson String name supername Override public String getName return newName public void setName String name newName name now Person immutability can be exploited through polymorphism by using the new subclass Person person new MutablePerson Average Joe System.out.printlnperson.getName prints Average Joe person.setNameMagic Mike NOT OK, person has now a new name! System.out.printlnperson.getName prints Magic Mike To \ufb01x this, either mark the class as final so it cannot be extended or declare all of its constructors as private . GoalKicker.com Java Notes for Professionals 262Chapter 46 Visibility controlling access to members of a class Section 46.1 Private Visibility private visibility allows a variable to only be accessed by its class. They are often used in conjunction with public getters and setters. class SomeClass private int variable public int getVariable return variable public void setVariable int variable this.variable variable public", "class SomeOtherClass public static void mainString args SomeClass sc new SomeClass These statement wont compile because SomeClassvariable is private sc. variable 7 System.out.printlnsc.variable Instead, you should use the public getter and setter sc. setVariable 7 System.out.printlnsc.getVariable Section 46.2 Public Visibility Visible to the class, package, and subclass. Lets see an example with the class Test. public class Test public int number 2 public Test Now lets try to create an instance of the class. In this example, we can access number because it is public . public class Other public static void mainString args Test t new Test System.out.printlnt.number GoalKicker.com Java Notes for Professionals 263 Section 46.3 Package Visibility With no modi\ufb01er , the default is package visibility. From the Java Documentation, package visibility indicates whether classes in the same package as the class regardless of their parentage have access to the member. In this example from javax.swing , package javax.swing public abstract class JComponent extends Container static boolean DEBUGGRAPHICSLOADED DebugGraphics is in the same package, so DEBUGGRAPHICSLOADED is accessible. package javax.swing public class DebugGraphics extends Graphics static JComponent .DEBUGGRAPHICSLOADED true This article gives some background on the topic. Section 46.4 Protected Visibility Protected visibility causes means that this", "member is visible to its package, along with any of its subclasses. As an example package com.stackexchange.docs public class MyClass protected int variable This is the variable that we are trying to access public MyClass variable 2 Now well extend this class and try to access one of its protected members. package some.other.pack import com.stackexchange.docs.MyClass public class SubClass extends MyClass public SubClass super System.out.printlnsuper.variable You would be also able to access a protected member without extending it if you are accessing it from the same package. GoalKicker.com Java Notes for Professionals 264Note that this modi\ufb01er only works on members of a class, not on the class itself. Section 46.5 Summary of Class Member Access Modi\ufb01ers Access Modi\ufb01er Visibility Inheritance Private Class only Cant be inherited No modi\ufb01er Package In package Available if subclass in package Protected In package Available in subclass Public Everywhere Available in subclass There was once a private protected both keywords at once modi\ufb01er that could be applied to methods or variables to make them accessible from a subclass outside the package, but make them private to the classes in that package. However, this was removed in Java 1.0s release . Section 46.6 Interface members public", "interface MyInterface public void foo int bar public String TEXT Hello int ANSWER 42 public class X class Y Interface members always have public visibility, even if the public keyword is omitted. So both foo, bar, TEXT , ANSWER , X, and Y have public visibility. However, access may still be limited by the containing interface - since MyInterface has public visibility, its members may be accessed from anywhere, but if MyInterface had had package visibility, its members would only have been accessible from within the same package. GoalKicker.com Java Notes for Professionals 265Chapter 47 Generics Generics are a facility of generic programming that extend Javas type system to allow a type or method to operate on objects of various types while providing compile-time type safety. In particular, the Java collections framework supports generics to specify the type of objects stored in a collection instance. Section 47.1 Creating a Generic Class Generics enable classes, interfaces, and methods to take other classes and interfaces as type parameters. This example uses generic class Param to take a single type parameter T, delimited by angle brackets public class ParamT private T value public T getValue return value public void setValue T value", "this.value value To instantiate this class, provide a type argument in place of T. For example, Integer ParamInteger integerParam new ParamInteger The type argument can be any reference type, including arrays and other generic types ParamString stringArrayParam Paramint int2dArrayParam ParamParamObject objectNestedParam In Java SE 7 and later, the type argument can be replaced with an empty set of type arguments called the diamond Version Java SE 7 ParamInteger integerParam new Param Unlike other identi\ufb01ers, type parameters have no naming constraints. However their names are commonly the \ufb01rst letter of their purpose in upper case. This is true even throughout the o\ufb03cial JavaDocs. Examples include T for type , E for element and KV for keyvalue . Extending a generic class public abstract class AbstractParam T private T value public T getValue return value public void setValue T value this.value value GoalKicker.com Java Notes for Professionals 266 AbstractParam is an abstract class declared with a type parameter of T. When extending this class, that type parameter can be replaced by a type argument written inside , or the type parameter can remain unchanged. In the \ufb01rst and second examples below, String and Integer replace the type parameter. In the third", "example, the type parameter remains unchanged. The fourth example doesnt use generics at all, so its similar to if the class had an Object parameter. The compiler will warn about AbstractParam being a raw type, but it will compile the ObjectParam class. The \ufb01fth example has 2 type parameters see multiple type parameters below, choosing the second parameter as the type parameter passed to the superclass. public class Email extends AbstractParam String ... public class Age extends AbstractParam Integer ... public class HeightT extends AbstractParam T ... public class ObjectParam extends AbstractParam ... public class MultiParam T, E extends AbstractParam E ... The following is the usage Email email new Email email.setValue testexample.com String retrievedEmail email.getValue Age age new Age age.setValue 25 Integer retrievedAge age.getValue int autounboxedAge age.getValue HeightInteger heightInInt new Height heightInInt. setValue 125 HeightFloat heightInFloat new Height heightInFloat. setValue 120.3f MultiParam String, Double multiParam new MultiParam multiParam. setValue 3.3 Notice that in the Email class, the T getValue method acts as if it had a signature of String getValue , and the void setValue T method acts as if it was declared void setValue String. It is also possible to instantiate with anonymous inner class with an", "empty curly braces AbstractParam Double height new AbstractParam Double height.setValue 198.6 GoalKicker.com Java Notes for Professionals 267Note that using the diamond with anonymous inner classes is not allowed. Multiple type parameters Java provides the ability to use more than one type parameter in a generic class or interface. Multiple type parameters can be used in a class or interface by placing a comma-separated list of types between the angle brackets. Example public class MultiGenericParam T, S private T firstParam private S secondParam public MultiGenericParam T firstParam, S secondParam this.firstParam firstParam this.secondParam secondParam public T getFirstParam return firstParam public void setFirstParam T firstParam this.firstParam firstParam public S getSecondParam return secondParam public void setSecondParam S secondParam this.secondParam secondParam The usage can be done as below MultiGenericParam String, String aParam new MultiGenericParam String, String value1 , value2 MultiGenericParam Integer, Double dayOfWeekDegrees new MultiGenericParam Integer, Double 1, 2.6 Section 47.2 Deciding between T, ? super T, and ? extends T The syntax for Java generics bounded wildcards, representing the unknown type by ? is ? extends T represents an upper bounded wildcard. The unknown type represents a type that must be a subtype of T, or type T itself. ? super T represents", "a lower bounded wildcard. The unknown type represents a type that must be a supertype of T, or type T itself. As a rule of thumb, you should use ? extends T if you only need read access input ? super T if you need write access output GoalKicker.com Java Notes for Professionals 268T if you need both modify Using extends or super is usually better because it makes your code more \ufb02exible as in allowing the use of subtypes and supertypes, as you will see below. class Shoe class IPhone interface Fruit class Apple implements Fruit class Banana implements Fruit class GrannySmith extends Apple public class FruitHelper public void eatAllCollection ? extends Fruit fruits public void addApple Collection ? super Apple apples The compiler will now be able to detect certain bad usage public class GenericsTest public static void mainString args FruitHelper fruitHelper new FruitHelper List Fruit fruits new ArrayList Fruit fruits. addnew Apple Allowed, as Apple is a Fruit fruits. addnew Banana Allowed, as Banana is a Fruit fruitHelper. addApple fruits Allowed, as Fruit super Apple fruitHelper. eatAllfruits Allowed Collection Banana bananas new ArrayList bananas. addnew Banana Allowed fruitHelper.addApplebananas Compile error may only contain Bananas! fruitHelper. eatAllbananas", "Allowed, as all Bananas are Fruits Collection Apple apples new ArrayList fruitHelper. addApple apples Allowed apples. addnew GrannySmith Allowed, as this is an Apple fruitHelper. eatAllapples Allowed, as all Apples are Fruits. Collection GrannySmith grannySmithApples new ArrayList fruitHelper. addApple grannySmithApples Compile error Not allowed. GrannySmith is not a supertype of Apple apples. addnew GrannySmith Still allowed, GrannySmith is an Apple fruitHelper. eatAllgrannySmithApples Still allowed, GrannySmith is a Fruit Collection Object objects new ArrayList fruitHelper. addApple objects Allowed, as Object super Apple objects. addnew Shoe Not a fruit objects. addnew IPhone Not a fruit fruitHelper.eatAllobjects Compile error may contain a Shoe, too! Choosing the right T, ? super T or ? extends T is necessary to allow the use with subtypes. The compiler can then ensure type safety you should not need to cast which is not type safe, and may cause programming errors if you use them properly. If it is not easy to understand, please remember PECS rule GoalKicker.com Java Notes for Professionals 269Producer uses Extends and Consumer uses Super. Producer has only write access, and Consumer has only read access Section 47.3 The Diamond Version Java SE 7 Java 7 introduced the Diamond 1 to remove some", "boiler-plate around generic class instantiation. With Java 7 you can write ListString list new LinkedList Where you had to write in previous versions, this ListString list new LinkedList String One limitation is for Anonymous Classes, where you still must provide the type parameter in the instantiation This will compile Comparator String caseInsensitiveComparator new Comparator String Override public int compare String s1, String s2 return s1.compareToIgnoreCase s2 But this will not Comparator String caseInsensitiveComparator new Comparator Override public int compare String s1, String s2 return s1.compareToIgnoreCase s2 Version Java SE 8 Although using the diamond with Anonymous Inner Classes is not supported in Java 7 and 8, it will be included as a new feature in Java 9 . Footnote 1 - Some people call the usage the diamond operator . This is incorrect. The diamond does not behave as an operator, and is not described or listed anywhere in the JLS or the o\ufb03cial Java Tutorials as an operator. Indeed, is not even a distinct Java token. Rather it is a token followed by a token, and it is legal though bad style to have whitespace or comments between the two. The JLS and the Tutorials consistently refer to", "as the diamond, and that is therefore the correct term for it. Section 47.4 Declaring a Generic Method Methods can also have generic type parameters. public class Example GoalKicker.com Java Notes for Professionals 270 The type parameter T is scoped to the method and is independent of type parameters of other methods. public T ListT makeList T t1, T t2 List T result new ArrayList T result. addt1 result. addt2 return result public void usage List String listString makeList Jeff, Atwood List Integer listInteger makeList 1, 2 Notice that we dont have to pass an actual type argument to a generic method. The compiler infers the type argument for us, based on the target type e.g. the variable we assign the result to, or on the types of the actual arguments. It will generally infer the most speci\ufb01c type argument that will make the call type-correct. Sometimes, albeit rarely, it can be necessary to override this type inference with explicit type arguments void usage consumeObjects this.ObjectmakeList Jeff, Atwood .stream void consumeObjects StreamObject stream ... Its necessary in this example because the compiler cant look ahead to see that Object is desired for T after calling stream and it would", "otherwise infer String based on the makeList arguments. Note that the Java language doesnt support omitting the class or object on which the method is called this in the above example when type arguments are explicitly provided. Section 47.5 Requiring multiple upper bounds extends A B You can require a generic type to extend multiple upper bounds. Example we want to sort a list of numbers but Number doesnt implement Comparable . public T extends Number Comparable T void sortNumbers ListT n Collections .sort n In this example T must extend Number and implement Comparable T which should \ufb01t all normal built-in number implementations like Integer or BigDecimal but doesnt \ufb01t the more exotic ones like Striped64 . Since multiple inheritance is not allowed, you can use at most one class as a bound and it must be the \ufb01rst listed. For example, T extends Comparable T Number is not allowed because Comparable is an interface, and not a class. Section 47.6 Obtain class that satis\ufb01es generic parameter at runtime Many unbound generic parameters, like those used in a static method, cannot be recovered at runtime see Other Threads on Erasure . However there is a common strategy employed", "for accessing the type satisfying a generic parameter on a class at runtime. This allows for generic code that depends on access to type without having to GoalKicker.com Java Notes for Professionals 271thread type information through every call. Background Generic parameterization on a class can be inspected by creating an anonymous inner class. This class will capture the type information. In general this mechanism is referred to as super type tokens , which are detailed in Neal Gafters blog post . Implementations Three common implementations in Java are Guavas TypeToken Springs ParameterizedTypeReference Jacksons TypeReference Example usage public class DataService MODELTYPE private final DataDao dataDao new DataDao private final ClassMODELTYPE type ClassMODELTYPE new TypeToken MODELTYPE getClass .getRawType public ListMODELTYPE getAll return dataDao. getAllOfType type the subclass definitively binds the parameterization to User for all instances of this class, so that information can be recovered at runtime public class UserService extends DataService User public class Main public static void mainString args UserService service new UserService List User users service. getAll Section 47.7 Bene\ufb01ts of Generic class and interface Code that uses generics has many bene\ufb01ts over non-generic code. Below are the main bene\ufb01ts Stronger type checks at compile time A Java", "compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than \ufb01xing runtime errors, which can be di\ufb03cult to \ufb01nd. Elimination of casts The following code snippet without generics requires casting List list new ArrayList list.addhello String s String list.get0 GoalKicker.com Java Notes for Professionals 272When re-written to use generics , the code does not require casting ListString list new ArrayList list.addhello String s list.get0 no cast Enabling programmers to implement generic algorithms By using generics, programmers can implement generic algorithms that work on collections of di\ufb00erent types, can be customized, and are type safe and easier to read. Section 47.8 Instantiating a generic type Due to type erasure the following will not work public T void genericMethod T t new T Can not instantiate the type T. The type T is erased. Since, at runtime, the JVM does not know what T originally was, it does not know which constructor to call. Workarounds Passing Ts class when calling genericMethod 1. public T void genericMethod ClassT cls try T t cls.newInstance catch InstantiationException IllegalAccessException e System.err.printlnCould not instantiate cls.getName genericMethod String.class Which throws exceptions, since there is", "no way to know if the passed class has an accessible default constructor. Version Java SE 8 Passing a reference to Ts constructor 2. public T void genericMethod Supplier T cons T t cons.get genericMethod Stringnew Section 47.9 Creating a Bounded Generic Class You can restrict the valid types used in a generic class by bounding that type in the class de\ufb01nition. Given the following simple type hierarchy GoalKicker.com Java Notes for Professionals 273public abstract class Animal public abstract String getSound public class Cat extends Animal public String getSound return Meow public class Dog extends Animal public String getSound return Woof Without bounded generics , we cannot make a container class that is both generic and knows that each element is an animal public class AnimalContainer T private Collection T col public AnimalContainer col new ArrayList T public void addT t col. addt public void printAllSounds for T t col Illegal, type T doesnt have makeSound it is used as an java.lang.Object here System.out.printlnt.makeSound With generic bound in class de\ufb01nition, this is now possible. public class BoundedAnimalContainer T extends Animal Note bound here. private Collection T col public BoundedAnimalContainer col new ArrayList T public void addT t col. addt", "public void printAllSounds for T t col Now works because T is extending Animal System.out.printlnt.makeSound GoalKicker.com Java Notes for Professionals 274 This also restricts the valid instantiations of the generic type Legal AnimalContainer Cat a new AnimalContainer Cat Legal AnimalContainer String a new AnimalContainer String Legal because Cat extends Animal BoundedAnimalContainer Cat b new BoundedAnimalContainer Cat Illegal because String doesnt extends Animal BoundedAnimalContainer String b new BoundedAnimalContainer String Section 47.10 Referring to the declared generic type within its own declaration How do you go about using an instance of a possibly further inherited generic type within a method declaration in the generic type itself being declared? This is one of the problems you will face when you dig a bit deeper into generics, but still a fairly common one. Assume we have a DataSeries T type interface here, which de\ufb01nes a generic data series containing values of type T. It is cumbersome to work with this type directly when we want to perform a lot of operations with e.g. double values, so we de\ufb01ne DoubleSeries extends DataSeries Double. Now assume, the original DataSeries T type has a method addvalues which adds another series of the same length and returns", "a new one. How do we enforce the type of values and the type of the return to be DoubleSeries rather than DataSeries Double in our derived class? The problem can be solved by adding a generic type parameter referring back to and extending the type being declared applied to an interface here, but the same stands for classes public interface DataSeries T, DS extends DataSeries T, DS DS add DS values List T data Here T represents the data type the series holds, e.g. Double and DS the series itself. An inherited type or types can now be easily implemented by substituting the above mentioned parameter by a corresponding derived type, thus, yielding a concrete Double -based de\ufb01nition of the form public interface DoubleSeries extends DataSeries Double, DoubleSeries static DoubleSeries instance Collection Double data return new DoubleSeriesImpl data At this moment even an IDE will implement the above interface with correct types in place, which, after a bit of content \ufb01lling may look like this class DoubleSeriesImpl implements DoubleSeries private final ListDouble data DoubleSeriesImpl Collection Double data this.data new ArrayList data GoalKicker.com Java Notes for Professionals 275 Override public DoubleSeries add DoubleSeries values List Double incoming values !", "null ? values. data null if incoming null incoming. size ! data.size throw new IllegalArgumentException bad series List Double newdata new ArrayList data.size for int i 0 i data.size i newdata. addthis.data.geti incoming. geti beware autoboxing return DoubleSeries. instance newdata Override public ListDouble data return Collections .unmodifiableList data As you can see the add method is declared as DoubleSeries add DoubleSeries values and the compiler is happy. The pattern can be further nested if required. Section 47.11 Binding generic parameter to more than 1 type Generic parameters can also be bound to more than one type using the T extends Type1 Type2 ... syntax. Lets say you want to create a class whose Generic type should implement both Flushable and Closeable , you can write class ExampleClass T extends Flushable Closeable Now, the ExampleClass only accepts as generic parameters, types which implement both Flushable and Closeable . ExampleClass BufferedWriter arg1 Works because BufferedWriter implements both Flushable and Closeable ExampleClass Console arg4 Does NOT work because Console only implements Flushable ExampleClass ZipFile arg5 Does NOT work because ZipFile only implements Closeable ExampleClass Flushable arg2 Does NOT work because Closeable bound is not satisfied. ExampleClass Closeable arg3 Does NOT work because", "Flushable bound is not satisfied. The class methods can choose to infer generic type arguments as either Closeable or Flushable . class ExampleClass T extends Flushable Closeable Assign it to a valid type as you want. public void test T param Flushable arg1 param Works Closeable arg2 param Works too. You can even invoke the methods of any valid type directly. GoalKicker.com Java Notes for Professionals 276 public void test2 T param param. flush Method of Flushable called on T and works fine. param. close Method of Closeable called on T and works fine too. Note You cannot bind the generic parameter to either of the type using OR clause. Only the AND clause is supported. Generic type can extends only one class and many interfaces. Class must be placed at the beginning of the list. Section 47.12 Using Generics to auto-cast With generics, its possible to return whatever the caller expects private MapString, Object data public T T getString key return T data.getkey The method will compile with a warning. The code is actually more safe than it looks because the Java runtime will do a cast when you use it Bar bar foo.getbar Its less safe when", "you use generic types ListBar bars foo.getbars Here, the cast will work when the returned type is any kind of List i.e. returning ListString would not trigger a ClassCastException youd eventually get it when taking elements out of the list. To work around this problem, you can create an API which uses typed keys public final static KeyListBar BARS new KeyBARS along with this put method public T T putKeyT key, T value With this approach, you cant put the wrong type into the map, so the result will always be correct unless you accidentally create two keys with the same name but di\ufb00erent types. Related Type-safe Map Section 47.13 Use of instanceof with Generics Using generics to de\ufb01ne the type in instanceof Consider the following generic class Example declared with the formal parameter T class Example T GoalKicker.com Java Notes for Professionals 277 public boolean isTypeAString String s return s instanceof T Compilation error, cannot use T as class type here This will always give a Compilation error because as soon as the compiler compiles the Java source into Java bytecode it applies a process known as type erasure , which converts all generic code into non-generic code,", "making impossible to distinguish among T types at runtime. The type used with instanceof has to be rei\ufb01able , which means that all information about the type has to be available at runtime, and this is usually not the case for generic types. The following class represents what two di\ufb00erent classes of Example , ExampleString and ExampleNumber, look like after generics has stripped o\ufb00 by type erasure class Example formal parameter is gone public boolean isTypeAString String s return s instanceof Object Both String and Number are now Object Since types are gone, its not possible for the JVM to know which type is T. Exception to the previous rule You can always use unbounded wildcard ? for specifying a type in the instanceof as follows public boolean isAList Object obj return obj instanceof List? This can be useful to evaluate whether an instance obj is a List or not System.out.printlnisAListfoo prints false System.out.printlnisAListnew ArrayList String prints true System.out.printlnisAListnew ArrayList Float prints true In fact, unbounded wildcard is considered a rei\ufb01able type. Using a generic instance with instanceof The other side of the coin is that using an instance t of T with instanceof is legal, as shown in", "the following example class Example T public boolean isTypeAString T t return t instanceof String No compilation error this time because after the type erasure the class will look like the following class Example formal parameter is gone public boolean isTypeAString Object t return t instanceof String No compilation error this time GoalKicker.com Java Notes for Professionals 278Since, even if the type erasure happen anyway, now the JVM can distinguish among di\ufb00erent types in memory, even if they use the same reference type Object , as the following snippet shows Object obj1 new Stringfoo reference type Object, object type String Object obj2 new Integer11 reference type Object, object type Integer System.out.printlnobj1 instanceof String true System.out.printlnobj2 instanceof String false, its an Integer, not a String Section 47.14 Dierent ways for implementing a Generic Interface or extending a Generic Class Suppose the following generic interface has been declared public interface MyGenericInterface T public void fooT t Below are listed the possible ways to implement it. Non-generic class implementation with a speci\ufb01c type Choose a speci\ufb01c type to replace the formal type parameter T of MyGenericClass and implement it, as the following example does public class NonGenericClass implements MyGenericInterface String public void", "fooString t type T has been replaced by String This class only deals with String , and this means that using MyGenericInterface with di\ufb00erent parameters e.g. Integer , Object etc. wont compile, as the following snippet shows NonGenericClass myClass new NonGenericClass myClass. foofoostring OK, legal myClass. foo11 NOT OK, does not compile myClass. foonew Object NOT OK, does not compile Generic class implementation Declare another generic interface with the formal type parameter T which implements MyGenericInterface , as follows public class MyGenericSubclass T implements MyGenericInterface T public void fooT t type T is still the same other methods... Note that a di\ufb00erent formal type parameter may have been used, as follows public class MyGenericSubclass U implements MyGenericInterface U equivalent to the previous declaration public void fooU t other methods... Raw type class implementation GoalKicker.com Java Notes for Professionals 279Declare a non-generic class which implements MyGenericInteface as a raw type not using generic at all, as follows public class MyGenericSubclass implements MyGenericInterface public void fooObject t type T has been replaced by Object other possible methods This way is not recommended, since it is not 100 safe at runtime because it mixes up raw type of the subclass with generics", "of the interface and it is also confusing. Modern Java compilers will raise a warning with this kind of implementation, nevertheless the code - for compatibility reasons with older JVM 1.4 or earlier - will compile. All the ways listed above are also allowed when using a generic class as a supertype instead of a generic interface. GoalKicker.com Java Notes for Professionals 280Chapter 48 Classes and Objects Objects have states and behaviors. Example A dog has states - color, name, breed as well as behaviors wagging the tail, barking, eating. An object is an instance of a class. Class A class can be de\ufb01ned as a templateblueprint that describes the behaviorstate that the object of its type support. Section 48.1 Overloading Methods Sometimes the same functionality has to be written for di\ufb00erent kinds of inputs. At that time, one can use the same method name with a di\ufb00erent set of parameters. Each di\ufb00erent set of parameters is known as a method signature. As seen per the example, a single method can have multiple signatures. public class Displayer public void displayName String firstName System.out.printlnName is firstName public void displayName String firstName, String lastName System.out.printlnName is firstName lastName public static void", "mainString args Displayer displayer new Displayer displayer. displayName Ram prints Name is Ram displayer. displayName Jon, Skeet prints Name is Jon Skeet The advantage is that the same functionality is called with two di\ufb00erent numbers of inputs. While invoking the method according to the input we are passing, In this case either one string value or two string values the corresponding method is executed. Methods can be overloaded Based on the number of parameters passed. 1. Example methodString s and methodString s1, String s2. Based on the order of parameters . 2. Example methodint i, float f and methodfloat f, int i. Note Methods cannot be overloaded by changing just the return type int method is considered the same as String method and will throw a RuntimeException if attempted. If you change the return type you must also change the parameters in order to overload. GoalKicker.com Java Notes for Professionals 281Section 48.2 Explaining what is method overloading and overriding Method Overriding and Overloading are two forms of polymorphism supported by Java. Method Overloading Method overloading also known as static Polymorphism is a way you can have two or more methods functions with same name in a single class. Yes", "its as simple as that. public class Shape It could be a circle or rectangle or square private String type To calculate area of rectangle public Double areaLong length, Long breadth return Double length breadth To calculate area of a circle public Double areaLong radius return Double 3.14 r r This way user can call the same method for area depending on the type of shape it has. But the real question now is, how will java compiler will distinguish which method body is to be executed? Well Java have made it clear that even though the method names area in our case can be same but the arguments method is taking should be di\ufb00erent. Overloaded methods must have di\ufb00erent arguments list quantity and types. That being said we cannot add another method to calculate area of a square like this public Double areaLong side because in this case, it will con\ufb02ict with area method of circle and will cause ambiguity for java compiler. Thank god, there are some relaxations while writing overloaded methods like May have di\ufb00erent return types. May have di\ufb00erent access modi\ufb01ers. May throw di\ufb00erent exceptions. Why is this called static polymorphism? Well thats because which", "overloaded methods is to be invoked is decided at compile time, based on the actual number of arguments and the compile-time types of the arguments. GoalKicker.com Java Notes for Professionals 282One of common reasons of using method overloading is the simplicity of code it provides. For example remember String.valueOf which takes almost any type of argument? What is written behind the scene is probably something like this static String valueOf boolean b static String valueOf char c static String valueOf char data static String valueOf char data, int offset, int count static String valueOf double d static String valueOf float f static String valueOf int i static String valueOf long l static String valueOf Object obj Method Overriding Well, method overriding yes you guess it right, it is also known as dynamic polymorphism is somewhat more interesting and complex topic. In method overriding we overwrite the method body provided by the parent class. Got it? No? Lets go through an example. public abstract class Shape public abstract Double area return 0.0 So we have a class called Shape and it has method called area which will probably return the area of the shape. Lets say now we have two", "classes called Circle and Rectangle. public class Circle extends Shape private Double radius 5.0 See this annotation Override, it is telling that this method is from parent class Shape and is overridden here Override public Double area return 3.14 radius radius Similarly rectangle class public class Rectangle extends Shape private Double length 5.0 private Double breadth 10.0 See this annotation Override, it is telling that this method is from parent class Shape and is overridden here Override public Double area return length breadth GoalKicker.com Java Notes for Professionals 283 So, now both of your children classes have updated method body provided by the parent Shape class. Now question is how to see the result? Well lets do it the old psvm way. public class AreaFinder public static void mainString args This will create an object of circle class Shape circle new Circle This will create an object of Rectangle class Shape rectangle new Rectangle Drumbeats ...... This should print 78.5 System.out.printlnShape of circle circle.area This should print 50.0 System.out.printlnShape of rectangle rectangle. area Wow! isnt it great? Two objects of same type calling same methods and returning di\ufb00erent values. My friend, thats the power of dynamic polymorphism. Heres a", "chart to better compare the di\ufb00erences between these two Method Overloading Method Overriding Method overloading is used to increase the readability of the program.Method overriding is used to provide the speci\ufb01c implementation of the method that is already provided by its super class. Method overloading is performed within class.Method overriding occurs in two classes that have IS-A inheritance relationship. In case of method overloading, parameter must be di\ufb00erent.In case of method overriding, parameter must be same. Method overloading is the example of compile time polymorphism.Method overriding is the example of run time polymorphism. In java, method overloading cant be performed by changing return type of the method only. Return type can be same or di\ufb00erent in method overloading. But you must have to change the parameter.Return type must be same or covariant in method overriding. Section 48.3 Constructors Constructors are special methods named after the class and without a return type, and are used to construct objects. Constructors, like methods, can take input parameters. Constructors are used to initialize objects. Abstract classes can have constructors also. public class Hello constructor public HelloString wordToPrint printHello wordToPrint public void printHello String word System.out.printlnword GoalKicker.com Java Notes for Professionals 284 instantiates the", "object during creating and prints out the content of wordToPrint It is important to understand that constructors are di\ufb00erent from methods in several ways Constructors can only take the modi\ufb01ers public , private , and protected , and cannot be declared abstract , 1. final , static , or synchronized . Constructors do not have a return type.2. Constructors MUST be named the same as the class name. In the Hello example, the Hello objects 3. constructor name is the same as the class name. The this keyword has an additional usage inside constructors. this.method... calls a method on the 4. current instance, while this... refers to another constructor in the current class with di\ufb00erent signatures. Constructors also can be called through inheritance using the keyword super . public class SuperManClass public SuperManClass some implementation ... methods public class BatmanClass extends SupermanClass public BatmanClass super ... methods... See Java Language Speci\ufb01cation 8.8 and 15.9 Section 48.4 Initializing static \ufb01nal \ufb01elds using a static initializer To initialize a static final \ufb01elds that require using more than a single expression, a static initializer can be used to assign the value. The following example initializes a unmodi\ufb01able set of String s public", "class MyClass public static final SetString WORDS static Set String set new HashSet set. addHello set. addWorld set. addfoo set. addbar set. add42 WORDS Collections .unmodifiableSet set GoalKicker.com Java Notes for Professionals 285 Section 48.5 Basic Object Construction and Use Objects come in their own class, so a simple example would be a car detailed explanations below public class Car Variables describing the characteristics of an individual car, varies per object private int milesPerGallon private String name private String color public int numGallonsInTank public Car milesPerGallon 0 name color numGallonsInTank 0 this is where an individual object is created public Carint mpg, int, gallonsInTank, String carName, String carColor milesPerGallon mpg name carName color carColor numGallonsInTank gallonsInTank methods to make the object more usable Cars need to drive public void driveint distanceInMiles get miles left in car int miles numGallonsInTank milesPerGallon check that car has enough gas to drive distanceInMiles if miles distanceInMiles numGallonsInTank numGallonsInTank - distanceInMiles milesPerGallon System.out.printlnDrove numGallonsInTank miles! else System.out.printlnCould not drive! public void paintCar String newColor color newColor set new Miles Per Gallon public void setMPGint newMPG milesPerGallon newMPG set new number of Gallon In Tank public void setGallonsInTank int numGallons numGallonsInTank numGallons public void nameCar", "String newName name newName GoalKicker.com Java Notes for Professionals 286 Get the Car color public String getColor return color Get the Car name public String getName return name Get the number of Gallons public String getGallons return numGallonsInTank Objects are instances of their class. So, the way you would create an object would be by calling the Car class in one of two ways in your main class main method in Java or onCreate in Android. Option 1 Car newCar new Car30, 10, Ferrari , Red Option 1 is where you essentially tell the program everything about the Car upon creation of the object. Changing any property of the car would require calling one of the methods such as the repaintCar method. Example newCar. repaintCar Blue Note Make sure you pass the correct data type to the method. In the example above, you may also pass a variable to the repaintCar method as long as the data type is correct . That was an example of changing properties of an object, receiving properties of an object would require using a method from the Car class that has a return value meaning a method that is not void . Example", "String myCarName newCar. getName returns string Ferrari Option 1 is the best option when you have all the objects data at the time of creation. Option 2 Car newCar new Car Option 2 gets the same e\ufb00ect but required more work to create an object correctly. I want to recall this Constructor in the Car class public void Car milesPerGallon 0 name color numGallonsInTank 0 Notice that you do not have to actually pass any parameters into the object to create it. This is very useful for when you do not have all the aspects of the object but you need to use the parts that you do have. This sets generic data into each of the instance variables of the object so that, if you call for a piece of data that does not exist, no errors GoalKicker.com Java Notes for Professionals 287are thrown. Note Do not forget that you have to set the parts of the object later that you did not initialize it with. For example, Car myCar new Car String color Car.getColor returns empty string This is a common mistake amongst objects that are not initialized with all their data. Errors were avoided because there", "is a Constructor that allows an empty Car object to be created with stand-in variables public Car, but no part of the myCar was actually customized. Correct example of creating Car Object Car myCar new Car myCar.nameCarFerrari myCar.paintCar Purple myCar.setGallonsInTank 10 myCar.setMPG30 And, as a reminder, get an objects properties by calling a method in your main class. Example String myCarName myCar.getName returns string Ferrari Section 48.6 Simplest Possible Class class TrivialClass A class consists at a minimum of the class keyword, a name, and a body, which might be empty. You instantiate a class with the new operator. TrivialClass tc new TrivialClass Section 48.7 Object Member vs Static Member With this class class ObjectMemberVsStaticMember static int staticCounter 0 int memberCounter 0 void increment staticCounter memberCounter the following code snippet final ObjectMemberVsStaticMember o1 new ObjectMemberVsStaticMember final ObjectMemberVsStaticMember o2 new ObjectMemberVsStaticMember o1.increment o2.increment o2.increment GoalKicker.com Java Notes for Professionals 288System.out.printlno1 static counter o1.staticCounter System.out.printlno1 member counter o1.memberCounter System.out.println System.out.printlno2 static counter o2.staticCounter System.out.printlno2 member counter o2.memberCounter System.out.println System.out.printlnObjectMemberVsStaticMember.staticCounter ObjectMemberVsStaticMember. staticCounter the following line does not compile. You need an object to access its members System.out.printlnObjectMemberVsStaticMember.staticCounter ObjectMemberVsStaticMember.memberCounter produces this output o1 static counter 3 o1 member counter 1 o2 static counter", "3 o2 member counter 2 ObjectMemberVsStaticMember.staticCounter 3 Note You should not call static members on objects, but on classes. While it does not make a di\ufb00erence for the JVM, human readers will appreciate it. static members are part of the class and exists only once per class. Non- static members exist on instances, there is an independent copy for each instance. This also means that you need access to an object of that class to access its members. GoalKicker.com Java Notes for Professionals 289Chapter 49 Local Inner Class A class i.e. created inside a method is called local inner class in java. If you want to invoke the methods of local inner class, you must instantiate this class inside the method. Section 49.1 Local Inner Class public class localInner1 private int data30instance variable void display class Local void msgSystem.out.printlndata Local l new Local l.msg public static void mainString args localInner1 obj new localInner1 obj.display GoalKicker.com Java Notes for Professionals 290Chapter 50 Nested and Inner Classes Using Java, developers have the ability to de\ufb01ne a class within another class. Such a class is called a Nested Class . Nested Classes are called Inner Classes if they were declared as non-static,", "if not, they are simply called Static Nested Classes. This page is to document and provide details with examples on how to use Java Nested and Inner Classes. Section 50.1 A Simple Stack Using a Nested Class public class IntStack private IntStackNode head IntStackNode is the inner class of the class IntStack Each instance of this inner class functions as one link in the Overall stack that it helps to represent private static class IntStackNode private int val private IntStackNode next private IntStackNode int v, IntStackNode n val v next n public IntStack push int v head new IntStackNode v, head return this public int pop int x head.val head head.next return x And the use thereof, which notably does not at all acknowledge the existence of the nested class. public class Main public static void mainString args IntStack s new IntStack s. push4.push3.push2.push1.push0 prints 0, 1, 2, 3, 4, forint i 0 i 5 i System.out.prints.pop , Section 50.2 Static vs Non Static Nested Classes When creating a nested class, you face a choice of having that nested class static GoalKicker.com Java Notes for Professionals 291public class OuterClass1 private static class StaticNestedClass Or non-static public class OuterClass2 private", "class NestedClass At its core, static nested classes do not have a surrounding instance of the outer class, whereas non-static nested classes do. This a\ufb00ects both wherewhen one is allowed to instantiate a nested class, and what instances of those nested classes are allowed to access. Adding to the above example public class OuterClass1 private int aField public void aMethod private static class StaticNestedClass private int innerField private StaticNestedClass innerField aField Illegal, cant access aField from static context aMethod Illegal, cant call aMethod from static context private StaticNestedClass OuterClass1 instance innerField instance. aField Legal public static void aStaticMethod StaticNestedClass s new StaticNestedClass Legal, able to construct in static context Do stuff involving s... public class OuterClass2 private int aField public void aMethod private class NestedClass private int innerField private NestedClass innerField aField Legal aMethod Legal GoalKicker.com Java Notes for Professionals 292 public void aNonStaticMethod NestedClass s new NestedClass Legal public static void aStaticMethod NestedClass s new NestedClass Illegal. Cant construct without surrounding OuterClass2 instance. As this is a static context, there is no surrounding OuterClass2 instance Thus, your decision of static vs non-static mainly depends on whether or not you need to be able to directly access \ufb01elds and", "methods of the outer class, though it also has consequences for when and where you can construct the nested class. As a rule of thumb, make your nested classes static unless you need to access \ufb01elds and methods of the outer class. Similar to making your \ufb01elds private unless you need them public, this decreases the visibility available to the nested class by not allowing access to an outer instance, reducing the likelihood of error. Section 50.3 Access Modi\ufb01ers for Inner Classes A full explanation of Access Modi\ufb01ers in Java can be found here. But how do they interact with Inner classes? public , as usual, gives unrestricted access to any scope able to access the type. public class OuterClass public class InnerClass public int x 5 public InnerClass createInner return new InnerClass public class SomeOtherClass public static void mainString args int x new OuterClass .createInner .x Direct field access is legal both protected and the default modi\ufb01er of nothing behave as expected as well, the same as they do for non- nested classes. private , interestingly enough, does not restrict to the class it belongs to. Rather, it restricts to the compilation unit - the .java \ufb01le. This", "means that Outer classes have full access to Inner class \ufb01elds and methods, even if they are marked private . public class OuterClass GoalKicker.com Java Notes for Professionals 293 public class InnerClass private int x private void anInnerMethod public InnerClass aMethod InnerClass a new InnerClass a. x 5 Legal a. anInnerMethod Legal return a The Inner Class itself can have a visibility other than public . By marking it private or another restricted access modi\ufb01er, other external classes will not be allowed to import and assign the type. They can still get references to objects of that type, however. public class OuterClass private class InnerClass public InnerClass makeInnerClass return new InnerClass public class AnotherClass public static void mainString args OuterClass o new OuterClass InnerClass x o.makeInnerClass Illegal, cant find type OuterClass. InnerClass x o.makeInnerClass Illegal, InnerClass has visibility private Object x o.makeInnerClass Legal Section 50.4 Anonymous Inner Classes An anonymous inner class is a form of inner class that is declared and instantiated with a single statement. As a consequence, there is no name for the class that can be used elsewhere in the program i.e. it is anonymous. Anonymous classes are typically used in situations where you need", "to be able to create a light-weight class to be passed as a parameter. This is typically done with an interface. For example public static Comparator String CASEINSENSITIVE new Comparator String Override public int compare String string1, String string2 return string1. toUpperCase .compareTo string2. toUpperCase This anonymous class de\ufb01nes a Comparator String object CASEINSENSITIVE that compares two strings ignoring di\ufb00erences in case. Other interfaces that are frequently implemented and instantiated using anonymous classes are Runnable and GoalKicker.com Java Notes for Professionals 294Callable . For example An anonymous Runnable class is used to provide an instance that the Thread will run when started. Thread t new Threadnew Runnable Override public void run System.out.printlnHello world t.start Prints Hello world Anonymous inner classes can also be based on classes. In this case, the anonymous class implicitly extends the existing class. If the class being extended is abstract, then the anonymous class must implement all abstract methods. It may also override non-abstract methods. Constructors An anonymous class cannot have an explicit constructor. Instead, an implicit constructor is de\ufb01ned that uses super... to pass any parameters to a constructor in the class that is being extended. For example SomeClass anon new SomeClass 1, happiness", "Override public int someMethod int arg do something The implicit constructor for our anonymous subclass of SomeClass will call a constructor of SomeClass that matches the call signature SomeClass int, String. If no constructor is available, you will get a compilation error. Any exceptions that are thrown by the matched constructor are also thrown by the implicit constructor. Naturally, this does not work when extending an interface. When you create an anonymous class from an interface, the classes superclass is java.lang.Object which only has a no-args constructor. Section 50.5 Create instance of non-static inner class from outside An inner class which is visible to any outside class can be created from this class as well. The inner class depends on the outside class and requires a reference to an instance of it. To create an instance of the inner class, the new operator only needs to be called on an instance of the outer class. class OuterClass class InnerClass class OutsideClass OuterClass outer new OuterClass OuterClass. InnerClass createInner return outer.new InnerClass GoalKicker.com Java Notes for Professionals 295Note the usage as outer.new. Section 50.6 Method Local Inner Classes A class written within a method called method local inner class .", "In that case the scope of the inner class is restricted within the method. A method-local inner class can be instantiated only within the method where the inner class is de\ufb01ned. The example of using method local inner class public class OuterClass private void outerMethod final int outerInt 1 Method Local Inner Class class MethodLocalInnerClass private void print System.out.printlnMethod local inner class outerInt Accessing the inner class MethodLocalInnerClass inner new MethodLocalInnerClass inner. print public static void mainString args OuterClass outer new OuterClass outer. outerMethod Executing will give an output Method local inner class 1 . Section 50.7 Accessing the outer class from a non-static inner class The reference to the outer class uses the class name and this public class OuterClass public class InnerClass public void method System.out.printlnI can access my enclosing class OuterClass. this You can access \ufb01elds and methods of the outer class directly. public class OuterClass private int counter public class InnerClass public void method System.out.printlnI can access counter GoalKicker.com Java Notes for Professionals 296 But in case of name collision you can use the outer class reference. public class OuterClass private int counter public class InnerClass private int counter public void method System.out.printlnMy counter counter", "System.out.printlnOuter counter OuterClass. this.counter updating my counter counter OuterClass. this.counter GoalKicker.com Java Notes for Professionals 297Chapter 51 The java.util.Objects Class Section 51.1 Basic use for object null check For null check in method Object nullableObject methodReturnObject if Objects. isNullnullableObject return For not null check in method Object nullableObject methodReturnObject if Objects. nonNullnullableObject return Section 51.2 Objects.nonNull method reference use in stream api In the old fashion way for collection null check ListObject someObjects methodGetList for Object obj someObjects if obj null continue doSomething obj With the Objects. nonNull method and Java8 Stream API, we can do the above in this way ListObject someObjects methodGetList someObjects. stream . filterObjectsnonNull . forEachthisdoSomething GoalKicker.com Java Notes for Professionals 298Chapter 52 Default Methods Default Method introduced in Java 8, allows developers to add new methods to an interface without breaking the existing implementations of this interface. It provides \ufb02exibility to allow the interface to de\ufb01ne an implementation which will be used as default when a class which implements that interface fails to provide an implementation of that method. Section 52.1 Basic usage of default methods Interface with default method public interface Printable default void printString System.out.println default implementation Class which falls back to", "default implementation of link printString public class WithDefault implements Printable Custom implementation of link printString public class OverrideDefault implements Printable Override public void printString System.out.println overridden implementation The following statements new WithDefault .printString new OverrideDefault .printString Will produce this output default implementation overridden implementation Section 52.2 Accessing overridden default methods from implementing class In classes, super.foo will look in superclasses only. If you want to call a default implementation from a superinterface, you need to qualify super with the interface name Fooable. super.foo. public interface Fooable GoalKicker.com Java Notes for Professionals 299 default int foo return 3 public class A extends Object implements Fooable Override public int foo return super.foo 1 error no method foo in java.lang.Object return Fooable. super.foo 1 okay, returns 4 Section 52.3 Why use Default Methods? The simple answer is that it allows you to evolve an existing interface without breaking existing implementations. For example, you have Swim interface that you published 20 years ago. public interface Swim void backStroke We did a great job, our interface is very popular, there are many implementation on that around the world and you dont have control over their source code. public class FooSwimmer implements Swim public void", "backStroke System.out.printlnDo backstroke After 20 years, youve decided to add new functionality to the interface, but it looks like our interface is frozen because it will break existing implementations. Luckily Java 8 introduces brand new feature called Default method. We can now add new method to the Swim interface. public interface Swim void backStroke default void sideStroke System.out.printlnDefault sidestroke implementation. Can be overridden Now all existing implementations of our interface can still work. But most importantly they can implement the newly added method in their own time. One of the biggest reasons for this change, and one of its biggest uses, is in the Java Collections framework. Oracle could not add a foreach method to the existing Iterable interface without breaking all existing code which implemented Iterable. By adding default methods, existing Iterable implementation will inherit the default implementation. Section 52.4 Accessing other interface methods within default method You can as well access other interface methods from within your default method. GoalKicker.com Java Notes for Professionals 300public interface Summable int getA int getB default int calculateSum return getA getB public class Sum implements Summable Override public int getA return 1 Override public int getB return 2 The following statement", "will print 3 System.out.printlnnew Sum.calculateSum Default methods could be used along with interface static methods as well public interface Summable static int getA return 1 static int getB return 2 default int calculateSum return getA getB public class Sum implements Summable The following statement will also print 3 System.out.printlnnew Sum.calculateSum Section 52.5 Default method multiple inheritance collision Consider next example public interface A default void foo System.out.printlnA.foo public interface B default void foo System.out.printlnB.foo GoalKicker.com Java Notes for Professionals 301 Here are two interfaces declaring default method foo with the same signature. If you will try to extend these both interfaces in the new interface you have to make choice of two, because Java forces you to resolve this collision explicitly. First , you can declare method foo with the same signature as abstract , which will override A and B behaviour. public interface ABExtendsAbstract extends A, B Override void foo And when you will implement ABExtendsAbstract in the class you will have to provide foo implementation public class ABExtendsAbstractImpl implements ABExtendsAbstract Override public void foo System.out.printlnABImpl.foo Or second , you can provide a completely new default implementation. You also may reuse code of A and B foo methods", "by Accessing overridden default methods from implementing class. public interface ABExtends extends A, B Override default void foo System.out.printlnABExtends.foo And when you will implement ABExtends in the class you will not have to provide foo implementation public class ABExtendsImpl implements ABExtends Section 52.6 Class, Abstract class and Interface method precedence Implementations in classes, including abstract declarations, take precedence over all interface defaults. Abstract class method takes precedence over Interface Default Method . public interface Swim default void backStroke System.out.printlnSwim.backStroke public abstract class AbstractSwimmer implements Swim public void backStroke System.out.printlnAbstractSwimmer.backStroke public class FooSwimmer extends AbstractSwimmer The following statement GoalKicker.com Java Notes for Professionals 302new FooSwimmer .backStroke Will produce AbstractSwimmer. backStroke Class method takes precedence over Interface Default Method public interface Swim default void backStroke System.out.printlnSwim.backStroke public abstract class AbstractSwimmer implements Swim public class FooSwimmer extends AbstractSwimmer public void backStroke System.out.printlnFooSwimmer.backStroke The following statement new FooSwimmer .backStroke Will produce FooSwimmer. backStroke GoalKicker.com Java Notes for Professionals 303Chapter 53 Packages package in java is used to group class and interfaces. This helps developer to avoid con\ufb02ict when there are huge numbers of classes. If we use this package the classes we can create a classinterface with same name in di\ufb00erent packages. By", "using packages we can import the piece of again in another class. There many built in packages in java like 1.java.util 2.java.lang 3.java.io We can de\ufb01ne our own user de\ufb01ned packages . Section 53.1 Using Packages to create classes with the same name First Test.class package foo.bar public class Test Also Test.class in another package package foo.bar.baz public class Test The above is \ufb01ne because the two classes exist in di\ufb00erent packages. Section 53.2 Using Package Protected Scope In Java if you dont provide an access modi\ufb01er the default scope for variables is package-protected level. This means that classes can access the variables of other classes within the same package as if those variables were publicly available. package foo.bar public class ExampleClass double exampleNumber String exampleString public ExampleClass exampleNumber 3 exampleString Test String No getters or setters package foo.bar public class AnotherClass ExampleClass clazz new ExampleClass System.out.printlnExample Number clazz.exampleNumber Prints Example Number 3 System.out.printlnExample String clazz.exampleString Prints Example String Test String GoalKicker.com Java Notes for Professionals 304 This method will not work for a class in another package package baz.foo public class ThisShouldNotWork ExampleClass clazz new ExampleClass System.out.printlnExample Number clazz.exampleNumber Throws an exception System.out.printlnExample String clazz.exampleString Throws an exception", "GoalKicker.com Java Notes for Professionals 305Chapter 54 Inheritance Inheritance is a basic object oriented feature in which one class acquires and extends upon the properties of another class, using the keyword extends . For Interfaces and the keyword implements , see interfaces. Section 54.1 Inheritance With the use of the extends keyword among classes, all the properties of the superclass also known as the Parent Class or Base Class are present in the subclass also known as the Child Class or Derived Class public class BaseClass public void baseMethod System.out.printlnDoing base class stuff public class SubClass extends BaseClass Instances of SubClass have inherited the method baseMethod SubClass s new SubClass s.baseMethod Valid, prints Doing base class stuff Additional content can be added to a subclass. Doing so allows for additional functionality in the subclass without any change to the base class or any other subclasses from that same base class public class Subclass2 extends BaseClass public void anotherMethod System.out.printlnDoing subclass2 stuff Subclass2 s2 new Subclass2 s2.baseMethod Still valid , prints Doing base class stuff s2.anotherMethod Also valid, prints Doing subclass2 stuff Fields are also inherited public class BaseClassWithField public int x public class SubClassWithField extends BaseClassWithField public SubClassWithField int", "x this.x x Can access fields private \ufb01elds and methods still exist within the subclass, but are not accessible GoalKicker.com Java Notes for Professionals 306public class BaseClassWithPrivateField private int x 5 public int getX return x public class SubClassInheritsPrivateField extends BaseClassWithPrivateField public void printX System.out.printlnx Illegal, cant access private field x System.out.printlngetX Legal, prints 5 SubClassInheritsPrivateField s new SubClassInheritsPrivateField int x s.getX x will have a value of 5. In Java, each class may extend at most one other class. public class A public class B public class ExtendsTwoClasses extends A, B Illegal This is known as multiple inheritance, and while it is legal in some languages, Java does not permit it with classes. As a result of this, every class has an unbranching ancestral chain of classes leading to Object , from which all classes descend. Section 54.2 Abstract Classes An abstract class is a class marked with the abstract keyword. It, contrary to non-abstract class, may contain abstract - implementation-less - methods. It is, however, valid to create an abstract class without abstract methods. An abstract class cannot be instantiated. It can be sub-classed extended as long as the sub-class is either also abstract, or implements all", "methods marked as abstract by super classes. An example of an abstract class public abstract class Component private int x, y public setPosition int x, int y this.x x this.y y public abstract void render The class must be marked abstract, when it has at least one abstract method. An abstract method is a method that has no implementation. Other methods can be declared within an abstract class that have implementation in order to provide common code for any sub-classes. Attempting to instantiate this class will provide a compile error GoalKicker.com Java Notes for Professionals 307error Component is abstract cannot be instantiated Component myComponent new Component However a class that extends Component , and provides an implementation for all of its abstract methods and can be instantiated. public class Button extends Component Override public void render render a button public class TextBox extends Component Override public void render render a textbox Instances of inheriting classes also can be cast as the parent class normal inheritance and they provide a polymorphic e\ufb00ect when the abstract method is called. Component myButton new Button Component myTextBox new TextBox myButton. render renders a button myTextBox. render renders a text box Abstract classes vs", "Interfaces Abstract classes and interfaces both provide a way to de\ufb01ne method signatures while requiring the extendingimplementing class to provide the implementation. There are two key di\ufb00erences between abstract classes and interfaces A class may only extend a single class, but may implement many interfaces. An abstract class can contain instance non- static \ufb01elds, but interfaces may only contain static \ufb01elds. Version Java SE 8 Methods declared in interfaces could not contain implementations, so abstract classes were used when it was useful to provide additional methods which implementations called the abstract methods. Version Java SE 8 Java 8 allows interfaces to contain default methods, usually implemented using the other methods of the interface, making interfaces and abstract classes equally powerful in this regard. Anonymous subclasses of Abstract Classes As a convenience java allows for instantiation of anonymous instances of subclasses of abstract classes, which provide implementations for the abstract methods upon creating the new object. Using the above example this could look like this GoalKicker.com Java Notes for Professionals 308Component myAnonymousComponent new Component Override public void render render a quick 1-time use component Section 54.3 Using \ufb01nal to restrict inheritance and overriding Final classes When used in a class", "declaration, the final modi\ufb01er prevents other classes from being declared that extend the class. A final class is a leaf class in the inheritance class hierarchy. This declares a final class final class MyFinalClass some code Compilation error cannot inherit from final MyFinalClass class MySubClass extends MyFinalClass more code Use-cases for \ufb01nal classes Final classes can be combined with a private constructor to control or prevent the instantiation of a class. This can be used to create a so-called utility class that only de\ufb01nes static members i.e. constants and static methods. public final class UtilityClass Private constructor to replace the default visible constructor private UtilityClass Static members can still be used as usual public static int doSomethingCool return 123 Immutable classes should also be declared as final . An immutable class is one whose instances cannot be changed after they have been created see the Immutable Objects topic. By doing this, you make it impossible to create a mutable subclass of an immutable class. That would violate the Liskov Substitution Principle which requires that a subtype should obey the behavioral contract of its supertypes. From a practical perspective, declaring an immutable class to be final makes it easier to", "reason about program behavior. It also addresses security concerns in the scenario where untrusted code is executed in a security sandbox. For instance, since String is declared as final , a trusted class does not need to worry that it might be tricked into accepting mutable subclass, which the untrusted caller could then surreptitiously change. One disadvantage of final classes is that they do not work with some mocking frameworks such as Mockito. Update Mockito version 2 now support mocking of \ufb01nal classes. Final methods GoalKicker.com Java Notes for Professionals 309The final modi\ufb01er can also be applied to methods to prevent them being overridden in sub-classes public class MyClassWithFinalMethod public final void someMethod public class MySubClass extends MyClassWithFinalMethod Override public void someMethod Compiler error overridden method is final Final methods are typically used when you want to restrict what a subclass can change in a class without forbidding subclasses entirely. The final modi\ufb01er can also be applied to variables, but the meaning of final for variables is unrelated to inheritance. Section 54.4 The Liskov Substitution Principle Substitutability is a principle in object-oriented programming introduced by Barbara Liskov in a 1987 conference keynote stating that, if class B is a", "subclass of class A, then wherever A is expected, B can be used instead class A ... class B extends A ... public void methodA obj ... A a new B Assignment OK methodnew B Passing as parameter OK This also applies when the type is an interface, where there doesnt need to any hierarchical relationship between the objects interface Foo void bar class A implements Foo void bar ... class B implements Foo void bar ... ListFoo foos new ArrayList foos.addnew A OK foos.addnew B OK Now the list contains objects that are not from the same class hierarchy. GoalKicker.com Java Notes for Professionals 310Section 54.5 Abstract class and Interface usage Is-a relation vs Has-a capability When to use abstract classes To implement the same or di\ufb00erent behaviour among multiple related objects When to use interfaces to implement a contract by multiple unrelated objects Abstract classes create is a relations while interfaces provide has a capability. This can be seen in the code below public class InterfaceAndAbstractClassDemo public static void mainString args Dog dog new DogJack,16 Cat cat new CatJoe,20 System.out.printlnDogdog System.out.printlnCatcat dog. remember dog. protectOwner Learn dl dog dl. learn cat. remember cat. protectOwner Climb c cat", "c. climb Man man new ManRavindra ,40 System.out.printlnman Climb cm man cm. climb Think t man t. think Learn l man l. learn Apply a man a. apply abstract class Animal String name int lifeExpentency public AnimalString name,int lifeExpentency this.name name this.lifeExpentency lifeExpentency public abstract void remember public abstract void protectOwner public String toString return this.getClass .getSimpleName namelifeExpentency class Dog extends Animal implements Learn GoalKicker.com Java Notes for Professionals 311 public DogString name,int age supername,age public void remember System.out.printlnthis.getClass .getSimpleName can remember for 5 minutes public void protectOwner System.out.printlnthis.getClass .getSimpleName will protect owner public void learn System.out.printlnthis.getClass .getSimpleName can learn class Cat extends Animal implements Climb public CatString name,int age supername,age public void remember System.out.printlnthis.getClass .getSimpleName can remember for 16 hours public void protectOwner System.out.printlnthis.getClass .getSimpleName wont protect owner public void climb System.out.printlnthis.getClass .getSimpleName can climb interface Climb void climb interface Think void think interface Learn void learn interface Apply void apply class Man implements Think,Learn,Apply,Climb String name int age public ManString name,int age this.name name this.age age public void think System.out.printlnI can think this.getClass .getSimpleName public void learn System.out.printlnI can learn this.getClass .getSimpleName public void apply System.out.printlnI can apply this.getClass .getSimpleName public void climb System.out.printlnI can climb this.getClass", ".getSimpleName public String toString GoalKicker.com Java Notes for Professionals 312 return Man nameAgeage output DogDogJack16 CatCatJoe20 Dog can remember for 5 minutes Dog will protect owner Dog can learn Cat can remember for 16 hours Cat wont protect owner Cat can climb Man RavindraAge40 I can climbMan I can thinkMan I can learnMan I can applyMan Key notes Animal is an abstract class with shared attributes name and lifeExpectancy and abstract methods 1. remember and protectOwner . Dog and Cat are Animals that have implemented the remember and protectOwner methods. Cat can climb but Dog cannot. Dog can think but Cat cannot. These speci\ufb01c capabilities are added to Cat 2. and Dog by implementation. Man is not an Animal but he can Think , Learn , Apply , and Climb . 3. Cat is not a Man but it can Climb . 4. Dog is not a Man but it can Learn 5. Man is neither a Cat nor a Dog but can have some of the capabilities of the latter two without extending 6. Animal , Cat, or Dog. This is done with Interfaces. Even though Animal is an abstract class, it has a constructor, unlike an interface.", "7. TLDR Unrelated classes can have capabilities through interfaces, but related classes change the behaviour through extension of base classes. Refer to the Java documentation page to understand which one to use in a speci\ufb01c use case. Consider using abstract classes if... You want to share code among several closely related classes.1. You expect that classes that extend your abstract class have many common methods or \ufb01elds, or require2. access modi\ufb01ers other than public such as protected and private. You want to declare non-static or non-\ufb01nal \ufb01elds.3. Consider using interfaces if... You expect that unrelated classes would implement your interface. For example, many unrelated objects can1. implement the Serializable interface. GoalKicker.com Java Notes for Professionals 313You want to specify the behaviour of a particular data type but are not concerned about who implements its2. behaviour. You want to take advantage of multiple inheritance of type.3. Section 54.6 Static Inheritance Static method can be inherited similar to normal methods, however unlike normal methods it is impossible to create abstract methods in order to force static method overriding. Writing a method with the same signature as a static method in a super class appears to be a form of overriding, but", "really this simply creates a new function hides the other. public class BaseClass public static int num 5 public static void sayHello System.out.printlnHello public static void mainString args BaseClass. sayHello System.out.printlnBaseClasss num BaseClass. num SubClass. sayHello This will be different than the above statements output, since it runs A different method SubClass. sayHello true StaticOverride. sayHello System.out.printlnStaticOverrides num StaticOverride. num public class SubClass extends BaseClass Inherits the sayHello function, but does not override it public static void sayHello boolean test System.out.printlnHey public static class StaticOverride extends BaseClass Hides the num field from BaseClass You can even change the type, since this doesnt affect the signature public static String num test Cannot use Override annotation, since this is static This overrides the sayHello method from BaseClass public static void sayHello System.out.printlnStatic says Hi Running any of these classes produces the output Hello BaseClasss num 5 GoalKicker.com Java Notes for Professionals 314Hello Hey Static says Hi StaticOverrides num test Note that unlike normal inheritance, in static inheritance methods are not hidden. You can always call the base sayHello method by using BaseClass. sayHello . But classes do inherit static methods if no methods with the same signature are found in the", "subclass. If two methods signatures vary, both methods can be run from the subclass, even if the name is the same. Static \ufb01elds hide each other in a similar way. Section 54.7 Programming to an interface The idea behind programming to an interface is to base the code primarily on interfaces and only use concrete classes at the time of instantiation. In this context, good code dealing with e.g. Java collections will look something like this not that the method itself is of any use at all, just illustration public T SetT toSetCollection T collection return Sets.newHashSet collection while bad code might look like this public T HashSet T toSetArrayList T collection return Sets.newHashSet collection Not only the former can be applied to a wider choice of arguments, its results will be more compatible with code provided by other developers that generally adhere to the concept of programming to an interface. However, the most important reasons to use the former are most of the time the context, in which the result is used, does not and should not need that many details as the concrete implementation provides adhering to an interface forces cleaner code and less hacks such as", "yet another public method gets added to a class serving some speci\ufb01c scenario the code is more testable as interfaces are easily mockable \ufb01nally, the concept helps even if only one implementation is expected at least for testability. So how can one easily apply the concept of programming to an interface when writing new code having in mind one particular implementation? One option that we commonly use is a combination of the following patterns programming to an interface factory builder The following example based on these principles is a simpli\ufb01ed and truncated version of an RPC implementation written for a number of di\ufb00erent protocols public interface RemoteInvoker RQ, RS CompletableFuture RS invokeRQ request, Class RS responseClass The above interface is not supposed to be instantiated directly via a factory, instead we derive further more GoalKicker.com Java Notes for Professionals 315concrete interfaces, one for HTTP invocation and one for AMQP, each then having a factory and a builder to construct instances, which in turn are also instances of the above interface public interface AmqpInvoker extends RemoteInvoker static AmqpInvokerBuilder with String instanceId, ConnectionFactory factory return new AmqpInvokerBuilder instanceId, factory Instances of RemoteInvoker for the use with AMQP can now be constructed", "as easy as or more involved depending on the builder RemoteInvoker invoker AmqpInvoker. withinstanceId, factory .requestRouter router .build And an invocation of a request is as easy as Response res invoker. invokenew Requestdata, Response. class.get Due to Java 8 permitting placing of static methods directly into interfaces, the intermediate factory has become implicit in the above code replaced with AmqpInvoker. with. In Java prior to version 8, the same e\ufb00ect can be achieved with an inner Factory class public interface AmqpInvoker extends RemoteInvoker class Factory public static AmqpInvokerBuilder with String instanceId, ConnectionFactory factory return new AmqpInvokerBuilder instanceId, factory The corresponding instantiation would then turn into RemoteInvoker invoker AmqpInvoker. Factory.withinstanceId, factory .requestRouter router .build The builder used above could look like this although this is a simpli\ufb01cation as the actual one permits de\ufb01ning of up to 15 parameters deviating from defaults. Note that the construct is not public, so it is speci\ufb01cally usable only from the above AmqpInvoker interface public class AmqpInvokerBuilder ... AmqpInvokerBuilder String instanceId, ConnectionFactory factory this.instanceId instanceId this.factory factory public AmqpInvokerBuilder requestRouter RequestRouter requestRouter this.requestRouter requestRouter return this public AmqpInvoker build throws TimeoutException, IOException return new AmqpInvokerImpl instanceId, factory, requestRouter GoalKicker.com Java Notes for Professionals 316 Generally,", "a builder can also be generated using a tool like FreeBuilder. Finally, the standard and the only expected implementation of this interface is de\ufb01ned as a package-local class to enforce the use of the interface, the factory and the builder class AmqpInvokerImpl implements AmqpInvoker AmqpInvokerImpl String instanceId, ConnectionFactory factory, RequestRouter requestRouter ... Override public RQ, RS CompletableFuture RS invokefinal RQ request, final ClassRS respClass ... Meanwhile, this pattern proved to be very e\ufb03cient in developing all our new code not matter how simple or complex the functionality is. Section 54.8 Overriding in Inheritance Overriding in Inheritance is used when you use a already de\ufb01ned method from a super class in a sub class, but in a di\ufb00erent way than how the method was originally designed in the super class. Overriding allows the user to reuse code by using existing material and modifying it to suit the users needs better. The following example demonstrates how ClassB overrides the functionality of ClassA by changing what gets sent out through the printing method Example public static void mainString args ClassA a new ClassA ClassA b new ClassB a.printing b.printing class ClassA public void printing System.out.printlnA class ClassB extends ClassA public void printing", "System.out.printlnB Output A GoalKicker.com Java Notes for Professionals 317B Section 54.9 Variable shadowing Variables are SHADOWED and methods are OVERRIDDEN. Which variable will be used depends on the class that the variable is declared of. Which method will be used depends on the actual class of the object that is referenced by the variable. class Car public int gearRatio 8 public String accelerate return Accelerate Car class SportsCar extends Car public int gearRatio 9 public String accelerate return Accelerate SportsCar public void test public static void mainString args Car car new SportsCar System.out.printlncar.gearRatio car.accelerate will print out 8 Accelerate SportsCar Section 54.10 Narrowing and Widening of object references Casting an instance of a base class to a subclass as in b B a is called narrowing as you are trying to narrow the base class object to a more speci\ufb01c class object and needs an explicit type-cast. Casting an instance of a subclass to a base class as in A a b is called widening and does not need a type-cast. To illustrate, consider the following class declarations, and test code class Vehicle class Car extends Vehicle class Truck extends Vehicle class MotorCycle extends Vehicle class Test GoalKicker.com Java", "Notes for Professionals 318 public static void mainString args Vehicle vehicle new Car Car car new Car vehicle car is valid, no cast needed Car c vehicle not valid Car c Car vehicle valid The statement Vehicle vehicle new Car is a valid Java statement. Every instance of Car is also a Vehicle . Therefore, the assignment is legal without the need for an explicit type-cast. On the other hand, Car c vehicle is not valid. The static type of the vehicle variable is Vehicle which means that it could refer to an instance of Car, Truck,MotorCycle , or any other current or future subclass ofVehicle. Or indeed, an instance of Vehicleitself, since we did not declare it as an abstractclass. The assignment cannot be allowed, since that might lead to carreferring to a Truck instance. To prevent this situation, we need to add an explicit type-cast Car c Car vehicle The type-cast tells the compiler that we expect the value of vehicle to be a Car or a subclass of Car. If necessary, compiler will insert code to perform a run-time type check. If the check fails, then a ClassCastException will be thrown when the code is executed.", "Note that not all type-casts are valid. For example String s String vehicle not valid The Java compiler knows that an instance that is type compatible with Vehicle cannot ever be type compatible with String . The type-cast could never succeed, and the JLS mandates that this gives in a compilation error. Section 54.11 Inheritance and Static Methods In Java, parent and child class both can have static methods with the same name. But in such cases implementation of static method in child is hiding parent class implementation, its not method overriding. For example class StaticMethodTest static method and inheritance public static void mainString args Parent p new Child p.staticMethod prints Inside Parent Child p.staticMethod prints Inside Child static class Parent public static void staticMethod System.out.printlnInside Parent static class Child extends Parent public static void staticMethod GoalKicker.com Java Notes for Professionals 319 System.out.printlnInside Child Static methods are bind to a class not to an instance and this method binding happens at compile time. Since in the \ufb01rst call to staticMethod , parent class reference p was used, Parent s version of staticMethod is invoked. In second case, we did cast p into Child class, Child s staticMethod executed. GoalKicker.com", "Java Notes for Professionals 320Chapter 55 Reference Types Section 55.1 Dierent Reference Types java.lang.ref package provides reference-object classes, which support a limited degree of interaction with the garbage collector. Java has four main di\ufb00erent reference types. They are Strong Reference Weak Reference Soft Reference Phantom Reference 1. Strong Reference This is the usual form of creating objects. MyObject myObject new MyObject The variable holder is holding a strong reference to the object created. As long as this variable is live and holds this value, the MyObject instance will not be collected by the garbage collector. 2. Weak Reference When you do not want to keep an object longer, and you need to clearfree the memory allocated for an object as soon as possible, this is the way to do so. WeakReference myObjectRef new WeakReference MyObject Simply, a weak reference is a reference that isnt strong enough to force an object to remain in memory. Weak references allow you to leverage the garbage collectors ability to determine reachability for you, so you dont have to do it yourself. When you need the object you created, just use .get method myObjectRef. get Following code will exemplify this WeakReference myObjectRef new WeakReference", "MyObject System.out.printlnmyObjectRef. get This will print the object reference address System.gc System.out.printlnmyObjectRef. get This will print null if the GC cleaned up the object 3. Soft Reference Soft references are slightly stronger than weak references. You can create a soft referenced object as following SoftReference myObjectRef new SoftReference MyObject They can hold onto the memory more strongly than the weak reference. If you have enough memory supplyresources, garbage collector will not clean the soft references as enthusiastically as weak references. GoalKicker.com Java Notes for Professionals 321Soft references are handy to use in caching. You can create soft referenced objects as a cache, where they kept until your memory runs out. When your memory cant supply enough resources, garbage collector will remove soft references. SoftReference myObjectRef new SoftReference MyObject System.out.printlnmyObjectRef. get This will print the reference address of the Object System.gc System.out.printlnmyObjectRef. get This may or may not print the reference address of the Object 4. Phantom Reference This is the weakest referencing type. If you created an object reference using Phantom Reference, the get method will always return null! The use of this referencing is that Phantom reference objects, which are enqueued after the collector determines that their referents", "may otherwise be reclaimed. Phantom references are most often used for scheduling pre- mortem cleanup actions in a more \ufb02exible way than is possible with the Java \ufb01nalization mechanism. - From Phantom Reference Javadoc from Oracle. You can create an object of Phantom Reference as following PhantomReference myObjectRef new PhantomReference MyObject GoalKicker.com Java Notes for Professionals 322Chapter 56 Console IO Section 56.1 Reading user input from the console Using BufferedReader System.out.printlnPlease type your name and press Enter. BufferedReader reader new BufferedReader new InputStreamReader System.in try String name reader. readLine System.out.printlnHello, name ! catchIOException e System.out.printlnAn error occurred e.getMessage The following imports are needed for this code import java.io.BufferedReader import java.io.IOException import java.io.InputStreamReader Using Scanner Version Java SE 5 System.out.printlnPlease type your name and press Enter Scanner scanner new Scanner System.in String name scanner. nextLine System.out.printlnHello, name ! The following import is needed for this example import java.util.Scanner To read more than one line, invoke scanner. nextLine repeatedly System.out.printlnPlease enter your first and your last name, on separate lines. Scanner scanner new Scanner System.in String firstName scanner. nextLine String lastName scanner. nextLine System.out.printlnHello, firstName lastName ! There are two methods for obtaining Strings , next and nextLine . next returns", "text up until the \ufb01rst space also known as a token, and nextLine returns all text that the user inputted until pressing enter. Scanner also provides utility methods for reading data types other than String . These include scanner. nextByte scanner. nextShort scanner. nextInt scanner. nextLong scanner. nextFloat scanner. nextDouble scanner. nextBigInteger GoalKicker.com Java Notes for Professionals 323scanner. nextBigDecimal Pre\ufb01xing any of these methods with has as in hasNextLine , hasNextInt returns true if the stream has any more of the request type. Note These methods will crash the program if the input is not of the requested type for example, typing a for nextInt . You can use a try catch to prevent this see Exceptions Scanner scanner new Scanner System.in Create the scanner scanner. useLocale Locale.US Set number format excepted System.out.printlnPlease input a float, decimal separator is . if scanner. hasNextFloat Check if it is a float float fValue scanner. nextFloat retrive the value directly as float System.out.printlnfValue is a float else String sValue scanner. next We can not retrive as float System.out.printlnsValue is not a float Using System.console Version Java SE 6 String name System.console.readLine Please type your name and press Entern System.out.printfHello, s! , name", "To read passwords without echoing as in unix terminal char password System.console.readPassword Advantages Reading methods are synchronized Format string syntax can be used Note This will only work if the program is run from a real command line without redirecting the standard input and output streams. It does not work when the program is run from within certain IDEs, such as Eclipse. For code that works within IDEs and with stream redirection, see the other examples. Section 56.2 Aligning strings in console The method PrintWriter .format called through System.out.format can be used to print aligned strings in console. The method receives a String with the format information and a series of objects to format String rowsStrings new String 1, 1234, 1234567 , 123456789 String column1Format -3s min 3 characters, left aligned String column2Format -5.8s min 5 and max 8 characters, left aligned String column3Format 6.6s fixed size 6 characters, right aligned String formatInfo column1Format column2Format column3Format forint i 0 i rowsStrings. length i System.out.formatformatInfo, rowsStrings i, rowsStrings i, rowsStrings i System.out.println Output GoalKicker.com Java Notes for Professionals 3241 1 1 1234 1234 1234 1234567 1234567 123456 123456789 12345678 123456 Using format strings with \ufb01xed size permits to print the", "strings in a table-like appearance with \ufb01xed size columns String rowsStrings new String 1, 1234, 1234567 , 123456789 String column1Format -3.3s fixed size 3 characters, left aligned String column2Format -8.8s fixed size 8 characters, left aligned String column3Format 6.6s fixed size 6 characters, right aligned String formatInfo column1Format column2Format column3Format forint i 0 i rowsStrings. length i System.out.formatformatInfo, rowsStrings i, rowsStrings i, rowsStrings i System.out.println Output 1 1 1 123 1234 1234 123 1234567 123456 123 12345678 123456 Format strings examples s just a string with no formatting 5s format the string with a minimum of 5 characters if the string is shorter it will be padded to 5 characters and right aligned -5s format the string with a minimum of 5 characters if the string is shorter it will be padded to 5 characters and left aligned 5.10s format the string with a minimum of 5 characters and a maximum of 10 characters if the string is shorter than 5 it will be padded to 5 characters and right aligned if the string is longer than 10 it will be truncated to 10 characters and right aligned -5.5s format the string with a \ufb01xed size of 5 characters", "minimum and maximum are equals if the string is shorter than 5 it will be padded to 5 characters and left aligned if the string is longer than 5 it will be truncated to 5 characters and left aligned Section 56.3 Implementing Basic Command-Line Behavior For basic prototypes or basic command-line behavior, the following loop comes in handy. public class ExampleCli private static final String CLILINE example-cli console like string private static final String CMDQUIT quit string for exiting the program private static final String CMDHELLO hello string for printing Hello World! on the screen private static final String CMDANSWER answer string for printing 42 on the screen GoalKicker.com Java Notes for Professionals 325 public static void mainString args ExampleCli claimCli new ExampleCli creates an object of this class try claimCli. start calls the start function to do the work like console catch IOException e e. printStackTrace prints the exception log if it is failed to do get the user input or something like that private void start throws IOException String cmd BufferedReader reader new BufferedReader new InputStreamReader System.in while !cmd.equalsCMDQUIT terminates console if user input is quit System.out.printCLILINE prints the console-like string cmd reader. readLine takes input from", "user. user input should be started with hello, answer or quit String cmdArr cmd.split if cmdArr0.equalsCMDHELLO executes when user input starts with hello hello cmdArr else if cmdArr0.equalsCMDANSWER executes when user input starts with answer answer cmdArr prints Hello World! on the screen if user input starts with hello private void helloString cmdArr System.out.printlnHello World! prints 42 on the screen if user input starts with answer private void answerString cmdArr System.out.println42 GoalKicker.com Java Notes for Professionals 326Chapter 57 Streams A Stream represents a sequence of elements and supports di\ufb00erent kind of operations to perform computations upon those elements. With Java 8, Collection interface has two methods to generate a Stream stream and parallelStream . Stream operations are either intermediate or terminal. Intermediate operations return a Stream so multiple intermediate operations can be chained before the Stream is closed. Terminal operations are either void or return a non-stream result. Section 57.1 Using Streams A Stream is a sequence of elements upon which sequential and parallel aggregate operations can be performed. Any given Stream can potentially have an unlimited amount of data \ufb02owing through it. As a result, data received from a Stream is processed individually as it arrives, as opposed", "to performing batch processing on the data altogether. When combined with lambda expressions they provide a concise way to perform operations on sequences of data using a functional approach. Example see it work on Ideone StreamString fruitStream Stream. ofapple, banana , pear, kiwi, orange fruitStream. filters - s.contains a . mapStringtoUpperCase . sorted . forEachSystem.outprintln Output APPLE BANANA ORANGE PEAR The operations performed by the above code can be summarized as follows Create a StreamString containing a sequenced ordered Stream of fruit String elements using the static 1. factory method Stream.ofvalues. The filter operation retains only elements that match a given predicate the elements that when tested 2. by the predicate return true. In this case, it retains the elements containing an a. The predicate is given as a lambda expression. The map operation transforms each element using a given function, called a mapper. In this case, each fruit 3. String is mapped to its uppercase String version using the method-reference StringtoUppercase . Note that the map operation will return a stream with a di\ufb00erent generic type if the mapping function returns a type di\ufb00erent to its input parameter. For example on a StreamString calling .mapStringisEmpty returns a StreamBoolean", "The sorted operation sorts the elements of the Stream according to their natural ordering 4. GoalKicker.com Java Notes for Professionals 327lexicographically, in the case of String . Finally, the forEachaction operation performs an action which acts on each element of the Stream , 5. passing it to a Consumer . In the example, each element is simply being printed to the console. This operation is a terminal operation, thus making it impossible to operate on it again. Note that operations de\ufb01ned on the Stream are performed because of the terminal operation. Without a terminal operation, the stream is not processed. Streams can not be reused. Once a terminal operation is called, the Stream object becomes unusable. Operations as seen above are chained together to form what can be seen as a query on the data. Closing Streams Note that a Stream generally does not have to be closed. It is only required to close streams that operate on IO channels. Most Stream types dont operate on resources and therefore dont require closing. The Stream interface extends AutoCloseable . Streams can be closed by calling the close method or by using try- with-resource statements. An example use case where a", "Stream should be closed is when you create a Stream of lines from a \ufb01le try StreamString lines Files.linesPaths.getsomePath lines. forEachSystem.outprintln The Stream interface also declares the Stream.onClose method which allows you to register Runnable handlers which will be called when the stream is closed. An example use case is where code which produces a stream needs to know when it is consumed to perform some cleanup. public StreamStringstreamAndDelete Path path throws IOException return Files.linespath.onClose - someClass. deletePath path The run handler will only execute if the close method gets called, either explicitly or implicitly by a try-with- resources statement. Processing Order GoalKicker.com Java Notes for Professionals 328A Stream objects processing can be sequential or parallel. In a sequential mode, the elements are processed in the order of the source of the Stream . If the Stream is ordered such as a SortedMap implementation or a List the processing is guaranteed to match the ordering of the source. In other cases, however, care should be taken not to depend on the ordering see is the Java HashMap keySet iteration order consistent? . Example ListInteger integerList Arrays.asList0, 1, 2, 3, 42 sequential long howManyOddNumbers integerList. stream . filtere - e", "2 1 . count System.out.printlnhowManyOddNumbers Output 2 Live on Ideone Parallel mode allows the use of multiple threads on multiple cores but there is no guarantee of the order in which elements are processed. If multiple methods are called on a sequential Stream , not every method has to be invoked. For example, if a Stream is \ufb01ltered and the number of elements is reduced to one, a subsequent call to a method such as sort will not occur. This can increase the performance of a sequential Stream an optimization that is not possible with a parallel Stream . Example parallel long howManyOddNumbersParallel integerList. parallelStream . filtere - e 2 1 . count System.out.printlnhowManyOddNumbersParallel Output 2 Live on Ideone Di\ufb00erences from Containers or Collections While some actions can be performed on both Containers and Streams, they ultimately serve di\ufb00erent purposes and support di\ufb00erent operations. Containers are more focused on how the elements are stored and how those elements can be accessed e\ufb03ciently. A Stream , on the other hand, doesnt provide direct access and manipulation to its elements it is more dedicated to the group of objects as a collective entity and performing operations on that entity as a", "whole. Stream and Collection are separate high-level abstractions for these di\ufb00ering purposes. Section 57.2 Consuming Streams A Stream will only be traversed when there is a terminal operation , like count, collect or forEach. Otherwise, no operation on the Stream will be performed. In the following example, no terminal operation is added to the Stream , so the filter operation will not be invoked and no output will be produced because peek is NOT a terminal operation . GoalKicker.com Java Notes for Professionals 329IntStream. range1, 10.filtera - a 2 0.peekSystem.outprintln Live on Ideone This is a Stream sequence with a valid terminal operation , thus an output is produced. You could also use forEach instead of peek IntStream. range1, 10.filtera - a 2 0.forEachSystem.outprintln Live on Ideone Output 2 4 6 8 After the terminal operation is performed, the Stream is consumed and cannot be reused. Although a given stream object cannot be reused, its easy to create a reusable Iterable that delegates to a stream pipeline. This can be useful for returning a modi\ufb01ed view of a live data set without having to collect results into a temporary structure. ListString list Arrays.asListFOO, BAR Iterable String iterable - list.stream.mapStringtoLowerCase", ".iterator for String str iterable System.out.printlnstr for String str iterable System.out.printlnstr Output foo bar foo bar This works because Iterable declares a single abstract method Iterator T iterator . That makes it e\ufb00ectively a functional interface, implemented by a lambda that creates a new stream on each call. In general, a Stream operates as shown in the following image GoalKicker.com Java Notes for Professionals 330 NOTE Argument checks are always performed, even without a terminal operation try IntStream. range1, 10.filternull catch NullPointerException e System.out.printlnWe got a NullPointerException as null was passed as an argument to filter Live on Ideone Output We got a NullPointerException as null was passed as an argument to \ufb01lter Section 57.3 Creating a Frequency Map The groupingBy classifier, downstream collector allows the collection of Stream elements into a Map by classifying each element in a group and performing a downstream operation on the elements classi\ufb01ed in the same group. A classic example of this principle is to use a Map to count the occurrences of elements in a Stream . In this example, the classi\ufb01er is simply the identity function, which returns the element as-is. The downstream operation counts the number of equal elements, using", "counting . Stream.ofapple, orange , banana , apple .collectCollectors. groupingBy Function. identity , Collectors. counting .entrySet .forEachSystem.outprintln The downstream operation is itself a collector Collectors. counting that operates on elements of type String and produces a result of type Long . The result of the collect method call is a MapString, Long. This would produce the following output banana1 orange1 apple2 Section 57.4 In\ufb01nite Streams It is possible to generate a Stream that does not end. Calling a terminal method on an in\ufb01nite Stream causes the Stream to enter an in\ufb01nite loop. The limit method of a Stream can be used to limit the number of terms of the Stream that Java processes. GoalKicker.com Java Notes for Professionals 331This example generates a Stream of all natural numbers, starting with the number 1. Each successive term of the Stream is one higher than the previous. By calling the limit method of this Stream , only the \ufb01rst \ufb01ve terms of the Stream are considered and printed. Generate infinite stream - 1, 2, 3, 4, 5, 6, 7, ... IntStream naturalNumbers IntStream. iterate1, x - x 1 Print out only the first 5 terms naturalNumbers. limit5.forEachSystem.outprintln Output 1 2 3 4", "5 Another way of generating an in\ufb01nite stream is using the Stream.generate method. This method takes a lambda of type Supplier . Generate an infinite stream of random numbers StreamDouble infiniteRandomNumbers Stream. generate Mathrandom Print out only the first 10 random numbers infiniteRandomNumbers. limit10.forEachSystem.outprintln Section 57.5 Collect Elements of a Stream into a Collection Collect with toList and toSet Elements from a Stream can be easily collected into a container by using the Stream.collect operation System.out.printlnArrays .asListapple, banana , pear, kiwi, orange .stream .filters - s.contains a .collectCollectors. toList prints apple, banana, pear, orange Other collection instances, such as a Set, can be made by using other Collectors built-in methods. For example, Collectors. toSet collects the elements of a Stream into a Set. Explicit control over the implementation of List or Set According to documentation of CollectorstoList and CollectorstoSet , there are no guarantees on the type, mutability, serializability, or thread-safety of the List or Set returned. For explicit control over the implementation to be returned, CollectorstoCollection Supplier can be used instead, where the given supplier returns a new and empty collection. syntax with method reference GoalKicker.com Java Notes for Professionals 332System.out.printlnstrings . stream . filters - s !", "null s.length 3 . collectCollectors. toCollection ArrayList new syntax with lambda System.out.printlnstrings . stream . filters - s ! null s.length 3 . collectCollectors. toCollection - new LinkedHashSet Collecting Elements using toMap Collector accumulates elements into a Map, Where key is the Student Id and Value is Student Value. ListStudent students new ArrayList Student students. addnew Student 1,test1 students. addnew Student 2,test2 students. addnew Student 3,test3 MapInteger, String IdToName students. stream . collectCollectors. toMapStudentgetId, Student getName System.out.printlnIdToName Output 1test1, 2test2, 3test3 The Collectors.toMap has another implementation Collector T, ?, MapK,U toMapFunction ? super T, ? extends K keyMapper, Function ? super T, ? extends U valueMapper, BinaryOperator U mergeFunction .The mergeFunction is mostly used to select either new value or retain old value if the key is repeated when adding a new member in the Map from a list. The mergeFunction often looks like s1, s2 - s1 to retain value corresponding to the repeated key, or s1, s2 - s2 to put new value for the repeated key. Collecting Elements to Map of Collections Example from ArrayList to MapString, List Often it requires to make a map of list out of a primary list. Example From a student", "of list, we need to make a map of list of subjects for each student. List Student list new ArrayList list. addnew Student Davis, SUBJECT. MATH, 35.0 list. addnew Student Davis, SUBJECT. SCIENCE, 12.9 list. addnew Student Davis, SUBJECT. GEOGRAPHY , 37.0 list. addnew Student Sascha , SUBJECT. ENGLISH, 85.0 list. addnew Student Sascha , SUBJECT. MATH, 80.0 list. addnew Student Sascha , SUBJECT. SCIENCE, 12.0 list. addnew Student Sascha , SUBJECT. LITERATURE , 50.0 list. addnew Student Robert , SUBJECT. LITERATURE , 12.0 GoalKicker.com Java Notes for Professionals 333 MapString, ListSUBJECT map new HashMap list. stream.forEachs - map. computeIfAbsent s.getName, x - new ArrayList .adds.getSubject System.out.printlnmap Output RobertLITERATURE, SaschaENGLISH, MATH, SCIENCE, LITERATURE, DavisMATH, SCIENCE, GEOGRAPHY Example from ArrayList to MapString, Map List Student list new ArrayList list. addnew Student Davis, SUBJECT. MATH, 1, 35.0 list. addnew Student Davis, SUBJECT. SCIENCE, 2, 12.9 list. addnew Student Davis, SUBJECT. MATH, 3, 37.0 list. addnew Student Davis, SUBJECT. SCIENCE, 4, 37.0 list. addnew Student Sascha , SUBJECT. ENGLISH, 5, 85.0 list. addnew Student Sascha , SUBJECT. MATH, 1, 80.0 list. addnew Student Sascha , SUBJECT. ENGLISH, 6, 12.0 list. addnew Student Sascha , SUBJECT. MATH, 3, 50.0 list. addnew Student Robert", ", SUBJECT. ENGLISH, 5, 12.0 MapString, MapSUBJECT, List Double map new HashMap list. stream.forEachstudent - map. computeIfAbsent student. getName, s - new HashMap . computeIfAbsent student. getSubject , s - new ArrayList . addstudent. getMarks System.out.printlnmap Output RobertENGLISH12.0, SaschaMATH80.0, 50.0, ENGLISH85.0, 12.0, DavisMATH35.0, 37.0, SCIENCE12.9, 37.0 Cheat-Sheet Goal Code Collect to a List Collectors. toList Collect to an ArrayList with pre- allocated sizeCollectors. toCollection - new ArrayList size Collect to a Set Collectors. toSet Collect to a Set with better iteration performanceCollectors. toCollection - new LinkedHashSet Collect to a case-insensitive SetStringCollectors. toCollection - new TreeSetString.CASEINSENSITIVEORDER Collect to an EnumSetAnEnum best performance for enumsCollectors. toCollection - EnumSet. noneOfAnEnum.class GoalKicker.com Java Notes for Professionals 334Collect to a MapK,V with unique keys Collectors. toMapkeyFunc,valFunc Map MyObject.getter to unique MyObjectCollectors. toMapMyObject getter, Function. identity Map MyObject.getter to multiple MyObjectsCollectors. groupingBy MyObject getter Section 57.6 Using Streams to Implement Mathematical Functions Stream s, and especially IntStream s, are an elegant way of implementing summation terms . The ranges of the Stream can be used as the bounds of the summation. E.g., Madhavas approximation of Pi is given by the formula Source wikipedia This can be calculated with an arbitrary precision. E.g., for 101 terms", "double pi Math.sqrt12 IntStream. rangeClosed 0, 100 . mapToDouble k - Math.pow-3, -1 k 2 k 1 . sum Note With double s precision, selecting an upper bound of 29 is su\ufb03cient to get a result thats indistinguishable from Math.Pi. Section 57.7 Flatten Streams with \ufb02atMap A Stream of items that are in turn streamable can be \ufb02attened into a single continuous Stream Array of List of Items can be converted into a single List. ListString list1 Arrays.asListone, two List String list2 Arrays.asListthree,four,five List String list3 Arrays.asListsix List String finalList Stream. oflist1, list2, list3.flatMapCollection stream.collectCollectors. toList System.out.printlnfinalList one, two, three, four, five, six Map containing List of Items as values can be Flattened to a Combined List MapString, ListInteger map new LinkedHashMap map.puta, Arrays.asList1, 2, 3 map.putb, Arrays.asList4, 5, 6 ListInteger allValues map.values CollectionListInteger . stream StreamListInteger . flatMapListstream StreamInteger . collectCollectors. toList System.out.printlnallValues 1, 2, 3, 4, 5, 6 List of Map can be \ufb02attened into a single continuous Stream GoalKicker.com Java Notes for Professionals 335ListMapString, String list new ArrayList MapString,String map1 new HashMap map1.put1, one map1.put2, two MapString,String map2 new HashMap map2.put3, three map2.put4, four list.addmap1 list.addmap2 SetString output list.stream StreamMapString, String .mapMapvalues StreamListString .flatMapCollection stream StreamString", ".collectCollectors. toSet SetString one, two, three,four Section 57.8 Parallel Stream Note Before deciding which Stream to use please have a look at ParallelStream vs Sequential Stream behavior . When you want to perform Stream operations concurrently, you could use either of these ways. ListString data Arrays.asListOne, Two, Three, Four, Five StreamString aParallelStream data.stream.parallel Or StreamString aParallelStream data.parallelStream To execute the operations de\ufb01ned for the parallel stream, call a terminal operator aParallelStream. forEachSystem.outprintln A possible output from the parallel Stream Three Four One Two Five The order might change as all the elements are processed in parallel Which may make it faster. Use parallelStream when ordering does not matter. Performance impact In case networking is involved, parallel Stream s may degrade the overall performance of an application because all parallel Stream s use a common fork-join thread pool for the network. On the other hand, parallel Stream s may signi\ufb01cantly improve performance in many other cases, depending of the number of available cores in the running CPU at the moment. GoalKicker.com Java Notes for Professionals 336Section 57.9 Creating a Stream All java Collection Es have stream and parallelStream methods from which a StreamE can be constructed Collection String stringList new", "ArrayList StreamString stringStream stringList. parallelStream A StreamE can be created from an array using one of two methods String values aaa, bbbb, ddd, cccc StreamString stringStream Arrays.streamvalues StreamString stringStreamAlternative Stream. ofvalues The di\ufb00erence between Arrays.stream and Stream.of is that Stream.of has a varargs parameter, so it can be used like StreamInteger integerStream Stream. of1, 2, 3 There are also primitive Stream s that you can use. For example IntStream intStream IntStream. of1, 2, 3 DoubleStream doubleStream DoubleStream. of1.0, 2.0, 3.0 These primitive streams can also be constructed using the Arrays.stream method IntStream intStream Arrays.streamnew int 1, 2, 3 It is possible to create a Stream from an array with a speci\ufb01ed range. int values new int1, 2, 3, 4, 5 IntStream intStram Arrays.streamvalues, 1, 3 Note that any primitive stream can be converted to boxed type stream using the boxed method StreamInteger integerStream intStream. boxed This can be useful in some case if you want to collect the data since primitive stream does not have any collect method that takes a Collector as argument. Reusing intermediate operations of a stream chain Stream is closed when ever terminal operation is called. Reusing the stream of intermediate operations, when only terminal", "operation is only varying. we could create a stream supplier to construct a new stream with all intermediate operations already set up. Supplier StreamString streamSupplier - Stream. ofapple, banana ,orange , grapes , melon,blueberry ,blackberry .mapStringtoUpperCase .sorted streamSupplier. get.filters - s.startsWith A.forEachSystem.outprintln APPLE streamSupplier. get.filters - s.startsWith B.forEachSystem.outprintln GoalKicker.com Java Notes for Professionals 337 BANANA BLACKBERRY BLUEBERRY int arrays can be converted to ListInteger using streams int ints 1,2,3 ListInteger list IntStream. ofints.boxed.collectCollectors. toList Section 57.10 Finding Statistics about Numerical Streams Java 8 provides classes called IntSummaryStatistics , DoubleSummaryStatistics and LongSummaryStatistics which give a state object for collecting statistics such as count , min, max, sum, and average . Version Java SE 8 ListInteger naturalNumbers Arrays.asList1, 2, 3, 4, 5, 6, 7, 8, 9, 10 IntSummaryStatistics stats naturalNumbers. stream . mapToInt x - x . summaryStatistics System.out.printlnstats Which will result in Version Java SE 8 IntSummaryStatistics count10, sum55, min1, max10, average 5.500000 Section 57.11 Converting an iterator to a stream Use Spliterators. spliterator or Spliterators. spliteratorUnknownSize to convert an iterator to a stream Iterator String iterator Arrays.asListA, B, C.iterator Spliterator String spliterator Spliterators. spliteratorUnknownSize iterator, 0 StreamString stream StreamSupport. streamspliterator, false Section 57.12 Using IntStream to iterate over indexes", "Stream s of elements usually do not allow access to the index value of the current item. To iterate over an array or ArrayList while having access to indexes, use IntStream. rangestart, endExclusive . String names Jon, Darin, Bauke, Hans, Marc IntStream. range0, names. length .mapToObj i - String.formatd s , i 1, namesi .forEachSystem.outprintln The rangestart, endExclusive method returns another \u00ccntStream and the mapToObj mapper returns a stream of String . Output 1 Jon 2 Darin 3 Bauke 4 Hans GoalKicker.com Java Notes for Professionals 3385 Marc This is very similar to using a normal for loop with a counter, but with the bene\ufb01t of pipelining and parallelization for int i 0 i names.length i String newName String.formatd s , i 1, namesi System.out.printlnnewName Section 57.13 Concatenate Streams Variable declaration for examples Collection String abc Arrays.asLista, b, c Collection String digits Arrays.asList1, 2, 3 Collection String greekAbc Arrays.asListalpha, beta, gamma Example 1 - Concatenate two Stream s final StreamString concat1 Stream. concatabc.stream, digits. stream concat1. forEachSystem.outprint prints abc123 Example 2 - Concatenate more than two Stream s final StreamString concat2 Stream. concat Stream. concatabc.stream, digits. stream, greekAbc. stream System.out.printlnconcat2. collectCollectors. joining, prints a, b, c, 1, 2, 3,", "alpha, beta, gamma Alternatively to simplify the nested concat syntax the Stream s can also be concatenated with flatMap final StreamString concat3 Stream. of abc. stream, digits. stream, greekAbc. stream .flatMaps - s or .flatMapFunction.identity java.util.function.Function System.out.printlnconcat3. collectCollectors. joining, prints a, b, c, 1, 2, 3, alpha, beta, gamma Be careful when constructing Stream s from repeated concatenation, because accessing an element of a deeply concatenated Stream can result in deep call chains or even a StackOverflowException . Section 57.14 Reduction with Streams Reduction is the process of applying a binary operator to every element of a stream to result in one value. The sum method of an IntStream is an example of a reduction it applies addition to every term of the Stream, resulting in one \ufb01nal value GoalKicker.com Java Notes for Professionals 339 This is equivalent to 1234 The reduce method of a Stream allows one to create a custom reduction. It is possible to use the reduce method to implement the sum method IntStream istr Initialize istr OptionalInt istr. reducea,b-ab The Optional version is returned so that empty Streams can be handled appropriately. Another example of reduction is combining a StreamLinkedList T into a single LinkedList", "T StreamLinkedList T listStream Create a StreamLinkedListT GoalKicker.com Java Notes for Professionals 340 Optional LinkedList T bigList listStream. reduceLinkedList T list1, LinkedList T list2- LinkedList T retList new LinkedList T retList. addAlllist1 retList. addAlllist2 return retList You can also provide an identity element . For example, the identity element for addition is 0, as x0x. For multiplication, the identity element is 1, as x1x. In the case above, the identity element is an empty LinkedList T, because if you add an empty list to another list, the list that you are adding to doesnt change StreamLinkedList T listStream Create a StreamLinkedListT LinkedList T bigList listStream. reducenew LinkedList T, LinkedList T list1, LinkedList T list2- LinkedList T retList new LinkedList T retList. addAlllist1 retList. addAlllist2 return retList Note that when an identity element is provided, the return value is not wrapped in an Optional if called on an empty stream, reduce will return the identity element. The binary operator must also be associative , meaning that abcabc. This is because the elements may be reduced in any order. For example, the above addition reduction could be performed like this GoalKicker.com Java Notes for Professionals 341This reduction is equivalent to writing", "1234. The property of associativity also allows Java to reduce the Stream in parallel a portion of the Stream can be reduced by each processor, with a reduction combining the result of each processor at the end. Section 57.15 Using Streams of Map.Entry to Preserve Initial Values after Mapping When you have a Stream you need to map but want to preserve the initial values as well, you can map the Stream to a Map.EntryK,V using a utility method like the following public static K, V Function K, Map.EntryK, V entryMapper Function K, V mapper return k-new AbstractMap .SimpleEntry k, mapper. applyk Then you can use your converter to process Stream s having access to both the original and mapped values SetK mySet Function K, V transformer SomeClass transformerMethod StreamMap.EntryK, V entryStream mySet.stream .mapentryMapper transformer You can then continue to process that Stream as normal. This avoids the overhead of creating an intermediate collection. Section 57.16 IntStream to String Java does not have a Char Stream , so when working with String s and constructing a Stream of Character s, an option is to get a IntStream of code points using String.codePoints method. So IntStream can be obtained as", "below public IntStream stringToIntStream String in return in.codePoints It is a bit more involved to do the conversion other way around i.e. IntStreamToString. That can be done as follows public String intStreamToString IntStream intStream return intStream. collectStringBuilder new, StringBuilder appendCodePoint, StringBuilder append.toString Section 57.17 Finding the First Element that Matches a Predicate It is possible to \ufb01nd the \ufb01rst element of a Stream that matches a condition. For this example, we will \ufb01nd the \ufb01rst Integer whose square is over 50000 . IntStream. iterate1, i - i 1 Generate an infinite stream 1,2,3,4... .filteri - ii 50000 Filter to find elements where the square is 50000 .findFirst Find the first filtered element This expression will return an OptionalInt with the result. GoalKicker.com Java Notes for Professionals 342Note that with an in\ufb01nite Stream , Java will keep checking each element until it \ufb01nds a result. With a \ufb01nite Stream , if Java runs out of elements but still cant \ufb01nd a result, it returns an empty OptionalInt . Section 57.18 Using Streams and Method References to Write Self-Documenting Processes Method references make excellent self-documenting code, and using method references with Stream s makes complicated processes simple to read and understand.", "Consider the following code public interface Ordered default int getOrder return 0 public interface ValuedV extends Ordered boolean hasPropertyTwo V getValue public interface ThingV extends Ordered boolean hasPropertyOne Valued V getValuedProperty public V extends Ordered ListV myMethod ListThingV things List V results new ArrayList V for ThingV thing things if thing.hasPropertyOne Valued V valued thing.getValuedProperty if valued ! null valued. hasPropertyTwo V value valued. getValue if value ! null results. addvalue results. sorta, b- return Integer.comparea.getOrder , b.getOrder return results This last method rewritten using Stream s and method references is much more legible and each step of the process is quickly and easily understood - its not just shorter, it also shows at a glance which interfaces and classes are responsible for the code in each step public V extends Ordered ListV myMethod ListThingV things return things. stream . filterThinghasPropertyOne . mapThinggetValuedProperty . filterObjectsnonNull . filterValuedhasPropertyTwo . mapValuedgetValue . filterObjectsnonNull . sortedComparator .comparing OrderedgetOrder . collectCollectors. toList GoalKicker.com Java Notes for Professionals 343 Section 57.19 Converting a Stream of Optional to a Stream of Values You may need to convert a Stream emitting Optional to a Stream of values, emitting only values from existing Optional . ie without", "null value and not dealing with Optional. empty. Optional String op1 Optional. empty Optional String op2 Optional. ofHello World ListString result Stream. ofop1, op2 . filterOptional isPresent . mapOptional get . collectCollectors. toList System.out.printlnresult Hello World Section 57.20 Get a Slice of a Stream Example Get a Stream of 30 elements, containing 21st to 50th inclusive element of a collection. final long n 20L the number of elements to skip final long maxSize 30L the number of elements the stream should be limited to final StreamT slice collection. stream.skipn.limitmaxSize Notes IllegalArgumentException is thrown if n is negative or maxSize is negative both skiplong and limitlong are intermediate operations if a stream contains fewer than n elements then skipn returns an empty stream both skiplong and limitlong are cheap operations on sequential stream pipelines, but can be quite expensive on ordered parallel pipelines Section 57.21 Create a Map based on a Stream Simple case without duplicate keys StreamString characters Stream. ofA, B, C MapInteger, String map characters . collectCollectors. toMapelement - element. hashCode , element - element map 65A, 66B, 67C To make things more declarative, we can use static method in Function interface - Function. identity . We can", "replace this lambda element - element with Function. identity . Case where there might be duplicate keys The javadoc for Collectors. toMap states If the mapped keys contains duplicates according to Object.equalsObject, an IllegalStateException is thrown when the collection operation is performed. If the mapped keys may have duplicates, use toMapFunction, Function, BinaryOperator instead. GoalKicker.com Java Notes for Professionals 344StreamString characters Stream. ofA, B, B, C MapInteger, String map characters . collectCollectors. toMap element - element. hashCode , element - element, existingVal, newVal - existingVal newVal map 65A, 66BB, 67C The BinaryOperator passed to Collectors. toMap... generates the value to be stored in the case of a collision. It can return the old value, so that the \ufb01rst value in the stream takes precedence, return the new value, so that the last value in the stream takes precedence, or combine the old and new values Grouping by value You can use Collectors. groupingBy when you need to perform the equivalent of a database cascaded group by operation. To illustrate, the following creates a map in which peoples names are mapped to surnames ListPerson people Arrays.asList new PersonSam, Rossi, new PersonSam, Verdi, new PersonJohn, Bianchi , new PersonJohn, Rossi, new", "PersonJohn, Verdi MapString, ListString map people. stream . collect function mapping input elements to keys Collectors. groupingBy PersongetName, function mapping input elements to values, how to store values Collectors. mappingPersongetSurname, Collectors. toList map JohnBianchi, Rossi, Verdi, SamRossi, Verdi Live on Ideone Section 57.22 Joining a stream to a single String A use case that comes across frequently, is creating a String from a stream, where the stream-items are separated by a certain character. The Collectors. joining method can be used for this, like in the following example StreamString fruitStream Stream. ofapple, banana , pear, kiwi, orange String result fruitStream. filters - s.contains a . mapStringtoUpperCase . sorted . collectCollectors. joining, System.out.printlnresult Output GoalKicker.com Java Notes for Professionals 345APPLE, BANANA, ORANGE, PEAR The Collectors. joining method can also cater for pre- and post\ufb01xes String result fruitStream. filters - s.contains e . mapStringtoUpperCase . sorted . collectCollectors. joining, , Fruits , . System.out.printlnresult Output Fruits APPLE, ORANGE, PEAR. Live on Ideone Section 57.23 Sort Using Stream ListString data new ArrayList data.addSydney data.addLondon data.addNew York data.addAmsterdam data.addMumbai data.addCalifornia System.out.printlndata ListString sortedData data.stream.sorted.collectCollectors. toList System.out.printlnsortedData Output Sydney, London, New York, Amsterdam, Mumbai, California Amsterdam, California, London, Mumbai, New York, Sydney Its also possible", "to use di\ufb00erent comparison mechanism as there is a overloaded sorted version which takes a comparator as its argument. Also, you can use a lambda expression for sorting ListString sortedData2 data.stream.sorteds1,s2 - s2.compareTo s1.collectCollectors. toList This would output Sydney, New York, Mumbai, London, California, Amsterdam You can use Comparator .reverseOrder to have a comparator that imposes the reverse of the natural ordering. ListString reverseSortedData GoalKicker.com Java Notes for Professionals 346data.stream.sortedComparator .reverseOrder .collectCollectors. toList Section 57.24 Streams of Primitives Java provides specialized Stream s for three types of primitives IntStream for ints, LongStream for long s and DoubleStream for double s. Besides being optimized implementations for their respective primitives, they also provide several speci\ufb01c terminal methods, typically for mathematical operations. E.g. IntStream is IntStream. of10, 20, 30 double average is.average.getAsDouble average is 20.0 Section 57.25 Stream operations categories Stream operations fall into two main categories, intermediate and terminal operations, and two sub-categories, stateless and stateful. Intermediate Operations An intermediate operation is always lazy, such as a simple Stream.map. It is not invoked until the stream is actually consumed. This can be veri\ufb01ed easily Arrays.asList1, 2 ,3.stream.mapi - throw new RuntimeException not gonna happen return i Intermediate operations are the common", "building blocks of a stream, chained after the source and are usually followed by a terminal operation triggering the stream chain. Terminal Operations Terminal operations are what triggers the consumption of a stream. Some of the more common are Stream.forEach or Stream.collect . They are usually placed after a chain of intermediate operations and are almost always eager . Stateless Operations Statelessness means that each item is processed without the context of other items. Stateless operations allow for memory-e\ufb03cient processing of streams. Operations like Stream.map and Stream.filter that do not require information on other items of the stream are considered to be stateless. Stateful operations Statefulness means the operation on each item depends on some other items of the stream. This requires a state to be preserved. Statefulness operations may break with long, or in\ufb01nite, streams. Operations like Stream.sorted require the entirety of the stream to be processed before any item is emitted which will break in a long enough stream of items. This can be demonstrated by a long stream run at your own risk works - stateless stream long BIGENOUGHNUMBER 999999999 GoalKicker.com Java Notes for Professionals 347IntStream. iterate0, i - i 1.limitBIGENOUGHNUMBER .forEachSystem.outprintln This will cause an", "out-of-memory due to statefulness of Stream.sorted Out of memory - stateful stream IntStream. iterate0, i - i 1.limitBIGENOUGHNUMBER .sorted.forEachSystem.outprintln Section 57.26 Collect Results of a Stream into an Array Analog to get a collection for a Stream by collect an array can be obtained by the Stream.toArray method ListString fruits Arrays.asListapple, banana , pear, kiwi, orange String filteredFruits fruits. stream .filters - s.contains a .toArrayStringnew prints apple, banana, pear, orange System.out.printlnArrays.toString filteredFruits Stringnew is a special kind of method reference a constructor reference. Section 57.27 Generating random Strings using Streams It is sometimes useful to create random Strings , maybe as Session-ID for a web-service or an initial password after registration for an application. This can be easily achieved using Stream s. First we need to initialize a random number generator. To enhance security for the generated String s, it is a good idea to use SecureRandom . Note Creating a SecureRandom is quite expensive, so it is best practice to only do this once and call one of its setSeed methods from time to time to reseed it. private static final SecureRandom rng new SecureRandom SecureRandom .generateSeed 20 20 Bytes as a seed is rather arbitrary, it is", "the number used in the JavaDoc example When creating random String s, we usually want them to use only certain characters e.g. only letters and digits. Therefore we can create a method returning a boolean which can later be used to \ufb01lter the Stream . returns true for all chars in 0-9, a-z and A-Z boolean useThisCharacter char c check for range to avoid using all unicode Letter e.g. some chinese symbols return c 0 c z Character .isLetterOrDigit c Next we can utilize the RNG to generate a random String of speci\ufb01c length containing the charset which pass our useThisCharacter check. public String generateRandomString long length Since there is no native CharStream, we use an IntStream instead and convert it to a StreamCharacter using mapToObj. We need to specify the boundaries for the int values to ensure they can safely be cast to char Stream Character randomCharStream rng.intsCharacter .MINCODEPOINT , Character .MAXCODEPOINT .mapToObj i - chari.filterc - thisuseThisCharacter .limitlength now we can use this Stream to build a String utilizing the collect method. GoalKicker.com Java Notes for Professionals 348 String randomString randomCharStream. collectStringBuilder new, StringBuilder append, StringBuilder append.toString return randomString GoalKicker.com Java Notes for Professionals 349Chapter 58 InputStreams", "and OutputStreams Section 58.1 Closing Streams Most streams must be closed when you are done with them, otherwise you could introduce a memory leak or leave a \ufb01le open. It is important that streams are closed even if an exception is thrown. Version Java SE 7 tryFileWriter fw new FileWriter outfilename BufferedWriter bw new BufferedWriter fw PrintWriter out new PrintWriter bw out. printlnthe text more code out. printlnmore text more code catch IOException e handle this however you Remember try-with-resources guarantees, that the resources have been closed when the block is exited, whether that happens with the usual control \ufb02ow or because of an exception. Version Java SE 6 Sometimes, try-with-resources is not an option, or maybe youre supporting older version of Java 6 or earlier. In this case, proper handling is to use a finally block FileWriter fw null BufferedWriter bw null PrintWriter out null try fw new FileWriter myfile.txt bw new BufferedWriter fw out new PrintWriter bw out. printlnthe text out. close catch IOException e handle this however you want finally try ifout ! null out. close catch IOException e typically not much you can do here... Note that closing a wrapper stream will also close its", "underlying stream. This means you cannot wrap a stream, close the wrapper and then continue using the original stream. Section 58.2 Reading InputStream into a String Sometimes you may wish to read byte-input into a String. To do this you will need to \ufb01nd something that converts GoalKicker.com Java Notes for Professionals 350between byte and the native Java UTF-16 Codepoints used as char . That is done with a InputStreamReader . To speed the process up a bit, its usual to allocate a bu\ufb00er, so that we dont have too much overhead when reading from Input. Version Java SE 7 public String inputStreamToString InputStream inputStream throws Exception StringWriter writer new StringWriter char buffer new char1024 try Reader reader new BufferedReader new InputStreamReader inputStream, UTF-8 int n while n reader. readbuffer ! -1 all this code does is redirect the output of reader to writer in 1024 byte chunks writer. writebuffer, 0, n return writer. toString Transforming this example to Java SE 6 and lower-compatible code is left out as an exercise for the reader. Section 58.3 Wrapping InputOutput Streams OutputStream and InputStream have many di\ufb00erent classes, each of them with a unique functionality. By wrapping a stream around another,", "you gain the functionality of both streams. You can wrap a stream any number of times, just take note of the ordering. Useful combinations Writing characters to a \ufb01le while using a bu\ufb00er File myFile new FiletargetFile.txt PrintWriter writer new PrintWriter new BufferedOutputStream new FileOutputStream myFile Compressing and encrypting data before writing to a \ufb01le while using a bu\ufb00er Cipher cipher ... Initialize cipher File myFile new FiletargetFile.enc BufferedOutputStream outputStream new BufferedOutputStream new DeflaterOutputStream new CipherOutputStream new FileOutputStream myFile, cipher List of InputOutput Stream wrappers Wrapper Description Bu\ufb00eredOutputStream Bu\ufb00eredInputStreamWhile OutputStream writes data one byte at a time, BufferedOutputStream writes data in chunks. This reduces the number of system calls, thus improving performance. De\ufb02aterOutputStream De\ufb02aterInputStreamPerforms data compression. In\ufb02aterOutputStream In\ufb02aterInputStream Performs data decompression. CipherOutputStream CipherInputStream EncryptsDecrypts data. DigestOutputStream DigestInputStream Generates Message Digest to verify data integrity. CheckedOutputStream CheckedInputStreamGenerates a CheckSum. CheckSum is a more trivial version of Message Digest. GoalKicker.com Java Notes for Professionals 351DataOutputStream DataInputStreamAllows writing of primitive data types and Strings. Meant for writing bytes. Platform independent. PrintStreamAllows writing of primitive data types and Strings. Meant for writing bytes. Platform dependent. OutputStreamWriterConverts a OutputStream into a Writer. An OutputStream deals with bytes while Writers deals with characters PrintWriterAutomatically calls", "OutputStreamWriter. Allows writing of primitive data types and Strings. Strictly for writing characters and best for writing characters Section 58.4 DataInputStream Example package com.streams import java.io. public class DataStreamDemo public static void mainString args throws IOException InputStream input new FileInputStream Ddatastreamdemo.txt DataInputStream inst new DataInputStream input int count input.available byte arr new bytecount inst. readarr for byte byt arr char ki char byt System.out.printki- Section 58.5 Writing bytes to an OutputStream Writing bytes to an OutputStream one byte at a time OutputStream stream object. getOutputStream byte b 0x00 stream.write b Writing a byte array byte bytes new byte 0x00, 0x00 stream.write bytes Writing a section of a byte array int offset 1 int length 2 byte bytes new byte 0xFF, 0x00, 0x00, 0xFF stream.write bytes, offset, length Section 58.6 Copying Input Stream to Output Stream This function copies data between two streams - void copyInputStream in, OutputStream out throws IOException GoalKicker.com Java Notes for Professionals 352 byte buffer new byte8192 while bytesRead in.readbuffer 0 out. writebuffer, 0, bytesRead Example - reading from System.in and writing to System.out copySystem.in, System.out GoalKicker.com Java Notes for Professionals 353Chapter 59 Readers and Writers Readers and Writers and their respective subclasses provide simple IO", "for text character-based data. Section 59.1 BueredReader Introduction The BufferedReader class is a wrapper for other Reader classes that serves two main purposes A BufferedReader provides bu\ufb00ering for the wrapped Reader . This allows an application to read characters 1. one at a time without undue IO overheads. A BufferedReader provides functionality for reading text a line at a time. 2. Basics of using a Bu\ufb00eredReader The normal pattern for using a BufferedReader is as follows. First, you obtain the Reader that you want to read characters from. Next you instantiate a BufferedReader that wraps the Reader . Then you read character data. Finally you close the BufferedReader which close the wrapped Reader. For example File someFile new File... int aCount 0 try FileReader fr new FileReader someFile BufferedReader br new BufferedReader fr Count the number of a characters. int ch while ch br.read ! -1 if ch a aCount System.out.printlnThere are aCount a characters in someFile You can apply this pattern to any Reader Notes We have used Java 7 or later try-with-resources to ensure that the underlying reader is always closed. This 1. avoids a potential resource leak. In earlier versions of Java, you would explicitly close", "the BufferedReader in a finally block. The code inside the try block is virtually identical to what we would use if we read directly from the 2. FileReader . In fact, a BufferedReader functions exactly like the Reader that it wraps would behave. The di\ufb00erence is that this version is a lot more e\ufb03cient. The Bu\ufb00eredReader bu\ufb00er size The Bu\ufb00eredReader.readLine method Example reading all lines of a File into a List This is done by getting each line in a \ufb01le, and adding it into a ListString. The list is then returned public ListString getAllLines String filename throws IOException List String lines new ArrayList String GoalKicker.com Java Notes for Professionals 354 try BufferedReader br new BufferedReader new FileReader filename String line null while line reader. readLine ! null lines. addline return lines Java 8 provides a more concise way to do this using the lines method public ListString getAllLines String filename throws IOException try BufferedReader br new BufferedReader new FileReader filename return br.lines.collectCollectors. toList return Collections .empty Section 59.2 StringWriter Example Java StringWriter class is a character stream that collects output from string bu\ufb00er, which can be used to construct a string. The StringWriter class extends the Writer class.", "In StringWriter class, system resources like network sockets and \ufb01les are not used, therefore closing the StringWriter is not necessary. import java.io. public class StringWriterDemo public static void mainString args throws IOException char ary new char1024 StringWriter writer new StringWriter FileInputStream input null BufferedReader buffer null input new FileInputStream cstringwriter.txt buffer new BufferedReader new InputStreamReader input, UTF-8 int x while x buffer. readary ! -1 writer. writeary, 0, x System.out.printlnwriter.toString writer. close buffer. close The above example helps us to know simple example of StringWriter using Bu\ufb00eredReader to read \ufb01le data from the stream. GoalKicker.com Java Notes for Professionals 355Chapter 60 Preferences Section 60.1 Using preferences Preferences can be used to store user settings that re\ufb02ect a users personal application settings, e.g. their editor font, whether they prefer the application to be started in full-screen mode, whether they checked a dont show this again checkbox and things like that. public class ExitConfirmer private static boolean confirmExit Preferences preferences Preferences. userNodeForPackage ExitConfirmer. class boolean doShowDialog preferences. getBoolean showExitConfirmation , true true is default value if !doShowDialog return true Show a dialog here... boolean exitWasConfirmed ... whether the user clicked OK or Cancel boolean doNotShowAgain ... get value from Do not", "show again checkbox if exitWasConfirmed doNotShowAgain Exit was confirmed and the user chose that the dialog should not be shown again Save these settings to the Preferences object so the dialog will not show again next time preferences. putBoolean showExitConfirmation , false return exitWasConfirmed public static void exit if confirmExit System.exit0 Section 60.2 Adding event listeners There are two types of events emitted by a Preferences object PreferenceChangeEvent and NodeChangeEvent . PreferenceChangeEvent A PreferenceChangeEvent gets emitted by a Properties object every time one of the nodes key-value-pairs changes. PreferenceChangeEvent s can be listened for with a PreferenceChangeListener Version Java SE 8 preferences. addPreferenceChangeListener evt - String newValue evt.getNewValue String changedPreferenceKey evt.getKey Preferences changedNode evt.getNode Version Java SE 8 GoalKicker.com Java Notes for Professionals 356preferences. addPreferenceChangeListener new PreferenceChangeListener Override public void preferenceChange PreferenceChangeEvent evt String newValue evt.getNewValue String changedPreferenceKey evt.getKey Preferences changedNode evt.getNode This listener will not listen to changed key-value pairs of child nodes. NodeChangeEvent This event will be \ufb01red whenever a child node of a Properties node is added or removed. preferences. addNodeChangeListener new NodeChangeListener Override public void childAdded NodeChangeEvent evt Preferences addedChild evt.getChild Preferences parentOfAddedChild evt.getParent Override public void childRemoved NodeChangeEvent evt Preferences removedChild evt.getChild Preferences parentOfRemovedChild", "evt.getParent Section 60.3 Getting sub-nodes of Preferences Preferences objects always represent a speci\ufb01c node in a whole Preferences tree, kind of like this rRoot com mycompany myapp darkApplicationModetrue showExitCon\ufb01rmationfalse windowMaximizedtrue org myorganization anotherapp defaultFontHelvetica defaultSavePathhomemattDocuments exporting defaultFormatpdf openInBrowserAfterExportfalse To select the commycompany myapp node By convention, based on the package of a class1. package com.mycompany.myapp ... Because this class is in the com.mycompany.myapp package, the node commycompanymyapp will be returned. Preferences myApp Preferences. userNodeForPackage getClass By relative path2. Preferences myApp Preferences. userRoot .nodecommycompanymyapp Using a relative path a path not starting with a will cause the path to be resolved relative to the parent node it is resolved on. For example, the following example will return the node of the path GoalKicker.com Java Notes for Professionals 357onetwothreecommycompany myapp Preferences prefix Preferences. userRoot .nodeonetwothree Preferences myAppWithPrefix prefix. nodecommycompanymyapp prefix is onetwothree myAppWithPrefix is onetwothreecommycompanymyapp By absolute path3. Preferences myApp Preferences. userRoot .nodecommycompanymyapp Using an absolute path on the root node will not be di\ufb00erent from using a relative path. The di\ufb00erence is that, if called on a sub-node, the path will be resolved relative to the root node. Preferences prefix Preferences. userRoot .nodeonetwothree Preferences myAppWitoutPrefix prefix. nodecommycompanymyapp prefix is onetwothree", "myAppWitoutPrefix is commycompanymyapp Section 60.4 Coordinating preferences access across multiple application instances All instances of Preferences are always thread-safe across the threads of a single Java Virtual Machine JVM. Because Preferences can be shared across multiple JVMs, there are special methods that deal with synchronizing changes across virtual machines. If you have an application which is supposed to run in a single instance only, then no external synchronization is required. If you have an application which runs in multiple instances on a single system and therefore Preferences access needs to be coordinated between the JVMs on the system, then the sync method of any Preferences node may be used to ensure changes to the Preferences node are visible to other JVMs on the system Warning dont use this if your application is intended to only run a single instance on a machine once this is probably the case for most desktop applications try preferences. sync catch BackingStoreException e Deal with any errors while saving the preferences to the backing storage e.printStackTrace Section 60.5 Exporting preferences Preferences nodes can be exported into a XML document representing that node. The resulting XML tree can be imported again. The resulting XML document", "will remember whether it was exported from the user or system Preferences . To export a single node, but not its child nodes Version Java SE 7 try OutputStream os ... preferences. exportNode os catch IOException ioe GoalKicker.com Java Notes for Professionals 358 Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace Version Java SE 7 OutputStream os null try os ... preferences. exportSubtree os catch IOException ioe Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace finally if os ! null try os. close catch IOException ignored To export a single node with its child nodes Version Java SE 7 try OutputStream os ... preferences. exportNode os catch IOException ioe Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace Version Java SE 7 OutputStream os null try os ... preferences. exportSubtree os catch IOException ioe Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace finally if", "os ! null try os. close catch IOException ignored Section 60.6 Importing preferences Preferences nodes can be imported from a XML document. Importing is meant to be used in conjunction with the GoalKicker.com Java Notes for Professionals 359exporting functionality of Preferences , since it creates the correct corresponding XML documents. The XML documents will remember whether they were exported from the user or system Preferences . Therefore, they can be imported into their respective Preferences trees again, without you having to \ufb01gure out or know where they came from. The static function will automatically \ufb01nd out whether the XML document was exported from the user or system Preferences and will automatically import them into the tree they were exported from. Version Java SE 7 try InputStream is ... This is a static call on the Preferences class Preferences. importPreferences is catch IOException ioe Exception whilst reading data from the InputStream ioe. printStackTrace catch InvalidPreferencesFormatException ipfe Exception whilst parsing the XML document tree ipfe. printStackTrace Version Java SE 7 InputStream is null try is ... This is a static call on the Preferences class Preferences. importPreferences is catch IOException ioe Exception whilst reading data from the InputStream ioe. printStackTrace catch", "InvalidPreferencesFormatException ipfe Exception whilst parsing the XML document tree ipfe. printStackTrace finally if is ! null try is. close catch IOException ignored Section 60.7 Removing event listeners Event listeners can be removed again from any Properties node, but the instance of the listener has to be kept around for that. Version Java SE 8 Preferences preferences Preferences. userNodeForPackage getClass PreferenceChangeListener listener evt - System.out.printlnevt.getKey got new value evt.getNewValue preferences. addPreferenceChangeListener listener later... preferences. removePreferenceChangeListener listener Version Java SE 8 Preferences preferences Preferences. userNodeForPackage getClass GoalKicker.com Java Notes for Professionals 360PreferenceChangeListener listener new PreferenceChangeListener Override public void preferenceChange PreferenceChangeEvent evt System.out.printlnevt.getKey got new value evt.getNewValue preferences. addPreferenceChangeListener listener later... preferences. removePreferenceChangeListener listener The same applies for NodeChangeListener . Section 60.8 Getting preferences values A value of a Preferences node can be of the type String , boolean , byte, double , float , int or long . All invocations must provide a default value, in case the speci\ufb01ed value is not present in the Preferences node. Preferences preferences Preferences. userNodeForPackage getClass String someString preferences. getsomeKey , this is the default value boolean someBoolean preferences. getBoolean someKey , true byte someByteArray preferences. getByteArray someKey , new byte0 double someDouble preferences. getDouble", "someKey , 887284.4d float someFloat preferences. getFloat someKey , 38723.3f int someInt preferences. getIntsomeKey , 13232 long someLong preferences. getLongsomeKey , 2827637868234L Section 60.9 Setting preferences values To store a value into the Preferences node, one of the putXXX methods is used. A value of a Preferences node can be of the type String , boolean , byte, double , float , int or long . Preferences preferences Preferences. userNodeForPackage getClass preferences. putsomeKey , some String value preferences. putBoolean someKey , false preferences. putByteArray someKey , new byte0 preferences. putDouble someKey , 187398123.4454d preferences. putFloat someKey , 298321.445f preferences. putIntsomeKey , 77637 preferences. putLongsomeKey , 2873984729834L GoalKicker.com Java Notes for Professionals 361Chapter 61 Collection Factory Methods Method w Parameter Description List.ofE e A generic type that can be a class or interface. Set.ofE e A generic type that can be a class or interface. Map.ofK k, V v A key-value pair of generic types that can each be a class or interface. Map.ofMap.Entry? extends K, ? extends V entryA Map.Entry instance where its key can be K or one of its children, and its value can be V or any of its children. The arrival of Java 9 brings", "many new features to Javas Collections API, one of which being collection factory methods. These methods allow for easy initialization of immutable collections, whether they be empty or nonempty. Note that these factory methods are only available for the following interfaces ListE, SetE, and MapK, V Section 61.1 ListE Factory Method Examples ListInteger immutableEmptyList List.of Initializes an empty, immutable ListInteger. ListInteger immutableList List.of1, 2, 3, 4, 5 Initializes an immutable ListInteger with \ufb01ve initial elements. ListInteger mutableList new ArrayList immutableList Initializes a mutable ListInteger from an immutable ListInteger. Section 61.2 SetE Factory Method Examples SetInteger immutableEmptySet Set.of Initializes an empty, immutable SetInteger. SetInteger immutableSet Set.of1, 2, 3, 4, 5 Initializes an immutable SetInteger with \ufb01ve initial elements. SetInteger mutableSet new HashSet immutableSet Initializes a mutable SetInteger from an immutable SetInteger. Section 61.3 MapK, V Factory Method Examples MapInteger, Integer immutableEmptyMap Map.of Initializes an empty, immutable MapInteger, Integer . MapInteger, Integer immutableMap Map.of1, 2, 3, 4 Initializes an immutable MapInteger, Integer with two initial key-value entries. MapInteger, Integer immutableMap Map.ofEntries Map.entry1, 2, Map.entry3, 4 Initializes an immutable MapInteger, Integer with two initial key-value entries. MapInteger, Integer mutableMap new HashMap immutableMap Initializes a mutable MapInteger, Integer from an immutable MapInteger, Integer", ". GoalKicker.com Java Notes for Professionals 362Chapter 62 Alternative Collections Section 62.1 Multimap in Guava, Apache and Eclipse Collections This multimap allows duplicate key-value pairs. JDK analogs are HashMapK, List, HashMapK, Set and so on. Keys order Values order Duplicate Analog key Analog value Guava ApacheEclipse GS CollectionsJDK not de\ufb01ned Insertion-order yes HashMap ArrayList ArrayListMultimap MultiValueMap FastListMultimapHashMapK, ArrayList V not de\ufb01ned not de\ufb01ned no HashMap HashSet HashMultimapMultiValueMap. multiValueMap new HashMapK, Set, HashSet.classUnifiedSetMultimapHashMapK, HashSetV not de\ufb01ned sorted no HashMap TreeSetMultimaps. newMultimap HashMap, Supplier TreeSetMultiValueMap. multiValueMap new HashMap K, Set, TreeSet.classTreeSortedSet - MultimapHashMapK, TreeSetV Insertion-order Insertion-order yes LinkedHashMap ArrayList LinkedListMultimapMultiValueMap. multiValueMapnew LinkedHashMapK, List, ArrayList.classLinkedHashMap K, ArrayList Insertion-order Insertion-order no LinkedHashMap LinkedHashSet LinkedHashMultimapMultiValueMap. multiValueMap new LinkedHashMap K, Set, LinkedHashSet. classLinkedHashMap K, LinkedHashSet V sorted sorted no TreeMap TreeSet TreeMultimapMultiValueMap. multiValueMap new TreeMapK, Set,TreeSet.classTreeMapK, TreeSetV Examples using Multimap Task Parse Hello World! Hello All! Hi World! string to separate words and print all indexes of every word using MultiMap for example, Hello0, 2, World!1, 5 and so on 1. MultiValueMap from Apache String INPUTTEXT Hello World! Hello All! Hi World! Parse text to words and index List String words Arrays.asListINPUTTEXT. split Create Multimap MultiMap String, Integer multiMap new MultiValueMap String, Integer Fill Multimap", "int i 0 forString word words multiMap. putword, i i Print all words System.out.printlnmultiMap print Hi4, Hello0, 2, World!1, 5, All!3 - in random orders Print all unique words System.out.printlnmultiMap. keySet print Hi, Hello, World!, All! - in random orders Print all indexes System.out.printlnHello multiMap. getHello print 0, 2 System.out.printlnWorld multiMap. getWorld! print 1, 5 System.out.printlnAll multiMap. getAll! print 3 System.out.printlnHi multiMap. getHi print 4 System.out.printlnEmpty multiMap. getEmpty print null Print count unique words GoalKicker.com Java Notes for Professionals 363 System.out.printlnmultiMap. keySet.size print 4 2. HashBiMap from GS Eclipse Collection String englishWords one, two, three,ball,snow String russianWords jeden, dwa, trzy, kula, snieg Create Multiset MutableBiMap String, String biMap new HashBiMap englishWords. length Create English-Polish dictionary int i 0 forString englishWord englishWords biMap. putenglishWord, russianWords i i Print count words System.out.printlnbiMap print twodwa, ballkula, onejeden, snowsnieg, threetrzy - in random orders Print all unique words System.out.printlnbiMap.keySet print snow, two, one, three, ball - in random orders System.out.printlnbiMap.values print dwa, kula, jeden, snieg, trzy - in random orders Print translate by words System.out.printlnone biMap.getone print one jeden System.out.printlntwo biMap.gettwo print two dwa System.out.printlnkula biMap.inverse.getkula print kula ball System.out.printlnsnieg biMap.inverse.getsnieg print snieg snow System.out.printlnempty biMap.getempty print empty null Print count words pair", "System.out.printlnbiMap.size print 5 HashMultiMap from Guava3. String INPUTTEXT Hello World! Hello All! Hi World! Parse text to words and index ListString words Arrays.asListINPUTTEXT. split Create Multimap Multimap String, Integer multiMap HashMultimap. create Fill Multimap int i 0 forString word words multiMap. putword, i i Print all words System.out.printlnmultiMap print Hi4, Hello0, 2, World!1, 5, All!3 - keys and values in random orders Print all unique words System.out.printlnmultiMap. keySet print Hi, Hello, World!, All! - in random orders Print all indexes System.out.printlnHello multiMap. getHello print 0, 2 System.out.printlnWorld multiMap. getWorld! print 1, 5 System.out.printlnAll multiMap. getAll! print 3 System.out.printlnHi multiMap. getHi print 4 GoalKicker.com Java Notes for Professionals 364 System.out.printlnEmpty multiMap. getEmpty print Print count all words System.out.printlnmultiMap. size print 6 Print count unique words System.out.printlnmultiMap. keySet.size print 4 Nore examples I. Apache Collection MultiValueMap1. MultiValueMapLinked2. MultiValueMapTree3. II. GS Eclipse Collection FastListMultimap1. HashBagMultimap2. TreeSortedSetMultimap3. Uni\ufb01edSetMultimap4. III. Guava HashMultiMap1. LinkedHashMultimap2. LinkedListMultimap3. TreeMultimap4. ArrayListMultimap5. Section 62.2 Apache HashBag, Guava HashMultiset and Eclipse HashBag A Bagultiset stores each object in the collection together with a count of occurrences. Extra methods on the interface allow multiple copies of an object to be added or removed at once. JDK analog is HashMapT, Integer, when values", "is count of copies this key. Type GuavaApache Commons CollectionsGS Collections JDK Order not de\ufb01nedHashMultiset HashBag HashBag HashMap Sorted TreeMultiset TreeBag TreeBag TreeMap Insertion-order LinkedHashMultiset - - LinkedHashMap Concurrent variantConcurrentHashMultiset SynchronizedBag SynchronizedBag Collections .synchronizedMap HashMapString, Integer Concurrent and sorted- SynchronizedSortedBag SynchronizedSortedBag Collections .synchronizedSortedMap TreeMapString,Integer Immutable collectionImmutableMultiset Unmodi\ufb01ableBag Unmodi\ufb01ableBag Collections .unmodifiableMap HashMapString, Integer Immutable and sortedImmutableSortedMultiset Unmodi\ufb01ableSortedBag Unmodi\ufb01ableSortedBagCollections .unmodifiableSortedMap TreeMapString, Integer Examples 1. Using SynchronizedSortedBag from Apache Parse text to separate words String INPUTTEXT Hello World! Hello All! Hi World! GoalKicker.com Java Notes for Professionals 365 Create Multiset Bag bag SynchronizedSortedBag. synchronizedBag new TreeBag Arrays.asListINPUTTEXT. split Print count words System.out.printlnbag print 1All!,2Hello,1Hi,2World!- in natural alphabet order Print all unique words System.out.printlnbag.uniqueSet print All!, Hello, Hi, World!- in natural alphabet order Print count occurrences of words System.out.printlnHello bag.getCount Hello print 2 System.out.printlnWorld bag.getCount World! print 2 System.out.printlnAll bag.getCount All! print 1 System.out.printlnHi bag.getCount Hi print 1 System.out.printlnEmpty bag.getCount Empty print 0 Print count all words System.out.printlnbag.size print 6 Print count unique words System.out.printlnbag.uniqueSet .size print 4 2. Using TreeBag from EclipseGC Parse text to separate words String INPUTTEXT Hello World! Hello All! Hi World! Create Multiset MutableSortedBag String bag TreeBag. newBagArrays.asListINPUTTEXT. split Print count words System.out.printlnbag print All!, Hello, Hello, Hi,", "World!, World!- in natural order Print all unique words System.out.printlnbag.toSortedSet print All!, Hello, Hi, World!- in natural order Print count occurrences of words System.out.printlnHello bag.occurrencesOf Hello print 2 System.out.printlnWorld bag.occurrencesOf World! print 2 System.out.printlnAll bag.occurrencesOf All! print 1 System.out.printlnHi bag.occurrencesOf Hi print 1 System.out.printlnEmpty bag.occurrencesOf Empty print 0 Print count all words System.out.printlnbag.size print 6 Print count unique words System.out.printlnbag.toSet.size print 4 3. Using LinkedHashMultiset from Guava Parse text to separate words String INPUTTEXT Hello World! Hello All! Hi World! Create Multiset Multiset String multiset LinkedHashMultiset. createArrays.asListINPUTTEXT. split Print count words System.out.printlnmultiset print Hello x 2, World! x 2, All!, Hi- in predictable iteration order Print all unique words System.out.printlnmultiset. elementSet print Hello, World!, All!, Hi - in predictable iteration order Print count occurrences of words GoalKicker.com Java Notes for Professionals 366 System.out.printlnHello multiset. countHello print 2 System.out.printlnWorld multiset. countWorld! print 2 System.out.printlnAll multiset. countAll! print 1 System.out.printlnHi multiset. countHi print 1 System.out.printlnEmpty multiset. countEmpty print 0 Print count all words System.out.printlnmultiset. size print 6 Print count unique words System.out.printlnmultiset. elementSet .size print 4 More examples I. Apache Collection HashBag - order not de\ufb01ned 1. SynchronizedBag - concurrent and order not de\ufb01ned 2. SynchronizedSortedBag - - concurrent and sorted", "order 3. TreeBag - sorted order 4. II. GS Eclipse Collection MutableBag - order not de\ufb01ned 5. MutableSortedBag - sorted order 6. III. Guava HashMultiset - order not de\ufb01ned 7. TreeMultiset - sorted order 8. LinkedHashMultiset - insertion order 9. ConcurrentHashMultiset - concurrent and order not de\ufb01ned 10. Section 62.3 Compare operation with collections - Create collections Compare operation with collections - Create collections 1. Create List Description JDK guava gs-collections Create empty listnew ArrayList Lists.newArrayList FastList. newList Create list from valuesArrays.asList1, 2, 3Lists.newArrayList 1, 2, 3FastList. newListWith 1, 2, 3 Create list with capacity 100new ArrayList 100Lists.newArrayListWithCapacity 100FastList. newList100 Create list from any collectinnew ArrayList collection Lists.newArrayList collection FastList. newListcollection Create list from any Iterable- Lists.newArrayList iterable FastList. newListiterable Create list from Iterator- Lists.newArrayList iterator - GoalKicker.com Java Notes for Professionals 367Create list from arrayArrays.asListarrayLists.newArrayList array FastList. newListWith array Create list using factory- -FastList. newWithNValues 10, - 1 Examples System.out.printlncreateArrayList start Create empty list List String emptyGuava Lists.newArrayList using guava List String emptyJDK new ArrayList using JDK MutableList String emptyGS FastList. newList using gs Create list with 100 element List String exactly100 Lists.newArrayListWithCapacity 100 using guava List String exactly100JDK new ArrayList 100 using JDK MutableList String empty100GS FastList.", "newList100 using gs Create list with about 100 element List String approx100 Lists.newArrayListWithExpectedSize 100 using guava List String approx100JDK new ArrayList 115 using JDK MutableList String approx100GS FastList. newList115 using gs Create list with some elements List String withElements Lists.newArrayList alpha, beta, gamma using guava List String withElementsJDK Arrays.asListalpha, beta, gamma using JDK MutableList String withElementsGS FastList. newListWith alpha, beta, gamma using gs System.out.printlnwithElements System.out.printlnwithElementsJDK System.out.printlnwithElementsGS Create list from any Iterable interface any collection Collection String collection new HashSet 3 collection. add1 collection. add2 collection. add3 List String fromIterable Lists.newArrayList collection using guava List String fromIterableJDK new ArrayList collection using JDK MutableList String fromIterableGS FastList. newListcollection using gs System.out.printlnfromIterable System.out.printlnfromIterableJDK System.out.printlnfromIterableGS Attention JDK create list only from Collection, but guava and gs can create list from Iterable and Collection Create list from any Iterator Iterator String iterator collection. iterator List String fromIterator Lists.newArrayList iterator using guava System.out.printlnfromIterator Create list from any array String array 4, 5, 6 List String fromArray Lists.newArrayList array using guava List String fromArrayJDK Arrays.asListarray using JDK MutableList String fromArrayGS FastList. newListWith array using gs System.out.printlnfromArray GoalKicker.com Java Notes for Professionals 368 System.out.printlnfromArrayJDK System.out.printlnfromArrayGS Create list using fabric MutableList String fromFabricGS FastList. newWithNValues 10, - String.valueOfMath.random", "using gs System.out.printlnfromFabricGS System.out.printlncreateArrayList end 2 Create Set Description JDK guava gs-collections Create empty setnew HashSet Sets.newHashSet UnifiedSet. newSet Creatre set from valuesnew HashSetArrays.asListalpha, beta, gammaSets.newHashSet alpha, beta, gammaUnifiedSet. newSetWith alpha, beta, gamma Create set from any collectionsnew HashSet collection Sets.newHashSet collection UnifiedSet. newSetcollection Create set from any Iterable- Sets.newHashSet iterable UnifiedSet. newSetiterable Create set from any Iterator- Sets.newHashSet iterator - Create set from Arraynew HashSetArrays.asListarraySets.newHashSet arrayUnifiedSet. newSetWith array Examples System.out.printlncreateHashSet start Create empty set SetString emptyGuava Sets.newHashSet using guava SetString emptyJDK new HashSet using JDK SetString emptyGS UnifiedSet. newSet using gs Create set with 100 element SetString approx100 Sets.newHashSetWithExpectedSize 100 using guava SetString approx100JDK new HashSet 130 using JDK SetString approx100GS UnifiedSet. newSet130 using gs Create set from some elements SetString withElements Sets.newHashSet alpha, beta, gamma using guava SetString withElementsJDK new HashSet Arrays.asListalpha, beta, gamma using JDK SetString withElementsGS UnifiedSet. newSetWith alpha, beta, gamma using gs System.out.printlnwithElements System.out.printlnwithElementsJDK System.out.printlnwithElementsGS Create set from any Iterable interface any collection Collection String collection new ArrayList 3 collection. add1 collection. add2 collection. add3 SetString fromIterable Sets.newHashSet collection using guava SetString fromIterableJDK new HashSet collection using JDK SetString fromIterableGS UnifiedSet. newSetcollection using gs GoalKicker.com Java Notes for Professionals 369 System.out.printlnfromIterable System.out.printlnfromIterableJDK System.out.printlnfromIterableGS Attention", "JDK create set only from Collection, but guava and gs can create set from Iterable and Collection Create set from any Iterator Iterator String iterator collection. iterator SetString fromIterator Sets.newHashSet iterator using guava System.out.printlnfromIterator Create set from any array String array 4, 5, 6 SetString fromArray Sets.newHashSet array using guava SetString fromArrayJDK new HashSet Arrays.asListarray using JDK SetString fromArrayGS UnifiedSet. newSetWith array using gs System.out.printlnfromArray System.out.printlnfromArrayJDK System.out.printlnfromArrayGS System.out.printlncreateHashSet end 3 Create Map Description JDK guava gs-collections Create empty mapnew HashMapMaps.newHashMap UnifiedMap. newMap Create map with capacity 130new HashMap130Maps.newHashMapWithExpectedSize 100UnifiedMap. newMap130 Create map from other mapnew HashMapmapMaps.newHashMap map UnifiedMap. newMapmap Create map from keys- -UnifiedMap. newWithKeysValues 1, a, 2, b Examples System.out.printlncreateHashMap start Create empty map MapString, String emptyGuava Maps.newHashMap using guava MapString, String emptyJDK new HashMap using JDK MapString, String emptyGS UnifiedMap. newMap using gs Create map with about 100 element MapString, String approx100 Maps.newHashMapWithExpectedSize 100 using guava MapString, String approx100JDK new HashMap 130 using JDK MapString, String approx100GS UnifiedMap. newMap130 using gs Create map from another map MapString, String map new HashMap 3 map. putk1,v1 map. putk2,v2 MapString, String withMap Maps.newHashMap map using guava MapString, String withMapJDK new HashMap map using JDK MapString, String withMapGS UnifiedMap. newMapmap using", "gs System.out.printlnwithMap System.out.printlnwithMapJDK System.out.printlnwithMapGS Create map from keys GoalKicker.com Java Notes for Professionals 370 MapString, String withKeys UnifiedMap. newWithKeysValues 1, a, 2, b System.out.printlnwithKeys System.out.printlncreateHashMap end More examples CreateCollectionTest CollectionCompare1. CollectionSearch2. JavaTransform3. GoalKicker.com Java Notes for Professionals 371Chapter 63 Concurrent Collections A concurrent collection is a collection1 which permits access by more than one thread at the same time. Di\ufb00erent threads can typically iterate through the contents of the collection and add or remove elements. The collection is responsible for ensuring that the collection doesnt become corrupt. 1 httpstackover\ufb02ow.comdocumentationjava90collectionst201612221936497298484 Section 63.1 Thread-safe Collections By default, the various Collection types are not thread-safe. However, its fairly easy to make a collection thread-safe. ListString threadSafeList Collections .synchronizedList new ArrayList String SetString threadSafeSet Collections .synchronizedSet new HashSet String MapString, String threadSafeMap Collections .synchronizedMap new HashMap String, String When you make a thread-safe collection, you should never access it through the original collection, only through the thread-safe wrapper. Version Java SE 5 Starting in Java 5, java.util.collections has several new thread-safe collections that dont need the various Collections .synchronized methods. ListString threadSafeList new CopyOnWriteArrayList String SetString threadSafeSet new ConcurrentHashSet String MapString, String threadSafeMap new ConcurrentHashMap String, String Section 63.2 Insertion into ConcurrentHashMap public", "class InsertIntoConcurrentHashMap public static void mainString args ConcurrentHashMap Integer, SomeObject concurrentHashMap new ConcurrentHashMap SomeObject value new SomeObject Integer key 1 SomeObject previousValue concurrentHashMap. putIfAbsent 1, value if previousValue ! null Then some other value was mapped to key 1. value that was passed to putIfAbsent method is NOT inserted, hence, any other thread which calls concurrentHashMap.get1 would NOT receive a reference to the value that your thread attempted to insert. Decide how you wish to handle this situation. else value reference is mapped to key 1. GoalKicker.com Java Notes for Professionals 372 Section 63.3 Concurrent Collections Concurrent collections are a generalization of thread-safe collections, that allow for a broader usage in a concurrent environment. While thread-safe collections have safe element addition or removal from multiple threads, they do not necessarily have safe iteration in the same context one may not be able to safely iterate through the collection in one thread, while another one modi\ufb01es it by addingremoving elements. This is where concurrent collections are used. As iteration is often the base implementation of several bulk methods in collections, like addAll , removeAll , or also collection copying through a constructor, or other means, sorting, ... the use case", "for concurrent collections is actually pretty large. For example, the Java SE 5 java.util.concurrent .CopyOnWriteArrayList is a thread safe and concurrent List implementation, its javadoc states The snapshot style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModi\ufb01cationException. Therefore, the following code is safe public class ThreadSafeAndConcurrent public static final ListInteger LIST new CopyOnWriteArrayList public static void mainString args throws InterruptedException Thread modifier new Threadnew ModifierRunnable Thread iterator new Threadnew IteratorRunnable modifier. start iterator. start modifier. join iterator. join public static final class ModifierRunnable implements Runnable Override public void run try for int i 0 i 50000 i LIST. addi catch Exception e e. printStackTrace public static final class IteratorRunnable implements Runnable Override public void run try GoalKicker.com Java Notes for Professionals 373 for int i 0 i 10000 i long total 0 forInteger inList LIST total inList System.out.printlntotal catch Exception e e. printStackTrace Another concurrent collection regarding iteration is ConcurrentLinkedQueue , which states Iterators are weakly consistent, returning elements re\ufb02ecting the state of the queue", "at some point at or since the creation of the iterator. They do not throw java.util.ConcurrentModi\ufb01cationException, and may proceed concurrently with other operations. Elements contained in the queue since the creation of the iterator will be returned exactly once. One should check the javadocs to see if a collection is concurrent, or not. The attributes of the iterator returned by the iterator method fail fast, weakly consistent, ... is the most important attribute to look for. Thread safe but non concurrent examples In the above code, changing the LIST declaration to public static final ListInteger LIST Collections .synchronizedList new ArrayList Could and statistically will on most modern, multi CPUcore architectures lead to exceptions. Synchronized collections from the Collections utility methods are thread safe for additionremoval of elements, but not iteration unless the underlying collection being passed to it already is. GoalKicker.com Java Notes for Professionals 374Chapter 64 Choosing Collections Java o\ufb00ers a wide variety of Collections. Choosing which Collection to use can be tricky. See the Examples section for an easy-to-follow \ufb02owchart to choose the right Collection for the job. Section 64.1 Java Collections Flowchart Use the following \ufb02owchart to choose the right Collection for the job. This \ufb02owchart", "was based o\ufb00 httpi.stack.imgur.comaSDsG.png . GoalKicker.com Java Notes for Professionals 375Chapter 65 super keyword Section 65.1 Super keyword use with examples super keyword performs important role in three places Constructor Level1. Method Level2. Variable Level3. Constructor Level super keyword is used to call parent class constructor. This constructor can be default constructor or parameterized constructor. Default constructor super Parameterized constructor superint no, double amount, String name class Parentclass Parentclass System.out.printlnConstructor of Superclass class Subclass extends Parentclass Subclass Compile adds super here at the first line of this constructor implicitly System.out.printlnConstructor of Subclass Subclass int n1 Compile adds super here at the first line of this constructor implicitly System.out.printlnConstructor with arg void display System.out.printlnHello public static void mainString args Creating object using default constructor Subclass obj new Subclass Calling sub class method obj. display Creating object 2 using arg constructor Subclass obj2 new Subclass 10 obj2. display Note super must be the \ufb01rst statement in constructor otherwise we will get the compilation error message. Method Level GoalKicker.com Java Notes for Professionals 376super keyword can also be used in case of method overriding. super keyword can be used to invoke or call parent class method. class Parentclass Overridden method void display", "System.out.printlnParent class method class Subclass extends Parentclass Overriding method void display System.out.printlnChild class method void printMsg This would call Overriding method display This would call Overridden method super.display public static void mainString args Subclass obj new Subclass obj. printMsg Note If there is not method overriding then we do not need to use super keyword to call parent class method. Variable Level super is used to refer immediate parent class instance variable. In case of inheritance, there may be possibility of base class and derived class may have similar data members.In order to di\ufb00erentiate between the data member of baseparent class and derivedchild class, in the context of derived class the base class data members must be preceded by super keyword. Parent class or Superclass class Parentclass int num100 Child class or subclass class Subclass extends Parentclass I am declaring the same variable num in child class too. int num110 void printNumber System.out.printlnnum It will print value 110 System.out.printlnsuper.num It will print value 100 public static void mainString args Subclass obj new Subclass obj. printNumber GoalKicker.com Java Notes for Professionals 377Note If we are not writing super keyword before the base class data member name then it will be", "referred as current class data member and base class data member are hidden in the context of derived class. GoalKicker.com Java Notes for Professionals 378Chapter 66 Serialization Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes that includes the objects data as well as information about the objects type and the types of data stored in the object. After a serialized object has been written into a \ufb01le, it can be read from the \ufb01le and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory. Section 66.1 Basic Serialization in Java What is Serialization Serialization is the process of converting an objects state including its references to a sequence of bytes, as well as the process of rebuilding those bytes into a live object at some future time. Serialization is used when you want to persist the object. It is also used by Java RMI to pass objects between JVMs, either as arguments in a method invocation from a client to a server or as return values from a method invocation, or as exceptions thrown", "by remote methods. In general, serialization is used when we want the object to exist beyond the lifetime of the JVM. java.io.Serializable is a marker interface has no body. It is just used to mark Java classes as serializable. The serialization runtime associates with each serializable class a version number, called a serialVersionUID , which is used during de-serialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a di\ufb00erent serialVersionUID than that of the corresponding senders class, then deserialization will result in an InvalidClassException . A serializable class can declare its own serialVersionUID explicitly by declaring a \ufb01eld named serialVersionUID that must be static, final, and of type long ANY-ACCESS-MODIFIER static final long serialVersionUID 1L How to make a class eligible for serialization To persist an object the respective class must implement the java.io.Serializable interface. import java.io.Serializable public class SerialClass implements Serializable private static final long serialVersionUID 1L private Date currentTime public SerialClass currentTime Calendar .getInstance .getTime public Date getCurrentTime return currentTime How to write an object into a \ufb01le Now", "we need to write this object to a \ufb01le system. We use java.io.ObjectOutputStream for this purpose. import java.io.FileOutputStream GoalKicker.com Java Notes for Professionals 379import java.io.ObjectOutputStream import java.io.IOException public class PersistSerialClass public static void mainString args String filename time.ser SerialClass time new SerialClass We will write this object to file system. try ObjectOutputStream out new ObjectOutputStream new FileOutputStream filename out. writeObject time Write byte stream to file system. out. close catchIOException ex ex. printStackTrace How to recreate an object from its serialized state The stored object can be read from \ufb01le system at later time using java.io.ObjectInputStream as shown below import java.io.FileInputStream import java.io.ObjectInputStream import java.io.IOException import java.io.java.lang.ClassNotFoundException public class ReadSerialClass public static void mainString args String filename time.ser SerialClass time null try ObjectInputStream in new ObjectInputStream new FileInputStream filename time SerialClass in.readObject in. close catchIOException ex ex. printStackTrace catchClassNotFoundException cnfe cnfe. printStackTrace print out restored time System.out.printlnRestored time time.getTime The serialized class is in binary form. The deserialization can be problematic if the class de\ufb01nition changes see the Versioning of Serialized Objects chapter of the Java Serialization Speci\ufb01cation for details. Serializing an object serializes the entire object graph of which it is the root, and operates correctly in the", "presence of cyclic graphs. A reset method is provided to force the ObjectOutputStream to forget about objects that have already been serialized. Transient-\ufb01elds - Serialization Section 66.2 Custom Serialization In this example we want to create a class that will generate and output to console, a random number between a GoalKicker.com Java Notes for Professionals 380range of two integers which are passed as arguments during the initialization. public class SimpleRangeRandom implements Runnable private int min private int max private Thread thread public SimpleRangeRandom int min, int max this.min min this.max max thread new Threadthis thread. start Override private void WriteObject ObjectOutputStreamout throws IO Exception private void ReadObject ObjectInputStream in throws IOException , ClassNotFoundException public void run whiletrue Random rand new Random System.out.printlnThread thread. getId Random rand.nextIntmax - min try Thread.sleep10000 catch InterruptedException e e. printStackTrace Now if we want to make this class Serializable there will be some problems. The Thread is one of the certain system-level classes that are not Serializable. So we need to declare the thread as transient . By doing this we will be able to serialize the objects of this class but we will still have an issue. As you can see in the", "constructor we set the min and the max values of our randomizer and after this we start the thread which is responsible for generating and printing the random value. Thus when restoring the persisted object by calling the readObject the constructor will not run again as there is no creation of a new object. In that case we need to develop a Custom Serialization by providing two methods inside the class. Those methods are private void writeObject ObjectOutputStream out throws IOException private void readObject ObjectInputStream in throws IOException , ClassNotFoundException Thus by adding our implementation in the readObject we can initiate and start our thread class RangeRandom implements Serializable , Runnable private int min private int max private transient Thread thread transient should be any field that either cannot be serialized e.g Thread or any field you do not want serialized public RangeRandom int min, int max this.min min this.max max thread new Threadthis thread. start GoalKicker.com Java Notes for Professionals 381Override public void run whiletrue Random rand new Random System.out.printlnThread thread. getId Random rand.nextIntmax - min try Thread.sleep10000 catch InterruptedException e e. printStackTrace private void writeObject ObjectOutputStream oos throws IOException oos. defaultWriteObject private void readObject ObjectInputStream in throws", "IOException , ClassNotFoundException in.defaultReadObject thread new Threadthis thread. start Here is the main for our example public class Main public static void mainString args System.out.printlnHello RangeRandom rangeRandom new RangeRandom 1,10 FileOutputStream fos null ObjectOutputStream out null try fos new FileOutputStream test out new ObjectOutputStream fos out. writeObject rangeRandom out. close catchIOException ex ex. printStackTrace RangeRandom rangeRandom2 null FileInputStream fis null ObjectInputStream in null try fis new FileInputStream test in new ObjectInputStream fis rangeRandom2 RangeRandom in.readObject in. close catchIOException ex ex. printStackTrace catchClassNotFoundException ex GoalKicker.com Java Notes for Professionals 382 ex. printStackTrace If you run the main you will see that there are two threads running for each RangeRandom instance and that is because the Thread.start method is now in both the constructor and the readObject . Section 66.3 Versioning and serialVersionUID When you implement java.io.Serializable interface to make a class serializable, the compiler looks for a static final \ufb01eld named serialVersionUID of type long . If the class doesnt have this \ufb01eld declared explicitly then the compiler will create one such \ufb01eld and assign it with a value which comes out of a implementation dependent computation of serialVersionUID . This computation depends upon various aspects of the class and", "it follows the Object Serialization Speci\ufb01cations given by Sun. But, the value is not guaranteed to be the same across all compiler implementations. This value is used for checking the compatibility of the classes with respect to serialization and this is done while de- serializing a saved object. The Serialization Runtime veri\ufb01es that serialVersionUID read from the de-serialized data and the serialVersionUID declared in the class are exactly the same. If that is not the case, it throws an InvalidClassException . Its highly recommended that you explicitly declare and initialize the static, \ufb01nal \ufb01eld of type long and named serialVersionUID in all your classes you want to make Serializable instead of relying on the default computation of the value for this \ufb01eld even if you are not gonna use versioning. serialVersionUID computation is extremely sensitive and may vary from one compiler implementation to another and hence you may turn up getting the InvalidClassException even for the same class just because you used di\ufb00erent compiler implementations on the sender and the receiver ends of the serialization process. public class Example implements Serializable static final long serialVersionUID 1L or some other value ... As long as serialVersionUID is the same, Java", "Serialization can handle di\ufb00erent versions of a class. Compatible and incompatible changes are Compatible Changes Adding \ufb01elds When the class being reconstituted has a \ufb01eld that does not occur in the stream, that \ufb01eld in the object will be initialized to the default value for its type. If class-speci\ufb01c initialization is needed, the class may provide a readObject method that can initialize the \ufb01eld to nondefault values. Adding classes The stream will contain the type hierarchy of each object in the stream. Comparing this hierarchy in the stream with the current class can detect additional classes. Since there is no information in the stream from which to initialize the object, the classs \ufb01elds will be initialized to the default values. Removing classes Comparing the class hierarchy in the stream with that of the current class can detect that a class has been deleted. In this case, the \ufb01elds and objects corresponding to that class are read from the stream. Primitive \ufb01elds are discarded, but the objects referenced by the deleted class are created, since they may be referred to later in the stream. They will be garbage-collected when the stream is garbage- collected or reset. Adding writeObjectreadObject methods If", "the version reading the stream has these methods then readObject is expected, as usual, to read the required data written to the stream by the default serialization. GoalKicker.com Java Notes for Professionals 383It should call defaultReadObject \ufb01rst before reading any optional data. The writeObject method is expected as usual to call defaultWriteObject to write the required data and then may write optional data. Adding java.io.Serializable This is equivalent to adding types. There will be no values in the stream for this class so its \ufb01elds will be initialized to default values. The support for subclassing nonserializable classes requires that the classs supertype have a no-arg constructor and the class itself will be initialized to default values. If the no-arg constructor is not available, the InvalidClassException is thrown. Changing the access to a \ufb01eld The access modi\ufb01ers public, package, protected, and private have no e\ufb00ect on the ability of serialization to assign values to the \ufb01elds. Changing a \ufb01eld from static to nonstatic or transient to nontransient When relying on default serialization to compute the serializable \ufb01elds, this change is equivalent to adding a \ufb01eld to the class. The new \ufb01eld will be written to the stream but earlier classes", "will ignore the value since serialization will not assign values to static or transient \ufb01elds. Incompatible Changes Deleting \ufb01elds If a \ufb01eld is deleted in a class, the stream written will not contain its value. When the stream is read by an earlier class, the value of the \ufb01eld will be set to the default value because no value is available in the stream. However, this default value may adversely impair the ability of the earlier version to ful\ufb01ll its contract. Moving classes up or down the hierarchy This cannot be allowed since the data in the stream appears in the wrong sequence. Changing a nonstatic \ufb01eld to static or a nontransient \ufb01eld to transient When relying on default serialization, this change is equivalent to deleting a \ufb01eld from the class. This version of the class will not write that data to the stream, so it will not be available to be read by earlier versions of the class. As when deleting a \ufb01eld, the \ufb01eld of the earlier version will be initialized to the default value, which can cause the class to fail in unexpected ways. Changing the declared type of a primitive \ufb01eld Each version of the", "class writes the data with its declared type. Earlier versions of the class attempting to read the \ufb01eld will fail because the type of the data in the stream does not match the type of the \ufb01eld. Changing the writeObject or readObject method so that it no longer writes or reads the default \ufb01eld data or changing it so that it attempts to write it or read it when the previous version did not. The default \ufb01eld data must consistently either appear or not appear in the stream. Changing a class from Serializable to Externalizable or vice versa is an incompatible change since the stream will contain data that is incompatible with the implementation of the available class. Changing a class from a non-enum type to an enum type or vice versa since the stream will contain data that is incompatible with the implementation of the available class. Removing either Serializable or Externalizable is an incompatible change since when written it will no longer supply the \ufb01elds needed by older versions of the class. Adding the writeReplace or readResolve method to a class is incompatible if the behavior would produce an object that is incompatible with any older version", "of the class. Section 66.4 Serialization with Gson Serialization with Gson is easy and will output correct JSON. public class Employe private String firstName private String lastName private int age private BigDecimal salary private ListString skills GoalKicker.com Java Notes for Professionals 384 getters and setters Serialization Skills ListString skills new LinkedList String skills.addleadership skills.addJava Experience Employe Employe obj new Employe obj.setFirstName Christian obj.setLastName Lusardi obj.setAge25 obj.setSalary new BigDecimal 10000 obj.setSkills skills Serialization process Gson gson new Gson String json gson.toJsonobj firstNameChristian,lastNameLusardi,age25,salary10000,skillsleadership,Java Experience Note that you can not serialize objects with circular references since that will result in in\ufb01nite recursion. Deserialization its very simple... Assuming that json is the previous String object.... Employe obj2 gson.fromJson json, Employe. class obj2 is just like obj Section 66.5 Custom JSON Deserialization with Jackson We consume rest API as a JSON format and then unmarshal it to a POJO. Jackson s org.codehaus.jackson.map.ObjectMapper just works out of the box and we really don t do anything in most cases. But sometimes we need custom deserializer to ful\ufb01ll our custom needs and this tutorial will guide you through the process of creating your own custom deserializer. Lets say we have following entities. public class User private", "Long id private String name private String email getter setter are omitted for clarity And public class Program private Long id private String name private User createdBy private String contents GoalKicker.com Java Notes for Professionals 385 getter setter are omitted for clarity Lets serializemarshal an object \ufb01rst. User user new User user.setId1L user.setEmail exampleexample.com user.setNameBazlur Rahman Program program new Program program. setId1L program. setNameProgram 1 program. setCreatedBy user program. setContents Some contents ObjectMapper objectMapper new ObjectMapper \ufb01nal String json objectMapper.writeValueAsStringprogram System.out.printlnjson The above code will produce following JSON- id 1, name Program 1 , createdBy id 1, name Bazlur Rahman , email exampleexample.com , contents Some contents Now can do the opposite very easily. If we have this JSON, we can unmarshal to a program object using ObjectMapper as following Now let s say, this is not the real case, we are going to have a di\ufb00erent JSON from an API which doesn t match with our Program class. id 1, name Program 1 , ownerId 1 contents Some contents Look at the JSON string, you can see, it has a di\ufb00erent \ufb01eld that is owenerId. Now if you want to serialize this JSON as we did earlier, you", "will have exceptions. There are two ways to avoid exceptions and have this serialized Ignore the unknown \ufb01elds Ignore the onwerId . Add the following annotation in the Program class JsonIgnoreProperties ignoreUnknown true public class Program GoalKicker.com Java Notes for Professionals 386Write custom deserializer But there are cases when you actually need this owerId \ufb01eld. Lets say you want to relate it as an id of the User class. In such case, you need to write a custom deserializer- As you can see, \ufb01rst you have to access the JsonNode from the JonsParser . And then you can easily extract information from a JsonNode using the get method. and you have to make sure about the \ufb01eld name. It should be the exact name, spelling mistake will cause exceptions. And \ufb01nally, you have to register your ProgramDeserializer to the ObjectMapper . ObjectMapper mapper new ObjectMapper SimpleModule module new SimpleModule module.addDeserializer Program. class, new ProgramDeserializer mapper.registerModule module String newJsonString id1,nameProgram 1 ,ownerId1,contents Some contents final Program program2 mapper. readValue newJsonString, Program. class Alternatively, you can use annotation to register the deserializer directly JsonDeserialize using ProgramDeserializer. class public class Program GoalKicker.com Java Notes for Professionals 387Chapter 67 Optional Optional is a", "container object which may or may not contain a non-null value. If a value is present, isPresent will return true and get will return the value. Additional methods that depend on the presence of the contained value are provided, such as orElse, which returns a default value if value not present, and ifPresent which executes a block of code if the value is present. Section 67.1 Map Use the map method of Optional to work with values that might be null without doing explicit null checks Note that the map and filter operations are evaluated immediately, unlike their Stream counterparts which are only evaluated upon a terminal operation . Syntax public U Optional U mapFunction ? super T,? extends U mapper Code examples String value null return Optional. ofNullable value.mapStringtoUpperCase .orElseNONE returns NONE String value something return Optional. ofNullable value.mapStringtoUpperCase .orElseNONE returns SOMETHING Because Optional.map returns an empty optional when its mapping function returns null, you can chain several map operations as a form of null-safe dereferencing. This is also known as Null-safe chaining . Consider the following example String value foo.getBar.getBaz.toString Any of getBar , getBaz , and toString can potentially throw a NullPointerException . Here is an", "alternative way to get the value from toString using Optional String value Optional. ofNullable foo . mapFoogetBar . mapBargetBaz . mapBaztoString . orElse This will return an empty string if any of the mapping functions returned null. Below is an another example, but slightly di\ufb00erent. It will print the value only if none of the mapping functions returned null. Optional. ofNullable foo . mapFoogetBar . mapBargetBaz GoalKicker.com Java Notes for Professionals 388 . mapBaztoString . ifPresent System.outprintln Section 67.2 Return default value if Optional is empty Dont just use Optional. get since that may throw NoSuchElementException . The Optional. orElseT and Optional. orElseGet Supplier ? extends T methods provide a way to supply a default value in case the Optional is empty. String value something return Optional. ofNullable value.orElsedefaultValue returns something return Optional. ofNullable value.orElseGet - getDefaultValue returns something never calls the getDefaultValue method String value null return Optional. ofNullable value.orElsedefaultValue returns defaultValue return Optional. ofNullable value.orElseGet - getDefaultValue calls getDefaultValue and returns its results The crucial di\ufb00erence between the orElse and orElseGet is that the latter is only evaluated when the Optional is empty while the argument supplied to the former one is evaluated even if the Optional", "is not empty. The orElse should therefore only be used for constants and never for supplying value based on any sort of computation. Section 67.3 Throw an exception, if there is no value Use the orElseThrow method of Optional to get the contained value or throw an exception, if it hasnt been set. This is similar to calling get, except that it allows for arbitrary exception types. The method takes a supplier that must return the exception to be thrown. In the \ufb01rst example, the method simply returns the contained value Optional optional Optional. ofsomething return optional. orElseThrow IllegalArgumentException new returns something string In the second example, the method throws an exception because a value hasnt been set Optional optional Optional. empty return optional. orElseThrow IllegalArgumentException new throws IllegalArgumentException You can also use the lambda syntax if throwing an exception with message is needed optional. orElseThrow - new IllegalArgumentException Illegal Section 67.4 Lazily provide a default value using a Supplier The normal orElse method takes an Object , so you might wonder why there is an option to provide a Supplier GoalKicker.com Java Notes for Professionals 389here the orElseGet method. Consider String value something return Optional. ofNullable value .", "orElsegetValueThatIsHardToCalculate returns something It would still call getValueThatIsHardToCalculate even though its result is not used as the optional is not empty. To avoid this penalty you supply a supplier String value something return Optional. ofNullable value . orElseGet - getValueThatIsHardToCalculate returns something This way getValueThatIsHardToCalculate will only be called if the Optional is empty. Section 67.5 Filter filter is used to indicate that you would like the value only if it matches your predicate. Think of it like if !somePredicate x x null . Code examples String value null Optional. ofNullable value nothing . filterx - x.equalscool string this is never run since value is null . isPresent false String value cool string Optional. ofNullable value something . filterx - x.equalscool string this is run and passes . isPresent true String value hot string Optional. ofNullable value something . filterx - x.equalscool string this is run and fails . isPresent false Section 67.6 Using Optional containers for primitive number types OptionalDouble , OptionalInt and OptionalLong work like Optional , but are speci\ufb01cally designed to wrap primitive types OptionalInt presentInt OptionalInt. ofvalue OptionalInt absentInt OptionalInt. empty Because numeric types do have a value, there is no special handling for null.", "Empty containers can be checked with presentInt. isPresent Is true. absentInt. isPresent Is false. Similarly, shorthands exist to aid value management GoalKicker.com Java Notes for Professionals 390 Prints the value since it is provided on creation. presentInt. ifPresent System.outprintln Gives the other value as the original Optional is empty. int finalValue absentInt. orElseGet thisotherValue Will throw a NoSuchElementException. int nonexistentValue absentInt. getAsInt Section 67.7 Run code only if there is a value present Optional String optionalWithValue Optional. offoo optionalWithValue. ifPresent System.outprintlnPrints foo. Optional String emptyOptional Optional. empty emptyOptional. ifPresent System.outprintlnDoes nothing. Section 67.8 FlatMap flatMap is similar to map. The di\ufb00erence is described by the javadoc as follows This method is similar to mapFunction , but the provided mapper is one whose result is already an Optional , and if invoked, flatMap does not wrap it with an additional Optional . In other words, when you chain a method call that returns an Optional , using Optional. flatMap avoids creating nested Optionals . For example, given the following classes public class Foo Optional Bar getBar return Optional. ofnew Bar public class Bar If you use Optional. map, you will get a nested Optional i.e. Optional Optional Bar. Optional Optional", "Bar nestedOptionalBar Optional. ofnew Foo . mapFoogetBar However, if you use Optional. flatMap , you will get a simple Optional i.e. Optional Bar. Optional Bar optionalBar Optional. ofnew Foo . flatMapFoogetBar GoalKicker.com Java Notes for Professionals 391Chapter 68 Object References Section 68.1 Object References as method parameters This topic explains the concept of an object reference it is targeted at people who are new to programming in Java. You should already be familiar with some terms and meanings class de\ufb01nition, main method, object instance, and the calling of methods on an object, and passing parameters to methods. public class Person private String name public void setName String name this.name name public String getName return name public static void mainString arguments Person person new Person person. setNameBob int i 5 setPersonName person, i System.out.printlnperson.getName i private static void setPersonName Person person, int num person. setNameLinda num 99 To be fully competent in Java programming, you should be able to explain this example to someone else o\ufb00 the top of your head. Its concepts are fundamental to understanding how Java works. As you can see, we have a main that instantiates an object to the variable person , and calls a", "method to set the name \ufb01eld in that object to Bob . Then it calls another method, and passes person as one of two parameters the other parameter is an integer variable, set to 5. The method called sets the name value on the passed object to Linda, and sets the integer variable passed to 99, then returns. So what would get printed? Linda 5 So why does the change made to person take e\ufb00ect in main , but the change made to the integer does not? When the call is made, the main method passes an object reference for person to the setPersonName method any change that setAnotherName makes to that object is part of that object, and so those changes are still part of that object when the method returns. Another way of saying the same thing person points to an object stored on the heap, if youre interested. Any change the method makes to that object are made on that object, and are not a\ufb00ected by whether the method making the change is still active or has returned. When the method returns, any changes made to the object are still stored on that object. GoalKicker.com Java", "Notes for Professionals 392Contrast this with the integer that is passed. Since this is a primitive int and not an Integer object instance, it is passed by value, meaning its value is provided to the method, not a pointer to the original integer passed in. The method can change it for the methods own purposes, but that does not a\ufb00ect the variable used when the method call is made. In Java, all primitives are passed by value. Objects are passed by reference, which means that a pointer to the object is passed as the parameter to any methods that take them. One less-obvious thing this means it is not possible for a called method to create a new object and return it as one of the parameters. The only way for a method to return an object that is created, directly or indirectly, by the method call, is as a return value from the method. Lets \ufb01rst see how that would not work, and then how it would work. Lets add another method to our little example here private static void getAnotherObjectNot Person person person new Person person. setNameGeorge And, back in the main , below the call to", "setAnotherName , lets put a call to this method and another println call getAnotherObjectNot person System.out.printlnperson.getName Now the program would print out Linda 5 Linda What happened to the object that had George? Well, the parameter that was passed in was a pointer to Linda when the getAnotherObjectNot method created a new object, it replaced the reference to the Linda object with a reference to the George object. The Linda object still exists on the heap, the main method can still access it, but the getAnotherObjectNot method wouldnt be able to do anything with it after that, because it has no reference to it. It would appear that the writer of the code intended for the method to create a new object and pass it back, but if so, it didnt work. If that is what the writer wanted to do, he would need to return the newly created object from the method, something like this private static Person getAnotherObject Person person new Person person. setNameMary return person Then call it like this Person mary mary getAnotherObject System.out.printlnmary.getName And the entire program output would now be Linda 5 GoalKicker.com Java Notes for Professionals 393Linda Mary Here is the entire", "program, with both additions public class Person private String name public void setName String name this.name name public String getName return name public static void mainString arguments Person person new Person person. setNameBob int i 5 setPersonName person, i System.out.printlnperson.getName i getAnotherObjectNot person System.out.printlnperson.getName Person person person getAnotherObject System.out.printlnperson.getName private static void setPersonName Person person, int num person. setNameLinda num 99 private static void getAnotherObjectNot Person person person new Person person. setMyName George private static person getAnotherObject Person person new Person person. setMyName Mary return person GoalKicker.com Java Notes for Professionals 394Chapter 69 Exceptions and exception handling Objects of type Throwable and its subtypes can be sent up the stack with the throw keyword and caught with trycatch statements. Section 69.1 Catching an exception with try-catch An exception can be caught and handled using the try...catch statement. In fact try statements take other forms, as described in other examples about try...catch...finally and try-with-resources . Try-catch with one catch block The most simple form looks like this try doSomething catch SomeException e handle e next statement The behavior of a simple try...catch is as follows The statements in the try block are executed. If no exception is thrown by the", "statements in the try block, then control passes to the next statement after the try...catch . If an exception is thrown within the try block. The exception object is tested to see if it is an instance of SomeException or a subtype. If it is, then the catch block will catch the exception The variable e is bound to the exception object. The code within the catch block is executed. If that code throws an exception, then the newly thrown exception is propagated in place of the original one. Otherwise, control passes to the next statement after the try...catch . If it is not, the original exception continues to propagate. Try-catch with multiple catches A try...catch can also have multiple catch blocks. For example try doSomething catch SomeException e handleOneWay e catch SomeOtherException e handleAnotherWay e next statement If there are multiple catch blocks, they are tried one at a time starting with the \ufb01rst one, until a match is found for the exception. The corresponding handler is executed as above, and then control is passed to the next statement after the try...catch statement. The catch blocks after the one that matches are always skipped, even if the handler", "code throws an exception . GoalKicker.com Java Notes for Professionals 395The top down matching strategy has consequences for cases where the exceptions in the catch blocks are not disjoint. For example try throw new RuntimeException test catch Exception e System.out.printlnException catch RuntimeException e System.out.printlnRuntimeException This code snippet will output Exception rather than RuntimeException. Since RuntimeException is a subtype of Exception , the \ufb01rst more general catch will be matched. The second more speci\ufb01c catch will never be executed. The lesson to learn from this is that the most speci\ufb01c catch blocks in terms of the exception types should appear \ufb01rst, and the most general ones should be last. Some Java compilers will warn you if a catch can never be executed, but this is not a compilation error. Multi-exception catch blocks Version Java SE 7 Starting with Java SE 7, a single catch block can handle a list of unrelated exceptions. The exception type are listed, separated with a vertical bar symbol. For example try doSomething catch SomeException SomeOtherException e handleSomeException e The behavior of a multi-exception catch is a simple extension for the single-exception case. The catch matches if the thrown exception matches at least one of the", "listed exceptions. There is some additional subtlety in the speci\ufb01cation. The type of e is a synthetic union of the exception types in the list. When the value of e is used, its static type is the least common supertype of the type union. However, if e is rethrown within the catch block, the exception types that are thrown are the types in the union. For example public void method throws IOException , SQLException try doSomething catch IOException SQLException e report e throw e In the above, IOException and SQLException are checked exceptions whose least common supertype is Exception . This means that the report method must match reportException . However, the compiler knows that the throw can throw only an IOException or an SQLException . Thus, method can be declared as throws IOException , SQLException rather than throws Exception . Which is a good thing see Pitfall - Throwing Throwable, Exception, Error or RuntimeException. Section 69.2 The try-with-resources statement Version Java SE 7 GoalKicker.com Java Notes for Professionals 396As the try-catch-\ufb01nal statement example illustrates, resource cleanup using a finally clause requires a signi\ufb01cant amount of boiler-plate code to implement the edge-cases correctly. Java 7 provides a much simpler", "way to deal with this problem in the form of the try-with-resources statement. What is a resource? Java 7 introduced the java.lang.AutoCloseable interface to allow classes to be managed using the try-with- resources statement. Instances of classes that implement AutoCloseable are referred to as resources . These typically need to be disposed of in a timely fashion rather than relying on the garbage collector to dispose of them. The AutoCloseable interface de\ufb01nes a single method public void close throws Exception A close method should dispose of the resource in an appropriate fashion. The speci\ufb01cation states that it should be safe to call the method on a resource that has already been disposed of. In addition, classes that implement Autocloseable are strongly encouraged to declare the close method to throw a more speci\ufb01c exception than Exception , or no exception at all. A wide range of standard Java classes and interfaces implement AutoCloseable . These include InputStream , OutputStream and their subclasses Reader , Writer and their subclasses Socket and ServerSocket and their subclasses Channel and its subclasses, and the JDBC interfaces Connection , Statement and ResultSet and their subclasses. Application and third party classes may do this as well.", "The basic try-with-resource statement The syntax of a try-with-resources is based on classical try-catch , try-\ufb01nally and try-catch-\ufb01nally forms. Here is an example of a basic form i.e. the form without a catch or finally . try PrintStream stream new PrintStream hello.txt stream. printlnHello world! The resources to be manage are declared as variables in the ... section after the try clause. In the example above, we declare a resource variable stream and initialize it to a newly created PrintStream . Once the resource variables have been initialized, the try block is executed. When that completes, stream.close will be called automatically to ensure that the resource does not leak. Note that the close call happens no matter how the block completes. The enhanced try-with-resource statements The try-with-resources statement can be enhanced with catch and finally blocks, as with the pre-Java 7 try-catch- \ufb01nally syntax. The following code snippet adds a catch block to our previous one to deal with the FileNotFoundException that the PrintStream constructor can throw try PrintStream stream new PrintStream hello.txt stream. printlnHello world! catch FileNotFoundException ex System.err.printlnCannot open the file GoalKicker.com Java Notes for Professionals 397 finally System.err.printlnAll done If either the resource initialization or the", "try block throws the exception, then the catch block will be executed. The finally block will always be executed, as with a conventional try-catch-\ufb01nally statement. There are a couple of things to note though The resource variable is out of scope in the catch and finally blocks. The resource cleanup will happen before the statement tries to match the catch block. If the automatic resource cleanup threw an exception, then that could be caught in one of the catch blocks. Managing multiple resources The code snippets above show a single resource being managed. In fact, try-with-resources can manage multiple resources in one statement. For example try InputStream is new FileInputStream file1 OutputStream os new FileOutputStream file2 Copy is to os This behaves as you would expect. Both is and os are closed automatically at the end of the try block. There are a couple of points to note The initializations occur in the code order, and later resource variable initializers can use of the values of the earlier ones. All resource variables that were successfully initialized will be cleaned up. Resource variables are cleaned up in reverse order of their declarations. Thus, in the above example, is is initialized", "before os and cleaned up after it, and is will be cleaned up if there is an exception while initializing os. Equivalence of try-with-resource and classical try-catch-\ufb01nally The Java Language Speci\ufb01cation speci\ufb01es the behavior of try-with-resource forms in terms of the classical try-catch- \ufb01nally statement. Please refer to the JLS for the full details. For example, this basic try-with-resource try PrintStream stream new PrintStream hello.txt stream. printlnHello world! is de\ufb01ned to be equivalent to this try-catch-\ufb01nally Note that the constructor is not part of the try-catch statement PrintStream stream new PrintStream hello.txt This variable is used to keep track of the primary exception thrown in the try statement. If an exception is thrown in the try block, any exception thrown by AutoCloseable.close will be suppressed. Throwable primaryException null The actual try block try GoalKicker.com Java Notes for Professionals 398 stream. printlnHello world! catch Throwable t If an exception is thrown, remember it for the finally block primaryException t throw t finally if primaryException null If no exception was thrown so far, exceptions thrown in close will not be caught and therefore be passed on to the enclosing code. stream. close else If an exception has already been thrown, any", "exception thrown in close will be suppressed as it is likely to be related to the previous exception. The suppressed exception can be retrieved using primaryException.getSuppressed. try stream. close catch Throwable suppressedException primaryException. addSuppressed suppressedException The JLS speci\ufb01es that the actual t and primaryException variables will be invisible to normal Java code. The enhanced form of try-with-resources is speci\ufb01ed as an equivalence with the basic form. For example try PrintStream stream new PrintStream fileName stream. printlnHello world! catch NullPointerException ex System.err.printlnNull filename finally System.err.printlnAll done is equivalent to try try PrintStream stream new PrintStream fileName stream. printlnHello world! catch NullPointerException ex System.err.printlnNull filename finally System.err.printlnAll done Section 69.3 Custom Exceptions Under most circumstances, it is simpler from a code-design standpoint to use existing generic Exception classes when throwing exceptions. This is especially true if you only need the exception to carry a simple error message. In that case, RuntimeException is usually preferred, since it is not a checked Exception. Other exception classes exist for common classes of errors UnsupportedOperationException - a certain operation is not supported IllegalArgumentException - an invalid parameter value was passed to a method IllegalStateException - your API has internally reached a condition that should never", "happen, or which occurs as a result of using your API in an invalid way GoalKicker.com Java Notes for Professionals 399Cases where you do want to use a custom exception class include the following You are writing an API or library for use by others, and you want to allow users of your API to be able to speci\ufb01cally catch and handle exceptions from your API, and be able to di\ufb00erentiate those exceptions from other, more generic exceptions . You are throwing exceptions for a speci\ufb01c kind of error in one part of your program, which you want to catch and handle in another part of your program, and you want to be able to di\ufb00erentiate these errors from other, more generic errors. You can create your own custom exceptions by extending RuntimeException for an unchecked exception, or checked exception by extending any Exception which is not also subclass of RuntimeException , because Subclasses of Exception that are not also subclasses of RuntimeException are checked exceptions public class StringTooLongException extends RuntimeException Exceptions can have methods and fields like other classes those can be useful to communicate information to pieces of code catching such an exception public final String value", "public final int maximumLength public StringTooLongException String value, int maximumLength superString.formatString exceeds maximum Length of s s , maximumLength, value this.value value this.maximumLength maximumLength Those can be used just as prede\ufb01ned exceptions void validateString String value if value.length 30 throw new StringTooLongException value, 30 And the \ufb01elds can be used where the exception is caught and handled void anotherMethod String value try validateString value catchStringTooLongException e System.out.printlnThe string e.value was longer than the max of e.maximumLength Keep in mind that, according to Oracles Java Documentation ... If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception. More GoalKicker.com Java Notes for Professionals 400Why does RuntimeException not require an explicit exception handling? Section 69.4 Handling InterruptedException InterruptedException is a confusing beast - it shows up in seemingly innocuous methods like Thread.sleep, but handling it incorrectly leads to hard-to-manage code that behaves poorly in concurrent environments. At its most basic, if an InterruptedException is caught it means someone, somewhere, called Thread.interrupt on the thread your code is currently running in. You might be inclined to say Its my", "code! Ill never interrupt it! and therefore do something like this Bad. Dont do this. try Thread.sleep1000 catch InterruptedException e disregard But this is exactly the wrong way to handle an impossible event occurring. If you know your application will never encounter an InterruptedException you should treat such an event as a serious violation of your programs assumptions and exit as quickly as possible. The proper way to handle an impossible interrupt is like so When nothing will interrupt your code try Thread.sleep1000 catch InterruptedException e Thread.currentThread .interrupt throw new AssertionError e This does two things it \ufb01rst restores the interrupt status of the thread as if the InterruptedException had not been thrown in the \ufb01rst place, and then it throws an AssertionError indicating the basic invariants of your application have been violated. If you know for certain that youll never interrupt the thread this code runs in this is safe since the catch block should never be reached. Using Guavas Uninterruptibles class helps simplify this pattern calling Uninterruptibles. sleepUninterruptibly disregards the interrupted state of a thread until the sleep duration has expired at which point its restored for later calls to inspect and throw their own InterruptedException .", "If you know youll never interrupt such code this safely avoids needing to wrap your sleep calls in a try-catch block. More often, however, you cannot guarantee that your thread will never be interrupted. In particular if youre writing code that will be executed by an Executor or some other thread-management its critical that your code responds promptly to interrupts, otherwise your application will stall or even deadlock. In such cases the best thing to do is generally to allow the InterruptedException to propagate up the call stack, adding a throws InterruptedException to each method in turn. This may seem kludgy but its actually a desirable property - your methods signatures now indicates to callers that it will respond promptly to interrupts. Let the caller determine how to handle the interrupt if youre unsure public void myLongRunningMethod throws InterruptedException ... GoalKicker.com Java Notes for Professionals 401In limited cases e.g. while overriding a method that doesnt throw any checked exceptions you can reset the interrupted status without raising an exception, expecting whatever code is executed next to handle the interrupt. This delays handling the interruption but doesnt suppress it entirely. Suppresses the exception but resets the interrupted state letting later", "code detect the interrupt and handle it properly. try Thread.sleep1000 catch InterruptedException e Thread.currentThread .interrupt return ... your expectations are still broken at this point - try not to do more work. Section 69.5 Return statements in try catch block Although its bad practice, its possible to add multiple return statements in a exception handling block public static int returnTest int number try ifnumber2 0 throw new Exception Exception thrown else return x catchException e return 3 finally return 7 This method will always return 7 since the \ufb01nally block associated with the trycatch block is executed before anything is returned. Now, as \ufb01nally has return 7, this value supersedes the trycatch return values. If the catch block returns a primitive value and that primitive value is subsequently changed in the \ufb01nally block, the value returned in the catch block will be returned and the changes from the \ufb01nally block will be ignored. The example below will print 0, not 1. public class FinallyExample public static void mainString args int n returnTest 4 System.out.printlnn public static int returnTest int number int returnNumber 0 try if number 2 0 throw new Exception Exception thrown else return returnNumber catch Exception e", "return returnNumber finally returnNumber 1 GoalKicker.com Java Notes for Professionals 402 Section 69.6 Introduction Exceptions are errors which occur when a program is executing. Consider the Java program below which divides two integers. class Division public static void mainString args int a, b, result Scanner input new Scanner System.in System.out.printlnInput two integers a input.nextInt b input.nextInt result a b System.out.printlnResult result Now we compile and execute the above code, and see the output for an attempted division by zero Input two integers 7 0 Exception in thread main java.lang.ArithmeticException by zero at Division.mainDisivion.java14 Division by zero is an invalid operation that would produce a value that cannot be represented as an integer. Java deals with this by throwing an exception . In this case, the exception is an instance of the ArithmeticException class. Note The example on creating and reading stack traces explains what the output after the two numbers means. The utility of an exception is the \ufb02ow control that it allows. Without using exceptions, a typical solution to this problem may be to \ufb01rst check if b 0 class Division public static void mainString args int a, b, result Scanner input new Scanner System.in System.out.printlnInput two integers", "a input.nextInt b input.nextInt if b 0 System.out.printlnYou cannot divide by zero. return GoalKicker.com Java Notes for Professionals 403 result a b System.out.printlnResult result This prints the message You cannot divide by zero. to the console and quits the program in a graceful way when the user tries to divide by zero. An equivalent way of dealing with this problem via exception handling would be to replace the if \ufb02ow control with a try-catch block ... a input.nextInt b input.nextInt try result a b catch ArithmeticException e System.out.printlnAn ArithmeticException occurred. Perhaps you tried to divide by zero. return ... A try catch block is executed as follows Begin executing the code in the try block. 1. If an exception occurs in the try block, immediately abort and check to see if this exception is caught by the 2. catch block in this case, when the Exception is an instance of ArithmeticException . If the exception is caught , it is assigned to the variable e and the catch block is executed. 3. If either the try or catch block is completed i.e. no uncaught exceptions occur during code execution then 4. continue to execute code below the try-catch block.", "It is generally considered good practice to use exception handling as part of the normal \ufb02ow control of an application where behavior would otherwise be unde\ufb01ned or unexpected. For instance, instead of returning null when a method fails, it is usually better practice to throw an exception so that the application making use of the method can de\ufb01ne its own \ufb02ow control for the situation via exception handling of the kind illustrated above. In some sense, this gets around the problem of having to return a particular type, as any one of multiple kinds of exceptions may be thrown to indicate the speci\ufb01c problem that occurred. For more advice on how and how not to use exceptions, refer to Java Pitfalls - Exception usage Section 69.7 The Java Exception Hierarchy - Unchecked and Checked Exceptions All Java exceptions are instances of classes in the Exception class hierarchy. This can be represented as follows java.lang.Throwable - This is the base class for all exception classes. Its methods and constructors implement a range of functionality common to all exceptions. java.lang.Exception - This is the superclass of all normal exceptions. various standard and custom exception classes. java.lang.RuntimeException - This the superclass of", "all normal exceptions that are unchecked exceptions . various standard and custom runtime exception classes. GoalKicker.com Java Notes for Professionals 404java.lang.Error - This is the superclass of all fatal error exceptions. Notes The distinction between checked and unchecked exceptions is described below. 1. The Throwable , Exception and RuntimeException class should be treated as abstract see Pitfall - Throwing 2. Throwable, Exception, Error or RuntimeException. The Error exceptions are thrown by the JVM in situations where it would be unsafe or unwise for an 3. application to attempt to recover. It would be unwise to declare custom subtypes of Throwable . Java tools and libraries may assume that Error 4. and Exception are the only direct subtypes of Throwable , and misbehave if that assumption is incorrect. Checked versus Unchecked Exceptions One of the criticisms of exception support in some programming languages is that is di\ufb03cult to know which exceptions a given method or procedure might throw. Given that an unhandled exception is liable to cause a program to crash, this can make exceptions a source of fragility. The Java language addresses this concern with the checked exception mechanism. First, Java classi\ufb01es exceptions into two categories Checked exceptions typically", "represent anticipated events that an application should be able to deal with. For instance, IOException and its subtypes represent error conditions that can occur in IO operations. Examples include, \ufb01le opens failing because a \ufb01le or directory does not exist, network reads and writes failing because a network connection has been broken and so on. Unchecked exceptions typically represent unanticipated events that an application cannot deal with. These are typically the result of a bug in the application. In the following, thrown refers to any exception thrown explicitly by a throw statement, or implicitly in a failed dereference, type cast and so on. Similarly, propagated refers to an exception that was thrown in a nested call, and not caught within that call. The sample code below will illustrate this. The second part of the checked exception mechanism is that there are restrictions on methods where a checked exception may occur When a checked exception is thrown or propagated in a method, it must either be caught by the method, or listed in the methods throws clause. The signi\ufb01cance of the throws clause is described in this example. When a checked exception is thrown or propagated in an initializer block,", "it must be caught the the block. A checked exception cannot be propagated by a method call in a \ufb01eld initialization expression. There is no way to catch such an exception. In short, a checked exception must be either handled, or declared. These restrictions do not apply to unchecked exceptions. This includes all cases where an exception is thrown implicitly, since all such cases throw unchecked exceptions. Checked exception examples These code snippets are intended to illustrate the checked exception restrictions. In each case, we show a version of the code with a compilation error, and a second version with the error corrected. This declares a custom checked exception. public class MyException extends Exception constructors omitted. GoalKicker.com Java Notes for Professionals 405 This declares a custom unchecked exception. public class MyException2 extends RuntimeException constructors omitted. The \ufb01rst example shows how explicitly thrown checked exceptions can be declared as thrown if they should not be handled in the method. INCORRECT public void methodThrowingCheckedException boolean flag int i 1 0 Compiles OK, throws ArithmeticException if flag throw new MyException Compilation error else throw new MyException2 Compiles OK CORRECTED public void methodThrowingCheckedException boolean flag throws MyException int i 1 0 Compiles OK,", "throws ArithmeticException if flag throw new MyException Compilation error else throw new MyException2 Compiles OK The second example shows how a propagated checked exception can be dealt with. INCORRECT public void methodWithPropagatedCheckedException InputStream is new FileInputStream someFile.txt Compilation error FileInputStream throws IOException or a subclass if the file cannot be opened. IOException is a checked exception. ... CORRECTED Version A public void methodWithPropagatedCheckedException throws IOException InputStream is new FileInputStream someFile.txt ... CORRECTED Version B public void methodWithPropagatedCheckedException try InputStream is new FileInputStream someFile.txt ... catch IOException ex System.out.printlnCannot open file ex.getMessage The \ufb01nal example shows how to deal with a checked exception in a static \ufb01eld initializer. INCORRECT public class Test GoalKicker.com Java Notes for Professionals 406 private static final InputStream is new FileInputStream someFile.txt Compilation error CORRECTED public class Test private static final InputStream is static InputStream tmp null try tmp new FileInputStream someFile.txt catch IOException ex System.out.printlnCannot open file ex.getMessage is tmp Note that in this last case, we also have to deal with the problems that is cannot be assigned to more than once, and yet also has to be assigned to, even in the case of an exception. Section 69.8 Creating and reading stacktraces When", "an exception object is created i.e. when you new it, the Throwable constructor captures information about the context in which the exception was created. Later on, this information can be output in the form of a stacktrace, which can be used to help diagnose the problem that caused the exception in the \ufb01rst place. Printing a stacktrace Printing a stacktrace is simply a matter of calling the printStackTrace method. For example try int a 0 int b 0 int c a b catch ArithmeticException ex This prints the stacktrace to standard output ex.printStackTrace The printStackTrace method without arguments will print to the applications standard output i.e. the current System.out. There are also printStackTrace PrintStream and printStackTrace PrintWriter overloads that print to a speci\ufb01ed Stream or Writer . Notes The stacktrace does not include the details of the exception itself. You can use the toString method to get 1. those details e.g. Print exception and stacktrace System.out.printlnex ex.printStackTrace Stacktrace printing should be used sparingly see Pitfall - Excessive or inappropriate stacktraces . It is often2. better to use a logging framework, and pass the exception object to be logged. Understanding a stacktrace GoalKicker.com Java Notes for Professionals 407Consider the following", "simple program consisting of two classes in two \ufb01les. We have shown the \ufb01lenames and added line numbers for illustration purposes. File Main.java 1 public class Main 2 public static void mainString args 3 new Test.foo 4 5 File Test.java 1 class Test 2 public void foo 3 bar 4 5 6 public int bar 7 int a 1 8 int b 0 9 return a b 10 When these \ufb01les are compiled and run, we will get the following output. Exception in thread main java.lang.ArithmeticException by zero at Test.barTest.java9 at Test.fooTest.java3 at Main.mainMain.java3 Let us read this one line at a time to \ufb01gure out what it is telling us. Line 1 tells us that the thread called main has terminated due to an uncaught exception. The full name of the exception is java.lang.ArithmeticException , and the exception message is by zero. If we look up the javadocs for this exception, it says Thrown when an exceptional arithmetic condition has occurred. For example, an integer divide by zero throws an instance of this class. Indeed, the message by zero is a strong hint that the cause of the exception is that some code has attempted to divide something", "by zero. But what? The remaining 3 lines are the stack trace. Each line represents a method or constructor call on the call stack, and each one tells us three things the name of the class and method that was being executed, the source code \ufb01lename, the source code line number of the statement that was being executed These lines of a stacktrace are listed with the frame for the current call at the top. The top frame in our example above is in the Test.bar method, and at line 9 of the Test.java \ufb01le. That is the following line return a b GoalKicker.com Java Notes for Professionals 408If we look a couple of lines earlier in the \ufb01le to where b is initialized, it is apparent that b will have the value zero. We can say without any doubt that this is the cause of the exception. If we needed to go further, we can see from the stacktrace that bar was called from foo at line 3 of Test.java, and that foo was in turn called from Main.main. Note The class and method names in the stack frames are the internal names for the classes and methods.", "You will need to recognize the following unusual cases A nested or inner class will look like OuterClassInnerClass. An anonymous inner class will look like OuterClass1, OuterClass2, etcetera. When code in a constructor, instance \ufb01eld initializer or an instance initializer block is being executed, the method name will be . When code in a static \ufb01eld initializer or static initializer block is being executed, the method name will be . In some versions of Java, the stacktrace formatting code will detect and elide repeated stackframe sequences, as can occur when an application fails due to excessive recursion. Exception chaining and nested stacktraces Version Java SE 1.4 Exception chaining happens when a piece of code catches an exception, and then creates and throws a new one, passing the \ufb01rst exception as the cause. Here is an example File Test,java 1 public class Test 2 int foo 3 return 0 0 4 5 6 public Test 7 try 8 foo 9 catch ArithmeticException ex 10 throw new RuntimeException A bad thing happened , ex 11 12 13 14 public static void mainString args 15 new Test 16 17 When the above class is compiled and run, we get the following stacktrace", "Exception in thread main java.lang.RuntimeException A bad thing happened at Test. initTest.java10 at Test. mainTest.java15 Caused by java.lang.ArithmeticException by zero at Test. fooTest.java3 at Test. initTest.java8 ... 1 more The stacktrace starts with the class name, method and call stack for the exception that in this case caused the application to crash. This is followed by a Caused by line that reports the cause exception. The class name and message are reported, followed by the cause exceptions stack frames. The trace ends with an ... N more which indicates that the last N frames are the same as for the previous exception. GoalKicker.com Java Notes for Professionals 409The Caused by is only included in the output when the primary exceptions cause is not null . Exceptions can be chained inde\ufb01nitely, and in that case the stacktrace can have multiple Caused by traces. Note the cause mechanism was only exposed in the Throwable API in Java 1.4.0. Prior to that, exception chaining needed to be implemented by the application using a custom exception \ufb01eld to represent the cause, and a custom printStackTrace method. Capturing a stacktrace as a String Sometimes, an application needs to be able to capture a stacktrace", "as a Java String , so that it can be used for other purposes. The general approach for doing this is to create a temporary OutputStream or Writer that writes to an in- memory bu\ufb00er and pass that to the printStackTrace .... The Apache Commons and Guava libraries provide utility methods for capturing a stacktrace as a String org.apache.commons.lang.exception .ExceptionUtils .getStackTrace Throwable com.google.common.base.Throwables .getStackTraceAsString Throwable If you cannot use third party libraries in your code base, then the following method with do the task Returns the string representation of the stack trace. param throwable the throwable return the string. public static String stackTraceToString Throwable throwable StringWriter stringWriter new StringWriter throwable. printStackTrace new PrintWriter stringWriter return stringWriter. toString Note that if your intention is to analyze the stacktrace, it is simpler to use getStackTrace and getCause than to attempt to parse a stacktrace. Section 69.9 Throwing an exception The following example shows the basics of throwing an exception public void checkNumber int number throws IllegalArgumentException if number 0 throw new IllegalArgumentException Number must be positive number The exception is thrown on the 3rd line. This statement can be broken down into two parts new IllegalArgumentException ... is creating an instance", "of the IllegalArgumentException class, with a message that describes the error that exception is reporting. throw ... is then throwing the exception object. When the exception is thrown, it causes the enclosing statements to terminate abnormally until the exception is handled . This is described in other examples. GoalKicker.com Java Notes for Professionals 410It is good practice to both create and throw the exception object in a single statement, as shown above. It is also good practice to include a meaningful error message in the exception to help the programmer to understand the cause of the problem. However, this is not necessarily the message that you should be showing to the end user. For a start, Java has no direct support for internationalizing exception messages. There are a couple more points to be made We have declared the checkNumber as throws IllegalArgumentException . This was not strictly necessary, since IllegalArgumentException is a checked exception see The Java Exception Hierarchy - Unchecked and Checked Exceptions. However, it is good practice to do this, and also to include the exceptions thrown a methods javadoc comments. Code immediately after a throw statement is unreachable . Hence if we wrote this throw new", "IllegalArgumentException it is bad return the compiler would report a compilation error for the return statement. Exception chaining Many standard exceptions have a constructor with a second cause argument in addition to the conventional message argument. The cause allows you to chain exceptions. Here is an example. First we de\ufb01ne an unchecked exception that our application is going throw when it encounters a non-recoverable error. Note that we have included a constructor that accepts a cause argument. public class AppErrorException extends RuntimeException public AppErrorException super public AppErrorException String message supermessage public AppErrorException String message, Throwable cause supermessage, cause Next, here is some code that illustrates exception chaining. public String readFirstLine String file throws AppErrorException try Reader r new BufferedReader new FileReader file String line r.readLine if line ! null return line else throw new AppErrorException File is empty file catch IOException ex throw new AppErrorException Cannot read file file, ex GoalKicker.com Java Notes for Professionals 411The throw within the try block detects a problem and reports it via an exception with a simple message. By contrast, the throw within the catch block is handling the IOException by wrapping it in a new checked exception. However, it is not throwing", "away the original exception. By passing the IOException as the cause , we record it so that it can be printed in the stacktrace, as explained in Creating and reading stacktraces. Section 69.10 Advanced features of Exceptions This example covers some advanced features and use-cases for Exceptions. Examining the callstack programmatically Version Java SE 1.4 The primary use of exception stacktraces is to provide information about an application error and its context so that the programmer can diagnose and \ufb01x the problem. Sometimes it can be used for other things. For example, a SecurityManager class may need to examine the call stack to decide whether the code that is making a call should be trusted. You can use exceptions to examine the call stack programmatically as follows Exception ex new Exception this captures the call stack StackTraceElement frames ex.getStackTrace System.out.printlnThis method is frames0.getMethodName System.out.printlnCalled from method frames1.getMethodName There are some important caveats on this The information available in a StackTraceElement is limited. There is no more information available than is 1. displayed by printStackTrace . The values of the local variables in the frame are not available. The javadocs for getStackTrace state that a JVM is permitted to leave", "out frames 2. Some virtual machines may, under some circumstances, omit one or more stack frames from the stack trace. In the extreme case, a virtual machine that has no stack trace information concerning this throwable is permitted to return a zero-length array from this method. Optimizing exception construction As mentioned elsewhere, constructing an exception is rather expensive because it entails capturing and recording information about all stack frames on the current thread. Sometimes, we know that that information is never going to be used for a given exception e.g. the stacktrace will never be printed. In that case, there is an implementation trick that we can use in a custom exception to cause the information to not be captured. The stack frame information needed for stacktraces, is captured when the Throwable constructors call the Throwable .fillInStackTrace method. This method is public , which means that a subclass can override it. The trick is to override the method inherited from Throwable with one that does nothing e.g. public class MyException extends Exception constructors Override public void fillInStackTrace do nothing GoalKicker.com Java Notes for Professionals 412 The problem with this approach is that an exception that overrides fillInStackTrace can never", "capture the stacktrace, and is useless in scenarios where you need one. Erasing or replacing the stacktrace Version Java SE 1.4 In some situations, the stacktrace for an exception created in the normal way contains either incorrect information, or information that the developer does not want to reveal to the user. For these scenarios, the Throwable .setStackTrace can be used to replace the array of StackTraceElement objects that holds the information. For example, the following can be used to discard an exceptions stack information exception. setStackTrace new StackTraceElement 0 Suppressed exceptions Version Java SE 7 Java 7 introduced the try-with-resources construct, and the associated concept of exception suppression. Consider the following snippet try Writer w new BufferedWriter new FileWriter someFilename do stuff int temp 0 0 throws an ArithmeticException When the exception is thrown, the try will call close on the w which will \ufb02ush any bu\ufb00ered output and then close the FileWriter . But what happens if an IOException is thrown while \ufb02ushing the output? What happens is that any exception that is thrown while cleaning up a resource is suppressed . The exception is caught, and added to the primary exceptions suppressed exception list. Next the try-with-resources", "will continue with the cleanup of the other resources. Finally, primary exception will be rethrown. A similar pattern occurs if an exception it thrown during the resource initialization, or if the try block completes normally. The \ufb01rst exception thrown becomes the primary exception, and subsequent ones arising from cleanup are suppressed. The suppressed exceptions can be retrieved from the primary exception object by calling getSuppressedExceptions . Section 69.11 The try-\ufb01nally and try-catch-\ufb01nally statements The try...catch...finally statement combines exception handling with clean-up code. The finally block contains code that will be executed in all circumstances. This makes them suitable for resource management, and other kinds of cleanup. Try-\ufb01nally Here is an example of the simpler try...finally form try doSomething finally cleanUp GoalKicker.com Java Notes for Professionals 413 The behavior of the try...finally is as follows The code in the try block is executed. If no exception was thrown in the try block The code in the finally block is executed. If the finally block throws an exception, that exception is propagated. Otherwise, control passes to the next statement after the try...finally . If an exception was thrown in the try block The code in the finally block is executed. If", "the finally block throws an exception, that exception is propagated. Otherwise, the original exception continues to propagate. The code within finally block will always be executed. The only exceptions are if System.exitint is called, or if the JVM panics. Thus a finally block is the correct place code that always needs to be executed e.g. closing \ufb01les and other resources or releasing locks. try-catch-\ufb01nally Our second example shows how catch and finally can be used together. It also illustrates that cleaning up resources is not straightforward. This code snippet writes the first line of a file to a string String result null Reader reader null try reader new BufferedReader new FileReader fileName result reader. readLine catch IOException ex Logger. getLogger .warnUnexpected IO error , ex logging the exception finally if reader ! null try reader. close catch IOException ex ignore discard this exception The complete set of hypothetical behaviors of try...catch...finally in this example are too complicated to describe here. The simple version is that the code in the finally block will always be executed. Looking at this from the perspective of resource management We declare the resource i.e. reader variable before the try block so that it will", "be in scope for the finally block. By putting the new FileReader ..., the catch is able to handle any IOError exception from thrown when opening the \ufb01le. We need a reader.close in the finally block because there are some exception paths that we cannot intercept either in the try block or in catch block. However, since an exception might have been thrown before reader was initialized, we also need an explicit null test. Finally, the reader.close call might hypothetically throw an exception. We dont care about that, but if we dont catch the exception at source, we would need to deal with it further up the call stack. GoalKicker.com Java Notes for Professionals 414Version Java SE 7 Java 7 and later provide an alternative try-with-resources syntax which signi\ufb01cantly simpli\ufb01es resource clean-up. Section 69.12 The throws clause in a method declaration Javas checked exception mechanism requires the programmer to declare that certain methods could throw specifed checked exceptions. This is done using the throws clause. For example public class OddNumberException extends Exception a checked exception public void checkEven int number throws OddNumberException if number 2 ! 0 throw new OddNumberException The throws OddNumberException declares that a call to checkEven", "could throw an exception that is of type OddNumberException . A throws clause can declare a list of types, and can include unchecked exceptions as well as checked exceptions. public void checkEven Double number throws OddNumberException, ArithmeticException if !Double.isFinite number throw new ArithmeticException INF or NaN else if number 2 ! 0 throw new OddNumberException What is the point of declaring unchecked exceptions as thrown? The throws clause in a method declaration serves two purposes It tells the compiler which exceptions are thrown so that the compiler can report uncaught checked1. exceptions as errors. It tells a programmer who is writing code that calls the method what exceptions to expect. For this purpose,2. it often makes to senses to include unchecked exceptions in a throws list. Note that the throws list is also used by the javadoc tool when generating API documentation, and by a typical IDEs hover text method tips. Throws and method overriding The throws clause forms part of a methods signature for the purpose of method overriding. An override method can be declared with the same set of checked exceptions as thrown by the overridden method, or with a subset. However the override method cannot add", "extra checked exceptions. For example Override public void checkEven int number throws NullPointerException OK NullPointerException is an unchecked exception ... GoalKicker.com Java Notes for Professionals 415Override public void checkEven Double number throws OddNumberException OK identical to the superclass ... class PrimeNumberException extends OddNumberException class NonEvenNumberException extends OddNumberException Override public void checkEven int number throws PrimeNumberException, NonEvenNumberException OK these are both subclasses Override public void checkEven Double number throws IOExcepion ERROR The reason for this rule is that if an overridden method can throw a checked exception that the overridden method could not throw, that would break type substitutability. GoalKicker.com Java Notes for Professionals 416Chapter 70 Calendar and its Subclasses Section 70.1 Creating Calendar objects Calendar objects can be created by using getInstance or by using the constructor GregorianCalendar . Its important to notice that months in Calendar are zero based, which means that JANUARY is represented by an int value 0. In order to provide a better code, always use Calendar constants, such as Calendar .JANUARY to avoid misunderstandings. Calendar calendar Calendar .getInstance Calendar gregorianCalendar new GregorianCalendar Calendar gregorianCalendarAtSpecificDay new GregorianCalendar 2016, Calendar .JANUARY, 1 Calendar gregorianCalendarAtSpecificDayAndTime new GregorianCalendar 2016, Calendar .JANUARY, 1, 6, 55, 10 Note Always use", "the month constants The numeric representation is misleading , e.g. Calendar .JANUARY has the value 0 Section 70.2 Increasing Decreasing calendar \ufb01elds add and roll can be used to increasedecrease Calendar \ufb01elds. Calendar calendar new GregorianCalendar 2016, Calendar .MARCH, 31 31 March 2016 The add method a\ufb00ects all \ufb01elds, and behaves e\ufb00ectively if one were to add or subtract actual dates from the calendar calendar. addCalendar .MONTH, -6 The above operation removes six months from the calendar, taking us back to 30 September 2015. To change a particular \ufb01eld without a\ufb00ecting the other \ufb01elds, use roll. calendar. rollCalendar .MONTH, -6 The above operation removes six months from the current month , so the month is identi\ufb01ed as September. No other \ufb01elds have been adjusted the year has not changed with this operation. Section 70.3 Subtracting calendars To get a di\ufb00erence between two Calendar s, use getTimeInMillis method Calendar c1 Calendar .getInstance Calendar c2 Calendar .getInstance c2.setCalendar .DATE, c2.getCalendar .DATE 1 System.out.printlnc2.getTimeInMillis - c1.getTimeInMillis outputs 86400000 24 60 60 1000 Section 70.4 Finding AMPM With Calendar class it is easy to \ufb01nd AM or PM. GoalKicker.com Java Notes for Professionals 417 Calendar cal Calendar .getInstance cal.setTimenew Date if cal.getCalendar .AMPM", "Calendar .PM System.out.printlnIt is PM GoalKicker.com Java Notes for Professionals 418Chapter 71 Using the static keyword Section 71.1 Reference to non-static member from static context Static variables and methods are not part of an instance, There will always be a single copy of that variable no matter how many objects you create of a particular class. For example you might want to have an immutable list of constants, it would be a good idea to keep it static and initialize it just once inside a static method. This would give you a signi\ufb01cant performance gain if you are creating several instances of a particular class on a regular basis. Furthermore you can also have a static block in a class as well. You can use it to assign a default value to a static variable. They are executed only once when the class is loaded into memory. Instance variable as the name suggest are dependent on an instance of a particular object, they live to serve the whims of it. You can play around with them during a particular life cycle of an object. All the \ufb01elds and methods of a class used inside a static method of that", "class must be static or local. If you try to use instance non-static variables or methods, your code will not compile. public class Week static int daysOfTheWeek 7 static variable int dayOfTheWeek instance variable public static int getDaysLeftInWeek return Week.daysOfTheWeek -dayOfTheWeek this will cause errors public int getDaysLeftInWeek return Week.daysOfTheWeek -dayOfTheWeek this is valid public static int getDaysLeftInTheWeek int today return Week.daysOfTheWeek -today this is valid Section 71.2 Using static to declare constants As the static keyword is used for accessing \ufb01elds and methods without an instantiated class, it can be used to declare constants for use in other classes. These variables will remain constant across every instantiation of the class. By convention, static variables are always ALLCAPS and use underscores rather than camel case. ex static E STATICVARIABLENAME As constants cannot change, static can also be used with the final modi\ufb01er For example, to de\ufb01ne the mathematical constant of pi public class MathUtilities static final double PI 3.14159265358 GoalKicker.com Java Notes for Professionals 419 Which can be used in any class as a constant, for example public class MathCalculations Calculates the circumference of a circle public double calculateCircumference double radius return 2 radius MathUtilities. PI GoalKicker.com Java Notes", "for Professionals 420Chapter 72 Properties Class The properties object contains key and value pair both as a string. The java.util.Properties class is the subclass of Hashtable. It can be used to get property value based on the property key. The Properties class provides methods to get data from properties \ufb01le and store data into properties \ufb01le. Moreover, it can be used to get properties of system. Advantage of properties \ufb01le Recompilation is not required, if information is changed from properties \ufb01le If any information is changed from Section 72.1 Loading properties To load a properties \ufb01le bundled with your application public class Defaults public static Properties loadDefaults try InputStream bundledResource Defaults. class.getResourceAsStream defaults.properties Properties defaults new Properties defaults. loadbundledResource return defaults catch IOException e Since the resource is bundled with the application, we should never get here. throw new UncheckedIOException defaults.properties not properly packaged with application , e Section 72.2 Saving Properties as XML Storing Properties in a XML File The way you store properties \ufb01les as XML \ufb01les is very similar to the way you would store them as .properties \ufb01les. Just instead of using the store you would use storeToXML . public void saveProperties String location throws", "IOException make new instance of properties Properties prop new Properties set the property values prop. setProperty name, Steve prop. setProperty color, green prop. setProperty age, 23 check to see if the file already exists File file new Filelocation if !file.exists file. createNewFile GoalKicker.com Java Notes for Professionals 421 save the properties prop. storeToXML new FileOutputStream file, testing properties with xml When you open the \ufb01le it will look like this. Loading Properties from a XML File Now to load this \ufb01le as a properties you need to call the loadFromXML instead of the load that you would use with regular .properties \ufb01les. public static void loadProperties String location throws FileNotFoundException , IOException make new properties instance to load the file into Properties prop new Properties check to make sure the file exists File file new Filelocation if file.exists load the file prop. loadFromXML new FileInputStream file print out all the properties for String name prop.stringPropertyNames System.out.printlnname prop.getProperty name else System.err.printlnError No file found at location When you run this code you will get the following in the console age23 colorgreen nameSteve Section 72.3 Property \ufb01les caveat trailing whitespace Take a close look at these two property \ufb01les which are", "seemingly completely identical except they are really not identical GoalKicker.com Java Notes for Professionals 422 screenshots are from Notepad Since trailing whitespace is preserved the value of lastName would be Smith in the \ufb01rst case and Smith in the second case. Very rarely this is what users expect and one and can only speculate why this is the default behavior of Properties class. It is however easy to create an enhanced version of Properties that \ufb01xes this problem. The following class, TrimmedProperties , does just that. It is a drop-in replacement for standard Properties class. import java.io.FileInputStream import java.io.FileReader import java.io.IOException import java.io.InputStream import java.io.Reader import java.util.Map.Entry import java.util.Properties Properties class where values are trimmed for trailing whitespace if the properties are loaded from a file. p In the standard link java.util.Properties Properties class trailing whitespace is always preserved. When loading properties from a file such trailing whitespace is almost always iunintentionali. This class fixes this problem. The trimming of trailing whitespace only takes place if the source of input is a file and only where the input is line oriented meaning that for example loading from XML file is inoti changed by this class. For this reason this", "class is almost in all cases a safe drop-in replacement for the standard ttPropertiestt class. p Whitespace is defined here as any of space U0020 or tab U0009. public class TrimmedProperties extends Properties Reads a property list key and element pairs from the input byte stream. pBehaves exactly as link java.util.Propertiesloadjava.io.InputStream with the exception that trailing whitespace is trimmed from property values if ttinStreamtt is an instance of ttFileInputStreamtt. see java.util.Propertiesloadjava.io.InputStream param inStream the input stream. throws IOException if an error occurred when reading from the input stream. Override public void loadInputStream inStream throws IOException if inStream instanceof FileInputStream First read into temporary props using the standard way Properties tempProps new Properties tempProps. loadinStream GoalKicker.com Java Notes for Professionals 423 Now trim and put into target trimAndLoad tempProps else super.loadinStream Reads a property list key and element pairs from the input character stream in a simple line-oriented format. pBehaves exactly as link java.util.Propertiesloadjava.io.Reader with the exception that trailing whitespace is trimmed on property values if ttreadertt is an instance of ttFileReadertt. see java.util.Propertiesloadjava.io.Reader param reader the input character stream. throws IOException if an error occurred when reading from the input stream. Override public void loadReader reader throws IOException if", "reader instanceof FileReader First read into temporary props using the standard way Properties tempProps new Properties tempProps. loadreader Now trim and put into target trimAndLoad tempProps else super.loadreader private void trimAndLoad Properties p for EntryObject, Object entry p.entrySet if entry.getValue instanceof String put entry.getKey, trimTrailing String entry.getValue else put entry.getKey, entry. getValue Trims trailing space or tabs from a string. param str return public static String trimTrailing String str if str ! null read str from tail until char is no longer whitespace for int i str.length - 1 i 0 i-- if str.charAti ! str.charAti ! t return str.substring 0, i 1 return str GoalKicker.com Java Notes for Professionals 424Chapter 73 Lambda Expressions Lambda expressions provide a clear and concise way of implementing a single-method interface using an expression. They allow you to reduce the amount of code you have to create and maintain. While similar to anonymous classes, they have no type information by themselves. Type inference needs to happen. Method references implement functional interfaces using existing methods rather than expressions. They belong to the lambda family as well. Section 73.1 Introduction to Java lambdas Functional Interfaces Lambdas can only operate on a functional interface, which is", "an interface with just one abstract method. Functional interfaces can have any number of default or static methods. For this reason, they are sometimes referred to as Single Abstract Method Interfaces, or SAM Interfaces. interface Foo1 void bar interface Foo2 int barboolean baz interface Foo3 String barObject baz, int mink interface Foo4 default String bar default so not counted return baz void quux When declaring a functional interface the FunctionalInterface annotation can be added. This has no special e\ufb00ect, but a compiler error will be generated if this annotation is applied to an interface which is not functional, thus acting as a reminder that the interface should not be changed. FunctionalInterface interface Foo5 void bar FunctionalInterface interface BlankFoo1 extends Foo3 inherits abstract method from Foo3 FunctionalInterface interface Foo6 void bar boolean equalsObject obj overrides one of Objects method so not counted Conversely, this is not a functional interface, as it has more than one abstract method GoalKicker.com Java Notes for Professionals 425interface BadFoo void bar void quux -- Second method prevents lambda which one should be considered as lambda? This is also not a functional interface, as it does not have any methods interface BlankFoo2 Take note of the", "following. Suppose you have interface Parent public int parentMethod and interface Child extends Parent public int ChildMethod Then Child cannot be a functional interface since it has two speci\ufb01ed methods. Java 8 also provides a number of generic templated functional interfaces in the package java.util.function . For example, the built-in interface Predicate T wraps a single method which inputs a value of type T and returns a boolean . Lambda Expressions The basic structure of a Lambda expression is fi will then hold a singleton instance of a class, similar to an anonymous class, which implements FunctionalInterface and where the one methods de\ufb01nition is System.out.printlnHello . In other words, the above is mostly equivalent to FunctionalInterface fi new FunctionalInterface Override public void theOneMethod System.out.printlnHello The lambda is only mostly equivalent to the anonymous class because in a lambda, the meaning of expressions like this , super or toString reference the class within which the assignment takes place, not the newly created object. You cannot specify the name of the method when using a lambda but you shouldnt need to, because a functional interface must have only one abstract method, so Java overrides that one. GoalKicker.com Java Notes for Professionals", "426In cases where the type of the lambda is not certain, e.g. overloaded methods you can add a cast to the lambda to tell the compiler what its type should be, like so Object fooHolder Foo1 - System.out.printlnHello System.out.printlnfooHolder instanceof Foo1 returns true If the functional interfaces single method takes parameters, the local formal names of these should appear between the brackets of the lambda. There is no need to declare the type of the parameter or return as these are taken from the interface although it is not an error to declare the parameter types if you want to. Thus, these two examples are equivalent Foo2 longFoo new Foo2 Override public int barboolean baz return baz ? 1 0 Foo2 shortFoo x - return x ? 1 0 The parentheses around the argument can be omitted if the function only has one argument Foo2 np x - return x ? 1 0 okay Foo3 np2 x, y - x.toString y not okay Implicit Returns If the code placed inside a lambda is a Java expression rather than a statement , it is treated as a method which returns the value of the expression. Thus, the following two are", "equivalent IntUnaryOperator addOneShort x - x 1 IntUnaryOperator addOneLong x - return x 1 Accessing Local Variables value closures Since lambdas are syntactic shorthand for anonymous classes, they follow the same rules for accessing local variables in the enclosing scope the variables must be treated as final and not modi\ufb01ed inside the lambda. IntUnaryOperator makeAdder int amount return x - x amount Legal even though amount will go out of scope because amount is not modified IntUnaryOperator makeAccumulator int value return x - value x return value Will not compile If it is necessary to wrap a changing variable in this way, a regular object that keeps a copy of the variable should be used. Read more in Java Closures with lambda expressions. Accepting Lambdas Because a lambda is an implementation of an interface, nothing special needs to be done to make a method accept a lambda any function which takes a functional interface can also accept a lambda. GoalKicker.com Java Notes for Professionals 427public void passMeALambda Foo1 f f.bar passMeALambda - System.out.printlnLambda called The Type of a Lambda Expression A lambda expression, by itself, does not have a speci\ufb01c type. While it is true that the types and", "number of parameters, along with the type of a return value can convey some type information, such information will only constrain what types it can be assigned to. The lambda receives a type when it is assigned to a functional interface type in one of the following ways Direct assignment to a functional type, e.g. myPredicate s - s.isEmpty Passing it as a parameter that has a functional type, e.g. stream.filters - s.isEmpty Returning it from a function that returns a functional type, e.g. return s - s.isEmpty Casting it to a functional type, e.g. Predicate String s - s.isEmpty Until any such assignment to a functional type is made, the lambda does not have a de\ufb01nite type. To illustrate, consider the lambda expression o - o.isEmpty. The same lambda expression can be assigned to many di\ufb00erent functional types Predicate String javaStringPred o - o.isEmpty Function String, Boolean javaFunc o - o.isEmpty Predicate List javaListPred o - o.isEmpty Consumer String javaStringConsumer o - o.isEmpty return value is ignored! com.google.common.base.Predicate String guavaPredicate o - o.isEmpty Now that they are assigned, the examples shown are of completely di\ufb00erent types even though the lambda expressions looked the same, and they cannot be", "assigned to each other. Section 73.2 Using Lambda Expressions to Sort a Collection Sorting lists Prior to Java 8, it was necessary to implement the java.util.Comparator interface with an anonymous or named class when sorting a list1 Version Java SE 1.2 ListPerson people ... Collections .sort people, new Comparator Person public int compare Person p1, Person p2 return p1.getFirstName .compareTo p2.getFirstName Starting with Java 8, the anonymous class can be replaced with a lambda expression. Note that the types for the parameters p1 and p2 can be left out, as the compiler will infer them automatically Collections .sort people, p1, p2 - p1.getFirstName .compareTo p2.getFirstName The example can be simpli\ufb01ed by using Comparator .comparing and method references expressed using the GoalKicker.com Java Notes for Professionals 428double colon symbol. Collections .sort people, Comparator .comparing PersongetFirstName A static import allows us to express this more concisely, but it is debatable whether this improves overall readability import static java.util.Collections .sort import static java.util.Comparator .comparing ... sortpeople, comparing PersongetFirstName Comparators built this way can also be chained together. For example, after comparing people by their \ufb01rst name, if there are people with the same \ufb01rst name, the thenComparing method with also compare by", "last name sortpeople, comparing PersongetFirstName .thenComparing PersongetLastName 1 - Note that Collections.sort... only works on collections that are subtypes of List . The Set and Collection APIs do not imply any ordering of the elements. Sorting maps You can sort the entries of a HashMap by value in a similar fashion. Note that a LinkedHashMap must be used as the target. The keys in an ordinary HashMap are unordered. MapString, Integer map new HashMap ... or any other Map class populate the map map map.entrySet .stream .sortedMap.Entry.String, Integer comparingByValue .collectCollectors. toMapk - k.getKey, v - v.getValue , k, v - k, LinkedHashMap new Section 73.3 Method References Method references allow prede\ufb01ned static or instance methods that adhere to a compatible functional interface to be passed as arguments instead of an anonymous lambda expression. Assume that we have a model class Person private final String name private final String surname public PersonString name, String surname this.name name this.surname surname public String getName return name public String getSurname return surname GoalKicker.com Java Notes for Professionals 429ListPerson people getSomePeople Instance method reference to an arbitrary instance people.stream.mapPersongetName The equivalent lambda people.stream.mapperson - person. getName In this example, a method reference to the", "instance method getName of type Person , is being passed. Since its known to be of the collection type, the method on the instance known later will be invoked. Instance method reference to a speci\ufb01c instance people.forEachSystem.outprintln Since System.out is an instance of PrintStream , a method reference to this speci\ufb01c instance is being passed as an argument. The equivalent lambda people.forEachperson - System.out.printlnperson Static method reference Also for transforming streams we can apply references to static methods ListInteger numbers Arrays.asList1, 2, 3, 4, 5, 6 numbers. stream.mapStringvalueOf This example passes a reference to the static valueOf method on the String type. Therefore, the instance object in the collection is passed as an argument to valueOf. The equivalent lambda numbers. stream.mapnum - String.valueOfnum Reference to a constructor ListString strings Arrays.asList1, 2, 3 strings. stream.mapIntegernew Read Collect Elements of a Stream into a Collection to see how to collect elements to collection. The single String argument constructor of the Integer type is being used here, to construct an integer given the string provided as the argument. In this case, as long as the string represents a number, the stream will be mapped to Integers. The equivalent lambda strings. stream.maps -", "new Integers Cheat-Sheet Method Reference Format Code Equivalent Lambda Static method TypeName methodargs - TypeName. methodargs GoalKicker.com Java Notes for Professionals 430Non-static method on instance instance methodargs - instance. methodargs Non-static method no instance TypeName methodinstance, args - instance. methodargs Constructor TypeName newargs - new TypeName args Array constructor TypeName newint size - new TypeName size instance can be any expression that evaluates to a reference to an instance, e.g. getInstance method , thismethod If TypeName is a non-static inner class, constructor reference is only valid within the scope of an outer class instance Section 73.4 Implementing multiple interfaces Sometimes you may want to have a lambda expression implementing more than one interface. This is mostly useful with marker interfaces such as java.io.Serializable since they dont add abstract methods. For example, you want to create a TreeSet with a custom Comparator and then serialize it and send it over the network. The trivial approach TreeSetLong ts new TreeSet x, y - Long.comparey, x doesnt work since the lambda for the comparator does not implement Serializable . You can \ufb01x this by using intersection types and explicitly specifying that this lambda needs to be serializable TreeSetLong ts new TreeSet Comparator", "Long Serializable x, y - Long.comparey, x If youre frequently using intersection types for example, if youre using a framework such as Apache Spark where almost everything has to be serializable, you can create empty interfaces and use them in your code instead public interface SerializableComparator extends Comparator Long, Serializable public class CustomTreeSet public CustomTreeSet SerializableComparator comparator This way youre guaranteed that the passed comparator will be serializable. Section 73.5 Lambda - Listener Example Anonymous class listener Before Java 8, it s very common that an anonymous class is used to handle click event of a JButton, as shown in the following code. This example shows how to implement an anonymous listener within the scope of btn.addActionListener . JButton btn new JButtonMy Button btn.addActionListener new ActionListener Override public void actionPerformed ActionEvent e System.out.printlnButton was pressed GoalKicker.com Java Notes for Professionals 431Lambda listener Because the ActionListener interface de\ufb01nes only one method actionPerformed , it is a functional interface which means there s a place to use Lambda expressions to replace the boilerplate code. The above example can be re-written using Lambda expressions as follows JButton btn new JButtonMy Button btn.addActionListener e - System.out.printlnButton was pressed Section 73.6 Java Closures with", "lambda expressions A lambda closure is created when a lambda expression references the variables of an enclosing scope global or local. The rules for doing this are the same as those for inline methods and anonymous classes. Local variables from an enclosing scope that are used within a lambda have to be final . With Java 8 the earliest version that supports lambdas, they dont need to be declared final in the outside context, but must be treated that way. For example int n 0 With Java 8 there is no need to explicit final Runnable r - Using lambda int i n do something This is legal as long as the value of the n variable is not changed. If you try to change the variable, inside or outside the lambda, you will get the following compilation error local variables referenced from a lambda expression must be \ufb01nal or e\ufb00ectively \ufb01nal . For example int n 0 Runnable r - Using lambda int i n do something n Will generate an error. If it is necessary to use a changing variable within a lambda, the normal approach is to declare a final copy of the variable and use", "the copy. For example int n 0 final int k n With Java 8 there is no need to explicit final Runnable r - Using lambda int i k do something n Now will not generate an error r.run Will run with i 0 because k was 0 when the lambda was created Naturally, the body of the lambda does not see the changes to the original variable. Note that Java does not support true closures. A Java lambda cannot be created in a way that allows it to see GoalKicker.com Java Notes for Professionals 432changes in the environment in which it was instantiated. If you want to implement a closure that observes or makes changes to its environment, you should simulate it using a regular class. For example Does not compile ... public IntUnaryOperator createAccumulator int value 0 IntUnaryOperator accumulate x - value x return value return accumulate The above example will not compile for reasons discussed previously. We can work around the compilation error as follows Compiles, but is incorrect ... public class AccumulatorGenerator private int value 0 public IntUnaryOperator createAccumulator IntUnaryOperator accumulate x - value x return value return accumulate The problem is that this breaks", "the design contract for the IntUnaryOperator interface which states that instances should be functional and stateless. If such a closure is passed to built-in functions that accept functional objects, it is liable to cause crashes or erroneous behavior. Closures that encapsulate mutable state should be implemented as regular classes. For example. Correct ... public class Accumulator private int value 0 public int accumulate int x value x return value Section 73.7 Lambdas and memory utilization Since Java lambdas are closures, they can capture the values of variables in the enclosing lexical scope. While not all lambdas capture anything -- simple lambdas like s - s.length capture nothing and are called stateless -- capturing lambdas require a temporary object to hold the captured variables. In this code snippet, the lambda - j is a capturing lambda, and may cause an object to be allocated when it is evaluated public static void mainString args throws Exception for int i 0 i 1000000000 i int j i doSomethingWithLambda - j Although it might not be immediately obvious since the new keyword doesnt appear anywhere in the snippet, this code is liable to create 1,000,000,000 separate objects to represent the instances of the", "- j lambda expression. However, it should also be noted that future versions of Java1 may be able to optimize this so that at runtime the lambda instances were reused, or were represented in some other way. GoalKicker.com Java Notes for Professionals 4331 - For instance, Java 9 introduces an optional link phase to the Java build sequence which will provide the opportunity for doing global optimizations like this. Section 73.8 Using lambda expression with your own functional interface Lambdas are meant to provide inline implementation code for single method interfaces and the ability to pass them around as we have been doing with normal variables. We call them Functional Interface. For example, writing a Runnable in anonymous class and starting a Thread looks like Old way new Thread new Runnable public void run System.out.printlnrun logic... .start lambdas, from Java 8 new Thread - System.out.printlnrun logic... .start Now, in line with above, lets say you have some custom interface interface TwoArgInterface int operate int a, int b How do you use lambda to give implementation of this interface in your code? Same as Runnable example shown above. See the driver program below public class CustomLambda public static void mainString", "args TwoArgInterface plusOperation a, b - a b TwoArgInterface divideOperation a,b- if b0 throw new IllegalArgumentException Divisor can not be 0 return ab System.out.printlnPlus operation of 3 and 5 is plusOperation. operate3, 5 System.out.printlnDivide operation 50 by 25 is divideOperation. operate50, 25 Section 73.9 Traditional style to Lambda style Traditional way interface MathOperation boolean unaryOperation int num GoalKicker.com Java Notes for Professionals 434public class LambdaTry public static void mainString args MathOperation isEven new MathOperation Override public boolean unaryOperation int num return num2 0 System.out.printlnisEven.unaryOperation 25 System.out.printlnisEven.unaryOperation 20 Lambda style Remove class name and functional interface body.1. public class LambdaTry public static void mainString args MathOperation isEven int num - return num2 0 System.out.printlnisEven.unaryOperation 25 System.out.printlnisEven.unaryOperation 20 Optional type declaration2. MathOperation isEven num - return num2 0 Optional parenthesis around parameter, if it is single parameter3. MathOperation isEven num - return num2 0 Optional curly braces, if there is only one line in function body4. Optional return keyword, if there is only one line in function body5. MathOperation isEven num - num2 0 Section 73.10 return only returns from the lambda, not the outer method The return method only returns from the lambda, not the outer method. Beware that this", "is di\ufb00erent from Scala and Kotlin! void threeTimes IntConsumer r for int i 0 i 3 i r.accepti GoalKicker.com Java Notes for Professionals 435void demo threeTimes i - System.out.printlni return Return from lambda to threeTimes only! This can lead to unexpected behavior when attempting to write own language constructs, as in builtin constructs such as for loops return behaves di\ufb00erently void demo2 for int i 0 i 3 i System.out.printlni return Return from demo2 entirely In Scala and Kotlin, demo and demo2 would both only print 0. But this is not more consistent. The Java approach is consistent with refactoring and the use of classes - the return in the code at the top, and the code below behaves the same void demo3 threeTimes new MyIntConsumer class MyIntConsumer implements IntConsumer public void acceptint i System.out.printlni return Therefore, the Java return is more consistent with class methods and refactoring, but less with the for and while builtins, these remain special. Because of this, the following two are equivalent in Java IntStream. range1, 4 .mapx - x x .forEachSystem.outprintln IntStream. range1, 4 .mapx - return x x .forEachSystem.outprintln Furthermore, the use of try-with-resources is safe in Java class Resource implements AutoCloseable", "public void close System.out.printlnclose void executeAround Consumer Resource f try Resource r new Resource System.out.printbefore f.acceptr System.out.printafter void demo4 GoalKicker.com Java Notes for Professionals 436 executeAround r - System.out.printaccept return Does not return from demo4, but frees the resource. will print before accept after close . In the Scala and Kotlin semantics, the try-with-resources would not be closed, but it would print before accept only. Section 73.11 Lambdas and Execute-around Pattern There are several good examples of using lambdas as a FunctionalInterface in simple scenarios. A fairly common use case that can be improved by lambdas is what is called the Execute-Around pattern. In this pattern, you have a set of standard setupteardown code that is needed for multiple scenarios surrounding use case speci\ufb01c code. A few common example of this are \ufb01le io, database io, trycatch blocks. interface DataProcessor void process Connection connection throws SQLException public void doProcessing DataProcessor processor throws SQLException try Connection connection DBUtil. getDatabaseConnection processor. processconnection connection. commit Then to call this method with a lambda it might look like public static void updateMyDAO MyVO vo throws DatabaseException doProcessing Connection conn - MyDAO.updateconn, ObjectMapper. mapvo This is not limited to IO operations. It can apply", "to any scenario where similar setuptear down tasks are applicable with minor variations. The main bene\ufb01t of this Pattern is code re-use and enforcing DRY Dont Repeat Yourself. Section 73.12 Using lambda expressions predicates to get a certain values from a list Starting with Java 8, you can use lambda expressions predicates. Example Use a lambda expressions a predicate to get a certain value from a list. In this example every person will be printed out with the fact if they are 18 and older or not. Person Class public class Person private String name private int age public PersonString name, int age this.name name this.age age public int getAge return age public String getName return name GoalKicker.com Java Notes for Professionals 437 The built-in interface Predicate from the java.util.function.Predicate packages is a functional interface with a boolean testT t method. Example Usage import java.util.ArrayList import java.util.List import java.util.function.Predicate public class LambdaExample public static void mainString args List Person personList new ArrayList Person personList. addnew PersonJeroen , 20 personList. addnew PersonJack, 5 personList. addnew PersonLisa, 19 print personList, p - p.getAge 18 private static void printListPerson personList, Predicate Person checker for Person person personList if checker. testperson System.out.printperson matches", "your expression. else System.out.printlnperson doesnt match your expression. The printpersonList, p - p.getAge 18 method takes a lambda expression because the Predicate is used a parameter where you can de\ufb01ne the expression that is needed. The checkers test method checks if this expression is correct or not checker. testperson. You can easily change this to something else, for example to printpersonList, p - p.getName.startsWith J. This will check if the persons name starts with a J. GoalKicker.com Java Notes for Professionals 438Chapter 74 Basic Control Structures Section 74.1 Switch statement The switch statement is Javas multi-way branch statement. It is used to take the place of long if-else if-else chains, and make them more readable. However, unlike if statements, one may not use inequalities each value must be concretely de\ufb01ned. There are three critical components to the switch statement case This is the value that is evaluated for equivalence with the argument to the switch statement. default This is an optional, catch-all expression, should none of the case statements evaluate to true . Abrupt completion of the case statement usually break This is required to prevent the undesired evaluation of further case statements. With the exception of continue ,", "it is possible to use any statement which would cause the abrupt completion of a statement . This includes break return throw In the example below, a typical switch statement is written with four possible cases, including default . Scanner scan new Scanner System.in int i scan.nextInt switch i case 0 System.out.printlni is zero break case 1 System.out.printlni is one break case 2 System.out.printlni is two break default System.out.printlni is less than zero or greater than two By omitting break or any statement which would an abrupt completion, we can leverage what are known as fall- through cases, which evaluate against several values. This can be used to create ranges for a value to be successful against, but is still not as \ufb02exible as inequalities. Scanner scan new Scanner System.in int foo scan.nextInt switchfoo case 1 System.out.printlnIm equal or greater than one case 2 case 3 System.out.printlnIm one, two, or three break default System.out.printlnIm not either one, two, or three GoalKicker.com Java Notes for Professionals 439In case of foo 1 the output will be Im equal or greater than one Im one, two, or three In case of foo 3 the output will be Im one, two, or three", "Version Java SE 5 The switch statement can also be used with enum s. enum Option BLUEPILL, REDPILL public void takeOne Option option switchoption case BLUEPILL System.out.printlnStory ends, wake up, believe whatever you want. break case REDPILL System.out.printlnI show you how deep the rabbit hole goes. break Version Java SE 7 The switch statement can also be used with String s. public void rhymingGame String phrase switch phrase case apples and pears System.out.printlnStairs break case lorry System.out.printlntruck break default System.out.printlnDont know any more Section 74.2 do...while Loop The do...while loop di\ufb00ers from other loops in that it is guaranteed to execute at least once . It is also called the post-test loop structure because the conditional statement is performed after the main loop body. int i 0 do i System.out.printlni while i 100 Condition gets checked AFTER the content of the loop executes. GoalKicker.com Java Notes for Professionals 440In this example, the loop will run until the number 100 is printed even though the condition is i 100 and not i 100, because the loop condition is evaluated after the loop executes. With the guarantee of at least one execution, it is possible to declare variables outside of the", "loop and initialize them inside. String theWord Scanner scan new Scanner System.in do theWord scan.nextLine while !theWord. equalsBird System.out.printlntheWord In this context, theWord is de\ufb01ned outside of the loop, but since its guaranteed to have a value based on its natural \ufb02ow, theWord will be initialized. Section 74.3 For Each Version Java SE 5 With Java 5 and up, one can use for-each loops, also known as enhanced for-loops List strings new ArrayList strings. addThis strings. addis strings. adda for-each loop String string strings System.out.printlnstring For each loops can be used to iterate over Arrays and implementations of the Iterable interface, the later includes Collections classes, such as List or Set. The loop variable can be of any type that is assignable from the source type. The loop variable for a enhanced for loop for Iterable T or T can be of type S, if T extends S both T and S are primitive types and assignable without a cast S is a primitive type and T can be converted to a type assignable to S after unboxing conversion. T is a primitive type and can be converted to S by autoboxing conversion. Examples T elements ... for S", "s elements T S Compiles int long yes long int no Iterable Byte long yes Iterable String CharSequence yes Iterable CharSequence String no int Long no GoalKicker.com Java Notes for Professionals 441int Integer yes Section 74.4 Continue Statement in Java The continue statement is used to skip the remaining steps in the current iteration and start with the next loop iteration. The control goes from the continue statement to the step value increment or decrement, if any. String programmers Adrian , Paul, John, Harry john is not printed out for String name programmers if name.equalsJohn continue System.out.printlnname The continue statement can also make the control of the program shift to the step value if any of a named loop Outer The name of the outermost loop is kept here as Outer forint i 0 i 5 forint j 0 j 5 j continue Outer Section 74.5 If Else If Else Control if i 2 System.out.printlni is less than 2 else if i 2 System.out.printlni is more than 2 else System.out.printlni is not less than 2, and not more than 2 The if block will only run when i is 1 or less. The else if condition is checked only", "if all the conditions before it in previous else if constructs, and the parent if constructs have been tested to false . In this example, the else if condition will only be checked if i is greater than or equal to 2. If its result is true , its block is run, and any else if and else constructs after it will be skipped. If none of the if and else if conditions have been tested to true , the else block at the end will be run. Section 74.6 For Loops for int i 0 i 100 i System.out.printlni The three components of the for loop separated by are variable declarationinitialization here int i 0, the condition here i 100, and the increment statement here i. The variable declaration is done once as if placed just inside the on the \ufb01rst run. Then the condition is checked, if it is true the body of the loop will execute, if it is GoalKicker.com Java Notes for Professionals 442false the loop will stop. Assuming the loop continues, the body will execute and \ufb01nally when the is reached the increment statement will execute just before the condition is checked again. The", "curly braces are optional you can one line with a semicolon if the loop contains just one statement. But, its always recommended to use braces to avoid misunderstandings and bugs. The for loop components are optional. If your business logic contains one of these parts, you can omit the corresponding component from your for loop. int i obj.getLastestValue i value is fetched from a method for i 100 i here initialization is not done System.out.printlni The for function -body structure is equal to a while true loop. Nested For Loops Any looping statement having another loop statement inside called nested loop. The same way for looping having more inner loop is called nested for loop. for Outer Loop Statements for Inner Loop Statements Outer Loop Statements Nested for loop can be demonstrated to print triangle shaped numbers. forint i9i0i--Outer Loop System.out.println forint kik0k--Inner Loop -1 System.out.print forint jij9jInner Loop -2 System.out.print j Section 74.7 Ternary Operator Sometimes you have to check for a condition and set the value of a variable. For ex. String name if A B name Billy else name Jimmy This can be easily written in one line as GoalKicker.com Java Notes for Professionals 443String name", "A B ? Billy Jimmy The value of the variable is set to the value immediately after the condition, if the condition is true. If the condition is false, the second value will be given to the variable. Section 74.8 Try ... Catch ... Finally The try ... catch ... ... control structure is used for handling Exceptions. String ageinput abc try int age Integer.parseInt ageinput if age 18 System.out.printlnYou can vote! else System.out.printlnSorry, you cant vote yet. catch NumberFormatException ex System.err.printlnInvalid input. ageinput is not a valid integer. This would print Invalid input. abc is not a valid integer. A finally clause can be added after the catch . The finally clause would always be executed, regardless of whether an exception was thrown. try ... catch ... ... finally ... String ageinput abc try int age Integer.parseInt ageinput if age 18 System.out.printlnYou can vote! else System.out.printlnSorry, you cant vote yet. catch NumberFormatException ex System.err.printlnInvalid input. ageinput is not a valid integer. finally System.out.printlnThis code will always be run, even if an exception is thrown This would print Invalid input. abc is not a valid integer. This code will always be run, even if an exception is thrown Section", "74.9 Break The break statement ends a loop like for, while or the evaluation of a switch statement. Loop GoalKicker.com Java Notes for Professionals 444whiletrue ifsomeCondition 5 break The loop in the example would run forever. But when someCondition equals 5 at some point of execution, then the loop ends. If multiple loops are cascaded, only the most inner loop ends using break . Section 74.10 While Loops int i 0 while i 100 condition gets checked BEFORE the loop body executes System.out.printlni i A while loop runs as long as the condition inside the parentheses is true . This is also called the pre-test loop structure because the conditional statement must be met before the main loop body is performed every time. The curly braces are optional if the loop contains just one statement, but some coding style conventions prefers having the braces regardless. Section 74.11 If Else int i 2 if i 2 System.out.printlni is less than 2 else System.out.printlni is greater than 2 An if statement executes code conditionally depending on the result of the condition in parentheses. When condition in parentheses is true it will enter to the block of if statement which is de\ufb01ned", "by curly braces like and . opening bracket till the closing bracket is the scope of the if statement. The else block is optional and can be omitted. It runs if the if statement is false and does not run if the if statement is true Because in that case if statement executes. See also Ternary If Section 74.12 Nested break continue Its possible to break continue to an outer loop by using label statements outerloop for... innerloop for... ifcondition1 break outerloop ifcondition2 continue innerloop equivalent to continue GoalKicker.com Java Notes for Professionals 445 There is no other use for labels in Java. GoalKicker.com Java Notes for Professionals 446Chapter 75 BueredWriter Section 75.1 Write a line of text to File This code writes the string to a \ufb01le. It is important to close the writer, so this is done in a finally block. public void writeLineToFile String str throws IOException File file new Filefile.txt BufferedWriter bw null try bw new BufferedWriter new FileWriter file bw. writestr finally if bw ! null bw. close Also note that writeString s does not place newline character after string has been written. To put it use newLine method. Version Java SE 7 Java", "7 adds the java.nio.file package, and try-with-resources public void writeLineToFile String str throws IOException Path path Paths.getfile.txt try BufferedWriter bw Files.newBufferedWriter path bw. writestr GoalKicker.com Java Notes for Professionals 447Chapter 76 New File IO Section 76.1 Creating paths The Path class is used to programmaticaly represent a path in the \ufb01le system and can therefore point to \ufb01les as well as directories, even to non-existent ones A path can be obtained using the helper class Paths Path p1 Paths.getvarwww Path p2 Paths.getURI.createfilehometestuserFile.txt Path p3 Paths.getCUsersDentArDocuments HHGTDG.odt Path p4 Paths.gethome, arthur , files, diary.tex Section 76.2 Manipulating paths Joining Two Paths Paths can be joined using the resolve method. The path passed has to be a partial path, which is a path that doesnt include the root element. Path p5 Paths.gethome Path p6 Paths.getarthurfiles Path joined p5.resolvep6 Path otherJoined p5.resolvefordfiles joined.toString homearthurfiles otherJoined. toString homefordfiles Normalizing a path Paths may contain the elements . which points to the directory youre currently in and ..which points to the parent directory. When used in a path, . can be removed at any time without changing the paths destination, and .. can be removed together with the preceding element. With the Paths API,", "this is done using the .normalize method Path p7 Paths.gethome.arthur..fordfiles Path p8 Paths.getCUsers...Program Files p7.normalize .toString homefordfiles p8.normalize .toString CProgram Files Section 76.3 Retrieving information about a path Information about a path can be get using the methods of a Path object toString returns the string representation of the path Path p1 Paths.getvarwww p1.toString returns varwww getFileName returns the \ufb01le name or, more speci\ufb01cally, the last element of the path Path p1 Paths.getvarwww p1.getFileName returns www GoalKicker.com Java Notes for Professionals 448Path p3 Paths.getCUsersDentArDocuments HHGTDG.odt p3.getFileName returns HHGTDG.odt getNameCount returns the number of elements that form the path Path p1 Paths.getvarwww p1.getNameCount returns 2 getNameint index returns the element at the given index Path p1 Paths.getvarwww p1.getName0 returns var, p1.getName1 returns www getParent returns the path of the parent directory Path p1 Paths.getvarwww p1.getParent.toString returns var getRoot returns the root of the path Path p1 Paths.getvarwww p1.getRoot.toString returns Path p3 Paths.getCUsersDentArDocuments HHGTDG.odt p3.getRoot.toString returns C Section 76.4 Retrieving information using the \ufb01lesystem To interact with the \ufb01lesystem you use the methods of the class Files . Checking existence To check the existence of the \ufb01le or directory a path points to, you use the following methods Files.existsPath path and", "Files.notExists Path path !Files.existspath does not neccesarily have to be equal to Files.notExists path, because there are three possible scenarios A \ufb01les or directorys existence is veri\ufb01ed exists returns true and notExists returns false in this case A \ufb01les or directorys nonexistence is ver\ufb01ed exists returns false and notExists returns true Neither the existence nor the nonexistence of a \ufb01le or a directory can be veri\ufb01ed for example due to access restrictions Both exists and nonExists return false. Checking whether a path points to a \ufb01le or a directory This is done using Files.isDirectory Path path and Files.isRegularFile Path path Path p1 Paths.getvarwww Path p2 Paths.gethometestuserFile.txt Files.isDirectory p1 true Files.isRegularFile p1 false Files.isDirectory p2 false GoalKicker.com Java Notes for Professionals 449Files.isRegularFile p2 true Getting properties This can be done using the following methods Files.isReadable Path path Files.isWritable Path path Files.isExecutable Path path Files.isHidden Path path Files.isSymbolicLink Path path Getting MIME type Files.probeContentType Path path This tries to get the MIME type of a \ufb01le. It returns a MIME type String, like this textplain for text \ufb01les texthtml for HTML pages application pdf for PDF \ufb01les imagepng for PNG \ufb01les Section 76.5 Reading \ufb01les Files can be read byte- and", "line-wise using the Files class. Path p2 Paths.getURI.createfilehometestuserFile.txt byte content Files.readAllBytes p2 ListString linesOfContent Files.readAllLines p2 Files.readAllLines optionally takes a charset as parameter default is StandardCharsets. UTF8 ListString linesOfContent Files.readAllLines p2, StandardCharsets. ISO88591 Section 76.6 Writing \ufb01les Files can be written bite- and line-wise using the Files class Path p2 Paths.gethometestuserFile.txt ListString lines Arrays.asList new StringFirst line , Second line , Third line Files.writep2, lines Files.writePath path, byte bytes Existing \ufb01les wile be overridden, non-existing \ufb01les will be created. GoalKicker.com Java Notes for Professionals 450Chapter 77 File IO Java IO Input and Output is used to process the input and produce the output. Java uses the concept of stream to make IO operation fast. The java.io package contains all the classes required for input and output operations. Handling \ufb01les is also done in java by Java IO API. Section 77.1 Migrating from java.io.File to Java 7 NIO java.nio.\ufb01le.Path These examples assume that you already know what Java 7s NIO is in general, and you are used to writing code using java.io.File . Use these examples as a means to quickly \ufb01nd more NIO-centric documentation for migrating. There is much more to Java 7s NIO such as memory-mapped \ufb01les or", "opening a ZIP or JAR \ufb01le using FileSystem . These examples will only cover a limited number of basic use cases. As a basic rule, if you are used to perform a \ufb01le system readwrite operation using a java.io.File instance method, you will \ufb01nd it as a static method within java.nio.file.Files . Point to a path - IO File file new Fileio.txt - NIO Path path Paths.getnio.txt Paths relative to another path Forward slashes can be used in place of backslashes even on a Windows operating system - IO File folder new FileC File fileInFolder new Filefolder, io.txt - NIO Path directory Paths.getC Path pathInDirectory directory. resolvenio.txt Converting File fromto Path for use with libraries - IO to NIO Path pathFromFile new Fileio.txt .toPath - NIO to IO File fileFromPath Paths.getnio.txt .toFile Check if the \ufb01le exists and delete it if it does - IO if file.exists boolean deleted file.delete if !deleted throw new IOException Unable to delete file - NIO Files.deleteIfExists path Write to a \ufb01le via an OutputStream There are several ways to write and read from a \ufb01le using NIO for di\ufb00erent performance and memory constraints, readability and use cases, such as FileChannel , Files.writePath path,", "byte bytes, OpenOption... GoalKicker.com Java Notes for Professionals 451options... In this example, only OutputStream is covered, but you are strongly encouraged to learn about memory- mapped \ufb01les and the various static methods available in java.nio.file.Files . ListString lines Arrays.asList String.valueOfCalendar .getInstance .getTimeInMillis , line one , line two - IO if file.exists Note Not atomic throw new IOException File already exists try FileOutputStream outputStream new FileOutputStream file for String line lines outputStream. writeline System.lineSeparator .getBytes StandardCharsets. UTF8 - NIO try OutputStream outputStream Files.newOutputStream path, StandardOpenOption. CREATENEW for String line lines outputStream. writeline System.lineSeparator .getBytes StandardCharsets. UTF8 Iterating on each \ufb01le within a folder - IO for File selectedFile folder. listFiles Note Depending on the number of files in the directory folder.listFiles may take a long time to return System.out.printlnselectedFile. isDirectory ? d f selectedFile. getAbsolutePath - NIO Files.walkFileTree directory, EnumSet. noneOfFileVisitOption. class, 1, new SimpleFileVisitor Path Override public FileVisitResult preVisitDirectory Path selectedPath, BasicFileAttributes attrs throws IOException System.out.printlnd selectedPath. toAbsolutePath return FileVisitResult. CONTINUE Override public FileVisitResult visitFile Path selectedPath, BasicFileAttributes attrs throws IOException System.out.printlnf selectedPath. toAbsolutePath return FileVisitResult. CONTINUE Recursive folder iteration - IO recurseFolder folder - NIO Note Symbolic links are NOT followed unless explicitly passed as an argument", "to Files.walkFileTree Files.walkFileTree directory, new SimpleFileVisitor Path Override GoalKicker.com Java Notes for Professionals 452 public FileVisitResult preVisitDirectory Path dir, BasicFileAttributes attrs throws IOException System.out.printlnd selectedPath. toAbsolutePath return FileVisitResult. CONTINUE Override public FileVisitResult visitFile Path selectedPath, BasicFileAttributes attrs throws IOException System.out.printlnf selectedPath. toAbsolutePath return FileVisitResult. CONTINUE private static void recurseFolder File folder for File selectedFile folder. listFiles System.out.printlnselectedFile. isDirectory ? d f selectedFile. getAbsolutePath if selectedFile. isDirectory Note Symbolic links are followed recurseFolder selectedFile Section 77.2 Reading an image from a \ufb01le import java.awt.Image import javax.imageio.ImageIO ... try Image img ImageIO. readnew FileDesktopcat.png catch IOException e e.printStackTrace Section 77.3 File ReadWrite Using FileInputStreamFileOutputStream Write to a \ufb01le test.txt String filepath Ctest.txt FileOutputStream fos null try fos new FileOutputStream filepath byte buffer This will be written in test.txt .getBytes fos. writebuffer, 0, buffer. length fos. close catch FileNotFoundException e e. printStackTrace catch IOException e e. printStackTrace finally iffos ! null fos. close GoalKicker.com Java Notes for Professionals 453Read from \ufb01le test.txt String filepath Ctest.txt FileInputStream fis null try fis new FileInputStream filepath int length int new Filefilepath .length byte buffer new bytelength fis.readbuffer, 0, length catch FileNotFoundException e e.printStackTrace catch IOException e e.printStackTrace finally iffis ! null fis. close Note, that", "since Java 1.7 the try-with-resources statement was introduced what made implementation of readingwriting operation much simpler Write to a \ufb01le test.txt String filepath Ctest.txt try FileOutputStream fos new FileOutputStream filepath byte buffer This will be written in test.txt .getBytes fos. writebuffer, 0, buffer. length catch FileNotFoundException e e.printStackTrace catch IOException e e.printStackTrace Read from \ufb01le test.txt String filepath Ctest.txt try FileInputStream fis new FileInputStream filepath int length int new Filefilepath .length byte buffer new bytelength fis. readbuffer, 0, length catch FileNotFoundException e e.printStackTrace catch IOException e e.printStackTrace Section 77.4 Reading all bytes to a byte Java 7 introduced the very useful Files class Version Java SE 7 import java.nio.file.Files import java.nio.file.Paths import java.nio.file.Path Path path Paths.getpathtofile try byte data Files.readAllBytes path GoalKicker.com Java Notes for Professionals 454 catchIOException e e.printStackTrace Section 77.5 Copying a \ufb01le using Channel We can use Channel to copy \ufb01le content faster. To do so, we can use transferTo method of FileChannel . import java.io.File import java.io.FileInputStream import java.io.FileOutputStream import java.io.IOException import java.nio.channels.FileChannel public class FileCopier public static void mainString args File sourceFile new Filehello.txt File sinkFile new Filehello2.txt copy sourceFile, sinkFile public static void copyFile sourceFile, File destFile if !sourceFile. exists !destFile. exists System.out.printlnSource", "or destination file doesnt exist return try FileChannel srcChannel new FileInputStream sourceFile .getChannel FileChannel sinkChanel new FileOutputStream destFile .getChannel srcChannel. transferTo 0, srcChannel. size, sinkChanel catch IOException e e. printStackTrace Section 77.6 Writing a byte to a \ufb01le Version Java SE 7 byte bytes 0x48, 0x65, 0x6c, 0x6c, 0x6f tryFileOutputStream stream new FileOutputStream Hello world.txt stream. writebytes catch IOException ioe Handle IO Exception ioe. printStackTrace Version Java SE 7 byte bytes 0x48, 0x65, 0x6c, 0x6c, 0x6f FileOutputStream stream null try stream new FileOutputStream Hello world.txt stream. writebytes catch IOException ioe Handle IO Exception GoalKicker.com Java Notes for Professionals 455 ioe. printStackTrace finally if stream ! null try stream. close catch IOException ignored Most java.io \ufb01le APIs accept both String s and File s as arguments, so you could as well use File file new FileHello world.txt FileOutputStream stream new FileOutputStream file Section 77.7 Stream vs WriterReader API Streams provide the most direct access to the binary content, so any InputStream OutputStream implementations always operate on ints and byte s. Read a single byte from the stream int b inputStream. read if b 0 A negative value represents the end of the stream, normal values are in the range 0", "- 255 Write the byte to another stream outputStream. writeb Read a chunk byte data new byte1024 int nBytesRead inputStream. readdata if nBytesRead 0 A negative value represents end of stream Write the chunk to another stream outputStream. writedata, 0, nBytesRead There are some exceptions, probably most notably the PrintStream which adds the ability to print representations of various data values conveniently. This allows to use System.out both as a binary InputStream and as a textual output using methods such as System.out.println. Also, some stream implementations work as an interface to higher-level contents such as Java objects see Serialization or native types, e.g. DataOutputStream DataInputStream . With the Writer and Reader classes, Java also provides an API for explicit character streams. Although most applications will base these implementations on streams, the character stream API does not expose any methods for binary content. This example uses the platforms default charset, see below for a better implementation. Writer writer new OutputStreamWriter System.out writer.writeHello world! Reader reader new InputStreamReader System.in char singleCharacter reader. read Whenever it is necessary to encode characters into binary data e.g. when using the InputStreamWriter OutputStreamWriter classes, you should specify a charset if you do not want to", "depend on the platforms default GoalKicker.com Java Notes for Professionals 456charset. When in doubt, use a Unicode-compatible encoding, e.g. UTF-8 which is supported on all Java platforms. Therefore, you should probably stay away from classes like FileWriter and FileReader as those always use the default platform charset. A better way to access \ufb01les using character streams is this Charset myCharset StandardCharsets. UTF8 Writer writer new OutputStreamWriter new FileOutputStream test.txt , myCharset writer.write\u00c4 writer.flush writer.close Reader reader new InputStreamReader new FileInputStream test.txt , myCharset char someUnicodeCharacter reader. read reader.close One of the most commonly used Reader s is BufferedReader which provides a method to read whole lines of text from another reader and is presumably the simplest way to read a character stream line by line Read from baseReader, one line at a time BufferedReader reader new BufferedReader baseReader String line whileline reader. readLine ! null Remember System.out is a stream, not a writer! System.out.printlnline Section 77.8 Reading a \ufb01le with a Scanner Reading a \ufb01le line by line public class Main public static void mainString args try Scanner scanner new Scanner new Fileexample.txt whilescanner. hasNextLine String line scanner. nextLine do stuff catch FileNotFoundException e e. printStackTrace word by word", "public class Main public static void mainString args try Scanner scanner new Scanner new Fileexample.txt whilescanner. hasNext String line scanner. next do stuff GoalKicker.com Java Notes for Professionals 457 catch FileNotFoundException e e. printStackTrace and you can also change the delimeter by using scanner.useDelimeter method Section 77.9 Copying a \ufb01le using InputStream and OutputStream We can directly copy data from a source to a data sink using a loop. In this example, we are reading data from an InputStream and at the same time, writing to an OutputStream. Once we are done reading and writing, we have to close the resource. public void copyInputStream source, OutputStream destination throws IOException try int c while c source. read ! -1 destination. writec finally if source ! null source. close if destination ! null destination. close Section 77.10 Reading from a binary \ufb01le You can read an a binary \ufb01le using this piece of code in all recent versions of Java Version Java SE 1.4 File file new Filepathtothefile byte data new byteint file.length DataInputStream stream new DataInputStream new FileInputStream file stream.readFully data stream.close If you are using Java 7 or later, there is a simpler way using the nio API Version", "Java SE 7 Path path Paths.getpathtothefile byte data Files.readAllBytes path Section 77.11 Reading a \ufb01le using Channel and Buer Channel uses a Buffer to readwrite data. A bu\ufb00er is a \ufb01xed sized container where we can write a block of data at once. Channel is a quite faster than stream-based IO. To read data from a \ufb01le using Channel we need to have the following steps- We need an instance of FileInputStream . FileInputStream has a method named getChannel which 1. returns a Channel. GoalKicker.com Java Notes for Professionals 458Call the getChannel method of FileInputStream and acquire Channel. 2. Create a ByteBu\ufb00er. ByteBu\ufb00er is a \ufb01xed size container of bytes.3. Channel has a read method and we have to provide a ByteBu\ufb00er as an argument to this read method.4. ByteBu\ufb00er has two modes - read-only mood and write-only mood. We can change the mode using flip method call. Bu\ufb00er has a position, limit, and capacity. Once a bu\ufb00er is created with a \ufb01xed size, its limit and capacity are the same as the size and the position starts from zero. While a bu\ufb00er is written with data, its position gradually increases. Changing mode means, changing the position. To read", "data from the beginning of a bu\ufb00er, we have to set the position to zero. \ufb02ip method change the position When we call the read method of the Channel , it \ufb01lls up the bu\ufb00er using data. 5. If we need to read the data from the ByteBuffer , we need to \ufb02ip the bu\ufb00er to change its mode to write-only 6. to read-only mode and then keep reading data from the bu\ufb00er. When there is no longer data to read, the read method of channel returns 0 or -1. 7. import java.io.File import java.io.FileInputStream import java.io.IOException import java.nio.ByteBuffer import java.nio.channels.FileChannel public class FileChannelRead public static void mainString args File inputFile new Filehello.txt if !inputFile. exists System.out.printlnThe input file doesnt exit. return try FileInputStream fis new FileInputStream inputFile FileChannel fileChannel fis.getChannel ByteBuffer buffer ByteBuffer. allocate 1024 while fileChannel. readbuffer 0 buffer. flip while buffer.hasRemaining byte b buffer. get System.out.printchar b buffer. clear fileChannel. close catch IOException e e.printStackTrace Section 77.12 Adding Directories To make a new directory from a File instance you would need to use one of two methods mkdirs or mkdir. mkdir - Creates the directory named by this abstract pathname. source mkdirs - Creates the directory", "named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary GoalKicker.com Java Notes for Professionals 459parent directories. source Note createNewFile will not create a new directory only a \ufb01le. File singleDir new FileCUsersSomeUserDesktopA New Folder File multiDir new FileCUsersSomeUserDesktopA New Folder 2Another Folder assume that neither A New Folder or A New Folder 2 exist singleDir. createNewFile will make a new file called A New Folder.file singleDir. mkdir will make the directory singleDir. mkdirs will make the directory multiDir. createNewFile will throw a IOException multiDir. mkdir will not work multiDir. mkdirs will make the directory Section 77.13 Blocking or redirecting standard output error Sometimes a poorly designed 3rd-party library will write unwanted diagnostics to System.out or System.err streams. The recommended solutions to this would be to either \ufb01nd a better library or in the case of open source \ufb01x the problem and contribute a patch to the developers. If the above solutions are not feasible, then you should consider redirecting the streams. Redirection on the command line On a UNIX, Linux or MacOSX system can be done from the shell using", "redirection. For example java -jar app. jar arg1 arg2 devnull 21 java -jar app. jar arg1 arg2 out.log 2 error.log The \ufb01rst one redirects standard output and standard error to devnull, which throws away anything written to those streams. The second of redirects standard output to out.log and standard error to error.log. For more information on redirection, refer to the documentation of the command shell you are using. Similar advice applies to Windows. Alternatively, you could implement the redirection in a wrapper script or batch \ufb01le that launches the Java application. Redirection within a Java application It is also possible to redired the streams within a Java application using System.setOut and System.setErr. For example, the following snippet redirects standard output and standard error to 2 log \ufb01les System.setOutnew PrintStream new FileOutputStream new Fileout.log System.setErrnew PrintStream new FileOutputStream new Fileerr.log If you want to throw away the output entirely, you can create an output stream that writes to an invalid \ufb01le descriptor. This is functionally equivalent to writing to devnull on UNIX. System.setOutnew PrintStream new FileOutputStream new FileDescriptor System.setErrnew PrintStream new FileOutputStream new FileDescriptor GoalKicker.com Java Notes for Professionals 460Caution be careful how you use setOut and setErr The redirection", "will a\ufb00ect the entire JVM.1. By doing this, you are taking away the users ability to redirect the streams from the command line.2. Section 77.14 Reading a whole \ufb01le at once File f new Filepath String content new Scanner f.useDelimiter Z.next Z is the EOF End of File Symbol. When set as delimiter the Scanner will read the \ufb01ll until the EOF Flag is reached. Section 77.15 Locking A \ufb01le can be locked using the FileChannel API that can be acquired from Input Output streams and readers Example with streams Open a file stream FileInputStream ios new FileInputStream filename get underlying channel FileChannel channel ios.getChannel try to lock the file. true means whether the lock is shared or not i.e. multiple processes can acquire a shared lock for reading only Using false with readable channel only will generate an exception. You should use a writable channel taken from FileOutputStream when using false. tryLock will always return immediately FileLock lock channel. tryLock0, Long.MAXVALUE , true if lock null System.out.printlnUnable to acquire lock else System.out.printlnLock acquired successfully you can also use blocking call which will block until a lock is acquired. channel. lock Once you have completed desired operations of file.", "release the lock if lock ! null lock. release close the file stream afterwards Example with reader RandomAccessFile randomAccessFile new RandomAccessFile filename, rw FileChannel channel randomAccessFile. getChannel repeat the same steps as above but now you can use shared as true or false as the channel is in read write mode Section 77.16 Reading a \ufb01le using BueredInputStream Reading \ufb01le using a BufferedInputStream generally faster than FileInputStream because it maintains an internal GoalKicker.com Java Notes for Professionals 461bu\ufb00er to store bytes read from the underlying input stream. import java.io.BufferedInputStream import java.io.FileInputStream import java.io.IOException public class FileReadingDemo public static void mainString args String source hello.txt try BufferedInputStream bis new BufferedInputStream new FileInputStream source byte data while data byte bis.read ! -1 System.out.printlnchar data catch IOException e e. printStackTrace Section 77.17 Iterate over a directory printing subdirectories in it public void iterate final String dirPath throws IOException final DirectoryStream Path paths Files.newDirectoryStream Paths.getdirPath for final Path path paths if Files.isDirectory path System.out.printlnpath.getFileName Section 77.18 Writing a \ufb01le using Channel and Buer To write data to a \ufb01le using Channel we need to have the following steps First, we need to get an object of FileOutputStream 1. Acquire FileChannel calling the getChannel", "method from the FileOutputStream 2. Create a ByteBuffer and then \ufb01ll it with data 3. Then we have to call the flip method of the ByteBuffer and pass it as an argument of the write 4. method of the FileChannel Once we are done writing, we have to close the resource5. import java.io. import java.nio. public class FileChannelWrite public static void mainString args File outputFile new Filehello.txt String text I love Bangladesh. try FileOutputStream fos new FileOutputStream outputFile GoalKicker.com Java Notes for Professionals 462 FileChannel fileChannel fos.getChannel byte bytes text.getBytes ByteBuffer buffer ByteBuffer. wrapbytes fileChannel. writebuffer fileChannel. close catch java.io.IOException e e.printStackTrace Section 77.19 Writing a \ufb01le using PrintStream We can use PrintStream class to write a \ufb01le. It has several methods that let you print any data type values. println method appends a new line. Once we are done printing, we have to \ufb02ush the PrintStream . import java.io.FileNotFoundException import java.io.PrintStream import java.time.LocalDate public class FileWritingDemo public static void mainString args String destination file1.txt tryPrintStream ps new PrintStream destination ps. printlnStackoverflow documentation seems fun. ps. println ps. printlnI love Java! ps. printfToday is 1tm1td1tY , LocalDate. now ps. flush catch FileNotFoundException e e. printStackTrace Section 77.20 Iterating over", "a directory and \ufb01lter by \ufb01le extension public void iterateAndFilter throws IOException Path dir Paths.getCfoobar PathMatcher imageFileMatcher FileSystems. getDefault .getPathMatcher regex.?ijpgjpegpnggifbmpjpejfif try DirectoryStream Path stream Files.newDirectoryStream dir, entry - imageFileMatcher. matchesentry.getFileName for Path path stream System.out.printlnpath.getFileName GoalKicker.com Java Notes for Professionals 463Section 77.21 Accessing the contents of a ZIP \ufb01le The FileSystem API of Java 7 allows to read and add entries from or to a Zip \ufb01le using the Java NIO \ufb01le API in the same way as operating on any other \ufb01lesystem. The FileSystem is a resource that should be properly closed after use, therefore the try-with-resources block should be used. Reading from an existing \ufb01le Path pathToZip Paths.getpathtofile.zip tryFileSystem zipFs FileSystems. newFileSystem pathToZip, null Path root zipFs.getPath ... access the content of the zip file same as ordinary files catchIOException ex ex.printStackTrace Creating a new \ufb01le MapString, String env new HashMap env.putcreate , true required for creating a new zip file env.putencoding , UTF-8 optional default is UTF-8 URI uri URI.createjarfilepathtofile.zip try FileSystem zipfs FileSystems. newFileSystem uri, env Path newFile zipFs.getPathnewFile.txt writing to file Files. writenewFile, Hello world .getBytes catchIOException ex ex.printStackTrace GoalKicker.com Java Notes for Professionals 464Chapter 78 Scanner Parameter Details Source Source could be", "either one of String, File or any kind of InputStream Section 78.1 General Pattern that does most commonly asked about tasks The following is how to properly use the java.util.Scanner class to interactively read user input from System.in correctly sometimes referred to as stdin , especially in C, C and other languages as well as in Unix and Linux. It idiomatically demonstrates the most common things that are requested to be done. package com.stackoverflow.scanner import javax.annotation.Nonnull import java.math.BigInteger import java.net.MalformedURLException import java.net.URL import java.util. import java.util.regex.Pattern import static java.lang.String.format public class ScannerExample private static final SetString EXITCOMMANDS private static final SetString HELPCOMMANDS private static final Pattern DATEPATTERN private static final String HELPMESSAGE static final SortedSet String ecmds new TreeSet StringString.CASEINSENSITIVEORDER ecmds. addAllArrays.asListexit, done, quit, end, fino EXITCOMMANDS Collections .unmodifiableSortedSet ecmds final SortedSet String hcmds new TreeSet StringString.CASEINSENSITIVEORDER hcmds. addAllArrays.asListhelp, helpi, ? HELPCOMMANDS Collections .unmodifiableSet hcmds DATEPATTERN Pattern. compiled4-d21d2 httpregex101.comrxB8dR31 HELPMESSAGE formatPlease enter some data or enter one of the following commands to exit s , EXITCOMMANDS Using exceptions to control execution flow is always bad. That is why this is encapsulated in a method, this is done this way specifically so as not to introduce any external libraries so", "that this is a completely self contained example. param s possible url return true if s represents a valid url, false otherwise private static boolean isValidURL Nonnull final String s try new URLs return true catch final MalformedURLException e return false private static void outputNonnull final String format, Nonnull final Object... args GoalKicker.com Java Notes for Professionals 465 System.out.printlnformatformat, args public static void mainfinal String args final Scanner sis new Scanner System.in output HELPMESSAGE while sis.hasNext if sis.hasNextInt final int next sis.nextInt output You entered an Integer d , next else if sis.hasNextLong final long next sis.nextLong output You entered a Long d , next else if sis.hasNextDouble final double next sis.nextDouble output You entered a Double f , next else if sis.hasNextd final BigInteger next sis.nextBigInteger output You entered a BigInteger s , next else if sis.hasNextBoolean final boolean next sis.nextBoolean output You entered a Boolean representation s , next else if sis.hasNextDATEPATTERN final String next sis.nextDATEPATTERN output You entered a Date representation s , next else unclassified final String next sis.next if isValidURL next output You entered a valid URL s , next else if EXITCOMMANDS. contains next output Exit command s issued, exiting! , next break", "else if HELPCOMMANDS. contains next outputHELPMESSAGE else outputYou entered an unclassified String s , next This will close the underlying Readable, in this case System.in, and free those resources. You will not be to read from System.in anymore after this you call .close. GoalKicker.com Java Notes for Professionals 466 If you wanted to use System.in for something else, then dont close the Scanner. sis. close System.exit0 Section 78.2 Using custom delimiters You can use custom delimiters regular expressions with Scanner, with .useDelimiter ,, to determine how the input is read. This works similarly to String.split.... For example, you can use Scanner to read from a list of comma separated values in a String Scanner scanner null try scanner new Scanner i,like,unicorns .useDelimiter , whilescanner. hasNext System.out.printlnscanner. next catchException e e.printStackTrace finally if scanner ! null scanner. close This will allow you to read every element in the input individually. Note that you should not use this to parse CSV data, instead, use a proper CSV parser library, see CSV parser for Java for other possibilities. Section 78.3 Reading system input using Scanner Scanner scanner new Scanner System.in Scanner obj to read System input String inputTaken new String while true", "String input scanner. nextLine reading one line of input if input.matchess if it matches spacestabs, stop reading break inputTaken input System.out.printlninputTaken The scanner object is initialized to read input from keyboard. So for the below input from keyboar, itll produce the output as Reading from keyboard Reading from keyboard space Section 78.4 Reading \ufb01le input using Scanner Scanner scanner null try scanner new Scanner new FileNames.txt while scanner. hasNext System.out.printlnscanner. nextLine GoalKicker.com Java Notes for Professionals 467 catch Exception e System.err.printlnException occurred! finally if scanner ! null scanner. close Here a Scanner object is created by passing a File object containing the name of a text \ufb01le as input. This text \ufb01le will be opened by the File object and read in by the scanner object in the following lines. scanner. hasNext will check to see if there is a next line of data in the text \ufb01le. Combining that with a while loop will allow you to iterate through every line of data in the Names.txt \ufb01le. To retrieve the data itself, we can use methods such as nextLine ,nextInt,nextBoolean , etc. In the example above, scanner. nextLine is used. nextLine refers to the following line in a", "text \ufb01le, and combining it with a scanner object allows you to print the contents of the line. To close a scanner object, you would use .close. Using try with resources from Java 7 onwards, the above mentioned code can be written elegantly as below. try Scanner scanner new Scanner new FileNames.txt while scanner. hasNext System.out.printlnscanner. nextLine catch Exception e System.err.printlnException occurred! Section 78.5 Read the entire input as a String using Scanner You can use Scanner to read all of the text in the input as a String, by using Z entire input as the delimiter. For example, this can be used to read all text in a text \ufb01le in one line String content new Scanner new Filefilename .useDelimiter Z.next System.out.printlncontent Remember that youll have to close the Scanner, as well as catch the IoException this may throw, as described in the example Reading \ufb01le input using Scanner. Section 78.6 Carefully Closing a Scanner it can happen that you use a scanner with the System.in as parameter for the constructor, then you need to be aware that closing the scanner will close the InputStream too giving as next that every try to read the input on that", "Or any other scanner object will throw an java.util.NoSuchElementException or an java.lang.IllegalStateException example Scanner sc1 new Scanner System.in Scanner sc2 new Scanner System.in int x1 sc1.nextInt sc1. close java.util.NoSuchElementException int x2 sc2.nextInt java.lang.IllegalStateException x2 sc1.nextInt GoalKicker.com Java Notes for Professionals 468Section 78.7 Read an int from the command line import java.util.Scanner Scanner s new Scanner System.in int number s.nextInt If you want to read an int from the command line, just use this snippet. First of all, you have to create a Scanner object, that listens to System.in, which is by default the Command Line, when you start the program from the command line. After that, with the help of the Scanner object, you read the \ufb01rst int that the user passes into the command line and store it in the variable number. Now you can do whatever you want with that stored int. GoalKicker.com Java Notes for Professionals 469Chapter 79 Interfaces An interface is a reference type, similar to a class, which can be declared by using interface keyword. Interfaces can contain only constants, method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Like abstract classes, Interfaces cannot", "be instantiated they can only be implemented by classes or extended by other interfaces. Interface is a common way to achieve full abstraction in Java. Section 79.1 Implementing multiple interfaces A Java class can implement multiple interfaces. public interface NoiseMaker String noise Making Noise interface variables are public static final by default String makeNoise interface methods are public abstract by default public interface FoodEater void eatFood food public class Cat implements NoiseMaker, FoodEater Override public String makeNoise return meow Override public void eatFood food System.out.printlnmeows appreciatively Notice how the Cat class must implement the inherited abstract methods in both the interfaces. Furthermore, notice how a class can practically implement as many interfaces as needed there is a limit of 65,535 due to JVM Limitation . NoiseMaker noiseMaker new Cat Valid FoodEater foodEater new Cat Valid Cat cat new Cat valid Cat invalid1 new NoiseMaker Invalid Cat invalid2 new FoodEater Invalid Note All variables declared in an interface are public static final 1. All methods declared in an interface methods are public abstract This statement is valid only through Java 2. 7. From Java 8, you are allowed to have methods in an interface, which need not be abstract such", "methods are known as default methods Interfaces cannot be declared as final 3. If more than one interface declares a method that has identical signature, then e\ufb00ectively it is treated as only4. one method and you cannot distinguish from which interface method is implemented A corresponding InterfaceName.class \ufb01le would be generated for each interface, upon compilation 5. GoalKicker.com Java Notes for Professionals 470Section 79.2 Declaring and Implementing an Interface Declaration of an interface using the interface keyword public interface Animal String getSound Interface methods are public by default Override Annotation Override public String getSound Code goes here... This forces the compiler to check that we are overriding and prevents the program from de\ufb01ning a new method or messing up the method signature. Interfaces are implemented using the implements keyword. public class Cat implements Animal Override public String getSound return meow public class Dog implements Animal Override public String getSound return woof In the example, classes Cat and Dog must de\ufb01ne the getSound method as methods of an interface are inherently abstract with the exception of default methods. Using the interfaces Animal cat new Cat Animal dog new Dog System.out.printlncat.getSound prints meow System.out.printlndog.getSound prints woof Section 79.3 Extending an interface", "An interface can extend another interface via the extends keyword. public interface BasicResourceService Resource getResource public interface ExtendedResourceService extends BasicResourceService void updateResource Resource resource GoalKicker.com Java Notes for Professionals 471 Now a class implementing ExtendedResourceService will need to implement both getResource and updateResource . Extending multiple interfaces Unlike classes, the extends keyword can be used to extend multiple interfaces Separated by commas allowing for combinations of interfaces into a new interface public interface BasicResourceService Resource getResource public interface AlternateResourceService Resource getAlternateResource public interface ExtendedResourceService extends BasicResourceService, AlternateResourceService Resource updateResource Resource resource In this case a class implementing ExtendedResourceService will need to implement getResource , getAlternateResource , and updateResource . Section 79.4 Usefulness of interfaces Interfaces can be extremely helpful in many cases. For example, say you had a list of animals and you wanted to loop through the list, each printing the sound they make. cat, dog, bird One way to do this would be to use interfaces. This would allow for the same method to be called on all of the classes public interface Animal public String getSound Any class that implements Animal also must have a getSound method in them, yet they can all have di\ufb00erent implementations", "public class Dog implements Animal public String getSound return Woof public class Cat implements Animal public String getSound return Meow public class Bird implements Animal public String getSound return Chirp GoalKicker.com Java Notes for Professionals 472 We now have three di\ufb00erent classes, each of which has a getSound method. Because all of these classes implement the Animal interface, which declares the getSound method, any instance of an Animal can have getSound called on it Animal dog new Dog Animal cat new Cat Animal bird new Bird dog.getSound Woof cat.getSound Meow bird.getSound Chirp Because each of these is an Animal , we could even put the animals in a list, loop through them, and print out their sounds Animal animals new Dog, new Cat, new Bird for Animal animal animals System.out.printlnanimal.getSound Because the order of the array is Dog, Cat, and then Bird , Woof Meow Chirp will be printed to the console. Interfaces can also be used as the return value for functions. For example, returning a Dog if the input is dog , Cat if the input is cat , and Bird if it is bird , and then printing the sound of that animal could be done", "using public Animal getAnimalByName String name switchname.toLowerCase case dog return new Dog case cat return new Cat case bird return new Bird default return null public String getAnimalSoundByName String name Animal animal getAnimalByName name if animal null return null else return animal. getSound String dogSound getAnimalSoundByName dog Woof String catSound getAnimalSoundByName cat Meow String birdSound getAnimalSoundByName bird Chirp String lightbulbSound getAnimalSoundByName lightbulb null Interfaces are also useful for extensibility, because if you want to add a new type of Animal , you wouldnt need to change anything with the operations you perform on them. GoalKicker.com Java Notes for Professionals 473Section 79.5 Default methods Introduced in Java 8, default methods are a way of specifying an implementation inside an interface. This could be used to avoid the typical Base or Abstract class by providing a partial implementation of an interface, and restricting the subclasses hierarchy. Observer pattern implementation For example, its possible to implement the Observer-Listener pattern directly into the interface, providing more \ufb02exibility to the implementing classes. interface Observer void onAction String a interface Observable public abstract ListObserver getObservers public default void addObserver Observer o getObservers .addo public default void notifyString something for Observer l getObservers l. onAction something", "Now, any class can be made Observable just by implementing the Observable interface, while being free to be part of a di\ufb00erent class hierarchy. abstract class Worker public abstract void work public class MyWorker extends Worker implements Observable private ListObserver myObservers new ArrayList Observer Override public ListObserver getObservers return myObservers Override public void work notify Started work Code goes here... notify Completed work public static void mainString args MyWorker w new MyWorker w. addListener new Observer Override GoalKicker.com Java Notes for Professionals 474 public void onAction String a System.out.printlna new Date w. work Diamond problem The compiler in Java 8 is aware of the diamond problem which is caused when a class is implementing interfaces containing a method with the same signature. In order to solve it, an implementing class must override the shared method and provide its own implementation. interface InterfaceA public default String getName return a interface InterfaceB public default String getName return b public class ImpClass implements InterfaceA, InterfaceB Override public String getName Must provide its own implementation return InterfaceA. super.getName InterfaceB. super.getName public static void mainString args ImpClass c new ImpClass System.out.println c.getName Prints ab System.out.println InterfaceA c.getName Prints ab System.out.println InterfaceB c.getName Prints ab", "Theres still the issue of having methods with the same name and parameters with di\ufb00erent return types, which will not compile. Use default methods to resolve compatibility issues The default method implementations come in very handy if a method is added to an interface in an existing system where the interfaces is used by several classes. To avoid breaking up the entire system, you can provide a default method implementation when you add a method to an interface. This way, the system will still compile and the actual implementations can be done step by step. For more information, see the Default Methods topic. GoalKicker.com Java Notes for Professionals 475Section 79.6 Modi\ufb01ers in Interfaces The Oracle Java Style Guide states Modi\ufb01ers should not be written out when they are implicit. See Modi\ufb01ers in Oracle O\ufb03cial Code Standard for the context and a link to the actual Oracle document. This style guidance applies particularly to interfaces. Lets consider the following code snippet interface I public static final int VARIABLE 0 public abstract void method public static void staticMethod ... public default void defaultMethod ... Variables All interface variables are implicitly constants with implicit public accessible for all, static are accessible by", "interface name and final must be initialized during declaration modi\ufb01ers public static final int VARIABLE 0 Methods All methods which dont provide implementation are implicitly public and abstract . 1. public abstract void method Version Java SE 8 All methods with static or default modi\ufb01er must provide implementation and are implicitly public . 2. public static void staticMethod ... After all of the above changes have been applied, we will get the following interface I int VARIABLE 0 void method static void staticMethod ... default void defaultMethod ... Section 79.7 Using Interfaces with Generics Lets say you want to de\ufb01ne an interface that allows publishing consuming data to and from di\ufb00erent types of channels e.g. AMQP, JMS, etc, but you want to be able to switch out the implementation details ... Lets de\ufb01ne a basic IO interface that can be re-used across multiple implementations GoalKicker.com Java Notes for Professionals 476public interface IOIncomingType, OutgoingType void publish OutgoingType data IncomingType consume IncomingType RPCSubmit OutgoingType data Now I can instantiate that interface, but since we dont have default implementations for those methods, itll need an implementation when we instantiate it IOString, String mockIO new IOString, String private String channel somechannel Override public", "void publish String data System.out.printlnPublishing data to channel Override public String consume System.out.printlnConsuming from channel return some useful data Override public String RPCSubmit String data return received data just now mockIO. consume prints Consuming from somechannel mockIO. publishTestData Publishing TestData to somechannel System.out.printlnmockIO.RPCSubmit TestData received TestData just now We can also do something more useful with that interface, lets say we want to use it to wrap some basic RabbitMQ functions public class RabbitMQ implements IOString, String private String exchange private String queue public RabbitMQ String exchange, String queue this.exchange exchange this.queue queue Override public void publish String data rabbit. basicPublish exchange, queue, data. getBytes Override public String consume return rabbit. basicConsume exchange, queue GoalKicker.com Java Notes for Professionals 477 Override public String RPCSubmit String data return rabbit. rpcPublish exchange, queue, data Lets say I want to use this IO interface now as a way to count visits to my website since my last system restart and then be able to display the total number of visits - you can do something like this import java.util.concurrent.atomic.AtomicLong public class VisitCounter implements IOLong, Integer private static AtomicLong websiteCounter new AtomicLong 0 Override public void publish Integer count websiteCounter. addAndGet count Override", "public Long consume return websiteCounter. get Override public Long RPCSubmit Integer count return websiteCounter. addAndGet count Now lets use the VisitCounter VisitCounter counter new VisitCounter just had 4 visits, yay counter. publish4 just had another visit, yay counter. publish1 get data for stats counter System.out.printlncounter. consume prints 5 show data for stats counter page, but include that as a page view System.out.printlncounter. RPCSubmit 1 prints 6 When implementing multiple interfaces, you cant implement the same interface twice. That also applies to generic interfaces. Thus, the following code is invalid, and will result in a compile error interface Printer T void printT value Invalid! class SystemPrinter implements Printer Double, Printer Integer Override public void printDouble d System.out.printlnDecimal d Override public void printInteger i System.out.printlnDiscrete i GoalKicker.com Java Notes for Professionals 478 Section 79.8 Strengthen bounded type parameters Bounded type parameters allow you to set restrictions on generic type arguments class SomeClass class DemoT extends SomeClass But a type parameter can only bind to a single class type. An interface type can be bound to a type that already had a binding. This is achieved using the symbol interface SomeInterface class GenericClass T extends SomeClass SomeInterface This strengthens the bind, potentially", "requiring type arguments to derive from multiple types. Multiple interface types can be bound to a type parameter class DemoT extends SomeClass FirstInterface SecondInterface But should be used with caution. Multiple interface bindings is usually a sign of a code smell , suggesting that a new type should be created which acts as an adapter for the other types interface NewInterface extends FirstInterface, SecondInterface class DemoT extends SomeClass NewInterface Section 79.9 Implementing interfaces in an abstract class A method de\ufb01ned in an interface is by default public abstract . When an abstract class implements an interface , any methods which are de\ufb01ned in the interface do not have to be implemented by the abstract class . This is because a class that is declared abstract can contain abstract method declarations. It is therefore the responsibility of the \ufb01rst concrete sub-class to implement any abstract methods inherited from any interfaces andor the abstract class . public interface NoiseMaker void makeNoise GoalKicker.com Java Notes for Professionals 479public abstract class Animal implements NoiseMaker Does not need to declare or implement makeNoise public abstract void eat Because Dog is concrete, it must define both makeNoise and eat public class Dog extends Animal Override", "public void makeNoise System.out.printlnBorf borf Override public void eat System.out.printlnDog eats some kibble. From Java 8 onward it is possible for an interface to declare default implementations of methods which means the method wont be abstract , therefore any concrete sub-classes will not be forced to implement the method but will inherit the default implementation unless overridden. GoalKicker.com Java Notes for Professionals 480Chapter 80 Regular Expressions A regular expression is a special sequence of characters that helps in matching or \ufb01nding other strings or sets of strings, using a specialized syntax held in a pattern. Java has support for regular expression usage through the java.util.regex package. This topic is to introduce and help developers understand more with examples on how Regular Expressions must be used in Java. Section 80.1 Using capture groups If you need to extract a part of string from the input string, we can use capture groups of regex. For this example, well start with a simple phone number regex d3-d3-d4 If parentheses are added to the regex, each set of parentheses is considered a capturing group . In this case, we are using what are called numbered capture groups d3-d3-d4 ----- ----- ----- Group 1", "Group 2 Group 3 Before we can use it in Java, we must not forget to follow the rules of Strings, escaping the backslashes, resulting in the following pattern d3-d3-d4 We \ufb01rst need to compile the regex pattern to make a Pattern and then we need a Matcher to match our input string with the pattern Pattern phonePattern Pattern. compiled3-d3-d4 Matcher phoneMatcher phonePattern. matcherabcd800-555-1234wxyz Next, the Matcher needs to \ufb01nd the \ufb01rst subsequence that matches the regex phoneMatcher. find Now, using the group method, we can extract the data from the string String number phoneMatcher. group0 800-555-1234 Group 0 is everything the regex matched String aCode phoneMatcher. group1 800 String threeDigit phoneMatcher. group2 555 String fourDigit phoneMatcher. group3 1234 Note Matcher. group can be used in place of Matcher. group0. Version Java SE 7 Java 7 introduced named capture groups. Named capture groups function the same as numbered capture groups but with a name instead of a number, although there are slight syntax changes. Using named capture groups improves readability. We can alter the above code to use named groups GoalKicker.com Java Notes for Professionals 481?d3-d3-d4 ---------------- ----- ----- AreaCode Group 2 Group 3 To get the contents of", "AreaCode, we can instead use String aCode phoneMatcher. groupAreaCode 800 Section 80.2 Using regex with custom behaviour by compiling the Pattern with \ufb02ags A Pattern can be compiled with \ufb02ags, if the regex is used as a literal String , use inline modi\ufb01ers Pattern pattern Pattern. compilefoo., Pattern. CASEINSENSITIVE Pattern. DOTALL pattern. matcherFOOn.matches Is true. Had the regex not been compiled case insensitively and singlelined, it would fail because FOO does not match foo and n newline does not match .. Pattern anotherPattern Pattern. compile?sifoo anotherPattern. matcherFOOn.matches Is true. foOt.replaceAll ?sifoo , ca Returns cat. Section 80.3 Escape Characters Generally To use regular expression speci\ufb01c characters ? etc. in their literal meaning they need to be escaped. In common regular expression this is done by a backslash . However, as it has a special meaning in Java Strings, you have to use a double backslash . These two examples will not work ???.replaceAll ?, ! java.util.regex.PatternSyntaxException ???.replaceAll ?, ! Invalid escape sequence This example works ???.replaceAll ?, ! !!! Splitting a Pipe Delimited String This does not return the expected result ab.split a, , b This returns the expected result ab.split a, b Escaping backslash GoalKicker.com Java Notes for", "Professionals 482This will give an error .matches PatternSyntaxException .matches Syntax Error This works .matches true Section 80.4 Not matching a given string To match something that does not contain a given string, one can use negative lookahead Regex syntax ?!string-to-not-match Example not matching popcorn String regexString ?!popcorn. System.out.printlnpopcorn popcorn .matchesregexString ? matched! nope! System.out.printlnunicorn unicorn .matchesregexString ? matched! nope! Output popcorn nope! unicorn matched! Section 80.5 Matching with a regex literal If you need to match characters that are a part of the regular expression syntax you can mark all or part of the pattern as a regex literal. Q marks the beginning of the regex literal. E marks the end of the regex literal. the following throws a PatternSyntaxException because of the un-closed bracket 123.matches123 wrapping the bracket in Q and E allows the pattern to match as you would expect. 123.matchesQE123 returns true An easier way of doing it without having to remember the Q and E escape sequences is to use Pattern. quote 123.matchesPattern. quote 123 returns true Section 80.6 Matching a backslash If you want to match a backslash in your regular expression, youll have to escape it. Backslash is an escape character in regular", "expressions. You can use to refer to a single backslash in a regular expression. However, backslash is also an escape character in Java literal strings. To make a regular expression from a string literal, you have to escape each of its backslashes. In a string literal can be used to create a regular expression GoalKicker.com Java Notes for Professionals 483with , which in turn can match . For example, consider matching strings like Cdirmy\ufb01le.txt. A regular expression A-Za-z. will match, and provide the drive letter as a capturing group. Note the doubled backslash. To express that pattern in a Java string literal, each of the backslashes in the regular expression needs to be escaped. String path Cdirmyfile.txt System.out.println Local path path Cdirmyfile.txt String regex A-Za-z . Four to match one System.out.printlnRegex regex A-Za-z. Pattern pattern Pattern. compile regex Matcher matcher pattern. matcher path if matcher. matches System.out.println This path is on drive matcher. group 1 . This path is on drive C. If you want to match two backslashes, youll \ufb01nd yourself using eight in a literal string, to represent four in the regular expression, to match two. String path myhostsharemyfile.txt System.out.println UNC path path myhostsharemyfile.txt String regex .?.", "Eight to match two System.out.printlnRegex regex .?. Pattern pattern Pattern. compile regex Matcher matcher pattern. matcher path if matcher. matches System.out.println This path is on host matcher. group 1 . This path is on host myhost. GoalKicker.com Java Notes for Professionals 484Chapter 81 Comparable and Comparator Section 81.1 Sorting a List using ComparableT or a ComparatorT Say we are working on a class representing a Person by their \ufb01rst and last names. We have created a basic class to do this and implemented proper equals and hashCode methods. public class Person private final String lastName invariant - nonnull private final String firstName invariant - nonnull public PersonString firstName, String lastName this.firstName firstName ! null ? firstName this.lastName lastName ! null ? lastName public String getFirstName return firstName public String getLastName return lastName public String toString return lastName , firstName Override public boolean equalsObject o if ! o instanceof Person return false Person p Persono return firstName. equalsp.firstName lastName. equalsp.lastName Override public int hashCode return Objects. hashfirstName, lastName Now we would like to sort a list of Person objects by their name, such as in the following scenario public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new", "PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople This currently wont work. Unfortunately, as marked, the above currently wont compile. Collections .sort.. only knows how to sort a list if the elements in that list are comparable, or a custom method of comparison is given. If you were asked to sort the following list 1,3,5,4,2, youd have no problem saying the answer is 1,2,3,4,5. This GoalKicker.com Java Notes for Professionals 485is because Integers both in Java and mathematically have a natural ordering , a standard, default comparison base ordering. To give our Person class a natural ordering, we implement Comparable Person, which requires implementing the method compareTo Person p public class Person implements Comparable Person private final String lastName invariant - nonnull private final String firstName invariant - nonnull public PersonString firstName, String lastName this.firstName firstName ! null ? firstName this.lastName lastName ! null ? lastName public String getFirstName return firstName public String getLastName return lastName public String toString return lastName , firstName Override public boolean equalsObject o if ! o instanceof Person return false Person p Persono return firstName. equalsp.firstName lastName. equalsp.lastName Override public int hashCode return Objects. hashfirstName, lastName", "Override public int compareTo Person other If this lastName and others lastName are not comparably equivalent, Compare this to other by comparing their last names. Otherwise, compare this to other by comparing their first names int lastNameCompare lastName. compareTo other.lastName if lastNameCompare ! 0 return lastNameCompare else return firstName. compareTo other.firstName Now, the main method given will function correctly public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople Now functions correctly GoalKicker.com Java Notes for Professionals 486 people is now sorted by last name, then first name -- Jill Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald If, however, you either do not want or are unable to modify class Person , you can provide a custom Comparator T that handles the comparison of any two Person objects. If you were asked to sort the following list circle, square, rectangle, triangle, hexagon you could not, but if you were asked to sort that list based on the number of corners , you could. Just so, providing a comparator instructs Java how to compare two normally not comparable objects. public", "class PersonComparator implements Comparator Person public int compare Person p1, Person p2 If p1s lastName and p2s lastName are not comparably equivalent, Compare p1 to p2 by comparing their last names. Otherwise, compare p1 to p2 by comparing their first names if p1.getLastName .compareTo p2.getLastName ! 0 return p1.getLastName .compareTo p2.getLastName else return p1.getFirstName .compareTo p2.getFirstName Assume the first version of Person that does not implement Comparable is used here public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople Illegal, Person doesnt implement Comparable. Collections .sortpeople, new PersonComparator Legal people is now sorted by last name, then first name -- Jill Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald Comparators can also be createdused as an anonymous inner class Assume the first version of Person that does not implement Comparable is used here public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople Illegal, Person doesnt implement Comparable. Collections .sortpeople, new PersonComparator Legal people is now sorted by last name, then", "first name -- Jill Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald Anonymous Class Collections .sortpeople, new Comparator Person Legal public int compare Person p1, Person p2 Method code... GoalKicker.com Java Notes for Professionals 487 Version Java SE 8 Lambda expression based comparators As of Java 8, comparators can also be expressed as lambda expressions Lambda Collections .sortpeople, p1, p2 - Legal Method code.... Comparator default methods Furthermore, there are interesting default methods on the Comparator interface for building comparators the following builds a comparator comparing by lastName and then firstName . Collections .sortpeople, Comparator .comparing PersongetLastName . thenComparing PersongetFirstName Inversing the order of a comparator Any comparator can also easily be reversed using the reversedMethod which will change ascending order to descending. Section 81.2 The compareTo and compare Methods The Comparable T interface requires one method public interface Comparable T public int compareTo T other And the Comparator T interface requires one method public interface Comparator T public int compare T t1, T t2 These two methods do essentially the same thing, with one minor di\ufb00erence compareTo compares this to other , whereas compare compares t1 to t2, not caring at all about this . Aside from", "that di\ufb00erence, the two methods have similar requirements. Speci\ufb01cally for compareTo, Compares this object with the speci\ufb01ed object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the speci\ufb01ed object. Thus, for the comparison of a and b If a b, a.compareTo b and comparea,b should return a negative integer, and b.compareTo a and compareb,a should return a positive integer If a b, a.compareTo b and comparea,b should return a positive integer, and b.compareTo a and compareb,a should return a negative integer If a equals b for comparison, all comparisons should return 0. GoalKicker.com Java Notes for Professionals 488Section 81.3 Natural comparable vs explicit comparator sorting There are two Collections .sort methods One that takes a ListT as a parameter where T must implement Comparable and override the compareTo method that determines sort order. One that takes a List and a Comparator as the arguments, where the Comparator determines the sort order. First, here is a Person class that implements Comparable public class Person implements Comparable Person private String name private int age public String getName return name public void setName String name this.name name public", "int getAge return age public void setAgeint age this.age age Override public int compareTo Person o return this.getAge - o.getAge Override public String toString return this.getAge-this.getName Here is how you would use the above class to sort a List in the natural ordering of its elements, de\ufb01ned by the compareTo method override -- usage ListPerson pList new ArrayList Person Person p new Person p. setNameA p. setAge10 pList. addp p new Person p. setNameZ p. setAge20 pList. addp p new Person p. setNameD p. setAge30 pList. addp -- natural sorting i.e comes with object implementation, by age Collections .sortpList GoalKicker.com Java Notes for Professionals 489 System.out.printlnpList Here is how you would use an anonymous inline Comparator to sort a List that does not implement Comparable, or in this case, to sort a List in an order other than the natural ordering -- explicit sorting, define sort on another property here goes with name Collections .sortpList, new Comparator Person Override public int compare Person o1, Person o2 return o1.getName.compareTo o2.getName System.out.printlnpList Section 81.4 Creating a Comparator using comparing method Comparator .comparing PersongetName This creates a comparator for the class Person that uses this person name as the comparison source. Also", "it is possible to use method version to compare long, int and double. For example Comparator .comparingInt PersongetAge Reversed order To create a comparator that imposes the reverse ordering use reversed method Comparator .comparing PersongetName.reversed Chain of comparators Comparator .comparing PersongetLastName .thenComparing PersongetFirstName This will create a comparator that \ufb01rs compares with last name then compares with \ufb01rst name. You can chain as many comparators as you want. Section 81.5 Sorting Map entries As of Java 8, there are default methods on the Map.Entry interface to allow sorting of map iterations. Version Java SE 8 MapString, Integer numberOfEmployees new HashMap numberOfEmployees. putexecutives , 10 numberOfEmployees. puthuman ressources , 32 numberOfEmployees. putaccounting , 12 numberOfEmployees. putIT, 100 Output the smallest departement in terms of number of employees numberOfEmployees. entrySet .stream .sortedMap.Entry.comparingByValue .limit1 .forEachSystem.outprintln outputs executives10 Of course, these can also be used outside of the stream api GoalKicker.com Java Notes for Professionals 490Version Java SE 8 ListMap.EntryString, Integer entries new ArrayList numberOfEmployees. entrySet Collections .sortentries, Map.Entry.comparingByValue GoalKicker.com Java Notes for Professionals 491Chapter 82 Java Floating Point Operations Floating-point numbers are numbers that have fractional parts usually expressed with a decimal point. In Java, there is two primitive types for \ufb02oating-point", "numbers which are float uses 4 bytes, and double uses 8 bytes. This documentation page is for detailing with examples operations that can be done on \ufb02oating points in Java. Section 82.1 Comparing \ufb02oating point values You should be careful when comparing \ufb02oating-point values float or double using relational operators , !, and so on. These operators give results according to the binary representations of the \ufb02oating point values. For example public class CompareTest public static void mainString args double oneThird 1.0 3.0 double one oneThird 3 System.out.printlnone 1.0 prints false The calculation oneThird has introduced a tiny rounding error, and when we multiply oneThird by 3 we get a result that is slightly di\ufb00erent to 1.0. This problem of inexact representations is more stark when we attempt to mix double and float in calculations. For example public class CompareTest2 public static void mainString args float floatVal 0.1f double doubleVal 0.1 double doubleValCopy floatVal System.out.printlnfloatVal 0.1 System.out.printlndoubleVal 0.1 System.out.printlndoubleValCopy 0.10000000149011612 System.out.printlnfloatVal doubleVal false System.out.printlndoubleVal doubleValCopy false The \ufb02oating point representations used in Java for the float and double types have limited number of digits of precision. For the float type, the precision is 23 binary digits or about 8", "decimal digits. For the double type, it is 52 bits or about 15 decimal digits. On top of that, some arithmetical operations will introduce rounding errors. Therefore, when a program compares \ufb02oating point values, it standard practice to de\ufb01ne an acceptable delta for the comparison. If the di\ufb00erence between the two numbers is less than the delta, they are deemed to be equal. For example if Math.absv1 - v2 delta Delta compare example public class DeltaCompareExample GoalKicker.com Java Notes for Professionals 492 private static boolean deltaCompare double v1, double v2, double delta return true iff the difference between v1 and v2 is less than delta return Math.absv1 - v2 delta public static void mainString args double doubles 1.0, 1.0001, 1.0000001 , 1.000000001 , 1.0000000000001 double deltas 0.01, 0.00001, 0.0000001 , 0.0000000001 , 0 loop through all of deltas initialized above for int j 0 j deltas. length j double delta deltasj System.out.printlndelta delta loop through all of the doubles initialized above for int i 0 i doubles. length - 1 i double d1 doubles i double d2 doubles i 1 boolean result deltaCompare d1, d2, delta System.out.println d1 d2 ? result System.out.println Result delta 0.01 1.0 1.0001 ? true", "1.0001 1.0000001 ? true 1.0000001 1.000000001 ? true 1.000000001 1.0000000000001 ? true delta 1.0E-5 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? true 1.000000001 1.0000000000001 ? true delta 1.0E-7 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? true 1.000000001 1.0000000000001 ? true delta 1.0E-10 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? false 1.000000001 1.0000000000001 ? false delta 0.0 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? false 1.000000001 1.0000000000001 ? false GoalKicker.com Java Notes for Professionals 493Also for comparison of double and float primitive types static compare method of corresponding boxing type can be used. For example double a 1.0 double b 1.0001 System.out.printlnDouble.comparea, b-1 System.out.printlnDouble.compareb, a1 Finally, determining what deltas are most appropriate for a comparison can be tricky. A commonly used approach is to pick delta values that are our intuition says are about right. However, if you know scale and true accuracy of the input values, and the calculations performed, it may be possible to come up with mathematically sound bounds on the accuracy of the results, and hence for the deltas. There is a formal branch of Mathematics known as Numerical Analysis", "that used to be taught to computational scientists that covered this kind of analysis. Section 82.2 OverFlow and UnderFlow Float data type The \ufb02oat data type is a single-precision 32-bit IEEE 754 \ufb02oating point. Float over\ufb02ow Maximum possible value is 3.4028235e 38 , When it exceeds this value it produces Infinity float f 3.4e38f float result f2 System.out.printlnresult Infinity Float UnderFlow Minimum value is 1.4e-45f, when is goes below this value it produces 0.0 float f 1e-45f float result f1000 System.out.printlnresult double data type The double data type is a double-precision 64-bit IEEE 754 \ufb02oating point. Double OverFlow Maximum possible value is 1.7976931348623157e 308 , When it exceeds this value it produces Infinity double d 1e308 double resultd2 System.out.printlnresult Infinity Double UnderFlow Minimum value is 4.9e-324, when is goes below this value it produces 0.0 double d 4.8e-323 double result d1000 GoalKicker.com Java Notes for Professionals 494 System.out.printlnresult 0.0 Section 82.3 Formatting the \ufb02oating point values Floating point Numbers can be formatted as a decimal number using String.format with f \ufb02ag Two digits in fracttional part are rounded String format1 String.format.2f, 1.2399 System.out.printlnformat1 1.24 three digits in fractional part are rounded String format2 String.format.3f, 1.2399 System.out.printlnformat2 1.240 rounded to", "two digits, filled with zero String format3 String.format.2f, 1.2 System.out.printlnformat3 returns 1.20 rounder to two digits String format4 String.format.2f, 3.19999 System.out.printlnformat4 3.20 Floating point Numbers can be formatted as a decimal number using DecimalFormat rounded with one digit fractional part String format new DecimalFormat 0..format4.3200 System.out.printlnformat 4.3 rounded with two digit fractional part String format new DecimalFormat 0..format1.2323000 System.out.printlnformat 1.23 formatting floating numbers to decimal number double dv 123456789 System.out.printlndv 1.23456789E8 String format new DecimalFormat 0.formatdv System.out.printlnformat 123456789 Section 82.4 Strict Adherence to the IEEE Speci\ufb01cation By default, \ufb02oating point operations on float and double do not strictly adhere to the rules of the IEEE 754 speci\ufb01cation. An expression is allowed to use implementation-speci\ufb01c extensions to the range of these values essentially allowing them to be more accurate than required. strictfp disables this behavior. It is applied to a class, interface, or method, and applies to everything contained in it, such as classes, interfaces, methods, constructors, variable initializers, etc. With strictfp , the intermediate values of a \ufb02oating-point expression must be within the \ufb02oat value set or the double value set. This causes the results of such expressions to be exactly those that the IEEE 754 speci\ufb01cation predicts. All", "constant expressions are implicitly strict, even if they arent inside a strictfp scope. Therefore, strictfp has the net e\ufb00ect of sometimes making certain corner case computations less accurate, and can also make \ufb02oating point operations slower as the CPU is now doing more work to ensure any native extra precision does not a\ufb00ect the result. However, it also causes the results to be exactly the same on all platforms. It is therefore useful in things like scienti\ufb01c programs, where reproducibility is more important than speed. public class StrictFP No strictfp - default lenient GoalKicker.com Java Notes for Professionals 495 public strictfp float strictfloat input return input input 3.4f Strictly adheres to the spec. May be less accurate and may be slower. public float lenient float input return input input 3.4f Can sometimes be more accurate and faster, but results may not be reproducable. public static final strictfp class Ops strictfp affects all enclosed entities private StrictOps public static divdouble dividend, double divisor implicitly strictfp return dividend divisor GoalKicker.com Java Notes for Professionals 496Chapter 83 Currency and Money Section 83.1 Add custom currency Required JARs on classpath javax.moneymoney-api1.0 JSR354 money and currency api org.javamoneymoneta1.0 Reference implementation javaxannotation-api1.2. Common annotations used", "by reference implementation Lets create non-ISO currency, such as bitcoin At first, this will throw UnknownCurrencyException MonetaryAmount moneys Money.ofnew BigDecimal 0.1, BTC This happens because bitcoin is unknown to default currency providers System.out.printlnMonetary. isCurrencyAvailable BTC false We will build new currency using CurrencyUnitBuilder provided by org.javamoney.moneta CurrencyUnit bitcoin CurrencyUnitBuilder .ofBTC, BtcCurrencyProvider Set currency code and currency provider name .setDefaultFractionDigits 2 Set default fraction digits .buildtrue Build new currency unit. Here true means currency unit is to be registered and accessible within default monetary context Now BTC is available System.out.printlnMonetary. isCurrencyAvailable BTC True GoalKicker.com Java Notes for Professionals 497Chapter 84 Object Cloning Section 84.1 Cloning performing a deep copy To copy nested objects, a deep copy must be performed, as shown in this example. import java.util.ArrayList import java.util.List public class Sheep implements Cloneable private String name private int weight private ListSheep children public SheepString name, int weight this.name name this.weight weight Override public Object clone throws CloneNotSupportedException Sheep clone Sheep super.clone if children ! null make a deep copy of the children List Sheep cloneChildren new ArrayList children. size for Sheep child children cloneChildren. addSheep child.clone clone. setChildren cloneChildren return clone public ListSheep getChildren return children public void setChildren ListSheep", "children this.children children import java.util.Arrays import java.util.List create a sheep Sheep sheep new SheepDolly, 20 create children Sheep child1 new SheepChild1 , 4 Sheep child2 new SheepChild2 , 5 sheep.setChildren Arrays.asListchild1, child2 clone the sheep Sheep dolly Sheep sheep.clone GoalKicker.com Java Notes for Professionals 498ListSheep sheepChildren sheep.getChildren ListSheep dollysChildren dolly.getChildren for int i 0 i sheepChildren. size i prints false, both arrays contain copies of the objects inside System.out.printlnsheepChildren. geti dollysChildren. geti Section 84.2 Cloning using a copy factory public class Sheep private String name private int weight public SheepString name, int weight this.name name this.weight weight public static Sheep newInstance Sheep other return new Sheepother.name, other. weight Section 84.3 Cloning using a copy constructor An easy way to clone an object is by implementing a copy constructor. public class Sheep private String name private int weight public SheepString name, int weight this.name name this.weight weight copy constructor copies the fields of other into the new object public SheepSheep other this.name other.name this.weight other.weight create a sheep Sheep sheep new SheepDolly, 20 clone the sheep Sheep dolly new Sheepsheep dolly.name is Dolly and dolly.weight is 20 Section 84.4 Cloning by implementing Clonable interface Cloning an object by implementing the", "Cloneable interface. GoalKicker.com Java Notes for Professionals 499public class Sheep implements Cloneable private String name private int weight public SheepString name, int weight this.name name this.weight weight Override public Object clone throws CloneNotSupportedException return super.clone create a sheep Sheep sheep new SheepDolly, 20 clone the sheep Sheep dolly Sheep sheep.clone dolly.name is Dolly and dolly.weight is 20 Section 84.5 Cloning performing a shallow copy Default behavior when cloning an object is to perform a shallow copy of the objects \ufb01elds. In that case, both the original object and the cloned object, hold references to the same objects. This example shows that behavior. import java.util.List public class Sheep implements Cloneable private String name private int weight private ListSheep children public SheepString name, int weight this.name name this.weight weight Override public Object clone throws CloneNotSupportedException return super.clone public ListSheep getChildren return children public void setChildren ListSheep children this.children children GoalKicker.com Java Notes for Professionals 500import java.util.Arrays import java.util.List create a sheep Sheep sheep new SheepDolly, 20 create children Sheep child1 new SheepChild1 , 4 Sheep child2 new SheepChild2 , 5 sheep.setChildren Arrays.asListchild1, child2 clone the sheep Sheep dolly Sheep sheep.clone ListSheep sheepChildren sheep.getChildren ListSheep dollysChildren dolly.getChildren for int i 0 i", "sheepChildren. size i prints true, both arrays contain the same objects System.out.printlnsheepChildren. geti dollysChildren. geti GoalKicker.com Java Notes for Professionals 501Chapter 85 Recursion Recursion occurs when a method calls itself. Such a method is called recursive . A recursive method may be more concise than an equivalent non-recursive approach. However, for deep recursion, sometimes an iterative solution can consume less of a threads \ufb01nite stack space. This topic includes examples of recursion in Java. Section 85.1 The basic idea of recursion What is recursion In general, recursion is when a function invokes itself, either directly or indirectly. For example This method calls itself infinitely public void useless useless method calls itself directly Conditions for applying recursion to a problem There are two preconditions for using recursive functions to solving a speci\ufb01c problem There must be a base condition for the problem, which will be the endpoint for the recursion. When a1. recursive function reaches the base condition, it makes no further deeper recursive calls. Each level of recursion should be attempting a smaller problem. The recursive function thus divides the2. problem into smaller and smaller parts. Assuming that the problem is \ufb01nite, this will ensure that the recursion terminates.", "In Java there is a third precondition it should not be necessary to recurse too deeply to solve the problem see Deep recursion is problematic in Java Example The following function calculates factorials using recursion. Notice how the method factorial calls itself within the function. Each time it calls itself, it reduces the parameter n by 1. When n reaches 1 the base condition the function will recurse no deeper. public int factorial int n if n 1 the base condition return 1 else return n factorial n - 1 This is not a practical way of computing factorials in Java, since it does not take account of integer over\ufb02ow, or call stack over\ufb02ow i.e. StackOverflowError exceptions for large values of n. Section 85.2 Deep recursion is problematic in Java Consider the following naive method for adding two positive numbers using recursion GoalKicker.com Java Notes for Professionals 502public static int addint a, int b if a 0 return b else return adda - 1, b 1 TAIL CALL This is algorithmically correct, but it has a major problem. If you call add with a large a, it will crash with a StackOverflowError , on any version of Java up", "to at least Java 9. In a typical functional programming language and many other languages the compiler optimizes tail recursion. The compiler would notice that the call to add at the tagged line is a tail call , and would e\ufb00ectively rewrite the recursion as a loop. This transformation is called tail-call elimination. However, current generation Java compilers do not perform tail call elimination. This is not a simple oversight. There are substantial technical reasons for this see below. Instead, each recursive call of add causes a new frame to be allocated on the threads stack. For example, if you call add1000, 1, it will take 1000 recursive calls to arrive at the answer 1001 . The problem is that the size of Java thread stack is \ufb01xed when the thread is created. This includes the main thread in a single-threaded program. If too many stack frames are allocated the stack will over\ufb02ow. The JVM will detect this and throw a StackOverflowError . One approach to dealing with this is to simply use a bigger stack. There are JVM options that control the default size of a stack, and you can also specify the stack size as a Thread", "constructor parameter. Unfortunately, this only puts o\ufb00 the stack over\ufb02ow. If you need to do a computation that requires an even larger stack, then the StackOverflowError comes back. The real solution is to identify recursive algorithms where deep recursion is likely, and manually perform the tail-call optimization at the source code level. For example, our add method can be rewritten as follows public static int addint a, int b while a ! 0 a a - 1 b b 1 return b Obviously, there are better ways to add two integers. The above is simply to illustrate the e\ufb00ect of manual tail-call elimination. Why tail-call elimination is not implemented in Java yet There are a number of reasons why adding tail call elimination to Java is not easy. For example Some code could rely on StackOverflowError to for example place a bound on the size of a computational problem. Sandbox security managers often rely on analyzing the call stack when deciding whether to allow non- privileged code to perform a privileged action. As John Rose explains in Tail calls in the VM The e\ufb00ects of removing the caller s stack frame are visible to some APIs, notably access control", "checks and GoalKicker.com Java Notes for Professionals 503stack tracing. It is as if the caller s caller had directly called the callee. Any privileges possessed by the caller are discarded after control is transferred to the callee. However, the linkage and accessibility of the callee method are computed before the transfer of control, and take into account the tail-calling caller. In other words, tail-call elimination could cause an access control method to mistakenly think that a security sensitive API was was being called by trusted code. Section 85.3 Types of Recursion Recursion can be categorized as either Head Recursion or Tail Recursion , depending on where the recursive method call is placed. In head recursion , the recursive call, when it happens, comes before other processing in the function think of it happening at the top, or head, of the function. In tail recursion , its the opposite the processing occurs before the recursive call. Choosing between the two recursive styles may seem arbitrary, but the choice can make all the di\ufb00erence. A function with a path with a single recursive call at the beginning of the path uses what is called head recursion. The factorial function of a", "previous exhibit uses head recursion. The \ufb01rst thing it does once it determines that recursion is needed is to call itself with the decremented parameter. A function with a single recursive call at the end of a path is using tail recursion. public void tailint n public void headint n ifn 1 ifn 0 return return else else System.out.printlnn head n-1 tailn-1 System.out.printlnn If the recursive call occurs at the end of a method, it is called a tail recursion . The tail recursion is similar to a loop . The method executes all the statements before jumping into the next recursive call . If the recursive call occurs at the beginning of a method, it is called a head recursion . The method saves the state before jumping into the next recursive call . Reference The di\ufb00erence between head tail recursion Section 85.4 Computing the Nth Fibonacci Number The following method computes the Nth Fibonacci number using recursion. public int fibfinal int n if n 2 return fibn - 2 fibn - 1 return 1 The method implements a base case n 2 and a recursive case n2. This illustrates the use of recursion to compute a recursive", "relation. GoalKicker.com Java Notes for Professionals 504However, while this example is illustrative, it is also ine\ufb03cient each single instance of the method will call the function itself twice, leading to an exponential growth in the number of times the function is called as N increases. The above function is O2N, but an equivalent iterative solution has complexity ON. In addition, there is a closed form expression that can be evaluated in ON \ufb02oating-point multiplications. Section 85.5 StackOver\ufb02owError recursion to loop If a recursive call goes too deep, this results in a StackOverflowError . Java allocates a new frame for every method call on its threads stack. However, the space of each threads stack is limited. Too many frames on the stack leads to the Stack Over\ufb02ow SO. Example public static void recursion int depth if depth 0 recursion depth-1 Calling this method with large parameters e.g. recursion 50000 probably will result in a stack over\ufb02ow. The exact value depends on the thread stack size, which in turn depends on the thread construction, command-line parameters such as -Xss, or the default size for the JVM. Workaround A recursion can be converted to a loop by storing the data for each", "recursive call in a data structure. This data structure can be stored on the heap rather than on the thread stack. In general the data required to restore the state of a method invocation can be stored in a stack and a while loop can be used to simulate the recursive calls. Data that may be required include the object the method was called for instance methods only the method parameters local variables the current position in the execution or the method Example The following class allows recursive of a tree structure printing up to a speci\ufb01ed depth. public class Node public int data public Node left public Node right public Nodeint data thisdata, null, null public Nodeint data, Node left, Node right this.data data this.left left this.right right public void printfinal int maxDepth if maxDepth 0 GoalKicker.com Java Notes for Professionals 505 System.out.print... else System.out.print if left ! null left. printmaxDepth -1 System.out.printdata if right ! null right. printmaxDepth -1 System.out.print e.g. Node n new Node10, new Node20, new Node50, new Node1, new Node30, new Node42, null n.print2 System.out.println Prints ...20...10...30 This could be converted to the following loop public class Frame public final Node node 0 before", "printing anything 1 before printing data 2 before printing public int state 0 public final int maxDepth public FrameNode node, int maxDepth this.node node this.maxDepth maxDepth ListFrame stack new ArrayList stack.addnew Framen, 2 first frame initial call while !stack.isEmpty get topmost stack element int index stack.size - 1 Frame frame stack.getindex get topmost frame if frame.maxDepth 0 termial case too deep System.out.print... stack. removeindex drop frame else switch frame.state case 0 frame. state GoalKicker.com Java Notes for Professionals 506 do everything done before the first recursive call System.out.print if frame.node.left ! null add new frame recursive call to left and stop stack. addnew Frameframe.node.left, frame. maxDepth - 1 break case 1 frame. state do everything done before the second recursive call System.out.printframe.node.data if frame.node.right ! null add new frame recursive call to right and stop stack. addnew Frameframe.node.right, frame. maxDepth - 1 break case 2 do everything after the second recursive call drop frame System.out.print stack. removeindex System.out.println Note This is just an example of the general approach. Often you can come up with a much better way to represent a frame andor store the frame data. Section 85.6 Computing the Nth power of a number The following method", "computes the value of num raised to the power of exp using recursion public long powerfinal int num, final int exp if exp 0 return 1 if exp 1 return num return num powernum, exp - 1 This illustrates the principles mentioned above the recursive method implements a base case two cases, n 0 and n 1 that terminates the recursion, and a recursive case that calls the method again. This method is ON and can be reduced to a simple loop using tail-call optimization. Section 85.7 Traversing a Tree data structure with recursion Consider the Node class having 3 members data, left child pointer and right child pointer like below. public class Node public int data public Node left public Node right public Nodeint data this.data data GoalKicker.com Java Notes for Professionals 507 We can traverse the tree constructed by connecting multiple Node classs object like below, the traversal is called in-order traversal of tree. public static void inOrderTraversal Node root if root ! null inOrderTraversal root.left traverse left sub tree System.out.printroot.data traverse current node inOrderTraversal root.right traverse right sub tree As demonstrated above, using recursion we can traverse the tree data structure without using any other data", "structure which is not possible with the iterative approach. Section 85.8 Reverse a string using Recursion Below is a recursive code to reverse a string Just a snippet to explain the idea of recursion public class Reverse public static void main String args String string hello world System.out.printlnreversestring prints dlrow olleh public static String reverse String s if s.length 1 return s return reverse s.substring 1 s.charAt0 Section 85.9 Computing the sum of integers from 1 to N The following method computes the sum of integers from 0 to N using recursion. public int sumfinal int n if n 0 return n sumn - 1 else return n This method is ON and can be reduced to a simple loop using tail-call optimization. In fact there is a closed form expression that computes the sum in O1 operations. GoalKicker.com Java Notes for Professionals 508Chapter 86 Converting to and from Strings Section 86.1 Converting String to other datatypes You can convert a numeric string to various Java numeric types as follows String to int String number 12 int num Integer.parseInt number String to \ufb02oat String number 12.0 float num Float.parseFloat number String to double String double 1.47 double num Double.parseDouble", "double String to boolean String falseString False boolean falseBool Boolean.parseBoolean falseString falseBool false String trueString True boolean trueBool Boolean.parseBoolean trueString trueBool true String to long String number 47 long num Long.parseLong number String to BigInteger String bigNumber 21 BigInteger reallyBig new BigInteger bigNumber String to BigDecimal String bigFraction 17.21455 BigDecimal reallyBig new BigDecimal bigFraction Conversion Exceptions The numeric conversions above will all throw an unchecked NumberFormatException if you attempt to parse a string that is not a suitably formatted number, or is out of range for the target type. The Exceptions topic discusses how to deal with such exceptions. If you wanted to test that you can parse a string, you could implement a tryParse... method like this GoalKicker.com Java Notes for Professionals 509boolean tryParseInt String value try String somechar Integer.parseInt value return true catch NumberFormatException e return false However, calling this tryParse... method immediately before parsing is arguably poor practice. It would be better to just call the parse... method and deal with the exception. Section 86.2 Conversion to from bytes To encode a string into a byte array, you can simply use the StringgetBytes method, with one of the standard character sets available on any Java runtime", "byte bytes test.getBytes StandardCharsets. UTF8 and to decode String testString new Stringbytes, StandardCharsets. UTF8 you can further simplify the call by using a static import import static java.nio.charset.StandardCharsets .UTF8 ... byte bytes test.getBytes UTF8 For less common character sets you can indicate the character set with a string byte bytes test.getBytes UTF-8 and the reverse String testString new String bytes, UTF-8 this does however mean that you have to handle the checked UnsupportedCharsetException . The following call will use the default character set. The default character set is platform speci\ufb01c and generally di\ufb00ers between Windows, Mac and Linux platforms. byte bytes test.getBytes and the reverse String testString new Stringbytes Note that invalid characters and bytes may be replaced or skipped by these methods. For more control - for instance for validating input - youre encouraged to use the CharsetEncoder and CharsetDecoder classes. Section 86.3 Base64 Encoding Decoding Occasionally you will \ufb01nd the need to encode binary data as a base64 -encoded string. GoalKicker.com Java Notes for Professionals 510For this we can use the DatatypeConverter class from the javax.xml.bind package import javax.xml.bind.DatatypeConverter import java.util.Arrays arbitrary binary data specified as a byte array byte binaryData some arbitrary data .getBytes UTF-8 convert", "the binary data to the base64-encoded string String encodedData DatatypeConverter. printBase64Binary binaryData encodedData is now c29tZSBhcmJpdHJhcnkgZGF0YQ convert the base64-encoded string back to a byte array byte decodedData DatatypeConverter. parseBase64Binary encodedData assert that the original data and the decoded data are equal assert Arrays.equalsbinaryData, decodedData Apache commons-codec Alternatively, we can use Base64 from Apache commons-codec . import org.apache.commons.codec.binary.Base64 your blob of binary as a byte array byte blob someBinaryData .getBytes use the Base64 class to encode String binaryAsAString Base64. encodeBase64String blob use the Base64 class to decode byte blob2 Base64. decodeBase64 binaryAsAString assert that the two blobs are equal System.out.printlnEqual Boolean.toString Arrays.equalsblob, blob2 If you inspect this program wile running, you will see that someBinaryData encodes to c29tZUJpbmFyeURhdGE , a very managable UTF-8 String object. Version Java SE 8 Details for the same can be found at Base64 encode with padding String encoded Base64. getEncoder .encodeToString someByteArray encode without padding String encoded Base64. getEncoder .withoutPadding .encodeToString someByteArray decode a String byte barr Base64. getDecoder .decodeencoded Reference Section 86.4 Converting other datatypes to String GoalKicker.com Java Notes for Professionals 511You can get the value of other primitive data types as a String using one the String classs valueOf methods. For example", "int i 42 String string String.valueOfi string now equals 42 . This method is also overloaded for other datatypes, such as float , double , boolean , and even Object . You can also get any other Object any instance of any class as a String by calling .toString on it. For this to give useful output, the class must override toString . Most of the standard Java library classes do, such as Date and others. For example Foo foo new Foo Any class. String stringifiedFoo foo.toString . Here stringifiedFoo contains a representation of foo as a String. You can also convert any number type to String with short notation like below. int i 10 String str i Or just simple way is String str 10 Section 86.5 Getting a String from an InputStream A String can be read from an InputStream using the byte array constructor. import java.io. public String readString InputStream input throws IOException byte bytes new byte50 supply the length of the string in bytes here input. readbytes return new Stringbytes This uses the system default charset, although an alternate charset may be speci\ufb01ed return new Stringbytes, Charset. forNameUTF-8 GoalKicker.com Java Notes for Professionals 512Chapter 87", "Random Number Generation Section 87.1 Pseudo Random Numbers Java provides, as part of the utils package, a basic pseudo-random number generator, appropriately named Random . This object can be used to generate a pseudo-random value as any of the built-in numerical datatypes int, float , etc. You can also use it to generate a random Boolean value, or a random array of bytes. An example usage is as follows import java.util.Random ... Random random new Random int randInt random. nextInt long randLong random. nextLong double randDouble random. nextDouble This returns a value between 0.0 and 1.0 float randFloat random. nextFloat Same as nextDouble byte randBytes new byte16 random.nextBytes randBytes nextBytes takes a user-supplied byte array, and fills it with random bytes. It returns nothing. NOTE This class only produces fairly low-quality pseudo-random numbers, and should never be used to generate random numbers for cryptographic operations or other situations where higher-quality randomness is critical For that, you would want to use the SecureRandom class, as noted below. An explanation for the distinction between secure and insecure randomness is beyond the scope of this example. Section 87.2 Pseudo Random Numbers in Speci\ufb01c Range The method nextIntint bound of Random accepts an", "upper exclusive boundary, i.e. a number that the returned random value must be less than. However, only the nextInt method accepts a bound nextLong , nextDouble etc. do not. Random random new Random random.nextInt1000 0 - 999 int number 10 random. nextInt100 number is in the range of 10 to 109 Starting in Java 1.7, you may also use ThreadLocalRandom source . This class provides a thread-safe PRNG pseudo- random number generator. Note that the nextInt method of this class accepts both an upper and lower bound. import java.util.concurrent.ThreadLocalRandom nextInt is normally exclusive of the top value, so add 1 to make it inclusive ThreadLocalRandom. current.nextIntmin, max 1 Note that the o\ufb03cial documentation states that nextIntint bound can do weird things when bound is near 2301 emphasis added The algorithm is slightly tricky. It rejects values that would result in an uneven distribution due to the fact that 231 is not divisible by n. The probability of a value being rejected depends on n. The worst GoalKicker.com Java Notes for Professionals 513case is n2301, for which the probability of a reject is 12, and the expected number of iterations before the loop terminates is 2. In other words, specifying", "a bound will slightly decrease the performance of the nextInt method, and this performance decrease will become more pronounced as the bound approaches half the max int value. Section 87.3 Generating cryptographically secure pseudorandom numbers Random and ThreadLocalRandom are good enough for everyday use, but they have a big problem They are based on a linear congruential generator , an algorithm whose output can be predicted rather easily. Thus, these two classes are not suitable for cryptographic uses such as key generation. One can use java.security .SecureRandom in situations where a PRNG with an output that is very hard to predict is required. Predicting the random numbers created by instances of this class is hard enough to label the class as cryptographically secure . import java.security.SecureRandom import java.util.Arrays public class Foo public static void mainString args SecureRandom rng new SecureRandom byte randomBytes new byte64 rng. nextBytes randomBytes Fills randomBytes with random bytes duh System.out.printlnArrays.toString randomBytes Besides being cryptographically secure, SecureRandom has a gigantic period of 2160, compared to Random s period of 248. It has one drawback of being considerably slower than Random and other linear PRNGs such as Mersenne Twister and Xorshift , however. Note that SecureRandom implementation", "is both platform and provider dependent. The default SecureRandom given by SUN provider in sun.security .provider .SecureRandom on Unix-like systems, seeded with data from devrandom andor devurandom . on Windows, seeded with calls to CryptGenRandom in CryptoAPI . Section 87.4 Generating Random Numbers with a Speci\ufb01ed Seed Creates a Random instance with a seed of 12345. Random random new Random12345L Gets a ThreadLocalRandom instance ThreadLocalRandom tlr ThreadLocalRandom. current Set the instances seed. tlr.setSeed12345L Using the same seed to generate random numbers will return the same numbers every time, so setting a di\ufb00erent seed for every Random instance is a good idea if you dont want to end up with duplicate numbers. GoalKicker.com Java Notes for Professionals 514A good method to get a Long that is di\ufb00erent for every call is System.currentTimeMillis Random random new RandomSystem.currentTimeMillis ThreadLocalRandom. current.setSeedSystem.currentTimeMillis Section 87.5 Select random numbers without duplicates returns a array of random numbers with no duplicates param range the range of possible numbers for ex. if 100 then it can be anywhere from 1-100 param length the length of the array of random numbers return array of random numbers with no duplicates. public static int getRandomNumbersWithNoDuplicates int range, int length if lengthrange", "this is where all the random numbers int randomNumbers new intlength loop through all the random numbers to set them for int q 0 q randomNumbers. length q get the remaining possible numbers int remainingNumbers range-q get a new random number from the remainingNumbers int newRandSpot int Math.randomremainingNumbers newRandSpot loop through all the possible numbers for int t 1 t range1 t check to see if this number has already been taken boolean taken false for int number randomNumbers if tnumber taken true break if it hasnt been taken then remove one from the spots if !taken newRandSpot -- if we have gone though all the spots then set the value if newRandSpot 0 randomNumbers q t return randomNumbers else invalid cant have a length larger then the range of possible numbers return null The method works by looping though an array that has the size of the requested length and \ufb01nds the remaining GoalKicker.com Java Notes for Professionals 515length of possible numbers. It sets a random number of those possible numbers newRandSpot and \ufb01nds that number within the non taken number left. It does this by looping through the range and checking to see if that number has", "already been taken. For example if the range is 5 and the length is 3 and we have already chosen the number 2. Then we have 4 remaining numbers so we get a random number between 1 and 4 and we loop through the range5 skipping over any numbers that we have already used2. Now lets say the next number chosen between 1 4 is 3. On the \ufb01rst loop we get 1 which has not yet been taken so we can remove 1 from 3 making it 2. Now on the second loop we get 2 which has been taken so we do nothing. We follow this pattern until we get to 4 where once we remove 1 it becomes 0 so we set the new randomNumber to 4. Section 87.6 Generating Random number using apache- common lang3 We can use org.apache.commons.lang3.RandomUtils to generate random numbers using a single line. int x RandomUtils. nextInt1, 1000 The method nextIntint startInclusive, int endExclusive takes a range. Apart from int, we can generate random long , double , float and bytes using this class. RandomUtils class contains the following methods- static byte nextBytes int count Creates an array of random bytes.", "static double nextDouble Returns a random double within 0 - Double.MAXVALUE static double nextDouble double startInclusive, double endInclusive Returns a random double within the specified range. static float nextFloat Returns a random float within 0 - Float.MAXVALUE static float nextFloat float startInclusive, float endInclusive Returns a random float within the specified range. static int nextInt Returns a random int within 0 - Integer.MAXVALUE static int nextInt int startInclusive, int endExclusive Returns a random integer within the specified range. static long nextLong Returns a random long within 0 - Long.MAXVALUE static long nextLong long startInclusive, long endExclusive Returns a random long within the specified range. GoalKicker.com Java Notes for Professionals 516Chapter 88 Singletons A singleton is a class that only ever has one single instance. For more information on the Singleton design pattern , please refer to the Singleton topic in the Design Patterns tag. Section 88.1 Enum Singleton Version Java SE 5 public enum Singleton INSTANCE public void execute String arg Perform operation here Enums have private constructors, are \ufb01nal and provide proper serialization machinery. They are also very concise and lazily initialized in a thread safe manner. The JVM provides a guarantee that enum values will not be", "instantiated more than once each, which gives the enum singleton pattern a very strong defense against re\ufb02ection attacks. What the enum pattern doesnt protect against is other developers physically adding more elements to the source code. Consequently, if you choose this implementation style for your singletons it is imperative that you very clearly document that no new values should be added to those enums. This is the recommended way of implementing the singleton pattern, as explained by Joshua Bloch in E\ufb00ective Java. Section 88.2 Singleton without use of Enum eager initialization public class Singleton private static final Singleton INSTANCE new Singleton private Singleton public static Singleton getInstance return INSTANCE It can be argued that this example is e\ufb00ectively lazy initialization. Section 12.4.1 of the Java Language Speci\ufb01cation states A class or interface type T will be initialized immediately before the \ufb01rst occurrence of any one of the following T is a class and an instance of T is created T is a class and a static method declared by T is invoked A static \ufb01eld declared by T is assigned A static \ufb01eld declared by T is used and the \ufb01eld is not a constant variable T is a", "top level class, and an assert statement lexically nested within T is executed. GoalKicker.com Java Notes for Professionals 517Therefore, as long as there are no other static \ufb01elds or static methods in the class, the Singleton instance will not be initialized until the method getInstance is invoked the \ufb01rst time. Section 88.3 Thread-safe lazy initialization using holder class Bill Pugh Singleton implementation public class Singleton private static class InstanceHolder static final Singleton INSTANCE new Singleton public static Singleton getInstance return InstanceHolder. INSTANCE private Singleton This initializes the INSTANCE variable on the \ufb01rst call to Singleton. getInstance , taking advantage of the languages thread safety guarantees for static initialization without requiring additional synchronization. This implementation is also known as Bill Pugh singleton pattern. Wiki Section 88.4 Thread safe Singleton with double checked locking This type of Singleton is thread safe, and prevents unnecessary locking after the Singleton instance has been created. Version Java SE 5 public class MySingleton instance of class private static volatile MySingleton instance null Private constructor private MySingleton Some code for constructing object public static MySingleton getInstance MySingleton result instance If the instance already exists, no locking is necessary ifresult null The singleton instance doesnt exist, lock", "and check again synchronized MySingleton. class result instance ifresult null instance result new MySingleton return result It must be emphasized -- in versions prior to Java SE 5, the implementation above is incorrect and should be GoalKicker.com Java Notes for Professionals 518avoided. It is not possible to implement double-checked locking correctly in Java prior to Java 5. Section 88.5 Extending singleton singleton inheritance In this example, base class Singleton provides getMessage method that returns Hello world! message. Its subclasses UppercaseSingleton and LowercaseSingleton override getMessage method to provide appropriate representation of the message. Yeah, well need reflection to pull this off. import java.lang.reflect. Enumeration that represents possible classes of singleton instance. If unknown, well go with base class - Singleton. enum SingletonKind UNKNOWN, LOWERCASE, UPPERCASE Base class class Singleton Extended classes has to be private inner classes, to prevent extending them in uncontrolled manner. private class UppercaseSingleton extends Singleton private UppercaseSingleton super Override public String getMessage return super.getMessage .toUpperCase Another extended class. private class LowercaseSingleton extends Singleton private LowercaseSingleton super Override public String getMessage return super.getMessage .toLowerCase Applying Singleton pattern private static SingletonKind kind SingletonKind. UNKNOWN private static Singleton instance By using this method prior to getInstance method, you effectively", "change the GoalKicker.com Java Notes for Professionals 519 type of singleton instance to be created. public static void setKind SingletonKind kind Singleton. kind kind If needed, getInstance creates instance appropriate class, based on value of singletonKind field. public static Singleton getInstance throws NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException ifinstance null synchronized Singleton. class ifinstance null Singleton singleton new Singleton switch kind case UNKNOWN instance singleton break case LOWERCASE I cant use simple instance new LowercaseSingleton because java compiler wont allow me to use constructor of inner class in static context, so I use reflection API instead. To be able to access inner class by reflection API, I have to create instance of outer class first. Therefore, in this implementation, Singleton cannot be abstract class. Get the constructor of inner class. Constructor LowercaseSingleton lcConstructor LowercaseSingleton. class.getDeclaredConstructor Singleton. class The constructor is private, so I have to make it accessible. lcConstructor. setAccessible true Use the constructor to create instance. instance lcConstructor. newInstance singleton break case UPPERCASE Same goes here, just with different type Constructor UppercaseSingleton ucConstructor UppercaseSingleton. class.getDeclaredConstructor Singleton. class GoalKicker.com Java Notes for Professionals 520 ucConstructor. setAccessible true instance ucConstructor. newInstance singleton return instance Singletons state that is to", "be used by subclasses protected String message Private constructor prevents external instantiation. private Singleton message Hello world! Singletons API. Implementation can be overwritten by subclasses. public String getMessage return message Just a small test program public class ExtendingSingletonExample public static void mainString args just uncomment one of following lines to change singleton class Singleton.setKindSingletonKind.UPPERCASE Singleton.setKindSingletonKind.LOWERCASE Singleton singleton null try singleton Singleton. getInstance catch NoSuchMethodException e e. printStackTrace catch IllegalAccessException e e. printStackTrace catch InvocationTargetException e e. printStackTrace catch InstantiationException e e. printStackTrace System.out.printlnsingleton. getMessage GoalKicker.com Java Notes for Professionals 521Chapter 89 Autoboxing Autoboxing is the automatic conversion that Java compiler makes between primitive types and their corresponding object wrapper classes. Example, converting int - Integer, double - Double... If the conversion goes the other way, this is called unboxing. Typically, this is used in Collections that cannot hold other than Objects, where boxing primitive types is needed before setting them in the collection. Section 89.1 Using int and Integer interchangeably As you use generic types with utility classes, you may often \ufb01nd that number types arent very helpful when speci\ufb01ed as the object types, as they arent equal to their primitive counterparts. ListInteger ints new ArrayList Integer Version Java", "SE 7 ListInteger ints new ArrayList Fortunately, expressions that evaluate to int can be used in place of an Integer when it is needed. for int i 0 i 10 i ints. addi The ints.addi statement is equivalent to ints.addInteger.valueOfi And retains properties from IntegervalueOf such as having the same Integer objects cached by the JVM when it is within the number caching range. This also applies to byte and Byte short and Short float and Float double and Double long and Long char and Character boolean and Boolean Care must be taken, however, in ambiguous situations. Consider the following code ListInteger ints new ArrayList Integer ints.add1 ints.add2 ints.add3 ints.remove1 ints is now 1, 3 The java.util.List interface contains both a removeint index List interface method and a removeObject o method inherited from java.util.Collection . In this case no boxing takes place and removeint index is called. One more example of strange Java code behavior caused by autoboxing Integers with values in range from -128 to 127 GoalKicker.com Java Notes for Professionals 522Integer a 127 Integer b 127 Integer c 128 Integer d 128 System.out.printlna b true System.out.printlnc d true System.out.printlnc d true System.out.printlnc d false This happens because", "operator implicitly calls intValue which returns int while compares references , not the int values. By default, Java caches values in range -128, 127, so the operator works because the Integers in this range reference to the same objects if their values are same. Maximal value of the cacheable range can be de\ufb01ned with - XXAutoBoxCacheMax JVM option. So, if you run the program with -XXAutoBoxCacheMax 1000 , the following code will print true Integer a 1000 Integer b 1000 System.out.printlna b true Section 89.2 Auto-unboxing may lead to NullPointerException This code compiles Integer arg null int x arg But it will crash at runtime with a java.lang.NullPointerException on the second line. The problem is that a primitive int cannot have a null value. This is a minimalistic example, but in practice it often manifests in more sophisticated forms. The NullPointerException is not very intuitive and is often little help in locating such bugs. Rely on autoboxing and auto-unboxing with care, make sure that unboxed values will not have null values at runtime. Section 89.3 Using Boolean in if statement Due to auto unboxing, one can use a Boolean in an if statement Boolean a Boolean.TRUE if a a", "gets converted to boolean System.out.printlnIt works! That works for while , do while and the condition in the for statements as well. Note that, if the Boolean is null , a NullPointerException will be thrown in the conversion. Section 89.4 Dierent Cases When Integer and int can be used interchangeably Case 1 While using in the place of method arguments. GoalKicker.com Java Notes for Professionals 523If a method requires an object of wrapper class as argument.Then interchangeably the argument can be passed a variable of the respective primitive type and vice versa. Example int i Integer j void exmethod Integer iIs a valid statement void exmethod1 int jIs a valid statement Case 2 While passing return values When a method returns a primitive type variable then an object of corresponding wrapper class can be passed as the return value interchangeably and vice versa. Example int i Integer j int exmethod ... return jIs a valid statement Integer exmethod1 ... return iIs a valid statement Case 3 While performing operations. Whenever performing operations on numbers the primitive type variable and object of respective wrapper class can be used interchangeably. int i5 Integer jnew Integer7 int kijIs a valid statement Integer", "mijIs also a valid statement Pitfall Remember to initialize or assign a value to an object of the wrapper class. While using wrapper class object and primitive variable interchangeably never forget or miss to initialize or assign a value to the wrapper class object else it may lead to null pointer exception at runtime. Example public class Test Integer i int j public void met jiNull pointer exception SOPj SOPi public static void mainString args Test tnew Test t.goNull pointer exception In the above example, the value of the object is unassigned and uninitialized and thus at runtime the program will GoalKicker.com Java Notes for Professionals 524run into null pointer exception.So as clear from the above example the value of object should never be left uninitialized and unassigned. Section 89.5 Memory and Computational Overhead of Autoboxing Autoboxing can come at a substantial memory overhead. For example MapInteger, Integer square new HashMap Integer, Integer forint i 256 i 1024 i square. puti, i i Autoboxing of large integers will typically consume substantial amount of memory about 60kb for 6k of actual data. Furthermore, boxed integers usually require additional round-trips in the memory, and thus make CPU caches less e\ufb00ective. In", "above example, the memory accessed is spread out to \ufb01ve di\ufb00erent locations that may be in entirely di\ufb00erent regions of the memory 1. the HashMap object, 2. the maps Entry table object, 3. the Entry object, 4. the entrys key object boxing the primitive key, 5. the entrys value object boxing the primitive value. class Example int primitive Stored directly in the class Example Integer boxed Reference to another memory location Reading boxed requires two memory accesses, accessing primitive only one. When getting data from this map, the seemingly innocent code int sumOfSquares 0 forint i 256 i 1024 i sumOfSquares square. geti is equivalent to int sumOfSquares 0 forint i 256 i 1024 i sumOfSquares square. getInteger.valueOfi.intValue Typically, the above code causes the creation and garbage collection of an Integer object for every MapgetInteger operation. See Note below for more details. To reduce this overhead, several libraries o\ufb00er optimized collections for primitive types that do not require boxing. In addition to avoiding the boxing overhead, these collection will require about 4x less memory per entry. While Java Hotspot may be able to optimize the autoboxing by working with objects on the stack instead of the heap, it is", "not possible to optimize the memory overhead and resulting memory indirection. Java 8 streams also have optimized interfaces for primitive data types, such as IntStream that do not require boxing. Note a typical Java runtime maintains a simple cache of Integer and other primitive wrapper object that is used by the valueOf factory methods, and by autoboxing. For Integer , the default range of this cache is -128 to 127. Some JVMs provide a JVM command-line option for changing the cache size range. GoalKicker.com Java Notes for Professionals 525Chapter 90 2D Graphics in Java Graphics are visual images or designs on some surface, such as a wall, canvas, screen, paper, or stone to inform, illustrate, or entertain. It includes pictorial representation of data, as in computer-aided design and manufacture, in typesetting and the graphic arts, and in educational and recreational software. Images that are generated by a computer are called computer graphics. The Java 2D API is powerful and complex. There are multiple ways to do 2D graphics in Java. Section 90.1 Example 1 Draw and Fill a Rectangle Using Java This is an Example which print rectangle and \ufb01ll color in the rectangle. httpsi.stack.imgur.comdlC5v.jpg Most methods of the", "Graphics class can be divided into two basic groups Draw and \ufb01ll methods, enabling you to render basic shapes, text, and images1. Attributes setting methods, which a\ufb00ect how that drawing and \ufb01lling appears2. Code Example Let us start this with a little example of drawing a rectangle and \ufb01lling color in it. There we declare two classes, one class is MyPanel and other Class is Test. In class MyPanel we use drawRect \ufb01llRect mathods to draw rectangle and \ufb01ll Color in it. We set the color by setColorColor.blue method. In Second Class we Test our graphic which is Test Class we make a Frame and put MyPanel with pnew MyPanel object in it.By running Test Class we see a Rectangle and a Blue Color Filled Rectangle. First Class MyPanel import javax.swing. import java.awt. MyPanel extends JPanel, which will eventually be placed in a JFrame public class MyPanel extends JPanel custom painting is performed by the paintComponent method Override public void paintComponent Graphics g GoalKicker.com Java Notes for Professionals 526 clear the previous painting super.paintComponent g cast Graphics to Graphics2D Graphics2D g2 Graphics2D g g2. setColor Color.red sets Graphics2D color draw the rectangle g2. drawRect 0,0,100,100 drawRectx-position, y-position, width, height", "g2. setColor Color.blue g2. fillRect 200,0,100,100 fill new rectangle with color blue Second Class Test import javax.swing. import java.awt. public class Test the Class by which we display our rectangle JFrame f MyPanel p public Test f new JFrame get the content area of Panel. Container c f.getContentPane set the LayoutManager c. setLayout new BorderLayout p new MyPanel add MyPanel object into container c. addp set the size of the JFrame f. setSize400,400 make the JFrame visible f. setVisible true sets close behavior EXITONCLOSE invokes System.exit0 on closing the JFrame f. setDefaultCloseOperation JFrame.EXITONCLOSE public static void mainString args Test t new Test For More Explanation about Border Layout httpsdocs.oracle.comjavasetutorialuiswinglayoutborder.html paintComponent It is a main method for painting By default, it \ufb01rst paints the background After that, it performs custom painting drawing circle, rectangles etc. Graphic2D refers Graphic2D Class Note The Java 2D API enables you to easily perform the following tasks Draw lines, rectangles and any other geometric shape. Fill those shapes with solid colors or gradients and textures. Draw text with options for \ufb01ne control over the font and rendering process. Draw images, optionally applying \ufb01ltering operations. Apply operations such as compositing and transforming during any of the", "above rendering operations. GoalKicker.com Java Notes for Professionals 527Section 90.2 Example 2 Drawing and Filling Oval import javax.swing. import java.awt. public class MyPanel extends JPanel Override public void paintComponent Graphics g clear the previous painting super.paintComponent g Graphics2D g2 Graphics2D g g2. setColor Color.blue g2. drawOval 0, 0, 20,20 g2. fillOval 50,50,20,20 g2.drawOvalint x,int y,int height, int width This method will draw an oval at speci\ufb01ed x and y position with given height and width. g2.\ufb01llOvalint x,int y,int height, int width This method will \ufb01ll an oval at speci\ufb01ed x and y position with given height and width. GoalKicker.com Java Notes for Professionals 528Chapter 91 JAXB Parameter Details \ufb01leObjOfXML File object of an XML \ufb01le className Name of a class with .class extension JAXB or Java Architecture for XML Binding JAXB is a software framework that allows Java developers to map Java classes to XML representations. This Page will introduce readers to JAXB using detailed examples about its functions provided mainly for marshaling and un-marshaling Java Objects into xml format and vice-versa. Section 91.1 Reading an XML \ufb01le unmarshalling To read an XML \ufb01le named UserDetails. xml with the below content ?xml version1.0 encoding UTF-8 standalone yes? user nameJon", "Skeet name userID8884321userID user We need a POJO class named User.java as below import javax.xml.bind.annotation.XmlRootElement XmlRootElement public class User private long userID private String name getters and setters Here we have created the variables and class name according to the XML nodes. To map them, we use the annotation XmlRootElement on the class. public class XMLReader public static void mainString args try User user JAXB.unmarshal new FileUserDetails.xml , User.class System.out.printlnuser.getName prints Jon Skeet System.out.printlnuser.getUserID prints 8884321 catch Exception e System.err.printlnException occurred while reading the XML! Here unmarshal method is used to parse the XML \ufb01le. It takes the XML \ufb01le name and the class type as two arguments. Then we can use the getter methods of the object to print the data. Section 91.2 Writing an XML \ufb01le marshalling an object import javax.xml.bind.annotation.XmlRootElement GoalKicker.com Java Notes for Professionals 529XmlRootElement public class User private long userID private String name getters and setters By using the annotation XMLRootElement , we can mark a class as a root element of an XML \ufb01le. import java.io.File import javax.xml.bind.JAXB public class XMLCreator public static void mainString args User user new User user. setNameJon Skeet user. setUserID 8884321 try JAXB. marshaluser, new FileUserDetails.xml catch Exception", "e System.err.printlnException occurred while writing in XML! finally System.out.printlnXML created marshal is used to write the objects content into an XML \ufb01le. Here user object and a new File object are passed as arguments to the marshal. On successful execution, this creates an XML \ufb01le named UserDetails. xml in the class-path with the below content. ?xml version1.0 encoding UTF-8 standalone yes? user nameJon Skeet name userID8884321userID user Section 91.3 Manual \ufb01eldproperty XML mapping con\ufb01guration Annotations XmlElement , XmlAttribute or XmlTransient and other in package javax.xml.bind.annotation allow the programmer to specify which and how marked \ufb01elds or properties should be serialized. XmlAccessorType XmlAccessType. NONE we want no automatic fieldproperty marshalling public class ManualXmlElementsExample XmlElement private String fieldfield value XmlAttribute private String attribute attr value XmlAttribute namedifferentAttribute private String oneAttribute other attr value GoalKicker.com Java Notes for Professionals 530 XmlElement namedifferent name private String oneName different name value XmlTransient private String transientField will not get serialized ever XmlElement public String getModifiedTransientValue return transientField. replace ever, , unless in a getter public void setModifiedTransientValue String val empty on purpose public static void mainString args try JAXB. marshalnew ManualXmlElementsExample , System.out catch Exception e System.err.printlnException occurred while writing in XML! Section 91.4 Binding", "an XML namespace to a serializable Java class This is an example of a package-info.java \ufb01le that binds an XML namespace to a serializable Java class. This should be placed in the same package as the Java classes that should be serialized using the namespace. A package containing serializable classes. XmlSchema xmlns XmlNs prefix MySerializableClass. NAMESPACEPREFIX , namespaceURI MySerializableClass. NAMESPACE , namespace MySerializableClass. NAMESPACE , elementFormDefault XmlNsForm. QUALIFIED package com.test.jaxb import javax.xml.bind.annotation.XmlNs import javax.xml.bind.annotation.XmlNsForm import javax.xml.bind.annotation.XmlSchema Section 91.5 Using XmlAdapter to generate desired xml format When desired XML format di\ufb00ers from Java object model, an XmlAdapter implementation can be used to transform model object into xml-format object and vice versa. This example demonstrates how to put a \ufb01elds value into an attribute of an element with \ufb01elds name. public class XmlAdapterExample GoalKicker.com Java Notes for Professionals 531 XmlAccessorType XmlAccessType. FIELD public static class NodeValueElement XmlAttribute nameattrValue String value public NodeValueElement public NodeValueElement String value super this.value value public String getValue return value public void setValue String value this.value value public static class ValueAsAttrXmlAdapter extends XmlAdapter NodeValueElement, String Override public NodeValueElement marshal String v throws Exception return new NodeValueElement v Override public String unmarshal NodeValueElement v throws Exception if vnull", "return return v.getValue XmlRootElement nameDataObject XmlAccessorType XmlAccessType. FIELD public static class DataObject String elementWithValue XmlJavaTypeAdapter valueValueAsAttrXmlAdapter. class String elementWithAttribute public static void mainString args DataObject data new DataObject data. elementWithValue value1 data. elementWithAttribute value2 ByteArrayOutputStream baos new ByteArrayOutputStream JAXB. marshaldata, baos String xmlString new Stringbaos.toByteArray , StandardCharsets. UTF8 System.out.printlnxmlString GoalKicker.com Java Notes for Professionals 532Section 91.6 Using XmlAdapter to trim string package com.example.xml.adapters import javax.xml.bind.annotation.adapters.XmlAdapter public class StringTrimAdapter extends XmlAdapter String, String Override public String unmarshal String v throws Exception if v null return null return v.trim Override public String marshal String v throws Exception if v null return null return v.trim And in package-info.java add following declaration. XmlJavaTypeAdapter value com.example.xml.adapters .StringTrimAdapter .class, type String.class package com.example.xml.jaxb.bindings Packge where you intend to apply trimming filter import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter Section 91.7 Automatic \ufb01eldproperty XML mapping con\ufb01guration XmlAccessorType Annotation XmlAccessorType determines whether \ufb01eldsproperties will be automatically serialized to XML. Note, that \ufb01eld and method annotations XmlElement , XmlAttribute or XmlTransient take precedence over the default settings. public class XmlAccessTypeExample XmlAccessorType XmlAccessType. FIELD static class AccessorExampleField public String fieldvalue1 public String getGetter return getter public void setGetter String value XmlAccessorType XmlAccessType. NONE static class AccessorExampleNone public String fieldvalue1 public String getGetter return getter", "public void setGetter String value GoalKicker.com Java Notes for Professionals 533XmlAccessorType XmlAccessType. PROPERTY static class AccessorExampleProperty public String fieldvalue1 public String getGetter return getter public void setGetter String value XmlAccessorType XmlAccessType. PUBLICMEMBER static class AccessorExamplePublic public String fieldvalue1 public String getGetter return getter public void setGetter String value public static void mainString args try System.out.printlnnField JAXB. marshalnew AccessorExampleField , System.out System.out.printlnnNone JAXB. marshalnew AccessorExampleNone , System.out System.out.printlnnProperty JAXB. marshalnew AccessorExampleProperty , System.out System.out.printlnnPublic JAXB. marshalnew AccessorExamplePublic , System.out catch Exception e System.err.printlnException occurred while writing in XML! outer class end Output Field ?xml version1.0 encodingUTF-8 standaloneyes? value1 None ?xml version1.0 encodingUTF-8 standaloneyes? Property ?xml version1.0 encodingUTF-8 standaloneyes? getter Public ?xml version1.0 encodingUTF-8 standaloneyes? value1 GoalKicker.com Java Notes for Professionals 534getter Section 91.8 Specifying a XmlAdapter instance to reuse existing data Sometimes speci\ufb01c instances of data should be used. Recreation is not desired and referencing static data would have a code smell. It is possible to specify a XmlAdapter instance the Unmarshaller should use, which allows the user to use XmlAdapter s with no zero-arg constructor andor pass data to the adapter. Example User class The following class contains a name and a users image. import java.awt.image.BufferedImage import javax.xml.bind.annotation.XmlAttribute import", "javax.xml.bind.annotation.XmlRootElement import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter XmlRootElement public class User private String name private BufferedImage image XmlAttribute public String getName return name public void setName String name this.name name XmlJavaTypeAdapter valueImageCacheAdapter. class XmlAttribute public BufferedImage getImage return image public void setImage BufferedImage image this.image image public UserString name, BufferedImage image this.name name this.image image public User this, null Adapter GoalKicker.com Java Notes for Professionals 535To avoid creating the same image in memory twice as well as downloading the data again, the adapter stores the images in a map. Version Java SE 7 For valid Java 7 code replace the getImage method with public BufferedImage getImage URL url BufferedImage image imageCache. geturl if image null try image ImageIO. readurl catch IOException ex Logger. getLogger ImageCacheAdapter. class.getName.logLevel.SEVERE, null, ex return null imageCache. puturl, image reverseIndex. putimage, url return image import java.awt.image.BufferedImage import java.io.IOException import java.net.URL import java.util.HashMap import java.util.Map import java.util.logging.Level import java.util.logging.Logger import javax.imageio.ImageIO import javax.xml.bind.annotation.adapters.XmlAdapter public class ImageCacheAdapter extends XmlAdapter String, BufferedImage private final MapURL, BufferedImage imageCache new HashMap private final MapBufferedImage , URL reverseIndex new HashMap public BufferedImage getImage URL url using a single lookup using Java 8 methods return imageCache. computeIfAbsent url, s - try BufferedImage img ImageIO. reads reverseIndex.", "putimg, s return img catch IOException ex Logger. getLogger ImageCacheAdapter. class.getName.logLevel.SEVERE, null, ex return null Override public BufferedImage unmarshal String v throws Exception return getImage new URLv Override public String marshal BufferedImage v throws Exception return reverseIndex. getv.toExternalForm GoalKicker.com Java Notes for Professionals 536 Example XMLs The following 2 xmls are for Jon Skeet and his earth 2 counterpart, which both look exactly the same and therefore use the same avatar. ?xml version1.0 encoding UTF-8? user nameJon Skeet imagehttpswww.gravatar.comavatar6d8ebb117e8d83d74ea95fbdd0f87e13?s328ampdidenticonampr PG ?xml version1.0 encoding UTF-8? user nameJon Skeet Earth 2 imagehttpswww.gravatar.comavatar6d8ebb117e8d83d74ea95fbdd0f87e13?s328ampdidenticonampr PG Using the adapter ImageCacheAdapter adapter new ImageCacheAdapter JAXBContext context JAXBContext. newInstance User.class Unmarshaller unmarshaller context. createUnmarshaller specifiy the adapter instance to use for every XmlJavaTypeAdaptervalueImageCacheAdapter.class unmarshaller. setAdapter ImageCacheAdapter. class, adapter User result1 User unmarshaller. unmarshal Main.class.getResource user.xml unmarshal second xml using the same adapter instance Unmarshaller unmarshaller2 context. createUnmarshaller unmarshaller2. setAdapter ImageCacheAdapter. class, adapter User result2 User unmarshaller2. unmarshal Main.class.getResource user2.xml System.out.printlnresult1. getName System.out.printlnresult2. getName yields true, since image is reused System.out.printlnresult1. getImage result2. getImage GoalKicker.com Java Notes for Professionals 537Chapter 92 Class - Java Re\ufb02ection The java.lang.Class class provides many methods that can be used to get metadata, examine and change the run time behavior of a", "class. The java.lang and java.lang.re\ufb02ect packages provide classes for java re\ufb02ection. Where it is used The Re\ufb02ection API is mainly used in IDE Integrated Development Environment e.g. Eclipse, MyEclipse, NetBeans etc. Debugger Test Tools etc. Section 92.1 getClass method of Object class class Simple class Test void printName Object obj Class c obj.getClass System.out.printlnc.getName public static void mainString args Simple s new Simple Test t new Test t. printName s GoalKicker.com Java Notes for Professionals 538Chapter 93 Networking Section 93.1 Basic Client and Server Communication using a Socket Server Start, and wait for incoming connections Open a listening ServerSocket on port 1234. ServerSocket serverSocket new ServerSocket 1234 while true Wait for a client connection. Once a client connected, we get a Socket object that can be used to send and receive messages tofrom the newly connected client Socket clientSocket serverSocket. accept Here well add the code to handle one specific client. Server Handling clients Well handle each client in a separate thread so multiple clients could interact with the server at the same time. This technique works \ufb01ne as long as the number of clients is low 1000 clients, depending on the OS architecture and the expected load of", "each thread. new Thread - Get the sockets InputStream, to read bytes from the socket InputStream in clientSocket. getInputStream wrap the InputStream in a reader so you can read a String instead of bytes BufferedReader reader new BufferedReader new InputStreamReader in, StandardCharsets. UTF8 Read text from the socket and print line by line String line while line reader. readLine ! null System.out.printlnline .start Client Connect to the server and send a message 127.0.0.1 is the address of the server this is the localhost address i.e. the address of our own machine 1234 is the port that the server will be listening on Socket socket new Socket127.0.0.1 , 1234 Write a string into the socket, and flush the buffer OutputStream outStream socket. getOutputStream PrintWriter writer new PrintWriter new OutputStreamWriter outStream, StandardCharsets. UTF8 writer.printlnHello world! writer.flush Closing Sockets and Handling Exceptions The above examples left out some things to make them easier to read. Just like \ufb01les and other external resources, its important we tell the OS when were done with them. When1. GoalKicker.com Java Notes for Professionals 539were done with a socket, call socket.close to properly close it. Sockets handle IO InputOutput operations that depend on a variety of external", "factors. For example what2. if the other side suddenly disconnects? What if there are network error? These things are beyond our control. This is why many socket operations might throw exceptions, especially IOException . A more complete code for the client would therefore be something like this try-with-resources will close the socket once we leave its scope try Socket socket new Socket127.0.0.1 , 1234 OutputStream outStream socket. getOutputStream PrintWriter writer new PrintWriter new OutputStreamWriter outStream, StandardCharsets. UTF8 writer. printlnHello world! writer. flush catch IOException e Handle the error Basic Server and Client - complete examples Server import java.io.BufferedReader import java.io.IOException import java.io.InputStream import java.io.InputStreamReader import java.net.ServerSocket import java.net.Socket import java.nio.charset.StandardCharsets public class Server public static void mainString args try ServerSocket serverSocket new ServerSocket 1234 while true Wait for a client connection. Socket clientSocket serverSocket. accept Create and start a thread to handle the new client new Thread - try Get the sockets InputStream, to read bytes from the socket InputStream in clientSocket. getInputStream wrap the InputStream in a reader so you can read a String instead of bytes BufferedReader reader new BufferedReader new InputStreamReader in, StandardCharsets. UTF8 Read from the socket and print line by line String line while", "line reader. readLine ! null System.out.printlnline catch IOException e e. printStackTrace finally This finally block ensures the socket is closed. A try-with-resources block cannot be used because the socket is passed into a thread, so it isnt GoalKicker.com Java Notes for Professionals 540 created and closed in the same block try clientSocket. close catch IOException e e. printStackTrace .start catch IOException e e. printStackTrace Client import java.io.IOException import java.io.OutputStream import java.io.OutputStreamWriter import java.io.PrintWriter import java.net.Socket import java.nio.charset.StandardCharsets public class Client public static void mainString args try Socket socket new Socket127.0.0.1 , 1234 Well reach this code once weve connected to the server Write a string into the socket, and flush the buffer OutputStream outStream socket. getOutputStream PrintWriter writer new PrintWriter new OutputStreamWriter outStream, StandardCharsets. UTF8 writer. printlnHello world! writer. flush catch IOException e Exception should be handled. e. printStackTrace Section 93.2 Basic ClientServer Communication using UDP Datagram Client.java import java.io. import java.net. public class Client public static void mainString args throws IOException DatagramSocket clientSocket new DatagramSocket InetAddress address InetAddress .getByName args0 String ex Hello, World! byte buf ex.getBytes GoalKicker.com Java Notes for Professionals 541 DatagramPacket packet new DatagramPacket buf,buf. length, address, 4160 clientSocket. sendpacket In this case, we pass", "in the address of the server, via an argument args0. The port we are using is 4160. Server.java import java.io. import java.net. public class Server public static void mainString args throws IOException DatagramSocket serverSocket new DatagramSocket 4160 byte rbuf new byte256 DatagramPacket packet new DatagramPacket rbuf, rbuf. length serverSocket. receivepacket String response new Stringpacket.getData System.out.printlnResponse response On the server-side, declare a DatagramSocket on the same port which we sent our message to 4160 and wait for a response. Section 93.3 Loading TrustStore and KeyStore from InputStream public class TrustLoader public static void mainString args try Gets the inputstream of a a trust store file under sslrpgrenadesClient.jks This path refers to the ssl folder in the jar file, in a jar file in the same directory as this jar file, or a different directory in the same directory as the jar file InputStream stream TrustLoader. class.getResourceAsStream sslrpgrenadesClient.jks Both trustStores and keyStores are represented by the KeyStore object KeyStore trustStore KeyStore .getInstance KeyStore .getDefaultType The password for the trustStore char trustStorePassword password .toCharArray This loads the trust store into the object trustStore. loadstream, trustStorePassword This is defining the SSLContext so the trust store will be used Getting default SSLContext to edit.", "SSLContext context SSLContext. getInstance SSL TrustMangers hold trust stores, more than one can be added TrustManagerFactory factory TrustManagerFactory. getInstance TrustManagerFactory. getDefaultAlgorithm Adds the truststore to the factory factory. inittrustStore This is passed to the SSLContext init method TrustManager managers factory. getTrustManagers context. initnull, managers, null Sets our new SSLContext to be used. SSLContext. setDefault context GoalKicker.com Java Notes for Professionals 542 catch KeyStoreException IOException NoSuchAlgorithmException CertificateException KeyManagementException ex Handle error ex. printStackTrace Intiating a KeyStore works the same, except replace any word Trust in a object name with Key. Additionally, the KeyManager array must be passed to the the \ufb01rst argument of SSLContext. init . That is SSLContext. initkeyMangers, trustMangers, null Section 93.4 Socket example - reading a web page using a simple socket import java.io. import java.net.Socket public class Main public static void mainString args throws IOException We dont handle Exceptions in this example Open a socket to stackoverflow.com, port 80 Socket socket new Socketstackoverflow.com ,80 Prepare input, output stream before sending request OutputStream outStream socket. getOutputStream InputStream inStream socket. getInputStream BufferedReader reader new BufferedReader new InputStreamReader inStream PrintWriter writer new PrintWriter new BufferedOutputStream outStream Send a basic HTTP header writer. printGET HTTP1.1 nHoststackoverflow.com nn writer. flush Read", "the response System.out.printlnreadFully reader Close the socket socket. close private static String readFully Reader in StringBuilder sb new StringBuilder int BUFFERSIZE 1024 char buffer new charBUFFERSIZE or some other size, int charsRead 0 while charsRead rd.readbuffer, 0, BUFFERSIZE ! -1 sb. appendbuffer, 0, charsRead You should get a response that starts with HTTP1.1 200 OK, which indicates a normal HTTP response, followed by the rest of the HTTP header, followed by the raw web page in HTML form. Note the readFully method is important to prevent a premature EOF exception. The last line of the web page may be missing a return, to signal the end of line, then readLine will complain, so one must read it by hand or GoalKicker.com Java Notes for Professionals 543use utility methods from Apache commons-io IOUtils This example is meant as a simple demonstration of connecting to an existing resource using a socket, its not a practical way of accessing web pages. If you need to access a web page using Java, its best to use an existing HTTP client library such as Apaches HTTP Client or Googles HTTP Client Section 93.5 Temporarily disable SSL veri\ufb01cation for testing purposes Sometimes in a development", "or testing environment, the SSL certi\ufb01cate chain might not have been fully established yet. To continue developing and testing, you can turn o\ufb00 SSL veri\ufb01cation programmatically by installing an all-trusting trust manager try Create a trust manager that does not validate certificate chains TrustManager trustAllCerts new TrustManager new X509TrustManager public X509Certificate getAcceptedIssuers return null public void checkClientTrusted X509Certificate certs, String authType public void checkServerTrusted X509Certificate certs, String authType Install the all-trusting trust manager SSLContext sc SSLContext. getInstance SSL sc.initnull, trustAllCerts, new java.security .SecureRandom HttpsURLConnection. setDefaultSSLSocketFactory sc.getSocketFactory Create all-trusting host name verifier HostnameVerifier allHostsValid new HostnameVerifier public boolean verifyString hostname, SSLSession session return true Install the all-trusting host verifier HttpsURLConnection. setDefaultHostnameVerifier allHostsValid catch NoSuchAlgorithmException KeyManagementException e e.printStackTrace Section 93.6 Downloading a \ufb01le using Channel If the \ufb01le already exists, it will be overwritten! String fileName file.zip name of the file String urlToGetFrom httpwww.mywebsite.com URL to get it from String pathToSaveTo CUsersuser where to put it If the file already exists, it will be overwritten! Opening OutputStream to the destination file GoalKicker.com Java Notes for Professionals 544try ReadableByteChannel rbc Channels. newChannel new URLurlToGetFrom fileName .openStream try FileChannel channel new FileOutputStream pathToSaveTo fileName .getChannel channel. transferFrom rbc, 0, Long.MAXVALUE catch FileNotFoundException e", "Output directory not found catch IOException e File IO error catch MalformedURLException e URL is malformed catch IOException e IO error connecting to website Notes Dont leave the catch blocks empty! In case of error, check if the remote \ufb01le exists This is a blocking operation, can take long time with large \ufb01les Section 93.7 Multicasting Multicasting is a type of Datagram Socket. Unlike regular Datagrams, Multicasting doesnt handle each client individually instead it sends it out to one IP Address and all subscribed clients will get the message. Example code for a server side public class Server private DatagramSocket serverSocket private String ip private int port public ServerString ip, int port throws SocketException , IOException this.ip ip this.port port socket used to send serverSocket new DatagramSocket public void send throws IOException make datagram packet byte message Multicasting... .getBytes GoalKicker.com Java Notes for Professionals 545 DatagramPacket packet new DatagramPacket message, message. length, InetAddress .getByName ip, port send packet serverSocket. sendpacket public void close serverSocket. close Example code for a client side public class Client private MulticastSocket socket public ClientString ip, int port throws IOException important that this is a multicast socket socket new MulticastSocket port join by ip socket.", "joinGroup InetAddress .getByName ip public void printMessage throws IOException make datagram packet to recieve byte message new byte256 DatagramPacket packet new DatagramPacket message, message. length recieve the packet socket. receivepacket System.out.printlnnew Stringpacket.getData public void close socket. close Code for running the Server public static void mainString args try final String ip args0 final int port Integer.parseInt args1 Server server new Serverip, port server. send server. close catch IOException ex ex. printStackTrace Code for running a Client public static void mainString args try final String ip args0 GoalKicker.com Java Notes for Professionals 546 final int port Integer.parseInt args1 Client client new Clientip, port client. printMessage client. close catch IOException ex ex. printStackTrace Run the Client First The Client must subscribe to the IP before it can start receiving any packets. If you start the server and call the send method, and then make a client call printMessage . Nothing will happen because the client connected after the message was sent. GoalKicker.com Java Notes for Professionals 547Chapter 94 NIO - Networking Section 94.1 Using Selector to wait for events example with OPCONNECT NIO appeared in Java 1.4 and introduced the concept of Channels, which are supposed to be faster than regular", "IO. Network-wise, the SelectableChannel is the most interesting as it allows to monitor di\ufb00erent states of the Channel. It works in a similar manner as the C SELECT system call we get woken-up when certain types of events occur connection received OPACCEPT connection realized OPCONNECT data available in read FIFO OPREAD data can be pushed to write FIFO OPWRITE It allows for separation between detecting socket IO something can be readwritten... and performing the IO readwrite.... Especially, all IO detection can be done in a single thread for multiple sockets clients, while performing IO can be handled in a thread pool or anywhere else. That allows for an application to scale easily to the number of connected clients. The following example shows the basics Create a Selector 1. Create a SocketChannel 2. Register the SocketChannel to the Selector 3. Loop with the Selector to detect events 4. Selector sel Selector .open CREATE the Selector SocketChannel sc SocketChannel .open CREATE a SocketChannel sc.configureBlocking FALSE ... non blocking sc.setOption StandardSocketOptions .SOKEEPALIVE , TRUE ... SET SOME options Register the Channel TO the Selector FOR wake-up ON CONNECT event AND USE SOME description AS an attachement sc.register sel, SelectionKey .OPCONNECT , Connection", "to google.com RETURNS a SelectionKey the association BETWEEN the SocketChannel AND the Selector System.out.printlnInitiating connection IF sc.connectNEW InetSocketAddress www.google.com , 80 System .out.printlnConnected Connected right -away nothing ELSE TO do ELSE BOOLEAN exit FALSE while !exit IF sel.select100 0 Did something happen ON SOME registered Channels during the LAST 100ms? continue No, wait SOME more Something happened ... Set SelectionKey KEYS sel.selectedKeys List OF SelectionKeys ON which SOME registered operation was triggered FOR SelectionKey k KEYS System .out.printlnChecking k.attachment IF k.isConnectable CONNECT event System .out.printConnected through select on k.channel - IF sc.finishConnect Finish connection process System .out.printlndone! k .interestOps k.interestOps SelectionKey .OPCONNECT We are already connected remove interest IN CONNECT event GoalKicker.com Java Notes for Professionals 548 exit TRUE ELSE System .out.printlnunfinished... TODO ELSE IF k.isReadable ... KEYS.clear Have TO clear the selected KEYS SET once processed! System.out.printDisconnecting ... sc.shutdownOutput Initiate graceful disconnection TODO empty receive buffer sc.close System.out.printlndone Would give the following output Initiating connection Checking Connection to google.com Connected through select on java.nio.channels.SocketChannelconnection-pending remotewww.google.com216.58.208.22880 - done! Disconnecting ... done GoalKicker.com Java Notes for Professionals 549Chapter 95 HttpURLConnection Section 95.1 Get response body from a URL as a String String getText String url throws IOException HttpURLConnection connection HttpURLConnection", "new URLurl.openConnection add headers to the connection, or check the status if desired.. handle error response code it occurs int responseCode conn.getResponseCode InputStream inputStream if 200 responseCode responseCode 299 inputStream connection. getInputStream else inputStream connection. getErrorStream BufferedReader in new BufferedReader new InputStreamReader inputStream StringBuilder response new StringBuilder String currentLine while currentLine in.readLine ! null response. appendcurrentLine in.close return response. toString This will download text data from the speci\ufb01ed URL, and return it as a String. How this works First, we create a HttpUrlConnection from our URL, with new URLurl.openConnection . We cast the UrlConnection this returns to a HttpUrlConnection , so we have access to things like adding headers such as User Agent, or checking the response code. This example does not do that, but its easy to add. Then, create InputStream basing on the response code for error handling Then, create a BufferedReader which allows us to read text from InputStream we get from the connection. Now, we append the text to a StringBuilder , line by line. Close the InputStream , and return the String we now have. Notes This method will throw an IoException in case of failure such as a network error, or no internet", "connection, and it will also throw an unchecked MalformedUrlException if the given URL is not valid. It can be used for reading from any URL which returns text, such as webpages HTML, REST APIs which return JSON or XML, etc. See also Read URL to String in few lines of Java code . GoalKicker.com Java Notes for Professionals 550Usage Is very simple String text getText httpexample.com Do something with the text from example.com, in this case the HTML. Section 95.2 POST data public static void postString url, byte data, String contentType throws IOException HttpURLConnection connection null OutputStream out null InputStream in null try connection HttpURLConnection new URLurl.openConnection connection. setRequestProperty Content-Type , contentType connection. setDoOutput true out connection. getOutputStream out. writedata out. close in connection. getInputStream BufferedReader reader new BufferedReader new InputStreamReader in String line null while line reader. readLine ! null System.out.printlnline in. close finally if connection ! null connection. disconnect if out ! null out.close if in ! null in.close This will POST data to the speci\ufb01ed URL, then read the response line-by-line. How it works As usual we obtain the HttpURLConnection from a URL. Set the content type using setRequestProperty , by default its application x-www-form-urlencoded setDoOutput", "true tells the connection that we will send data. Then we obtain the OutputStream by calling getOutputStream and write data to it. Dont forget to close it after you are done. At last we read the server response. Section 95.3 Delete resource public static void delete String urlString, String contentType throws IOException HttpURLConnection connection null try URL url new URLurlString connection HttpURLConnection url.openConnection connection. setDoInput true GoalKicker.com Java Notes for Professionals 551 connection. setRequestMethod DELETE connection. setRequestProperty Content-Type , contentType Map String, ListString map connection. getHeaderFields StringBuilder sb new StringBuilder Iterator Map.EntryString, String iterator responseHeader. entrySet .iterator whileiterator. hasNext Map.EntryString, String entry iterator. next sb. appendentry.getKey sb. append.append sb. appendentry.getValue sb. append ifiterator. hasNext sb. append,.append System.out.printlnsb.toString catch Exception e e. printStackTrace finally if connection ! null connection. disconnect This will DELETE the resource in the speci\ufb01ed URL, then print the response header. How it works we obtain the HttpURLConnection from a URL. Set the content type using setRequestProperty , by default its application x-www-form-urlencoded setDoInput true tells the connection that we intend to use the URL connection for input. setRequestMethod DELETE to perform HTTP DELETE At last we print the server response header. Section 95.4 Check if resource", "exists Checks if a resource exists by sending a HEAD-Request. param url The url of a resource which has to be checked. return true if the response code is 200 OK. public static final boolean checkIfResourceExists URL url throws IOException HttpURLConnection conn HttpURLConnection url.openConnection conn. setRequestMethod HEAD int code conn.getResponseCode conn. disconnect return code 200 Explanation If you are just checking if a resource exists, it better to use a HEAD request than a GET. This avoids the overhead of transferring the resource. Note that the method only returns true if the response code is 200. If you anticipate redirect i.e. 3XX responses, then the method may need to be enhanced to honor them. GoalKicker.com Java Notes for Professionals 552Example checkIfResourceExists new URLhttpimages.google.com true checkIfResourceExists new URLhttppictures.google.com false GoalKicker.com Java Notes for Professionals 553Chapter 96 JAX-WS Section 96.1 Basic Authentication The way to do a JAX-WS call with basic authentication is a little unobvious. Here is an example where Service is the service class representation and Port is the service port you want to access. Service s new Service Port port s.getPort BindingProvider prov BindingProvider port prov.getRequestContext .putBindingProvider. USERNAMEPROPERTY , myusername prov.getRequestContext .putBindingProvider. PASSWORDPROPERTY , mypassword port.call GoalKicker.com Java", "Notes for Professionals 554Chapter 97 Nashorn JavaScript engine Nashorn is a JavaScript engine developed in Java by Oracle, and has been released with Java 8. Nashorn allows embedding Javascript in Java applications via JSR-223 and allows to develop standalone Javascript applications, and it provides better runtime performance and better compliance with the ECMA normalized Javascript speci\ufb01cation. Section 97.1 Execute JavaScript \ufb01le Required imports import javax.script.ScriptEngineManager import javax.script.ScriptEngine import javax.script.ScriptException import java.io.FileReader import java.io.FileNotFoundException Obtain an instance of the JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Load and execute a script from the file demo.js try engine. evalnew FileReader demo.js catch FileNotFoundException ex ex.printStackTrace catch ScriptException ex This is the generic Exception subclass for the Scripting API ex.printStackTrace Outcome Script from file! printed on standard output demo.js printScript from file! Section 97.2 Intercept script output Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Setup a custom writer StringWriter stringWriter new StringWriter Modify the engine context so that the custom writer is now the default output writer of the engine engine.getContext .setWriter stringWriter Execute some script try engine. evalprintRedirected text! catch ScriptException ex ex.printStackTrace Outcome Nothing printed on standard output,", "but GoalKicker.com Java Notes for Professionals 555 stringWriter.toString contains Redirected text! Section 97.3 Hello Nashorn Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Execute an hardcoded script try engine. evalprintHello Nashorn! catch ScriptException ex This is the generic Exception subclass for the Scripting API ex.printStackTrace Outcome Hello Nashorn! printed on standard output Section 97.4 Evaluate Arithmetic Strings Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName JavaScript String to be evaluated String str 3245 Value after doing Arithmetic operation with operator precedence will be 16 Printing the value try System.out.printlnengine.evalstr catch ScriptException ex ex.printStackTrace Outcome Value of the string after arithmetic evaluation is printed on standard output. In this case 16.0 will be printed on standard output. Section 97.5 Set global variables Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Define a global variable engine.puttextToPrint , Data defined in Java. Print the global variable try engine. evalprinttextToPrint catch ScriptException ex ex.printStackTrace Outcome Data defined in Java. printed on standard output GoalKicker.com Java Notes for Professionals 556Section 97.6 Set and get global variables Obtain an instance of JavaScript engine ScriptEngineManager manager", "new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn try Set value in the global name space of the engine engine. putname,Nashorn Execute an hardcoded script engine. evalvar valueHello name! Get value String valueStringengine.getvalue System.out.printlnvalue catch ScriptException ex This is the generic Exception subclass for the Scripting API ex.printStackTrace Outcome Hello Nashorn! printed on standard output Section 97.7 Usage of Java objects in JavaScript in Nashorn Its possible to pass Java objects to Nashorn engine to be processed in Java code. At the same time, there are some JavaScript and Nashorn speci\ufb01c constructions, and its not always clear how they work with java objects. Below there is a table which describes behaviour of native Java objects inside JavaScript constructions. Tested constructions Expression in if clause. In JS expression in if clause doesnt have to be boolean unlike Java. Its evaluated as1. false for so called falsy values null, unde\ufb01ned, 0, empty strings etc for each statement Nashorn has a special kind of loop - for each - which can iterate over di\ufb00erent JS and Java2. object. Getting object size. In JS objects have a property length, which returns size of an array or a string.3. Results Type If for each .length", "Java null false No iterations Exception Java empty string false No iterations 0 Java string true Iterates over string characters Length of the string Java IntegerLong value ! 0 No iterations unde\ufb01ned Java ArrayList true Iterates over elements Length of the list Java HashMap true Iterates over values null Java HashSet true Iterates over items unde\ufb01ned Recommendatons Its advisable to use if somestring to check if a string is not null and not empty for each can be safely used to iterate over any collection, and it doesnt raise exceptions if the collection is not iterable, null or unde\ufb01ned Before getting length of an object it must be checked for null or unde\ufb01ned the same is true for any attempt of calling a method or getting a property of Java object GoalKicker.com Java Notes for Professionals 557Section 97.8 Implementing an interface from script import java.io.FileReader import java.io.IOException import javax.script.ScriptEngine import javax.script.ScriptEngineManager import javax.script.ScriptException public class InterfaceImplementationExample public static interface Pet public void eat public static void mainString args throws IOException Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn try evaluate a script pet.js var Pet Java.typeInterfaceImplementationExample.Pet new Pet eat function printeat Pet", "pet Pet engine. evalnew FileReader pet.js pet. eat catch ScriptException ex ex. printStackTrace Outcome eat printed on standard output GoalKicker.com Java Notes for Professionals 558Chapter 98 Java Native Interface Parameter Details JNIEnv Pointer to the JNI environment jobject The object which invoked the non- static native method jclass The class which invoked the static native method Section 98.1 Calling C methods from Java Static and member methods in Java can be marked as native to indicate that their implementation is to be found in a shared library \ufb01le. Upon execution of a native method, the JVM looks for a corresponding function in loaded libraries see Loading native libraries, using a simple name mangling scheme, performs argument conversion and stack setup, then hands over control to native code. Java code comexamplejniJNIJava.java package com.example.jni public class JNIJava static System.loadLibrary libJNICPP Obviously, native methods may not have a body defined in Java public native void printString String name public static native double average int nums public static void mainfinal String args JNIJava jniJava new JNIJava jniJava. printString Invoked C printString from Java double d average new int1, 2, 3, 4, 7 System.out.printlnGot result from C average d C code Header \ufb01les containing", "native function declarations should be generated using the javah tool on target classes. Running the following command at the build directory javah -o comexamplejniJNIJava. hpp com.example.jni.JNIJava ... produces the following header \ufb01le comments stripped for brevity comexamplejniJNIJava.hpp DO NOT EDIT THIS FILE - it is machine generated include jni.h The JNI API declarations ifndef IncludedcomexamplejniJNIJava define IncludedcomexamplejniJNIJava ifdef cplusplus extern C This is absolutely required if using a C compiler endif GoalKicker.com Java Notes for Professionals 559JNIEXPORT void JNICALL JavacomexamplejniJNIJavaprintString JNIEnv , jobject, jstring JNIEXPORT jdouble JNICALL JavacomexamplejniJNIJavaaverage JNIEnv , jclass, jintArray ifdef cplusplus endif endif Here is an example implementation comexamplejniJNIJava.cpp include iostream include comexamplejniJNIJava.hpp using namespace std JNIEXPORT void JNICALL JavacomexamplejniJNIJavaprintString JNIEnv env, jobject jthis, jstring string const char stringInC env-GetStringUTFChars string, NULL if NULL stringInC return cout stringInC endl env-ReleaseStringUTFChars string, stringInC JNIEXPORT jdouble JNICALL JavacomexamplejniJNIJavaaverage JNIEnv env, jclass jthis, jintArray intArray jint intArrayInC env-GetIntArrayElements intArray, NULL if NULL intArrayInC return -1 jsize length env-GetArrayLength intArray int sum 0 for int i 0 i length i sum intArrayInC i env-ReleaseIntArrayElements intArray, intArrayInC, 0 return double sum length Output Running the example class above yields the following output Invoked C printString from Java Got result from C", "average 3.4 Section 98.2 Calling Java methods from C callback Calling a Java method from native code is a two-step process obtain a method pointer with the GetMethodID JNI function, using the method name and descriptor 1. call one of the CallMethod functions listed here . 2. GoalKicker.com Java Notes for Professionals 560Java code com.example.jni.JNIJavaCallback.java package com.example.jni public class JNIJavaCallback static System.loadLibrary libJNICPP public static void mainString args new JNIJavaCallback .callback public native void callback public static void printNum int i System.out.printlnGot int from C i public void printFloat float i System.out.printlnGot float from C i C code comexamplejniJNICppCallback.cpp include iostream include comexamplejniJNIJavaCallback.h using namespace std JNIEXPORT void JNICALL JavacomexamplejniJNIJavaCallbackcallback JNIEnv env, jobject jthis jclass thisClass env-GetObjectClass jthis jmethodID printFloat env-GetMethodID thisClass, printFloat , FV if NULL printFloat return env-CallVoidMethod jthis, printFloat, 5.221 jmethodID staticPrintInt env-GetStaticMethodID thisClass, printNum , IV if NULL staticPrintInt return env-CallVoidMethod jthis, staticPrintInt, 17 Output Got \ufb02oat from C 5.221 Got int from C 17 Getting the descriptor Descriptors or internal type signatures are obtained using the javap program on the compiled .class \ufb01le. Here is the output of javap -p -s com.example.jni.JNIJavaCallback GoalKicker.com Java Notes for Professionals 561Compiled from JNIJavaCallback.java public class com.example.jni.JNIJavaCallback static", "descriptor V public com.example.jni.JNIJavaCallback descriptor V public static void mainjava.lang.String descriptor LjavalangStringV public native void callback descriptor V public static void printNum int descriptor IV ---- Needed public void printFloat float descriptor FV ---- Needed Section 98.3 Loading native libraries The common idiom for loading shared library \ufb01les in Java is the following public class ClassWithNativeMethods static System.loadLibrary Example public native void someNativeMethod String arg ... Calls to System.loadLibrary are almost always static so as to occur during class loading, ensuring that no native method can execute before the shared library has been loaded. However the following is possible public class ClassWithNativeMethods Call this before using any native method public static void prepareNativeMethods System.loadLibrary Example ... This allows to defer shared library loading until necessary, but requires extra care to avoid java.lang.UnsatisfiedLinkError s. Target \ufb01le lookup Shared library \ufb01les are searched for in the paths de\ufb01ned by the java.library.path system property, which can be overridden using the -Djava.library.path JVM argument at runtime java -Djava.library.pathpathtolibpathtootherlib MainClassWithNativeMethods Watch out for system path separators for example, Windows uses instead of . Note that System.loadLibrary resolves library \ufb01lenames in a platform-dependent manner the code snippet above expects a \ufb01le named libExample. so on", "Linux, and Example. dll on Windows. GoalKicker.com Java Notes for Professionals 562An alternative to System.loadLibrary is System.loadString, which takes the full path to a shared library \ufb01le, circumventing the java.library.path lookup public class ClassWithNativeMethods static System.loadpathtoliblibExample.so ... GoalKicker.com Java Notes for Professionals 563Chapter 99 Functional Interfaces In Java 8, a functional interface is an interface that has just one abstract method aside from the methods of Object. See JLS 9.8. Functional Interfaces . Section 99.1 List of standard Java Runtime Library functional interfaces by signature Parameter Types Return Type Interface void Runnable T Supplier boolean BooleanSupplier int IntSupplier long LongSupplier double DoubleSupplier T void ConsumerT T T UnaryOperatorT T R FunctionT,R T boolean PredicateT T int ToIntFunctionT T long ToLongFunctionT T double ToDoubleFunctionT T, T T BinaryOperatorT T, U void BiConsumerT,U T, U R BiFunctionT,U,R T, U boolean BiPredicateT,U T, U int ToIntBiFunctionT,U T, U long ToLongBiFunctionT,U T, U double ToDoubleBiFunctionT,U T, int void ObjIntConsumerT T, long void ObjLongConsumerT T, double void ObjDoubleConsumerT int void IntConsumer int R IntFunctionR int boolean IntPredicate int int IntUnaryOperator int long IntToLongFunction int double IntToDoubleFunction int, int int IntBinaryOperator long void LongConsumer long R LongFunctionR long boolean LongPredicate long int LongToIntFunction long long", "LongUnaryOperator long double LongToDoubleFunction long, long long LongBinaryOperator GoalKicker.com Java Notes for Professionals 564double void DoubleConsumer double R DoubleFunctionR double boolean DoublePredicate double int DoubleToIntFunction double long DoubleToLongFunction double double DoubleUnaryOperator double, double double DoubleBinaryOperator GoalKicker.com Java Notes for Professionals 565Chapter 100 Fluent Interface Section 100.1 Fluent programming style In \ufb02uent programming style you return this from \ufb02uent setter methods that would return nothing in non-\ufb02uent programming style. This allows you to chain the di\ufb00erent method calls which makes your code shorter and easier to handle for the developers. Consider this non-\ufb02uent code public class Person private String firstName private String lastName public String getFirstName return firstName public void setFirstName String firstName this.firstName firstName public String getLastName return lastName public void setLastName String lastName this.lastName lastName public String whoAreYou return I am firstName lastName public static void mainString args Person person new Person person. setFirstName John person. setLastName Doe System.out.printlnperson.whoAreYou As the setter methods dont return anything, we need 4 instructions in the main method to instantiate a Person with some data and print it. With a \ufb02uent style this code can be changed to public class Person private String firstName private String lastName public String getFirstName return firstName", "public Person withFirstName String firstName this.firstName firstName return this GoalKicker.com Java Notes for Professionals 566 public String getLastName return lastName public Person withLastName String lastName this.lastName lastName return this public String whoAreYou return I am firstName lastName public static void mainString args System.out.printlnnew Person.withFirstName John .withLastName Doe.whoAreYou The idea is to always return some object to enable building of a method call chain and to use method names which re\ufb02ect natural speaking. This \ufb02uent style makes the code more readable. Section 100.2 Truth - Fluent Testing Framework From How to use Truth httpgoogle.github.iotruth String string awesome assertThat string.startsWith awe assertWithMessage Without me, its just aweso .thatstring.contains me Iterable Color googleColors googleLogo. getColors assertThat googleColors .containsExactly BLUE, RED, YELLOW, BLUE, GREEN, RED .inOrder GoalKicker.com Java Notes for Professionals 567Chapter 101 Remote Method Invocation RMI Section 101.1 Callback invoking methods on a client Overview In this example 2 clients send information to each other through a server. One client sends the server a number which is relayed to the second client. The second client halves the number and sends it back to the \ufb01rst client through the server. The \ufb01rst client does the same. The server stops the communication when the", "number returned to it by any of the clients is less than 10. The return value from the server to the clients the number it got converted to string representation then backtracks the process. A login server binds itself to a registry.1. A client looks up the login server and calls the login method with its information. Then 2. The login server stores the client information. It includes the clients stub with the callback methods. The login server creates and returns a server stub connection or session to the client to store. It includes the servers stub with its methods including a logout method unused in this example. A client calls the servers passInt with the name of the recipient client and an int. 3. The server calls the half on the recipient client with that int. This initiates a back-and-forth calls and 4. callbacks communication until stopped by the server. The shared remote interfaces The login server package callbackRemote import java.rmi.Remote import java.rmi.RemoteException public interface RemoteLogin extends Remote RemoteConnection login String name, RemoteClient client throws RemoteException The server package callbackRemote import java.rmi.Remote import java.rmi.RemoteException public interface RemoteConnection extends Remote void logout throws RemoteException String passInt String name, int", "i throws RemoteException The client package callbackRemote import java.rmi.Remote GoalKicker.com Java Notes for Professionals 568import java.rmi.RemoteException public interface RemoteClient extends Remote void halfint i throws RemoteException The implementations The login server package callbackServer import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import java.rmi.server.UnicastRemoteObject import java.util.HashMap import java.util.Map import callbackRemote.RemoteClient import callbackRemote.RemoteConnection import callbackRemote.RemoteLogin public class LoginServer implements RemoteLogin static MapString, RemoteClient clients new HashMap Override public RemoteConnection login String name, RemoteClient client Connection connection new Connection name, client clients. putname, client System.out.printlnname logged in return connection public static void mainString args try Registry reg LocateRegistry .createRegistry Registry .REGISTRYPORT LoginServer server new LoginServer UnicastRemoteObject .exportObject server, Registry .REGISTRYPORT reg. rebindLoginServerName , server catch RemoteException e e. printStackTrace The server package callbackServer import java.rmi.NoSuchObjectException import java.rmi.RemoteException import java.rmi.registry.Registry import java.rmi.server.UnicastRemoteObject import java.rmi.server.Unreferenced import callbackRemote.RemoteClient import callbackRemote.RemoteConnection GoalKicker.com Java Notes for Professionals 569public class Connection implements RemoteConnection, Unreferenced RemoteClient client String name public Connection String name, RemoteClient client this.client client this.name name try UnicastRemoteObject .exportObject this, Registry .REGISTRYPORT catch RemoteException e e. printStackTrace Override public void unreferenced try UnicastRemoteObject .unexportObject this, true catch NoSuchObjectException e e. printStackTrace Override public void logout try UnicastRemoteObject .unexportObject this, true catch NoSuchObjectException e e. printStackTrace Override public String", "passInt String recipient, int i System.out.printlnServer received from name i if i 10 return String.valueOfi RemoteClient client LoginServer. clients.getrecipient try client. halfi catch RemoteException e e. printStackTrace return String.valueOfi The client package callbackClient import java.rmi.NotBoundException import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import java.rmi.server.UnicastRemoteObject GoalKicker.com Java Notes for Professionals 570import callbackRemote.RemoteClient import callbackRemote.RemoteConnection import callbackRemote.RemoteLogin public class Client implements RemoteClient RemoteConnection connection String name, target Client String name, String target this.name name this.target target public static void mainString args Client client new Clientargs0, args1 try Registry reg LocateRegistry .getRegistry RemoteLogin login RemoteLogin reg.lookupLoginServerName UnicastRemoteObject .exportObject client, Integer.parseInt args2 client. connection login.loginclient.name, client catch RemoteException NotBoundException e e. printStackTrace if Client1 .equalsclient.name try client. connection .passIntclient.target, 120 catch RemoteException e e. printStackTrace Override public void halfint i throws RemoteException String result connection. passInttarget, i 2 System.out.printlnname received result Running the example Run the login server.1. Run a client with the arguments Client2 Client1 1097 . 2. Run a client with the arguments Client1 Client2 1098 . 3. The outputs will appear in 3 consoles since there are 3 JVMs. here they are lumped together Client2 logged in Client1 logged in Server received from Client1120 Server received from Client260 Server received from", "Client130 Server received from Client215 Server received from Client17 GoalKicker.com Java Notes for Professionals 571Client1 received 7 Client2 received 15 Client1 received 30 Client2 received 60 Section 101.2 Simple RMI example with Client and Server implementation This is a simple RMI example with \ufb01ve Java classes and two packages, server and client . Server Package PersonListInterface.java public interface PersonListInterface extends Remote This interface is used by both client and server return List of Persons throws RemoteException ArrayList String getPersonList throws RemoteException PersonListImplementation.java public class PersonListImplementation extends UnicastRemoteObject implements PersonListInterface private static final long serialVersionUID 1L standard constructor needs to be available public PersonListImplementation throws RemoteException Implementation of PersonListInterface throws RemoteException Override public ArrayList String getPersonList throws RemoteException ArrayList String personList new ArrayList String personList. addPeter Pan personList. addPippi Langstrumpf add your name here return personList Server.java public class Server GoalKicker.com Java Notes for Professionals 572 Register servicer to the known public methods private static void createServer try Register registry with standard port 1099 LocateRegistry .createRegistry Registry .REGISTRYPORT System.out.printlnServer Registry created. Register PersonList to registry Naming.rebindPersonList , new PersonListImplementation System.out.printlnServer PersonList registered catch final IOException e e. printStackTrace public static void mainfinal String args createServer Client package PersonListLocal.java public class", "PersonListLocal private static PersonListLocal instance private PersonListInterface personList Create a singleton instance private PersonListLocal try Lookup to the local running server with port 1099 final Registry registry LocateRegistry .getRegistry localhost , Registry .REGISTRYPORT Lookup to the registered PersonList personList PersonListInterface registry. lookupPersonList catch final RemoteException e e. printStackTrace catch final NotBoundException e e. printStackTrace public static PersonListLocal getInstance if instance null instance new PersonListLocal return instance Returns the servers PersonList public ArrayList String getPersonList GoalKicker.com Java Notes for Professionals 573 if instance ! null try return personList. getPersonList catch final RemoteException e e. printStackTrace return new ArrayList PersonTest.java public class PersonTest public static void mainString args get local PersonList ArrayList String personList PersonListLocal. getInstance .getPersonList print all persons forString person personList System.out.printlnperson Test your application Start main method of Server.java. Output Server Registry created. Server PersonList registered Start main method of PersonTest.java. Output Peter Pan Pippi Langstrumpf Section 101.3 Client-Server invoking methods in one JVM from another The shared remote interface package remote import java.rmi.Remote import java.rmi.RemoteException public interface RemoteServer extends Remote int stringToInt String string throws RemoteException GoalKicker.com Java Notes for Professionals 574The server implementing the shared remote interface package server import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import", "java.rmi.server.UnicastRemoteObject import remote.RemoteServer public class Server implements RemoteServer Override public int stringToInt String string throws RemoteException System.out.printlnServer received string return Integer.parseInt string public static void mainString args try Registry reg LocateRegistry .createRegistry Registry .REGISTRYPORT Server server new Server UnicastRemoteObject .exportObject server, Registry .REGISTRYPORT reg. rebindServerName , server catch RemoteException e e. printStackTrace The client invoking a method on the server remotely package client import java.rmi.NotBoundException import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import remote.RemoteServer public class Client static RemoteServer server public static void mainString args try Registry reg LocateRegistry .getRegistry server RemoteServer reg.lookupServerName catch RemoteException NotBoundException e e. printStackTrace Client client new Client client. callServer GoalKicker.com Java Notes for Professionals 575 void callServer try int i server. stringToInt 120 System.out.printlnClient received i catch RemoteException e e. printStackTrace Output Server received 120 Client received 120 GoalKicker.com Java Notes for Professionals 576Chapter 102 Iterator and Iterable The java.util.Iterator is the standard Java SE interface for object that implement the Iterator design pattern. The java.lang.Iterable interface is for objects that can provide an iterator. Section 102.1 Removing elements using an iterator The Iterator .remove method is an optional method that removes the element returned by the previous call to Iterator .next. For example,", "the following code populates a list of strings and then removes all of the empty strings. ListString names new ArrayList names.addname 1 names.addname 2 names.add names.addname 3 names.add System.out.printlnOld Size names.size Iterator String it names.iterator while it.hasNext String el it.next if el.equals it.remove System.out.printlnNew Size names.size Output Old Size 5 New Size 3 Note that is the code above is the safe way to remove elements while iterating a typical collection. If instead, you attempt to do remove elements from a collection like this for String el names if el.equals names. removeel WRONG! a typical collection such as ArrayList which provides iterators with fail fast iterator semantics will throw a ConcurrentModificationException . The remove method can only called once following a next call. If it is called before calling next or if it is called twice following a next call, then the remove call will throw an IllegalStateException . The remove operation is described as an optional operation i.e. not all iterators will allow it. Examples where it is not supported include iterators for immutable collections, read-only views of collections, or \ufb01xed sized collections. If remove is called when the iterator does not support removal, it will throw an", "UnsupportedOperationException . Section 102.2 Creating your own Iterable To create your own Iterable as with any interface you just implement the abstract methods in the interface. For GoalKicker.com Java Notes for Professionals 577Iterable there is only one which is called iterator . But its return type Iterator is itself an interface with three abstract methods. You can return an iterator associated with some collection or create your own custom implementation public static class Alphabet implements Iterable Character Override public Iterator Character iterator return new Iterator Character char letter a Override public boolean hasNext return letter z Override public Character next return letter Override public void remove throw new UnsupportedOperationException Doesnt make sense to remove a letter To use public static void mainString args forchar c new Alphabet System.out.printlnc c The new Iterator should come with a state pointing to the \ufb01rst item, each call to next updates its state to point to the next one. The hasNext checks to see if the iterator is at the end. If the iterator were connected to a modi\ufb01able collection then the iterators optional remove method might be implemented to remove the item currently pointed to from the underlying collection. Section 102.3 Using", "Iterable in for loop Classes implementing Iterable interface can be used in for loops. This is actually only syntactic sugar for getting an iterator from the object and using it to get all elements sequentially it makes code clearer, faster to write end less error-prone. public class UsingIterable public static void mainString args List Integer intList Arrays.asList1,2,3,4,5,6,7 List extends Collection, Collection extends Iterable Iterable Integer iterable intList foreach-like loop for Integer i iterable GoalKicker.com Java Notes for Professionals 578 System.out.printlni pre java 5 way of iterating loops forIterator Integer i iterable. iterator i.hasNext Integer item i.next System.out.printlnitem Section 102.4 Using the raw iterator While using the foreach loop or extended for loop is simple, its sometimes bene\ufb01cial to use the iterator directly. For example, if you want to output a bunch of comma-separated values, but dont want the last item to have a comma ListString yourData ... Iterator String iterator yourData. iterator while iterator. hasNext next moves the iterator to the next entry and returns its value. String entry iterator. next System.out.printentry if iterator. hasNext If the iterator has another element after the current one System.out.print, This is much easier and clearer than having a isLastEntry variable or doing", "calculations with the loop index. GoalKicker.com Java Notes for Professionals 579Chapter 103 Re\ufb02ection API Re\ufb02ection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the JVM. Java Re\ufb02ection API is used for that purpose where it makes it possible to inspect classes, interfaces, \ufb01elds and methods at runtime, without knowing their names at compile time. And It also makes it possible to instantiate new objects, and to invoke methods using re\ufb02ection. Section 103.1 Dynamic Proxies Dynamic Proxies do not really have much to do with Re\ufb02ection but they are part of the API. Its basically a way to create a dynamic implementation of an interface. This could be helpful when creating mockup services. A Dynamic Proxy is an instance of an interface that is created with a so-called invocation handler that intercepts all method calls and allows the handling of their invocation manually. public class DynamicProxyTest public interface MyInterface1 public void someMethod1 public int someMethod2 String s public interface MyInterface2 public void anotherMethod public static void mainString args throws Exception the dynamic proxy class Class ? proxyClass Proxy.getProxyClass ClassLoader .getSystemClassLoader , new Class MyInterface1. class, MyInterface2. class the", "dynamic proxy class constructor Constructor ? proxyConstructor proxyClass. getConstructor InvocationHandler .class the invocation handler InvocationHandler handler new InvocationHandler this method is invoked for every proxy method call method is the invoked method, args holds the method parameters it must return the method result Override public Object invokeObject proxy, Method method, Object args throws Throwable String methodName method. getName ifmethodName. equalssomeMethod1 System.out.printlnsomeMethod1 was invoked! return null ifmethodName. equalssomeMethod2 System.out.printlnsomeMethod2 was invoked! System.out.printlnParameter args0 return 42 ifmethodName. equalsanotherMethod System.out.printlnanotherMethod was invoked! return null System.out.printlnUnkown method! return null GoalKicker.com Java Notes for Professionals 580 create the dynamic proxy instances MyInterface1 i1 MyInterface1 proxyConstructor. newInstance handler MyInterface2 i2 MyInterface2 proxyConstructor. newInstance handler and invoke some methods i1. someMethod1 i1. someMethod2 stackoverflow i2. anotherMethod The result of this code is this someMethod1 was invoked ! someMethod2 was invoked ! Parameter stackoverflow anotherMethod was invoked ! Section 103.2 Introduction Basics The Re\ufb02ection API allows one to check the class structure of the code at runtime and invoke code dynamically. This is very powerful, but it is also dangerous since the compiler is not able to statically determine whether dynamic invocations are valid. A simple example would be to get the public constructors and methods of", "a given class import java.lang.reflect.Constructor import java.lang.reflect.Method This is a object representing the String class not an instance of String! ClassString clazz String.class Constructor ? constructors clazz.getConstructors returns all public constructors of String Method methods clazz.getMethods returns all public methods from String and parents With this information it is possible to instance the object and call di\ufb00erent methods dynamically. Re\ufb02ection and Generic Types Generic type information is available for method parameters, using getGenericParameterTypes . method return types, using getGenericReturnType . public \ufb01elds, using getGenericType . The following example shows how to extract the generic type information in all three cases import java.lang.reflect.Field import java.lang.reflect.Method import java.lang.reflect.ParameterizedType import java.lang.reflect.Type import java.util.List GoalKicker.com Java Notes for Professionals 581import java.util.Map public class GenericTest public static void mainfinal String args throws Exception final Method method GenericTest. class.getMethod testMethod , Map.class final Field field GenericTest. class.getField testField System.out.printlnMethod parameter final Type parameterType method. getGenericParameterTypes 0 displayGenericType parameterType, t System.out.printlnMethod return type final Type returnType method. getGenericReturnType displayGenericType returnType, t System.out.printlnField type final Type fieldType field.getGenericType displayGenericType fieldType, t private static void displayGenericType final Type type, final String prefix System.out.printlnprefix type.getTypeName if type instanceof ParameterizedType for final Type subtype ParameterizedType type.getActualTypeArguments displayGenericType subtype, prefix t", "public MapString, MapInteger, ListString testField public ListNumber testMethod final MapString, Double arg return null This results in the following output Method parameter java.util.Map java.lang.String java.lang.Double Method return type java.util.List java.lang.Number Field type java.util.Map java.lang.String java.util.Map java.lang.Integer java.util.List java.lang.String Section 103.3 Evil Java hacks with Re\ufb02ection The Re\ufb02ection API could be used to change values of private and \ufb01nal \ufb01elds even in the JDK default library. This GoalKicker.com Java Notes for Professionals 582could be used to manipulate the behaviour of some well known classes as we will see. What is not possible Lets start \ufb01rst with the only limitation means the only \ufb01eld we cant change with Re\ufb02ection. That is the Java SecurityManager . It is declared in java.lang.System as private static volatile SecurityManager security null But it wont be listed in the System class if we run this code forField f System.class.getDeclaredFields System.out.printlnf Thats because of the fieldFilterMap in sun.reflect.Reflection that holds the map itself and the security \ufb01eld in the System.class and protects them against any access with Re\ufb02ection. So we could not deactivate the SecurityManager . Crazy Strings Each Java String is represented by the JVM as an instance of the String class. However, in some situations", "the JVM saves heap space by using the same instance for Strings that are. This happens for string literals, and also for strings that have been interned by calling String.intern. So if you have hello in your code multiple times it is always the same object instance. Strings are supposed to be immutable, but it is possible to use evil re\ufb02ection to change them. The example below show how we can change the characters in a String by replacing its value \ufb01eld. public class CrazyStrings static try Field f String.class.getDeclaredField value f. setAccessible true f. sethello, you stink! .toCharArray catch Exception e public static void mainString args System.out.printlnhello So this code will print you stink! 1 42 The same idea could be used with the Integer Class public class CrazyMath static try Field value Integer.class.getDeclaredField value value. setAccessible true value. setIntInteger.valueOf1, 42 catch Exception e GoalKicker.com Java Notes for Professionals 583 public static void mainString args System.out.printlnInteger.valueOf1 Everything is true And according to this stackover\ufb02ow post we can use re\ufb02ection to do something really evil. public class Evil static try Field field Boolean.class.getField FALSE field. setAccessible true Field modifiersField Field.class.getDeclaredField modifiers modifiersField. setAccessible true modifiersField. setIntfield, field. getModifiers Modifier", ".FINAL field. setnull, true catch Exception e public static void mainString args System.out.formatEverything is s , false Note that what we are doing here is going to cause the JVM to behave in inexplicable ways. This is very dangerous. Section 103.4 Misuse of Re\ufb02ection API to change private and \ufb01nal variables Re\ufb02ection is useful when it is properly used for right purpose. By using re\ufb02ection, you can access private variables and re-initialize \ufb01nal variables. Below is the code snippet, which is not recommended. import java.lang.reflect. public class ReflectionDemo public static void mainString args try Field fields A.class.getDeclaredFields A a new A for Field fieldfields iffield.getName.equalsIgnoreCase name field. setAccessible true field. seta, StackOverFlow System.out.printlnA.name field.geta iffield.getName.equalsIgnoreCase age field. seta, 20 System.out.printlnA.age field.geta iffield.getName.equalsIgnoreCase rep field. setAccessible true field. seta,New Reputation System.out.printlnA.rep field.geta iffield.getName.equalsIgnoreCase count GoalKicker.com Java Notes for Professionals 584 field. seta,25 System.out.printlnA.count field.geta catchException err err. printStackTrace class A private String name public int age public final String rep public static int count0 public A name Unset age 0 rep Reputation count Output A.nameStackOverFlow A.age20 A.repNew Reputation A.count25 Explanation In normal scenario, private variables cant be accessed outside of declared class without getter and setter methods. final variables cant", "be re-assigned after initialization. Reflection breaks both barriers can be abused to change both private and \ufb01nal variables as explained above. field.setAccessible true is the key to achieve desired functionality. Section 103.5 Getting and Setting \ufb01elds Using the Re\ufb02ection API, it is possible to change or get the value of a \ufb01eld at runtime. For example, you could use it in an API to retrieve di\ufb00erent \ufb01elds based on a factor, like the OS. You can also remove modi\ufb01ers like final to allow modi\ufb01ng \ufb01elds that are \ufb01nal. To do so, you will need to use the method ClassgetField in a way such as the one shown below Get the field in class SomeClass NAME. Field nameField SomeClass. class.getDeclaredField NAME Get the field in class Field modifiers. Note that it does not need to be static Field modifiersField Field.class.getDeclaredField modifiers Allow access from anyone even if its declared private modifiersField. setAccessible true GoalKicker.com Java Notes for Professionals 585 Get the modifiers on the NAME field as an int. int existingModifiersOnNameField nameField. getModifiers Bitwise AND NOT Modifier.FINAL 16 on the existing modifiers Readup here httpsen.wikipedia.orgwikiBitwiseoperationsinC if youre unsure what bitwise operations are. int newModifiersOnNameField existingModifiersOnNameField Modifier .FINAL Set the value", "of the modifiers field under an object for non-static fields modifiersField. setIntnameField, newModifiersOnNameField Set it to be accessible. This overrides normal Java privateprotectedpackageetc access control checks. nameField. setAccessible true Set the value of NAME here. Note the null argument. Pass null when modifying static fields, as there is no instance object nameField. setnull, Hacked by reflection... Here I can directly access it. If needed, use reflection to get it. Below System.out.printlnSomeClass. NAME Getting \ufb01elds is much easier. We can use Fieldget and its variants to get its value Get the field in class SomeClass NAME. Field nameField SomeClass. class.getDeclaredField NAME Set accessible for private fields nameField. setAccessible true Pass null as there is no instance, remember? String name String nameField. getnull Do note this When using ClassgetDeclaredField , use it to get a \ufb01eld in the class itself class HackMe extends Hacked public String iAmDeclared class Hacked public String someState Here, HackMeiAmDeclared is declared \ufb01eld. However, HackMesomeState is not a declared \ufb01eld as it is inherited from its superclass, Hacked. Section 103.6 Call constructor Getting the Constructor Object You can obtain Constructor class from the Class object like this Class myClass ... get a class object Constructor constructors myClass.", "getConstructors Where the constructors variable will have one Constructor instance for each public constructor declared in the GoalKicker.com Java Notes for Professionals 586class. If you know the precise parameter types of the constructor you want to access, you can \ufb01lter the speci\ufb01c constructor. The next example returns the public constructor of the given class which takes a Integer as parameter Class myClass ... get a class object Constructor constructor myClass. getConstructor new ClassInteger.class If no constructor matches the given constructor arguments a NoSuchMethodException is thrown. New Instance using Constructor Object Class myClass MyObj.class get a class object Constructor constructor myClass. getConstructor Integer.class MyObj myObj MyObj constructor. newInstance Integer.valueOf123 Section 103.7 Call constructor of nested class If you want to create an instance of an inner nested class you need to provide a class object of the enclosing class as an extra parameter with ClassgetDeclaredConstructor . public class Enclosing public class Nested public NestedString a System.out.printlnConstructor String a public static void mainString args throws Exception Class ? clazzEnclosing Class.forNameEnclosing Class ? clazzNested Class.forNameEnclosingNested Enclosing objEnclosing Enclosing clazzEnclosing. newInstance Constructor ? constructor clazzNested. getDeclaredConstructor new ClassEnclosing. class, String.class Nested objInner Nestedconstructor. newInstance new ObjectobjEnclosing, StackOverFlow If the nested class is static", "you will not need this enclosing instance. Section 103.8 Invoking a method Using re\ufb02ection, a method of an object can be invoked during runtime. The example shows how to invoke the methods of a String object. import java.lang.reflect.InvocationTargetException import java.lang.reflect.Method String s Hello World! method without parameters invoke s.length Method method1 String.class.getMethod length int length int method1. invokes variable length contains 12 method with parameters GoalKicker.com Java Notes for Professionals 587 invoke s.substring6 Method method2 String.class.getMethod substring , int.class String substring String method2. invokes, 6 variable substring contains World! Section 103.9 Get Class given its fully quali\ufb01ed name Given a String containing the name of a class, its Class object can be accessed using Class.forName Class clazz null try clazz Class.forNamejava.lang.Integer catch ClassNotFoundException ex throw new IllegalStateException ex Version Java SE 1.2 It can be speci\ufb01ed, if the class should be initialized second parameter of forName and which ClassLoader should be used third parameter ClassLoader classLoader ... boolean initialize ... Class clazz null try clazz Class.forNamejava.lang.Integer , initialize, classLoader catch ClassNotFoundException ex throw new IllegalStateException ex Section 103.10 Getting the Constants of an Enumeration Giving this enumeration as Example enum Compass NORTH 0, EAST 90, SOUTH 180, WEST 270", "private int degree Compass int deg degree deg public int getDegree return degree In Java an enum class is like any other class but has some de\ufb01nied constants for the enum values. Additionally it has a \ufb01eld that is an array that holds all the values and two static methods with name values and valueOfString. We can see this if we use Re\ufb02ection to print all \ufb01elds in this class forField f Compass. class.getDeclaredFields System.out.printlnf.getName the output will be NORTH GoalKicker.com Java Notes for Professionals 588EAST SOUTH WEST degree ENUMVALUES So we could examine enum classes with Re\ufb02ection like any other class. But the Re\ufb02ection API o\ufb00ers three enum- speci\ufb01c methods. enum check Compass. class.isEnum Returns true for classes that represents an enum type. retrieving values Object values Compass. class.getEnumConstants Returns an array of all enum values like Compass.values but without the need of an instance. enum constant check forField f Compass. class.getDeclaredFields iff.isEnumConstant System.out.printlnf.getName Lists all the class \ufb01elds that are enum values. Section 103.11 Call overloaded constructors using re\ufb02ection Example Invoke di\ufb00erent constructors by passing relevant parameters import java.lang.reflect. class NewInstanceWithReflection public NewInstanceWithReflection System.out.printlnDefault constructor public NewInstanceWithReflection String a System.out.printlnConstructor String a public static void mainString args", "throws Exception NewInstanceWithReflection object NewInstanceWithReflection Class.forNameNewInstanceWithReflection .newInstance Constructor constructor NewInstanceWithReflection. class.getDeclaredConstructor new Class String.class NewInstanceWithReflection object1 NewInstanceWithReflection constructor. newInstance new ObjectStackOverFlow output GoalKicker.com Java Notes for Professionals 589Default constructor Constructor String StackOverFlow Explanation Create instance of class using Class.forName It calls default constructor 1. Invoke getDeclaredConstructor of the class by passing type of parameters as Class array 2. After getting the constructor, create newInstance by passing parameter value as Object array 3. GoalKicker.com Java Notes for Professionals 590Chapter 104 ByteBuer The ByteBuffer class was introduced in java 1.4 to ease working on binary data. Its especially suited to use with primitive type data. It allows the creation, but also subsequent manipulation of a bytes on a higher abstraction level Section 104.1 Basic Usage - Using DirectByteBuer DirectByteBuffer is special implementation of ByteBuffer that has no byte laying underneath. We can allocate such ByteBu\ufb00er by calling ByteBuffer directBuffer ByteBuffer. allocateDirect 16 This operation will allocate 16 bytes of memory. The contents of direct bu\ufb00ers may reside outside of the normal garbage-collected heap. We can verify whether ByteBu\ufb00er is direct by calling directBuffer. isDirect true The main characteristics of DirectByteBuffer is that JVM will try to natively work on allocated memory", "without any additional bu\ufb00ering so operations performed on it may be faster then those performed on ByteBu\ufb00ers with arrays lying underneath. It is recomended to use DirectByteBuffer with heavy IO operations that rely on speed of execution, like real time communication. We have to be aware that if we try using array method we will get UnsupportedOperationException . So it is a good practice to chech whether our ByteBu\ufb00er has it byte array before we try to access it byte arrayOfBytes ifbuffer.hasArray arrayOfBytes buffer. array Another use of direct byte bu\ufb00er is interop through JNI. Since a direct byte bu\ufb00er does not use a byte, but an actual block of memory, it is possible to access that memory directly through a pointer in native code. This can save a bit of trouble and overhead on marshalling between the Java and native representation of data. The JNI interface de\ufb01nes several functions to handle direct byte bu\ufb00ers NIO Support . Section 104.2 Basic Usage - Creating a ByteBuer Theres two ways to create a ByteBuffer , where one can be subdivided again. If you have an already existing byte, you can wrap it into a ByteBuffer to simplify processing byte reqBuffer", "new byteBUFFERSIZE int readBytes socketInputStream. readreqBuffer final ByteBuffer reqBufferWrapper ByteBuffer. wrapreqBuffer This would be a possibility for code that handles low-level networking interactions GoalKicker.com Java Notes for Professionals 591If you do not have an already existing byte, you can create a ByteBuffer over an array thats speci\ufb01cally allocated for the bu\ufb00er like this final ByteBuffer respBuffer ByteBuffer. allocate RESPONSEBUFFERSIZE putResponseData respBuffer socketOutputStream. writerespBuffer. array If the code-path is extremely performance critical and you need direct system memory access , the ByteBuffer can even allocate direct bu\ufb00ers using allocateDirect Section 104.3 Basic Usage - Write Data to the Buer Given a ByteBuffer instance one can write primitive-type data to it using relative and absolute put. The striking di\ufb00erence is that putting data using the relative method keeps track of the index the data is inserted at for you, while the absolute method always requires giving an index to put the data at. Both methods allow chaining calls. Given a su\ufb03ciently sized bu\ufb00er one can accordingly do the following buffer.putInt0xCAFEBABE .putCharc.putFloat 0.25.putLong0xDEADBEEFCAFEBABE which is equivalent to buffer.putInt0xCAFEBABE buffer.putCharc buffer.putFloat 0.25 buffer.putLong0xDEADBEEFCAFEBABE Do note that the method operating on byte s is not named specially. Additionally note that its also valid to", "pass both a ByteBuffer and a byte to put. Other than that, all primitive types have specialized put-methods. An additional note The index given when using absolute put is always counted in byte s. GoalKicker.com Java Notes for Professionals 592Chapter 105 Applets Applets have been part of Java since its o\ufb03cial release and have been used to teach Java and programming for a number of years. Recent years have seen an active push to move away from Applets and other browser plugins, with some browsers blocking them or actively not supporting them. In 2016, Oracle announced their plans to deprecate the plugin, Moving to a Plugin-Free Web Newer and better APIs are now available Section 105.1 Minimal Applet A very simple applet draws a rectangle and prints a string something on the screen. public class MyApplet extends JApplet private String str StackOverflow Override public void init setBackground Color.gray Override public void destroy Override public void start Override public void stop Override public void paintGraphics g g. setColor Color.yellow g. fillRect 1,1,300,150 g. setColor Color.red g. setFontnew FontTimesRoman , Font.PLAIN, 48 g. drawString str, 10, 80 The main class of an applet extends from javax.swing.JApplet . Version Java SE 1.2", "Before Java 1.2 and the introduction of the swing API applets had extended from java.applet.Applet . Applets dont require a main method. The entry point is controlled by the life cycle. To use them, they need to be embedded in a HTML document. This is also the point where their size is de\ufb01ned. html headhead body applet codeMyApplet.class width400 height200applet body html GoalKicker.com Java Notes for Professionals 593Section 105.2 Creating a GUI Applets could easily be used to create a GUI. They act like a Container and have an add method that takes any awt or swing component. public class MyGUIApplet extends JApplet private JPanel panel private JButton button private JComboBox String cmbBox private JTextField textField Override public void init panel new JPanel button new JButtonClickMe! button. addActionListener new ActionListener Override public void actionPerformed ActionEvent ae ifStringcmbBox.getSelectedItem .equalsgreet JOptionPane .showMessageDialog null,Hello textField. getText else JOptionPane .showMessageDialog null,textField. getText stinks! cmbBox new JComboBox new Stringgreet, offend textField new JTextField John Doe panel. addcmbBox panel. addtextField panel. addbutton add panel Section 105.3 Open links from within the applet You can use the method getAppletContext to get an AppletContext object that allows you to request the browser to open a link. For", "this you use the method showDocument . Its second parameter tells the browser to use a new window blank or the one that shows the applet self . public class MyLinkApplet extends JApplet Override public void init JButton button new JButtonClickMe! button. addActionListener new ActionListener Override public void actionPerformed ActionEvent ae AppletContext a getAppletContext try URL url new URLhttpstackoverflow.com a. showDocument url,blank catch Exception e omitted for brevity add button GoalKicker.com Java Notes for Professionals 594Section 105.4 Loading images, audio and other resources Java applets are able to load di\ufb00erent resources. But since they are running in the web browser of the client you need to make sure that these resources are accessible. Applets are not able to access client resources as the local \ufb01le system. If you want to load resources from the same URL the Applet is stored you can use the method getCodeBase to retrieve the base URL. To load resources, applets o\ufb00er the methods getImage and getAudioClip to load images or audio \ufb01les. Load and show an image public class MyImgApplet extends JApplet private Image img Override public void init try img getImage new URLhttpcdn.sstatic.netstackexchangeimglogossoso- logo.png catch MalformedURLException e omitted for brevity Override public void", "paintGraphics g g. drawImage img, 0, 0, this Load and play an audio \ufb01le public class MyAudioApplet extends JApplet private AudioClip audioClip Override public void init try audioClip getAudioClip new URLURLTOANAUDIOFILE.WAV catch MalformedURLException e omitted for brevity Override public void start audioClip. play Override public void stop audioClip. stop Load and display a text \ufb01le public class MyTextApplet extends JApplet Override public void init JTextArea textArea new JTextArea JScrollPane sp new JScrollPane textArea add sp GoalKicker.com Java Notes for Professionals 595 load text try URL url new URLhttpwww.textfiles.comfunquotes.txt InputStream in url.openStream BufferedReader bf new BufferedReader new InputStreamReader in String line whileline bf.readLine ! null textArea. appendline n catchException e omitted for brevity GoalKicker.com Java Notes for Professionals 596Chapter 106 Expressions Expressions in Java are the primary construct for doing calculations. Section 106.1 Operator Precedence When an expression contains multiple operators, it can potentially be read in di\ufb00erent ways. For example, the mathematical expression 1 2 x 3 could be read in two ways Add 1 and 2 and multiply the result by 3. This gives the answer 9. If we added parentheses, this would look 1. like 1 2 x 3. Add 1 to the result of multiplying 2", "and 3. This gives the answer 7. If we added parentheses, this would look 2. like 1 2 x 3 . In mathematics, the convention is to read the expression the second way. The general rule is that multiplication and division are done before addition and subtraction. When more advanced mathematical notation is used, either the meaning is either self-evident to a trained mathematician!, or parentheses are added to disambiguate. In either case, the e\ufb00ectiveness of the notation to convey meaning depends on the intelligence and shared knowledge of the mathematicians. Java has the same clear rules on how to read an expression, based on the precedence of the operators that are used. In general, each operator is ascribed a precedence value see the table below. For example 1 2 3 The precedence of is lower than the precedence of , so the result of the expression is 7, not 9. Description Operators constructs primary Precedence Associativity Quali\ufb01er Parentheses Instance creation Field access Array access Method invocation Method referencename.name expr new primary.name primaryexpr primaryexpr, ... primaryname15 Left to right Post increment expr, expr-- 14 - Pre increment Unary Cast1expr, --expr, expr, -expr, expr, !expr, typeexpr13- Right to left Right", "to left Multiplicative 12 Left to right Additive - 11 Left to right Shift 10 Left to right Relational instanceof 9 Left to right Equality ! 8 Left to right Bitwise AND 7 Left to right Bitwise exclusive OR 6 Left to right Bitwise inclusive OR 5 Left to right Logical AND 4 Left to right GoalKicker.com Java Notes for Professionals 597Logical OR 3 Left to right Conditional1 ? 2 Right to left Assignment Lambda1 - -1 Right to left 1 Lambda expression precedence is complex, as it can also occur after a cast, or as the third part of the conditional ternary operator. Section 106.2 Expression Basics Expressions in Java are the primary construct for doing calculations. Here are some examples 1 A simple literal is an expression 1 2 A simple expression that adds two numbers i j k An expression with multiple operations flag ? c d An expression using the conditional operator String s A type-cast is an expression obj.test A method call is an expression new Object Creation of an object is an expression new int Creation of an object is an expression In general, an expression consists of the following forms Expression names", "which consist of Simple identi\ufb01ers e.g. someIdentifier Quali\ufb01ed identi\ufb01ers e.g. MyClass. someField Primaries which consist of Literals e.g. 1, 1.0, X, hello , false and null Class literal expressions e.g. MyClass. class this and TypeName . this Parenthesized expressions e.g. a b Class instance creation expressions e.g. new MyClass 1, 2, 3 Array instance creation expressions e.g. new int3 Field access expressions e.g. obj.someField or this.someField Array access expressions e.g. vector21 Method invocations e.g. obj.doIt1, 2, 3 Method references Java 8 and later e.g. MyClassdoIt Unary operator expressions e.g. !a or i Binary operator expressions e.g. a b or obj null Ternary operator expressions e.g. obj null ? 1 obj.getCount Lambda expressions Java 8 and later e.g. obj - obj.getCount The details of the di\ufb00erent forms of expressions may be found in other Topics. The Operators topic covers unary, binary and ternary operator expressions. The Lambda expressions topic covers lambda expressions and method reference expressions. The Classes and Objects topic covers class instance creation expressions. The Arrays topic covers array access expressions and array instance creation expressions. The Literals topic covers the di\ufb00erent kinds of literals expressions. The Type of an Expression In most cases, an expression has a", "static type that can be determined at compile time by examining and its subexpressions. These are referred to as stand-alone expressions. GoalKicker.com Java Notes for Professionals 598However, in Java 8 and later the following kinds of expressions may be poly expressions Parenthesized expressions Class instance creation expressions Method invocation expressions Method reference expressions Conditional expressions Lambda expressions When an expression is a poly expression, its type may be in\ufb02uenced by the expressions target type i.e. what it is being used for. The value of an Expression The value of an expression is assignment compatible with its type. The exception to this is when heap pollution has occurred e.g. because unsafe conversion warnings have been inappropriately suppressed or ignored. Expression Statements Unlike many other languages, Java does not generally allow expressions to be used as statements. For example public void compute int i, int j i j ERROR Since the result of evaluating an expression like cannot be use, and since it cannot a\ufb00ect the execution of the program in any other way, the Java designers took the position that such usage is either a mistake, or misguided. However, this does not apply to all expressions. A subset of expressions", "are in fact legal as statements. The set comprises Assignment expression, including operation-and-becomes assignments. Pre and post increment and decrement expressions. Method calls void or non-void . Class instance creation expressions. Section 106.3 Expression evaluation order Java expressions are evaluated following the following rules Operands are evaluated from left to right. The operands of an operator are evaluated before the operator. Operators are evaluated according to operator precedence Argument lists are evaluated from left to right. Simple Example In the following example int i method1 method2 the order of evaluation is The left operand of operator is evaluated to the address of i. 1. The left operand of the operator method1 is evaluated. 2. GoalKicker.com Java Notes for Professionals 599The right operand of the operator method2 is evaluated. 3. The operation is evaluated. 4. The operation is evaluated, assigning the result of the addition to i. 5. Note that if the e\ufb00ects of the calls are observable, you will be able to observe that the call to method1 occurs before the call to method2 . Example with an operator which has a side-e\ufb00ect In the following example int i 1 intArray i i 1 the order of evaluation is", "The left operand of operator is evaluated. This gives the address of intArray 1. 1. The pre-increment is evaluated. This adds 1 to i, and evaluates to 2. 2. The right hand operand of the is evaluated. 3. The operation is evaluated to 2 1 - 3. 4. The operation is evaluated, assigning 3 to intArray 1. 5. Note that since the left-hand operand of the is evaluated \ufb01rst, it is not in\ufb02uenced by the side-e\ufb00ect of the i subexpression. Reference JLS 15.7 - Evaluation Order Section 106.4 Constant Expressions A constant expression is an expression that yields a primitive type or a String, and whose value can be evaluated at compile time to a literal. The expression must evaluate without throwing an exception, and it must be composed of only the following Primitive and String literals. Type casts to primitive types or String . The following unary operators , -, and !. The following binary operators , , , , -, , , , , , , , , !, , , , and . The ternary conditional operator ? . Parenthesized constant expressions. Simple names that refer to constant variables. A constant variable is a variable declared", "as final where the initializer expression is itself a constant expression. Quali\ufb01ed names of the form TypeName . Identifier that refer to constant variables. Note that the above list excludes and --, the assignment operators, class and instanceof , method calls and references to general variables or \ufb01elds. Constant expressions of type String result in an interned String , and \ufb02oating point operations in constant expressions are evaluated with FP-strict semantics. GoalKicker.com Java Notes for Professionals 600Uses for Constant Expressions Constant expressions can be used just about anywhere that a normal expression can be used. However, they have a special signi\ufb01cance in the following contexts. Constant expressions are required for case labels in switch statements. For example switch someValue case 1 1 OK case Math.min2, 3 Error - not a constant expression doSomething When the expression on the right hand side of an assignment is a constant expression, then the assignment can perform a primitive narrowing conversion. This is allowed provided that the value of the constant expression is within the range of the type on the left hand side. See JLS 5.1.3 and 5.2 For example byte b1 1 1 OK - primitive narrowing conversion. byte b2 127", "1 Error - out of range byte b3 b1 1 Error - not a constant expession byte b4 byte b1 1 OK When a constant expression is used as the condition in a do, while or for, then it a\ufb00ects the readability analysis. For example while false doSomething Error - statenent not reachable boolean flag false while flag doSomething OK Note that this does not apply if statements. The Java compiler allows the then or else block of an if statement to be unreachable. This is the Java analog of conditional compilation in C and C. Finally, static final \ufb01elds in an class or interface with constant expression initializers are initialized eagerly. Thus, it is guaranteed that these constants will be observed in the initialized state, even when there is a cycle in the class initialization dependency graph. For more information, refer to JLS 15.28. Constant Expressions . GoalKicker.com Java Notes for Professionals 601Chapter 107 JSON in Java JSON JavaScript Object Notation is a lightweight, text-based, language-independent data exchange format that is easy for humans and machines to read and write. JSON can represent two structured types objects and arrays. JSON is often used in Ajax applications, con\ufb01gurations, databases,", "and RESTful web services. The Java API for JSON Processing provides portable APIs to parse, generate, transform, and query JSON. Section 107.1 Using Jackson Object Mapper Pojo Model public class Model private String firstName private String lastName private int age Getters and setters not shown for brevity Example String to Object Model outputObject objectMapper. readValue firstName John,lastName Doe,age23, Model. class System.out.printlnoutputObject. getFirstName result John Example Object to String String jsonString objectMapper. writeValueAsString inputObject result firstNameJohn,lastNameDoe,age23 Details Import statement needed import com.fasterxml.jackson.databind.ObjectMapper Maven dependency jackson-databind ObjectMapper instance creating one ObjectMapper objectMapper new ObjectMapper ObjectMapper is threadsafe recommended have a shared, static instance Deserialization T T readValueString content, Class T valueType valueType needs to be speci\ufb01ed -- the return will be of this type Throws IOException - in case of a low-level IO problem JsonParseException - if underlying input contains invalid content JsonMappingException - if the input JSON structure does not match object structure GoalKicker.com Java Notes for Professionals 602Usage example jsonString is the input string Model fromJson objectMapper. readValue jsonString, Model. class Method for serialization String writeValueAsStringObject value Throws JsonProcessingException in case of an error Note prior to version 2.1, throws clause included IOException 2.1 removed it. Section 107.2 JSON", "To Object Gson Library Lets assume you have a class called Person with just name private class Person public String name public PersonString name this.name name Code Gson gson new Gson String json name John Person person gson.fromJson json, Person. class System.out.printlnperson.name John You must have gson library in your classpath. Section 107.3 JSONObject.NULL If you need to add a property with a null value, you should use the prede\ufb01ned static \ufb01nal JSONObject. NULL and not the standard Java null reference. JSONObject. NULL is a sentinel value used to explicitly de\ufb01ne a property with an empty value. JSONObject obj new JSONObject obj.putsome, JSONObject. NULL Creates somenull System.out.printlnobj.getsomeprints null Note JSONObject. NULL.equalsnull returns true Which is a clear violation of Java.equals contract For any non-null reference value x, x.equalsnull should return false GoalKicker.com Java Notes for Professionals 603Section 107.4 JSON Builder - chaining methods You can use method chaining while working with JSONObject and JSONArray . JSONObject example JSONObject obj new JSONObject Initialize an empty JSON object Before obj.putname,Nikita .putage,30.putisMarried ,true After nameNikita,age30,isMarriedtrue JSONArray JSONArray arr new JSONArray Initialize an empty array Before arr.putStack.putOver.putFlow After Stack,Over,Flow Section 107.5 Object To JSON Gson Library Lets assume you have a class called", "Person with just name private class Person public String name public PersonString name this.name name Code Gson g new Gson Person person new PersonJohn System.out.printlng.toJsonperson nameJohn Of course the Gson jar must be on the classpath. Section 107.6 JSON Iteration Iterate over JSONObject properties JSONObject obj new JSONObject isMarried true, nameNikita, age30 Iterator String keys obj.keysall keys isMarried, name age while keys.hasNext as long as there is another key String key keys.next get next key Object value obj.getkey get next value by key System.out.printlnkey valueprint key value Iterate over JSONArray values JSONArray arr new JSONArray Initialize an empty array push append some values in arr.putStack GoalKicker.com Java Notes for Professionals 604arr.putOver arr.putFlow for int i 0 i arr.length i iterate over all values Object value arr.geti get value System.out.printlnvalue print each value Section 107.7 optXXX vs getXXX methods JSONObject and JSONArray have a few methods that are very useful while dealing with a possibility that a value your are trying to get does not exist or is of another type. JSONObject obj new JSONObject obj.putString foo, bar For existing properties of the correct type, there is no difference obj.getString foo returns bar obj.optString foo returns bar obj.optString foo, tux", "returns bar However, if a value cannot be coerced to the required type, the behavior differs obj.getIntfoo throws JSONException obj.optIntfoo returns 0 obj.optIntfoo, 123 returns 123 Same if a property does not exist obj.getString undefined throws JSONException obj.optString undefined returns obj.optString undefined , tux returns tux The same rules apply to the getXXX optXXX methods of JSONArray . Section 107.8 Extract single element from JSON String json name John, age21 JsonObject jsonObject new JsonParser .parsejson.getAsJsonObject System.out.printlnjsonObject. getname.getAsString John System.out.printlnjsonObject. getage.getAsInt 21 Section 107.9 JsonArray to Java List Gson Library Here is a simple JsonArray which you would like to convert to a Java ArrayList list TestString1 , TestString2 Now pass the JsonArray list to the following method which returns a corresponding Java ArrayList public ArrayList String getListString String jsonList Type listType new TypeToken ListString .getType make sure the name list matches the name of JsonArray in your Json. ArrayList String list new Gson.fromJson jsonList, listType GoalKicker.com Java Notes for Professionals 605 return list You should add the following maven dependency to your POM.xml \ufb01le !-- httpsmvnrepository.comartifactcom.google.code.gsongson -- dependency groupId com.google.code.gson groupId artifactId gsonartifactId version 2.7version dependency Or you should have the jar com.google.code.gsongsonjarversion in your classpath. Section 107.10 Encoding", "data as JSON If you need to create a JSONObject and put data in it, consider the following example Create a new javax.json.JSONObject instance. JSONObject first new JSONObject first.putfoo, bar first.puttemperature , 21.5 first.putyear, 2016 Add a second object. JSONObject second new JSONObject second.putHello, world first.putmessage , second Create a new JSONArray with some values JSONArray someMonths new JSONArray new String January , February someMonths. putMarch Add another month as the fifth element, leaving the 4th element unset. someMonths. put4, May Add the array to our object object.putmonths , someMonths Encode String json object. toString An exercise for the reader Add pretty-printing! foobar, temperature21.5, year2016, messageHelloworld, monthsJanuary,February,March,null,May Section 107.11 Decoding JSON data If you need to get data from a JSONObject , consider the following example String json foobar,temperature 21.5,year2016,messageHelloworld,months January,February ,March,null,May GoalKicker.com Java Notes for Professionals 606 Decode the JSON-encoded string JSONObject object new JSONObject json Retrieve some values String foo object. getString foo double temperature object. getDouble temperature int year object. getIntyear Retrieve another object JSONObject secondary object. getJSONObject message String world secondary. getString Hello Retrieve an array JSONArray someMonths object. getJSONArray months Get some values from the array int nMonths someMonths. length String february someMonths. getString", "1 GoalKicker.com Java Notes for Professionals 607Chapter 108 XML Parsing using the JAXP APIs Section 108.1 Parsing a document using the StAX API Considering the following document ?xml version1.0 encoding UTF-8 ? library book id1Effective Java book book id2Java Concurrency In Practice book notABook id3This is not a book element notABook library One can use the following code to parse it and build a map of book titles by book id. import javax.xml.stream.XMLInputFactory import javax.xml.stream.XMLStreamConstants import javax.xml.stream.XMLStreamReader import java.io.StringReader import java.util.HashMap import java.util.Map public class StaxDemo public static void mainString args throws Exception String xmlDocument ?xml version1.0 encodingUTF-8 ? library book id1Effective Javabook book id2Java Concurrency In Practicebook notABook id3This is not a book element notABook library XMLInputFactory xmlInputFactory XMLInputFactory. newFactory Various flavors are possible, e.g. from an InputStream, a Source, ... XMLStreamReader xmlStreamReader xmlInputFactory. createXMLStreamReader new StringReader xmlDocument MapInteger, String bookTitlesById new HashMap We go through each event using a loop while xmlStreamReader. hasNext switch xmlStreamReader. getEventType case XMLStreamConstants. STARTELEMENT System.out.printlnFound start of element xmlStreamReader. getLocalName Check if we are at the start of a book element if book.equalsxmlStreamReader. getLocalName int bookId Integer.parseInt xmlStreamReader. getAttributeValue , id String bookTitle xmlStreamReader. getElementText bookTitlesById. putbookId, bookTitle break A bunch of", "other things are possible comments, processing instructions, Whitespace... default break xmlStreamReader. next GoalKicker.com Java Notes for Professionals 608 System.out.printlnbookTitlesById This outputs Found start of element library Found start of element book Found start of element book Found start of element notABook 1Effective Java, 2Java Concurrency In Practice In this sample, one must be carreful of a few things The use of xmlStreamReader. getAttributeValue works because we have checked \ufb01rst that the parser is in 1. the STARTELEMENT state. In evey other states except ATTRIBUTES , the parser is mandated to throw IllegalStateException , because attributes can only appear at the beginning of elements. same goes for xmlStreamReader. getTextContent , it works because we are at a STARTELEMENT and we 2. know in this document that the book element has no non-text child nodes. For more complex documents parsing deeper, nested elements, ..., it is a good practice to delegate the parser to sub-methods or other objets, e.g. have a BookParser class or method, and have it deal with every element from the STARTELEMENT to the ENDELEMENT of the book XML tag. One can also use a Stack object to keep around important datas up and down the tree. Section", "108.2 Parsing and navigating a document using the DOM API Considering the following document ?xml version1.0 encoding UTF-8 ? library book id1Effective Java book book id2Java Concurrency In Practice book library One can use the following code to build a DOM tree out of a String import org.w3c.dom.Document import org.w3c.dom.Node import org.w3c.dom.NodeList import org.xml.sax.InputSource import javax.xml.parsers.DocumentBuilder import javax.xml.parsers.DocumentBuilderFactory import java.io.StringReader public class DOMDemo public static void mainString args throws Exception String xmlDocument ?xml version1.0 encodingUTF-8 ? library book id1Effective Javabook GoalKicker.com Java Notes for Professionals 609 book id2Java Concurrency In Practicebook library DocumentBuilderFactory documentBuilderFactory DocumentBuilderFactory. newInstance This is useless here, because the XML does not have namespaces, but this option is usefull to know in cas documentBuilderFactory. setNamespaceAware true DocumentBuilder documentBuilder documentBuilderFactory. newDocumentBuilder There are various options here, to read from an InputStream, from a file, ... Document document documentBuilder. parsenew InputSource new StringReader xmlDocument Root of the document System.out.printlnRoot of the XML Document document. getDocumentElement .getLocalName Iterate the contents NodeList firstLevelChildren document. getDocumentElement .getChildNodes for int i 0 i firstLevelChildren. getLength i Node item firstLevelChildren. itemi System.out.printlnFirst level child found, XML tag name is item.getLocalName System.out.printlntid attribute of this tag is item.getAttributes .getNamedItem id.getTextContent Another way would have", "been NodeList allBooks document. getDocumentElement .getElementsByTagName book The code yields the following Root of the XML Document library First level child found, XML tag name is book id attribute of this tag is 1 First level child found, XML tag name is book id attribute of this tag is 2 GoalKicker.com Java Notes for Professionals 610Chapter 109 XML XPath Evaluation Section 109.1 Parsing multiple XPath Expressions in a single XML Using the same example as Evaluating a NodeList in an XML document , here is how you would make multiple XPath calls e\ufb03ciently Given the following XML document documentation tags tag nameJava topic nameRegular expressions example Matching groups example example Escaping metacharacters example topic topic nameArrays example Looping over arrays example example Converting an array to a list example topic tag tag nameAndroid topic nameBuilding Android projects example Building an Android application using Gradle example example Building an Android application using Maven example topic topic nameLayout resources example Including layout resources example example Supporting multiple device screens example topic tag tags documentation This is how you would use XPath to evaluate multiple expressions in one document XPath xPath XPathFactory. newInstance .newXPath Make new XPath DocumentBuilder builder DocumentBuilderFactory. newInstance Document", "doc builder. parsenew Filepathtoxml.xml Specify XML file path NodeList javaExampleNodes NodeList xPath.evaluate documentationtagstagnameJavaexample , doc, XPathConstants. NODESET Evaluate the XPath xPath.reset Resets the xPath so it can be used again NodeList androidExampleNodes NodeList xPath.evaluate documentationtagstagnameAndroidexample , doc, XPathConstants. NODESET Evaluate the XPath ... Section 109.2 Parsing single XPath Expression multiple times in an XML In this case, you want to have the expression compiled before the evaluations, so that each call to evaluate does not compile the same expression. The simple syntax would be GoalKicker.com Java Notes for Professionals 611XPath xPath XPathFactory. newInstance .newXPath Make new XPath XPathExpression exp xPath.compiledocumentationtagstagnameJavaexample DocumentBuilder builder DocumentBuilderFactory. newInstance Document doc builder. parsenew Filepathtoxml.xml Specify XML file path NodeList javaExampleNodes NodeList exp.evaluate doc, XPathConstants. NODESET Evaluate the XPath from the already-compiled expression NodeList javaExampleNodes2 NodeList exp.evaluate doc, XPathConstants. NODESET Do it again Overall, two calls to XPathExpression. evaluate will be much more e\ufb03cient than two calls to XPath.evaluate . Section 109.3 Evaluating a NodeList in an XML document Given the following XML document documentation tags tag nameJava topic nameRegular expressions example Matching groups example example Escaping metacharacters example topic topic nameArrays example Looping over arrays example example Converting an array to a list example", "topic tag tag nameAndroid topic nameBuilding Android projects example Building an Android application using Gradle example example Building an Android application using Maven example topic topic nameLayout resources example Including layout resources example example Supporting multiple device screens example topic tag tags documentation The following retrieves all example nodes for the Java tag Use this method if only evaluating XPath in the XML once. See other example for when multiple XPath calls are evaluated in the same XML \ufb01le. XPathFactory xPathFactory XPathFactory. newInstance XPath xPath xPathFactory. newXPath Make new XPath InputSource inputSource new InputSource pathtoxml.xml Specify XML file path NodeList javaExampleNodes NodeList xPath.evaluate documentationtagstagnameJavaexample , inputSource, XPathConstants. NODESET Evaluate the XPath ... GoalKicker.com Java Notes for Professionals 612Chapter 110 XOM - XML Object Model Section 110.1 Reading a XML \ufb01le In order to load the XML data with XOM you will need to make a Builder from which you can build it into a Document . Builder builder new Builder Document doc builder. buildfile To get the root element, the highest parent in the xml \ufb01le, you need to use the getRootElement on the Document instance. Element root doc.getRootElement Now the Element class has a lot of handy methods", "that make reading xml really easy. Some of the most useful are listed below getChildElements String name - returns an Elements instance that acts as an array of elements getFirstChildElement String name - returns the \ufb01rst child element with that tag. getValue - returns the value inside the element. getAttributeValue String name - returns the value of an attribute with the speci\ufb01ed name. When you call the getChildElements you get a Elements instance. From this you can loop through and call the getint index method on it to retrieve all the elements inside. Elements colors root.getChildElements color for int q 0 q colors. size q Element color colors. getq Example Here is an example of reading an XML File XML File Code for reading and printing it GoalKicker.com Java Notes for Professionals 613import java.io.File import java.io.IOException import nu.xom.Builder import nu.xom.Document import nu.xom.Element import nu.xom.Elements import nu.xom.ParsingException public class XMLReader public static void mainString args throws ParsingException, IOException File file new Fileinsert path here builder builds xml data Builder builder new Builder Document doc builder. buildfile get the root element example Element root doc.getRootElement gets all element with tag person Elements people root.getChildElements person for int q 0 q people.", "size q get the current person element Element person people. getq get the name element and its children first and last Element nameElement person. getFirstChildElement name Element firstNameElement nameElement. getFirstChildElement first Element lastNameElement nameElement. getFirstChildElement last get the age element Element ageElement person. getFirstChildElement age get the favorite color element Element favColorElement person. getFirstChildElement favcolor String fName, lName, ageUnit, favColor int age try fName firstNameElement. getValue lName lastNameElement. getValue age Integer.parseInt ageElement. getValue ageUnit ageElement. getAttributeValue unit favColor favColorElement. getValue System.out.printlnName lName , fName System.out.printlnAge age ageUnit System.out.printlnFavorite Color favColor System.out.println---------------- catch NullPointerException ex ex. printStackTrace catch NumberFormatException ex ex. printStackTrace GoalKicker.com Java Notes for Professionals 614This will print out in the console Name Smith, Dan Age 23 years Favorite Color green ---------------- Name Autry, Bob Age 3 months Favorite Color NA ---------------- Section 110.2 Writing to a XML File Writing to a XML File using XOM is very similar to reading it except in this case we are making the instances instead of retrieving them o\ufb00 the root. To make a new Element use the constructor ElementString name. You will want to make a root element so that you can easily add it to a Document . Element", "root new Elementroot The Element class has some handy methods for editing elements. They are listed below appendChild String name - this will basically set the value of the element to name. appendChild Node node - this will make node the elements parent. Elements are nodes so you can parse elements. addAttribute Attribute attribute - will add an attribute to the element. The Attribute class has a couple of di\ufb00erent constructors. The simplest one is Attribute String name, String value. Once you have all of your elements add to your root element you can turn it into a Document . Document will take a Element as an argument in its constructor. You can use a Serializer to write your XML to a \ufb01le. You will need to make a new output stream to parse in the constructor of Serializer . FileOutputStream fileOutputStream new FileOutputStream file Serializer serializer new Serializer fileOutputStream, UTF-8 serializer. setIndent 4 serializer. writedoc Example Code import java.io.File import java.io.FileOutputStream import java.io.IOException import java.io.UnsupportedEncodingException import nu.xom.Attribute import nu.xom.Builder import nu.xom.Document import nu.xom.Element import nu.xom.Elements import nu.xom.ParsingException import nu.xom.Serializer GoalKicker.com Java Notes for Professionals 615public class XMLWriter public static void mainString args throws UnsupportedEncodingException , IOException root element", "example Element root new Elementexample make a array of people to store Person people new PersonSmith, Dan, years, green, 23, new PersonAutry, Bob, months , NA, 3 add all the people for Person person people make the main person element person Element personElement new Elementperson make the name element and its children first and last Element nameElement new Elementname Element firstNameElement new Elementfirst Element lastNameElement new Elementlast make age element Element ageElement new Elementage make favorite color element Element favColorElement new Elementfavcolor add value to names firstNameElement. appendChild person.getFirstName lastNameElement. appendChild person.getLastName add names to name nameElement. appendChild firstNameElement nameElement. appendChild lastNameElement add value to age ageElement. appendChild String.valueOfperson.getAge add unit attribute to age ageElement. addAttribute new Attribute unit, person. getAgeUnit add value to favColor favColorElement. appendChild person.getFavoriteColor add all contents to person personElement. appendChild nameElement personElement. appendChild ageElement personElement. appendChild favColorElement add person to root root. appendChild personElement create doc off of root Document doc new Document root the file it will be stored in File file new Fileout.xml if !file.exists file. createNewFile GoalKicker.com Java Notes for Professionals 616 get a file output stream ready FileOutputStream fileOutputStream new FileOutputStream file use the serializer class to write it all", "Serializer serializer new Serializer fileOutputStream, UTF-8 serializer. setIndent 4 serializer. writedoc private static class Person private String lName, fName, ageUnit, favColor private int age public PersonString lName, String fName, String ageUnit, String favColor, int age this.lName lName this.fName fName this.age age this.ageUnit ageUnit this.favColor favColor public String getLastName return lName public String getFirstName return fName public String getAgeUnit return ageUnit public String getFavoriteColor return favColor public int getAge return age This will be the contents of out.xml GoalKicker.com Java Notes for Professionals 617Chapter 111 Polymorphism Polymorphism is one of main OOPobject oriented programming concepts. Polymorphism word was derived from the greek words poly and morphs. Poly means many and morphs means forms many forms. There are two ways to perform polymorphism. Method Overloading and Method Overriding . Section 111.1 Method Overriding Method overriding is the ability of subtypes to rede\ufb01ne override the behavior of their supertypes. In Java, this translates to subclasses overriding the methods de\ufb01ned in the super class. In Java, all non-primitive variables are actually references , which are akin to pointers to the location of the actual object in memory. The references only have one type, which is the type they were declared with. However, they", "can point to an object of either their declared type or any of its subtypes. When a method is called on a reference , the corresponding method of the actual object being pointed to is invoked . class SuperType public void sayHello System.out.printlnHello from SuperType public void sayBye System.out.printlnBye from SuperType class SubType extends SuperType override the superclass method public void sayHello System.out.printlnHello from SubType class Test public static void mainString... args SuperType superType new SuperType superType. sayHello - Hello from SuperType make the reference point to an object of the subclass superType new SubType behaviour is governed by the object, not by the reference superType. sayHello - Hello from SubType non-overridden method is simply inherited superType. sayBye - Bye from SuperType Rules to keep in mind To override a method in the subclass, the overriding method i.e. the one in the subclass MUST HAVE same name same return type in case of primitives a subclass is allowed for classes, this is also known as covariant return GoalKicker.com Java Notes for Professionals 618types. same type and order of parameters it may throw only those exceptions that are declared in the throws clause of the superclasss method or exceptions that", "are subclasses of the declared exceptions. It may also choose NOT to throw any exception. The names of the parameter types do not matter. For example, void methodXint i is same as void methodXint k We are unable to Override \ufb01nal or Static methods. Only thing that we can do change only method body. Section 111.2 Method Overloading Method overloading , also known as function overloading , is the ability of a class to have multiple methods with the same name, granted that they di\ufb00er in either number or type of arguments. Compiler checks method signature for method overloading. Method signature consists of three things - Method name1. Number of parameters2. Types of parameters3. If these three are same for any two methods in a class, then compiler throws duplicate method error . This type of polymorphism is called static or compile time polymorphism because the appropriate method to be called is decided by the compiler during the compile time based on the argument list. class Polymorph public int addint a, int b return a b public int addint a, int b, int c return a b c public float addfloat a, float b return a b public static", "void mainString... args Polymorph poly new Polymorph int a 1, b 2, c 3 float d 1.5, e 2.5 System.out.printlnpoly.adda, b System.out.printlnpoly.adda, b, c System.out.printlnpoly.addd, e This will result in 2 6 4.000000 GoalKicker.com Java Notes for Professionals 619Overloaded methods may be static or non-static. This also does not e\ufb00ect method overloading. public class Polymorph private static void methodOverloaded No argument, private static method private int methodOverloaded int i One argument private non-static method return i static int methodOverloaded double d static Method return 0 public void methodOverloaded int i, double d Public non-static Method Also if you change the return type of method, we are unable to get it as method overloading. public class Polymorph void methodOverloaded No argument and No return type int methodOverloaded No argument and int return type return 0 Section 111.3 Polymorphism and dierent types of overriding From java tutorial The dictionary de\ufb01nition of polymorphism refers to a principle in biology in which an organism or species can have many di\ufb00erent forms or stages. This principle can also be applied to object-oriented programming and languages like the Java language. Subclasses of a class can de\ufb01ne their own unique behaviors and yet share some of", "the same functionality of the parent class. Have a look at this example to understand di\ufb00erent types of overriding. Base class provides no implementation and sub-class has to override complete method - abstract1. Base class provides default implementation and sub-class can change the behaviour2. Sub-class adds extension to base class implementation by calling super.methodName as \ufb01rst statement 3. Base class de\ufb01nes structure of the algorithm Template method and sub-class will override a part of4. algorithm GoalKicker.com Java Notes for Professionals 620code snippet import java.util.HashMap abstract class Game implements Runnable protected boolean runGame true protected Player player1 null protected Player player2 null protected Player currentPlayer null public Game player1 new PlayerPlayer 1 player2 new PlayerPlayer 2 currentPlayer player1 initializeGame Type 1 Let subclass define own implementation. Base class defines abstract method to force sub-classes to define implementation protected abstract void initializeGame Type 2 Sub-class can change the behaviour. If not, base class behaviour is applicable protected void logTimeBetweenMoves Player player System.out.printlnBase class Move Duration player.PlayerActTime - player.MoveShownTime Type 3 Base class provides implementation. Sub-class can enhance base class implementation by calling super.methodName in first line of the child class method and specific implementation later protected void logGameStatistics System.out.printlnBase class logGameStatistics", "Type 4 Template method Structure of base class cant be changed but sub-class can some part of behaviour protected void runGame throws Exception System.out.printlnBase class Defining the flow for Game while runGame 1. Set current player 2. Get Player Move validatePlayerMove currentPlayer logTimeBetweenMoves currentPlayer Thread.sleep500 setNextPlayer logGameStatistics sub-part of the template method, which define child class behaviour protected abstract void validatePlayerMove Player p protected void setRunGame boolean status this.runGame status public void setCurrentPlayer Player p this.currentPlayer p GoalKicker.com Java Notes for Professionals 621 public void setNextPlayer if currentPlayer player1 currentPlayer player2 else currentPlayer player1 public void run try runGame catchException err err. printStackTrace class Player String name Player String name this.name name public String getName return name Concrete Game implementation class Chess extends Game public Chess super public void initializeGame System.out.printlnChild class Initialized Chess game protected void validatePlayerMove Player p System.out.printlnChild class Validate Chess move p.getName protected void logGameStatistics super.logGameStatistics System.out.printlnChild class Add Chess specific logGameStatistics class TicTacToe extends Game public TicTacToe super public void initializeGame System.out.printlnChild class Initialized TicTacToe game protected void validatePlayerMove Player p System.out.printlnChild class Validate TicTacToe move p.getName public class Polymorphism public static void mainString args try Game game new Chess Thread t1 new Threadgame", "t1. start Thread.sleep1000 GoalKicker.com Java Notes for Professionals 622 game. setRunGame false Thread.sleep1000 game new TicTacToe Thread t2 new Threadgame t2. start Thread.sleep1000 game. setRunGame false catchException err err. printStackTrace Output Child class Initialized Chess game Base class Defining the flow for Game Child class Validate Chess movePlayer 1 Base class Move Duration player.PlayerActTime - player.MoveShownTime Child class Validate Chess movePlayer 2 Base class Move Duration player.PlayerActTime - player.MoveShownTime Base class logGameStatistics Child class Add Chess specific logGameStatistics Child class Initialized TicTacToe game Base class Defining the flow for Game Child class Validate TicTacToe movePlayer 1 Base class Move Duration player.PlayerActTime - player.MoveShownTime Child class Validate TicTacToe movePlayer 2 Base class Move Duration player.PlayerActTime - player.MoveShownTime Base class logGameStatistics Section 111.4 Virtual functions Virtual Methods are methods in Java that are non-static and without the keyword Final in front. All methods by default are virtual in Java. Virtual Methods play important roles in Polymorphism because children classes in Java can override their parent classes methods if the function being overridden is non-static and has the same method signature. There are, however, some methods that are not virtual. For example, if the method is declared private or with the keyword", "\ufb01nal, then the method is not Virtual. Consider the following modi\ufb01ed example of inheritance with Virtual Methods from this StackOver\ufb02ow post How do virtual functions work in C and Java? public class A public void hello System.out.printlnHello public void boo System.out.printlnSay boo GoalKicker.com Java Notes for Professionals 623public class B extends A public void hello System.out.printlnNo public void boo System.out.printlnSay haha If we invoke class B and call hello and boo, we would get No and Say haha as the resulting output because B overrides the same methods from A. Even though the example above is almost exactly the same as method overriding, it is important to understand that the methods in class A are all, by default, Virtual. Additionally, we can implement Virtual methods using the abstract keyword. Methods declared with the keyword abstract does not have a method de\ufb01nition, meaning the methods body is not yet implemented. Consider the example from above again, except the boo method is declared abstract public class A public void hello System.out.printlnHello abstract void boo public class B extends A public void hello System.out.printlnNo public void boo System.out.printlnSay haha If we invoke boo from B, the output will still be Say haha", "since B inherits the abstract method boo and makes boo output Say haha. Sources used and further readings How do virtual functions work in C and Java? Check out this great answer that gives a much more complete information about Virtual functions Can you write virtual functions methods in Java? Section 111.5 Adding behaviour by adding classes without touching existing code import java.util.ArrayList import java.util.List import static java.lang.System.out public class PolymorphismDemo GoalKicker.com Java Notes for Professionals 624 public static void mainString args List FlyingMachine machines new ArrayList FlyingMachine machines. addnew FlyingMachine machines. addnew Jet machines. addnew Helicopter machines. addnew Jet new MakeThingsFly .letTheMachinesFly machines class MakeThingsFly public void letTheMachinesFly ListFlyingMachine flyingMachines for FlyingMachine flyingMachine flyingMachines flyingMachine. fly class FlyingMachine public void fly out. printlnNo implementation class Jet extends FlyingMachine Override public void fly out. printlnStart, taxi, fly public void bombardment out. printlnFire missile class Helicopter extends FlyingMachine Override public void fly out. printlnStart vertically, hover, fly Explanation a The MakeThingsFly class can work with everything that is of type FlyingMachine . b The method letTheMachinesFly also works without any change ! when you add a new class, for example PropellerPlane public void letTheMachinesFly ListFlyingMachine flyingMachines for FlyingMachine flyingMachine flyingMachines", "flyingMachine. fly Thats the power of polymorphism. You can implement the open-closed-principle with it. GoalKicker.com Java Notes for Professionals 625Chapter 112 Encapsulation Imagine you had a class with some pretty important variables and they were set by other programmers from their code to unacceptable values.Their code brought errors in your code. As a solution, In OOP, you allow the state of an object stored in its variables to be modi\ufb01ed only through methods. Hiding the state of an object and providing all interaction through an objects methods is known as Data Encapsulation. Section 112.1 Encapsulation to maintain invariants There are two parts of a class the interface and the implementation. The interface is the exposed functionality of the class. Its public methods and variables are part of the interface. The implementation is the internal workings of a class. Other classes shouldnt need to know about the implementation of a class. Encapsulation refers to the practice of hiding the implementation of a class from any users of that class. This allows the class to make assumptions about its internal state. For example, take this class representing an Angle public class Angle private double angleInDegrees private double angleInRadians public static Angle", "angleFromDegrees double degrees Angle a new Angle a. angleInDegrees degrees a. angleInRadians Math.PIdegrees180 return a public static Angle angleFromRadians double radians Angle a new Angle a. angleInRadians radians a. angleInDegrees radians 180Math.PI return a public double getDegrees return angleInDegrees public double getRadians return angleInRadians public void setDegrees double degrees this.angleInDegrees degrees this.angleInRadians Math.PIdegrees180 public void setRadians double radians this.angleInRadians radians this.angleInDegrees radians 180Math.PI private Angle GoalKicker.com Java Notes for Professionals 626 This class relies on a basic assumption or invariant angleInDegrees and angleInRadians are always in sync . If the class members were public, there would be no guarantees that the two representations of angles are correlated. Section 112.2 Encapsulation to reduce coupling Encapsulation allows you to make internal changes to a class without a\ufb00ecting any code that calls the class. This reduces coupling , or how much any given class relies on the implementation of another class. For example, lets change the implementation of the Angle class from the previous example public class Angle private double angleInDegrees public static Angle angleFromDegrees double degrees Angle a new Angle a. angleInDegrees degrees return a public static Angle angleFromRadians double radians Angle a new Angle a. angleInDegrees radians 180Math.PI return a", "public double getDegrees return angleInDegrees public double getRadians return angleInDegrees Math.PI 180 public void setDegrees double degrees this.angleInDegrees degrees public void setRadians double radians this.angleInDegrees radians 180Math.PI private Angle The implementation of this class has changed so that it only stores one representation of the angle and calculates the other angle when needed. However, the implementation changed, but the interface didnt . If a calling class relied on accessing the angleInRadians method, it would need to be changed to use the new version of Angle . Calling classes shouldnt care about the internal representation of a class. GoalKicker.com Java Notes for Professionals 627Chapter 113 Java Agents Section 113.1 Modifying classes with agents Firstly, make sure that the agent being used has the following attributes in the Manifest.mf Can-Redefine -Classes true Can-Retransform -Classes true Starting a java agent will let the agent access the class Instrumentation. With Instrumentation you can call addTransformerClassFileTransformer transformer . ClassFileTransformers will let you rewrite the bytes of classes. The class has only a single method which supplies the ClassLoader that loads the class, the classs name, a java.lang.Class instance of it, its ProtectionDomain, and lastly the bytes of the class itself. It looks like this", "byte transform ClassLoader loader, String className, Class ? classBeingRedefined, ProtectionDomain protectionDomain, byte classfileBuffer Modifying a class purely from bytes can take ages. To remedy this there are libraries that can be used to convert the class bytes into something more usable. In this example Ill be using ASM, but other alternatives like Javassist and BCEL have similar features. ClassNode getNode byte bytes Create a ClassReader that will parse the byte array into a ClassNode ClassReader cr new ClassReader bytes ClassNode cn new ClassNode try This populates the ClassNode cr. acceptcn, ClassReader. EXPANDFRAMES cr null catch Exception e e. printStackTrace return cn From here changes can be made to the ClassNode object. This makes changing \ufb01eldmethod access incredibly easy. Plus with ASMs Tree API modifying the bytecode of methods is a breeze. Once the edits are \ufb01nished you can convert the ClassNode back into bytes with the following method and return them in the transform method public static byte getNodeBytes ClassNode cn, boolean useMaxs ClassWriter cw new ClassWriter useMaxs ? ClassWriter. COMPUTEMAXS ClassWriter. COMPUTEFRAMES cn.acceptcw byte b cw.toByteArray return b Section 113.2 Adding an agent at runtime Agents can be added to a JVM at runtime. To load an agent", "you will need to use the Attach APIs GoalKicker.com Java Notes for Professionals 628VirtualMachine.attatchString id . You can then load a compiled agent jar with the following method public static void loadAgent String agentPath String vmName ManagementFactory. getRuntimeMXBean .getName int index vmName. indexOf String pid vmName. substring 0, index try File agentFile new FileagentPath VirtualMachine vm VirtualMachine. attachpid vm. loadAgent agentFile. getAbsolutePath , VirtualMachine. attachvm.id catch Exception e throw new RuntimeException e This will not call premainString agentArgs, Instrumentation inst in the loaded agent, but instead will call agentmainString agentArgs, Instrumentation inst . This requires Agent-Class to be set in the agent Manifest.mf. Section 113.3 Setting up a basic agent The Premain class will contain the method premainString agentArgs Instrumentation inst Here is an example import java.lang.instrument.Instrumentation public class PremainExample public static void premain String agentArgs, Instrumentation inst System.out.printlnagentArgs When compiled into a jar \ufb01le open the Manifest and ensure that it has the Premain-Class attribute. Here is an example Premain-Class PremainExample To use the agent with another java program myProgram you must de\ufb01ne the agent in the JVM arguments java -javaagent PremainAgent. jar -jar myProgram. jar GoalKicker.com Java Notes for Professionals 629Chapter 114 Varargs Variable Argument Section 114.1", "Working with Varargs parameters Using varargs as a parameter for a method de\ufb01nition, it is possible to pass either an array or a sequence of arguments. If a sequence of arguments are passed, they are converted into an array automatically. This example shows both an array and a sequence of arguments being passed into the printVarArgArray method, and how they are treated identically in the code inside the method public class VarArgs this method will print the entire contents of the parameter passed in void printVarArgArray int... x for int i 0 i x.length i System.out.printxi , public static void mainString args VarArgs obj new VarArgs Using an array int testArray new int10, 20 obj. printVarArgArray testArray System.out.println Using a sequence of arguments obj. printVarArgArray 5, 6, 5, 8, 6, 31 Output 10,20, 5,6,5,8,6,31 If you de\ufb01ne the method like this, it will give compile-time errors. void methodString... a, int... b , int c Compile time error multiple varargs void methodint... a, String b Compile time error varargs must be the last argument Section 114.2 Specifying a varargs parameter void doSomething String... strings for String s strings System.out.printlns The three periods after the \ufb01nal parameters type indicate that the", "\ufb01nal argument may be passed as an array or as a sequence of arguments. Varargs can be used only in the \ufb01nal argument position. GoalKicker.com Java Notes for Professionals 630Chapter 115 Logging java.util.logging Section 115.1 Logging complex messages eciently Lets look at a sample of logging which you can see in many programs public class LoggingComplex private static final Logger logger Logger. getLogger LoggingComplex. class.getName private int total 50, orders 20 private String username Bob public void takeOrder ... making some stuff logger. fineString.formatUser s ordered d things d in total , username, orders, total ... some other stuff some other methods and calculations The above example looks perfectly \ufb01ne, but many programmers forgets that Java VM is stack machine. This means that all methods parameters are calculated before executing the method. This fact is crucial for logging in Java, especially for logging something in low levels like FINE , FINER , FINEST which are disabled by default. Lets look at Java bytecode for the takeOrder method. The result for javap -c LoggingComplex. class is something like this public void takeOrder Code 0 getstatic 27 Field loggerLjavautilloggingLogger 3 ldc 45 String User s ordered d things d in total", "5 iconst3 6 anewarray 3 class javalangObject 9 dup 10 iconst0 11 aload0 12 getfield 40 Field usernameLjavalangString 15 aastore 16 dup 17 iconst1 18 aload0 19 getfield 36 Field ordersI 22 invokestatic 47 Method javalangInteger.valueOfILjavalangInteger 25 aastore 26 dup 27 iconst2 28 aload0 29 getfield 34 Field totalI 32 invokestatic 47 Method javalangInteger.valueOfILjavalangInteger 35 aastore 36 invokestatic 53 Method javalangString.formatLjavalangStringLjavalangObjectLjavalangString 39 invokevirtual 59 Method javautilloggingLogger.fineLjavalangStringV GoalKicker.com Java Notes for Professionals 631 42 return Line 39 runs the actual logging. All of the previous work loading variables, creating new objects, concatenating Strings in format method can be for nothing if logging level is set higher then FINE and by default it is. Such logging can be very ine\ufb03cient, consuming unnecessary memory and processor resources. Thats why you should ask if the level you want to use is enabled. The right way should be public void takeOrder making some stuff if logger.isLoggable Level.FINE no action taken when theres no need for it logger. fineString.formatUser s ordered d things d in total , username, orders, total some other stuff Since Java 8 The Logger class has additional methods that take a Supplier String as parameter, which can simply be provided by", "a lambda public void takeOrder making some stuff logger. fine - String.formatUser s ordered d things d in total , username, orders, total some other stuff The Suppliers getmethod - in this case the lambda - is only called when the corresponding level is enabled and so the ifconstruction is not needed anymore. Section 115.2 Using the default logger This example shows how to use the default logging api. import java.util.logging.Level import java.util.logging.Logger public class MyClass retrieve the logger for the current class private static final Logger LOG Logger. getLogger MyClass. class.getName public void foo LOG. infoA log message LOG. logLevel.INFO, Another log message LOG. fineA fine message logging an exception try code might throw an exception catch SomeException ex log a warning printing Something went wrong GoalKicker.com Java Notes for Professionals 632 together with the exception message and stacktrace LOG. logLevel.WARNING, Something went wrong , ex String s Hello World! logging an object LOG. logLevel.FINER, String s 0 , s logging several objects LOG. logLevel.FINEST, String s 0 has length 1 , new Objects, s.length Section 115.3 Logging levels Java Logging Api has 7 levels . The levels in descending order are SEVERE highest value WARNING INFO CONFIG", "FINE FINER FINEST lowest value The default level is INFO but this depends on the system and used a virtual machine. Note There are also levels OFF can be used to turn logging o\ufb00 and ALL the opposite of OFF. Code example for this import java.util.logging.Logger public class Levels private static final Logger logger Logger. getLogger Levels.class.getName public static void mainString args logger. severeMessage logged by SEVERE logger. warningMessage logged by WARNING logger. infoMessage logged by INFO logger. configMessage logged by CONFIG logger. fineMessage logged by FINE logger. finerMessage logged by FINER logger. finestMessage logged by FINEST All of above methods are really just shortcut for public void logLevel level, String msg logger. logLevel.FINEST, Message logged by FINEST By default running this class will output only messages with level higher then CONFIG Jul 23, 2016 91611 PM LevelsExample main SEVERE Message logged by SEVERE GoalKicker.com Java Notes for Professionals 633Jul 23, 2016 91611 PM LevelsExample main WARNING Message logged by WARNING Jul 23, 2016 91611 PM LevelsExample main INFO Message logged by INFO GoalKicker.com Java Notes for Professionals 634Chapter 116 log4j log4j2 Apache Log4j is a Java-based logging utility, it is one of several Java logging frameworks. This topic", "is to show how to setup and con\ufb01gure Log4j in Java with detailed examples on all of its possible aspects of usage. Section 116.1 Properties-File to log to DB For this example to work youll need a JDBC driver compatible to the system the database is running on. An opensource one that allows you to connect to DB2 databases on an IBM System i can be found here JT400 Even though this example is DB2 speci\ufb01c, it works for almost every other system if you exchange the driver and adapt the JDBC URL. Root logger option log4j.rootLogger ERROR, DB Redirect log messages to a DB2 Define the DB appender log4j.appender .DBorg.apache.log4j.jdbc.JDBCAppender Set JDBC URL !!! adapt to your target system !!! log4j.appender .DB.URLjdbcas40010.10.10.1446DATABASENAMEnamingsystemerrorsfull Set Database Driver !!! adapt to your target system !!! log4j.appender .DB.drivercom.ibm.as400.access.AS400JDBCDriver Set database user name and password log4j.appender .DB.userUSER log4j.appender .DB.password PASSWORD Set the SQL statement to be executed. log4j.appender .DB.sqlINSERT INTO DB. TABLENAME VALUESdyyyy-MM- dd,dHHmmss ,C,p,m Define the layout for file appender log4j.appender .DB.layoutorg.apache.log4j.PatternLayout Section 116.2 How to get Log4j Current version log4j2 Using Maven Add the following dependency to your POM.xml \ufb01le dependencies dependency groupId org.apache.logging.log4j groupId artifactId log4j-api artifactId version 2.6.2version dependency", "dependency groupId org.apache.logging.log4j groupId artifactId log4j-core artifactId version 2.6.2version dependency dependencies GoalKicker.com Java Notes for Professionals 635Using Ivy dependencies dependency orgorg.apache.logging.log4j namelog4j-api rev2.6.2 dependency orgorg.apache.logging.log4j namelog4j-core rev2.6.2 dependencies Using Gradle dependencies compile group org.apache.logging.log4j , name log4j-api , version 2.6.2 compile group org.apache.logging.log4j , name log4j-core , version 2.6.2 Getting log4j 1.x Note Log4j 1.x has reached End-of-Life EOL see Remarks. Using Maven Declare this dependency in the POM.xml \ufb01le dependency groupId log4jgroupId artifactId log4jartifactId version 1.2.17version dependency Using Ivy dependency orglog4j namelog4j rev1.2.17 Usign Gradle compile group log4j, name log4j, version 1.2.17 Using Buildr log4jlog4jjar1.2.17 Adding manually in path build Download from Log4j website project Section 116.3 Setting up property \ufb01le Log4j gives you posibility to log data into console and \ufb01le at same time. Create a log4j.properties \ufb01le and put inside this basic con\ufb01guration Root logger option log4j.rootLogger DEBUG, stdout, file Redirect log messages to console log4j.appender .stdoutorg.apache.log4j.ConsoleAppender log4j.appender .stdout.TargetSystem.out log4j.appender .stdout.layoutorg.apache.log4j.PatternLayout GoalKicker.com Java Notes for Professionals 636log4j.appender .stdout.layout.ConversionPattern dyyyy-MM-dd HHmmss -5p c1L - mn Redirect log messages to a log file, support file rolling. log4j.appender .fileorg.apache.log4j.RollingFileAppender log4j.appender .file.FileClog4j-application. log log4j.appender .file.MaxFileSize 5MB log4j.appender .file.MaxBackupIndex 10 log4j.appender .file.layoutorg.apache.log4j.PatternLayout log4j.appender .file.layout.ConversionPattern dyyyy-MM-dd HHmmss -5p c1L - mn If", "you are using maven, put this propertie \ufb01le in path ProjectFolder srcjavaresources Section 116.4 Basic log4j2.xml con\ufb01guration \ufb01le ?xml version1.0 encoding UTF-8? Configuration Appenders Console nameSTDOUT targetSYSTEMOUT PatternLayout patternd -5p t C2 mn Console Appenders Loggers Root leveldebug AppenderRef refSTDOUT Root Loggers Configuration This is a basic log4j2.xml con\ufb01guration which has a console appender and a root logger. The pattern layout speci\ufb01es which pattern should be used for logging the statements. In order to debug the loading of log4j2.xml you can add the attribute status WARN DEBUG ERROR FATAL TRACE INFO in the con\ufb01guration tag of your log4j2.xml. You can also add a monitor interval so that it loads the con\ufb01guration again after the speci\ufb01ed interval period. The monitor interval can be added to the con\ufb01guration tag as follows monitorInterval 30. It means that the con\ufb01g will be loaded every 30 seconds. Section 116.5 How to use Log4j in Java code First need to create a final static logger object final static Logger logger Logger. getLogger classname. class Then, call logging methods logs an error message logger.infoInformation about some param parameter Note that this line could throw a NullPointerException! in order to improve performance, it is advised to use", "the isXXXEnabled Methods if logger. isInfoEnabled logger. infoInformation about some param parameter In log4j2 parameter substitution is preferable due to readability and performance The parameter substitution only takes place if info level is active which obsoletes the use of GoalKicker.com Java Notes for Professionals 637isXXXEnabled. logger.infoInformation about some param , parameter logs an exception logger.errorInformation about some error , exception Section 116.6 Migrating from log4j 1.x to 2.x If you want to migrate from existing log4j 1.x in your project to log4j 2.x then remove all existing log4j 1.x dependencies and add the following dependency Log4j 1.x API Bridge Maven Build dependencies dependency groupId org.apache.logging.log4j groupId artifactId log4j-1.2-api artifactId version 2.6.2version dependency dependencies Ivy Build dependencies dependency orgorg.apache.logging.log4j namelog4j-1.2-api rev2.6.2 dependencies Gradle Build dependencies compile group org.apache.logging.log4j , name log4j-1.2-api , version 2.6.2 Apache Commons Logging Bridge If your project is using Apache Commons Logging which use log4j 1.x and you want to migrate it to log4j 2.x then add the following dependencies Maven Build dependencies dependency groupId org.apache.logging.log4j groupId artifactId log4j-jcl artifactId version 2.6.2version dependency dependencies Ivy Build dependencies dependency orgorg.apache.logging.log4j namelog4j-jcl rev2.6.2 dependencies Gradle Build GoalKicker.com Java Notes for Professionals 638dependencies compile group org.apache.logging.log4j , name log4j-jcl", ", version 2.6.2 Note Do not remove any existing dependencies of Apache commons logging Reference httpslogging.apache.orglog4j2.xmaven-artifacts.html Section 116.7 Filter Logoutput by level log4j 1.x You can use a \ufb01lter to log only messages lower than e.g. ERROR level. But the \ufb01lter is not supported by PropertyCon\ufb01gurator. So you must change to XML con\ufb01g to use it . See log4j-Wiki about \ufb01lters . Example speci\ufb01c level appender nameinfo-out classorg.apache.log4j.FileAppender param nameFile valueinfo.log layout classorg.apache.log4j.PatternLayout param nameConversionPattern valuemn layout filter classorg.apache.log4j.varia.LevelMatchFilter param nameLevelToMatch valueinfo param nameAcceptOnMatch valuetrue filter filter classorg.apache.log4j.varia.DenyAllFilter appender Or Level range appender nameinfo-out classorg.apache.log4j.FileAppender param nameFile valueinfo.log layout classorg.apache.log4j.PatternLayout param nameConversionPattern valuemn layout filter classorg.apache.log4j.varia.LevelRangeFilter param nameLevelMax valueinfo param nameLevelMin valueinfo param nameAcceptOnMatch valuetrue filter appender GoalKicker.com Java Notes for Professionals 639Chapter 117 Oracle Ocial Code Standard Oracle o\ufb03cial style guide for the Java Programming Language is a standard followed by developers at Oracle and recommended to be followed by any other Java developer. It covers \ufb01lenames, \ufb01le organization, indentation, comments, declarations, statements, white space, naming conventions, programming practices and includes a code example. Section 117.1 Naming Conventions Package names Package names should be all lower case without underscores or other special characters. Package names begin with the", "reversed authority part of the web address of the company of the developer. This part can be followed a by projectprogram structure dependent package substructure. Dont use plural form. Follow the convention of the standard API which uses for instance java.lang.annotation and not java.lang.annotations . Examples com.yourcompany .widget.button , com.yourcompany .core.api Class, Interface and Enum Names Class and enum names should typically be nouns. Interface names should typically be nouns or adjectives ending with able. Use mixed case with the \ufb01rst letter in each word in upper case i.e. CamelCase . Match the regular expression A-Za-zA-Z0-9. Use whole words and avoid using abbreviations unless the abbreviation is more widely used than the long form. Format an abbreviation as a word if the it is part of a longer class name. Examples ArrayList , BigInteger , ArrayIndexOutOfBoundsException , Iterable . Method Names Method names should typically be verbs or other descriptions of actions They should match the regular expression a-za-zA-Z0-9. Use mixed case with the \ufb01rst letter in lower case. Examples toString , hashCode Variables Variable names should be in mixed case with the \ufb01rst letter in lower case Match the regular expression a-za-zA-Z0-9 Further recommendation Variables Examples elements ,", "currentIndex Type Variables For simple cases where there are few type variables involved use a single upper case letter. Match the regular expression A-Z0-9? If one letter is more descriptive than another such as K and V for keys and values in maps or R for a function return type use that, otherwise use T. For complex cases where single letter type variables become confusing, use longer names written in all capital letters and use underscore to separate words. GoalKicker.com Java Notes for Professionals 640Examples T, V, SRCVERTEX Constants Constants static final \ufb01elds whose content is immutable, by language rules or by convention should be named with all capital letters and underscore to separate words. Match the regular expression A-ZA-Z0-9A-Z0-9 Examples BUFFERSIZE , MAXLEVEL Other guidelines on naming Avoid hidingshadowing methods, variables and type variables in outer scopes. Let the verbosity of the name correlate to the size of the scope. For instance, use descriptive names for \ufb01elds of large classes and brief names for local short-lived variables. When naming public static members, let the identi\ufb01er be self descriptive if you believe they will be statically imported. Further reading Naming Section in the o\ufb03cial Java Style Guide Source Java", "Style Guidelines from Oracle Section 117.2 Class Structure Order of class members Class members should be ordered as follows Fields in order of public, protected and private1. Constructors2. Factory methods3. Other Methods in order of public, protected and private4. Ordering \ufb01elds and methods primarily by their access modi\ufb01ers or identi\ufb01er is not required. Here is an example of this order class Example private int i Example int i this.i i static Example getExample int i return new Example i Override public String toString return An example i Grouping of class members GoalKicker.com Java Notes for Professionals 641Related \ufb01elds should be grouped together. A nested type may be declared right before its \ufb01rst use otherwise it should be declared before the \ufb01elds. Constructors and overloaded methods should be grouped together by functionality and ordered with increasing arity. This implies that delegation among these constructs \ufb02ow downward in the code. Constructors should be grouped together without other members between. Overloaded variants of a method should be grouped together without other members between. Section 117.3 Annotations Declaration annotations should be put on a separate line from the declaration being annotated. SuppressWarnings unchecked public T toArray T typeHolder ... However, few or short", "annotations annotating a single-line method may be put on the same line as the method if it improves readability. For example, one may write Nullable String getName return name For a matter of consistency and readability, either all annotations should be put on the same line or each annotation should be put on a separate line. Bad. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Even worse. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Good. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Good. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Section 117.4 Import statements First javajavax packages import java.util.ArrayList import javax.tools.JavaCompiler GoalKicker.com Java Notes for Professionals 642 Then third party libraries import com.fasterxml.jackson.annotation.JsonProperty Then project imports import com.example.my.package.ClassA import com.example.my.package.ClassB Then static imports in the same order as above import static java.util.stream.Collectors .toList Import statements should be sorted primarily by non-static static with non-static imports \ufb01rst. secondarily by package origin according to the following order java packages javax packages external packages e.g. org.xml internal packages e.g. com.sun tertiary by package and class identi\ufb01er in lexicographical order Import statements should not be line wrapped, regardless of whether it exceeds the recommended maximum length", "of a line. No unused imports should be present. Wildcard imports Wildcard imports should in general not be used. When importing a large number of closely-related classes such as implementing a visitor over a tree with dozens of distinct node classes, a wildcard import may be used. In any case, no more than one wildcard import per \ufb01le should be used. Section 117.5 Braces class Example void methodboolean error if error Log. errorError occurred! System.out.printlnError! else Use braces since the other block uses braces. System.out.printlnNo error Opening braces should be put on the end of the current line rather than on a line by its own. There should be a new line in front of a closing brace unless the block is empty see Short Forms below Braces are recommended even where the language makes them optional, such as single-line if and loop bodies. If a block spans more than one line including comments it must have braces. If one of the blocks in a if else statement has braces, the other block must too. If the block comes last in an enclosing block, it must have braces. The else , catch and the while keyword in dowhile loops", "go on the same line as the closing brace of the GoalKicker.com Java Notes for Professionals 643preceding block. Short forms enum Response YES, NO, MAYBE public boolean isReference return true The above recommendations are intended to improve uniformity and thus increase familiarity readability. In some cases short forms that deviate from the above guidelines are just as readable and may be used instead. These cases include for instance simple enum declarations and trivial methods and lambda expressions. Section 117.6 Redundant Parentheses return flag ? yes no String cmp flag1 ! flag2 ? not equal equal Dont do this return flag ? yes no Redundant grouping parentheses i.e. parentheses that does not a\ufb00ect evaluation may be used if they improve readability. Redundant grouping parentheses should typically be left out in shorter expressions involving common operators but included in longer expressions or expressions involving operators whose precedence and associativity is unclear without parentheses. Ternary expressions with non-trivial conditions belong to the latter. The entire expression following a return keyword must not be surrounded by parentheses. Section 117.7 Modi\ufb01ers class ExampleClass Access modifiers first dont do for instance static public public static void mainString args System.out.printlnHello World interface ExampleInterface Avoid public and", "abstract since they are implicit void sayHello Modi\ufb01ers should go in the following order Access modi\ufb01er public private protected abstract static final transient volatile default synchronized native strictfp GoalKicker.com Java Notes for Professionals 644Modi\ufb01ers should not be written out when they are implicit. For example, interface methods should neither be declared public nor abstract , and nested enums and interfaces should not be declared static. Method parameters and local variables should not be declared final unless it improves readability or documents an actual design decision. Fields should be declared final unless there is a compelling reason to make them mutable. Section 117.8 Indentation Indentation level is four spaces . Only space characters may be used for indentation. No tabs. Empty lines must not be indented. This is implied by the no trailing white space rule. case lines should be indented with four spaces, and statements within the case should be indented with another four spaces. switch var case TWO setChoice two break case THREE setChoice three break default throw new IllegalArgumentException Refer to Wrapping statements for guidelines on how to indent continuation lines. Section 117.9 Literals long l 5432L int i 0x123 0xABC byte b 0b1010 float f1 1", "5432f float f2 0.123e4f double d1 1 5432d or 1 5432.0 double d2 0x1.3p2 long literals should use the upper case letter L su\ufb03x. Hexadecimal literals should use upper case letters A-F. All other numerical pre\ufb01xes, in\ufb01xes, and su\ufb03xes should use lowercase letters. Section 117.10 Package declaration package com.example.my.package The package declaration should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line. Section 117.11 Lambda Expressions Runnable r - System.out.printlnHello World Supplier String c - Hello World GoalKicker.com Java Notes for Professionals 645 Collectioncontains is a simple unary method and its behavior is clear from the context. A method reference is preferred here. appendFilter goodStrings contains A lambda expression is easier to understand than just tempMapput in this case trackTemperature time, temp - tempMap. puttime, temp Expression lambdas are preferred over single-line block lambdas. Method references should generally be preferred over lambda expressions. For bound instance method references, or methods with arity greater than one, a lambda expression may be easier to understand and therefore preferred. Especially if the behavior of the method is not clear from the context. The parameter types should be omitted unless they improve readability. If a lambda", "expression stretches over more than a few lines, consider creating a method. Section 117.12 Java Source Files All lines must be terminated with a line feed character LF, ASCII value 10 and not for instance CR or CRLF. There may be no trailing white space at the end of a line. The name of a source \ufb01le must equal the name of the class it contains followed by the .java extension, even for \ufb01les that only contain a package private class. This does not apply to \ufb01les that do not contain any class declarations, such as package-info.java . Section 117.13 Wrapping statements Source code and comments should generally not exceed 80 characters per line and rarely if ever exceed 100 characters per line, including indentation. The character limit must be judged on a case by case basis. What really matters is the semantical density and readability of the line. Making lines gratuitously long makes them hard to read similarly, making heroic attempts to \ufb01t them into 80 columns can also make them hard to read. The \ufb02exibility outlined here aims to enable developers to avoid these extremes, not to maximize use of monitor real-estate. URLs or example commands should", "not be wrapped. Ok even though it might exceed max line width when indented. Error e isTypeParam ? Errors. InvalidRepeatableAnnotationNotApplicable targetContainerType, on Errors. InvalidRepeatableAnnotationNotApplicableInContext targetContainerType Wrapping preferable String pretty Stream. ofargs . mapArgument prettyPrint . collectors joining, Too strict interpretation of max line width. Readability suffers. Error e isTypeParam ? Errors. InvalidRepeatableAnnotationNotApplicable targetContainerType, on Errors. InvalidRepeatableAnnotationNotApplicableInContext targetContainerType Should be wrapped even though it fits within the character limit GoalKicker.com Java Notes for Professionals 646String pretty Stream. ofargs.mapArgument prettyPrint .collectors joining, Wrapping at a higher syntactical level is preferred over wrapping at a lower syntactical level. There should be at most 1 statement per line. A continuation line should be indented in one of the following four ways Variant 1 With 8 extra spaces relative to the indentation of the previous line. Variant 2 With 8 extra spaces relative to the starting column of the wrapped expression. Variant 3 Aligned with previous sibling expression as long as it is clear that it s a continuation line Variant 4 Aligned with previous method call in a chained expression. Section 117.14 Wrapping Method Declarations int someMethod String aString, List Integer aList, Map String, String aMap, int anInt, long aLong, Set Number aSet,", "double aDouble int someMethod String aString, List Integer aList, Map String, String aMap, int anInt, long aLong, double aDouble, long aLong int someMethod String aString, List MapInteger, StringBuffer aListOfMaps, Map String, String aMap throws IllegalArgumentException int someMethod String aString, List Integer aList, Map String, String aMap, int anInt throws IllegalArgumentException Method declarations can be formatted by listing the arguments vertically, or by a new line and 8 extra spaces If a throws clause needs to be wrapped, put the line break in front of the throws clause and make sure it stands out from the argument list, either by indenting 8 relative to the function declaration, or 8 relative to the previous line. Section 117.15 Wrapping Expressions If a line approaches the maximum character limit, always consider breaking it down into multiple statements expressions instead of wrapping the line. Break before operators. Break before the . in chained method calls. GoalKicker.com Java Notes for Professionals 647popupMsg Inbox notification You have newMsgs new messages Dont! Looks like two arguments popupMsg Inbox notification You have newMsgs new messages Section 117.16 Whitespace Vertical Whitespace A single blank line should be used to separate Package declaration Class declarations Constructors Methods Static initializers Instance", "initializers and may be used to separate logical groups of import statements \ufb01elds statements Multiple consecutive blank lines should only be used to separate groups of related members and not as the standard inter-member spacing. Horizontal Whitespace A single space should be used To separate keywords from neighboring opening or closing brackets and braces Before and after all binary operators and operator like symbols such as arrows in lambda expressions and the colon in enhanced for loops but not before the colon of a label After that starts a comment. After commas separating arguments and semicolons separating the parts of a for loop. After the closing parenthesis of a cast. In variable declarations it is not recommended to align types and variables. Section 117.17 Special Characters Apart from LF the only allowed white space character is Space ASCII value 32. Note that this implies that other white space characters in, for instance, string and character literals must be written in escaped form. , , , t, b, r, f, and n should be preferred over corresponding octal e.g. 047 or Unicode e.g. u0027 escaped characters. Should there be a need to go against the above rules for the sake", "of testing, the test should generate the required input programmatically. GoalKicker.com Java Notes for Professionals 648Section 117.18 Variable Declarations One variable per declaration and at most one declaration per line Square brackets of arrays should be at the type String args and not on the variable String args. Declare a local variable right before it is \ufb01rst used, and initialize it as close to the declaration as possible. GoalKicker.com Java Notes for Professionals 649Chapter 118 Character encoding Section 118.1 Reading text from a \ufb01le encoded in UTF-8 import java.io.BufferedReader import java.io.BufferedWriter import java.io.IOException import java.nio.charset.StandardCharsets import java.nio.file.Files import java.nio.file.Paths public class ReadingUTF8TextFile public static void mainString args throws IOException StandardCharsets is available since Java 1.7 for ealier version use Charset.forNameUTF-8 try BufferedWriter wr Files.newBufferedWriter Paths.gettest.txt , StandardCharsets. UTF8 wr. writeStrange cyrillic symbol \u042b First Way. For big files try BufferedReader reader Files.newBufferedReader Paths.gettest.txt , StandardCharsets. UTF8 String line while line reader. readLine ! null System.out.printline System.out.println just separating output Second way. For small files String s new StringFiles.readAllBytes Paths.gettest.txt , StandardCharsets. UTF8 System.out.prints Section 118.2 Writing text to a \ufb01le in UTF-8 import java.io.BufferedWriter import java.io.IOException import java.nio.charset.StandardCharsets import java.nio.file.Files import java.nio.file.Paths public class WritingUTF8TextFile public static void mainString", "args throws IOException StandardCharsets is available since Java 1.7 for ealier version use Charset.forNameUTF-8 try BufferedWriter wr Files.newBufferedWriter Paths.gettest2.txt , StandardCharsets. UTF8 wr. writeCyrillic symbol \u042b GoalKicker.com Java Notes for Professionals 650Section 118.3 Getting byte representation of a string in UTF-8 import java.nio.charset.StandardCharsets import java.util.Arrays public class GetUtf8BytesFromString public static void mainString args String str Cyrillic symbol \u042b StandardCharsets is available since Java 1.7 for ealier version use Charset.forNameUTF-8 byte textInUtf8 str.getBytes StandardCharsets. UTF8 System.out.printlnArrays.toString textInUtf8 GoalKicker.com Java Notes for Professionals 651Chapter 119 Apache Commons Lang Section 119.1 Implement equals method To implement the equals method of an object easily you could use the EqualsBuilder class. Selecting the \ufb01elds Override public boolean equalsObject obj if!obj instanceof MyClass return false MyClass theOther MyClass obj EqualsBuilder builder new EqualsBuilder builder. appendfield1, theOther. field1 builder. appendfield2, theOther. field2 builder. appendfield3, theOther. field3 return builder. isEquals Using re\ufb02ection Override public boolean equalsObject obj return EqualsBuilder. reflectionEquals this, obj, false the boolean parameter is to indicates if the equals should check transient \ufb01elds. Using re\ufb02ection avoiding some \ufb01elds Override public boolean equalsObject obj return EqualsBuilder. reflectionEquals this, obj, field1 , field2 Section 119.2 Implement hashCode method To implement the hashCode method of an object", "easily you could use the HashCodeBuilder class. Selecting the \ufb01elds Override public int hashCode HashCodeBuilder builder new HashCodeBuilder builder. appendfield1 builder. appendfield2 builder. appendfield3 return builder. hashCode GoalKicker.com Java Notes for Professionals 652Using re\ufb02ection Override public int hashCode return HashCodeBuilder. reflectionHashCode this, false the boolean parameter indicates if it should use transient \ufb01elds. Using re\ufb02ection avoiding some \ufb01elds Override public int hashCode return HashCodeBuilder. reflectionHashCode this, field1 , field2 Section 119.3 Implement toString method To implement the toString method of an object easily you could use the ToStringBuilder class. Selecting the \ufb01elds Override public String toString ToStringBuilder builder new ToStringBuilder this builder. appendfield1 builder. appendfield2 builder. appendfield3 return builder. toString Example result ar.com.jonat.lang.MyClassdd7123null,0,false Explicitly giving names to the \ufb01elds Override public String toString ToStringBuilder builder new ToStringBuilder this builder. appendfield1 ,field1 builder. appendfield2 ,field2 builder. appendfield3 ,field3 return builder. toString Example result ar.com.jonat.lang.MyClassdd7404field1null,field20,field3false You could change the style via parameter Override GoalKicker.com Java Notes for Professionals 653public String toString ToStringBuilder builder new ToStringBuilder this, ToStringStyle. MULTILINESTYLE builder. appendfield1 , field1 builder. appendfield2 , field2 builder. appendfield3 , field3 return builder. toString Example result ar.com.bna.lang.MyClassebbf5c field1 null field2 0 field3 false There are some styles, for example JSON, no Classname,", "short, etc ... Via re\ufb02ection Override public String toString return ToStringBuilder. reflectionToString this You could also indicate the style Override public String toString return ToStringBuilder. reflectionToString this, ToStringStyle. JSONSTYLE GoalKicker.com Java Notes for Professionals 654Chapter 120 Localization and Internationalization Section 120.1 Locale The java.util.Locale class is used to represent a geographical, political or cultural region to localize a given text, number, date or operation to. A Locale object may thus contain a country, region, language, and also a variant of a language, for instance a dialect spoken in a certain region of a country, or spoken in a di\ufb00erent country than the country from which the language originates. The Locale instance is handed to components that need to localize their actions, whether it is converting the input, output, or just need it for internal operations. The Locale class cannot do any internationalization or localization by itself Language The language must be an ISO 639 2 or 3 character language code, or a registered language subtag of up to 8 characters. In case a language has both a 2 and 3 character language code, use the 2 character code. A full list of language codes can be found in the", "IANA Language Subtag Registry. Language codes are case insensitive, but the Locale class always use lowercase versions of the language codes Creating a Locale Creating a java.util.Locale instance can be done in four di\ufb00erent ways Locale constants Locale constructors Locale.Builder class Locale.forLanguageTag factory method Java ResourceBundle You create a ResourceBundle instance like this Locale locale new Localeen, US ResourceBundle labels ResourceBundle .getBundle i18n.properties System.out.printlnlabels.getString message Consider I have a property \ufb01le i18n.properties messageThis is locale Output This is locale Setting Locale If you want to reproduce the state using other languages, you can use setDefault method. Its usage setDefault Locale.JAPANESE Set Japanese GoalKicker.com Java Notes for Professionals 655Section 120.2 Automatically formatted Dates using locale SimpleDateFormatter is great in a pinch, but like the name suggests it doesnt scale well. If you hard-code MMddyyyy all over your application your international users wont be happy. Let Java do the work for you Use the static methods in DateFormat to retrieve the right formatting for your user. For a desktop application where youll rely on the default locale , simply call String localizedDate DateFormat .getDateInstance style.formatdate Where style is one of the formatting constants FULL , LONG , MEDIUM , SHORT ,", "etc. speci\ufb01ed in DateFormat . For a server-side application where the user speci\ufb01es their locale as part of the request, you should pass it explicitly to getDateInstance instead String localizedDate DateFormat .getDateInstance style, request. getLocale .formatdate Section 120.3 String Comparison Compare two Strings ignoring case School .equalsIgnoreCase school true Dont use text1.toLowerCase .equalstext2.toLowerCase Languages have di\ufb00erent rules for converting upper and lower case. A I would be converted to i in English. But in Turkish a I becomes a \u0131. If you have to use toLowerCase use the overload which expects a Locale String.toLowerCase Locale. Comparing two Strings ignoring minor di\ufb00erences Collator collator Collator .getInstance Locale.GERMAN collator. setStrength Collator .PRIMARY collator. equalsG\u00e4rten, gaerten returns true Sort Strings respecting natural language order, ignoring case use collation key to String texts new String Birne, \u00e4ther, Apfel Collator collator Collator .getInstance Locale.GERMAN collator. setStrength Collator .SECONDARY ignore case Arrays.sorttexts, collator compare will return Apfel, \u00e4ther, Birne GoalKicker.com Java Notes for Professionals 656Chapter 121 Parallel programming with ForkJoin framework Section 121.1 ForkJoin Tasks in Java The forkjoin framework in Java is ideal for a problem that can be divided into smaller pieces and solved in parallel. The fundamental steps of a forkjoin problem", "are Divide the problem into multiple pieces Solve each of the pieces in parallel to each other Combine each of the sub-solutions into one overall solution A ForkJoinTask is the interface that de\ufb01nes such a problem. It is generally expected that you will subclass one of its abstract implementations usually the RecursiveTask rather than implement the interface directly. In this example, we are going to sum a collection of integers, dividing until we get to batch sizes of no more than ten. import java.util.List import java.util.concurrent.RecursiveTask public class SummingTask extends RecursiveTask Integer private static final int MAXBATCHSIZE 10 private final ListInteger numbers private final int minInclusive, maxExclusive public SummingTask ListInteger numbers thisnumbers, 0, numbers. size This constructor is only used internally as part of the dividing process private SummingTask ListInteger numbers, int minInclusive, int maxExclusive this.numbers numbers this.minInclusive minInclusive this.maxExclusive maxExclusive Override public Integer compute if maxExclusive - minInclusive MAXBATCHSIZE This is too big for a single batch, so we shall divide into two tasks int mid minInclusive maxExclusive 2 SummingTask leftTask new SummingTask numbers, minInclusive, mid SummingTask rightTask new SummingTask numbers, mid, maxExclusive Submit the left hand task as a new task to the same ForkJoinPool leftTask. fork", "Run the right hand task on the same thread and get the result int rightResult rightTask. compute Wait for the left hand task to complete and get its result int leftResult leftTask. join And combine the result return leftResult rightResult else GoalKicker.com Java Notes for Professionals 657 This is fine for a single batch, so we will run it here and now int sum 0 for int i minInclusive i maxExclusive i sum numbers. geti return sum An instance of this task can now be passed to an instance of ForkJoinPool . Because I am not specifying the number of threads it will create a thread for each available processor ForkJoinPool pool new ForkJoinPool Submit the task to the pool, and get what is effectively the Future ForkJoinTask Integer task pool.submitnew SummingTask numbers Wait for the result int result task.join GoalKicker.com Java Notes for Professionals 658Chapter 122 Non-Access Modi\ufb01ers Non-Access Modi\ufb01ers do not change the accessibility of variables and methods, but they do provide them special properties . Section 122.1 \ufb01nal final in Java can refer to variables, methods and classes. There are three simple rules \ufb01nal variable cannot be reassigned \ufb01nal method cannot be overridden \ufb01nal class cannot", "be extended Usages Good Programming Practice Some developer consider it good practice to mark a variable \ufb01nal when you can. If you have a variable that should not be changed, you should mark it \ufb01nal. An important use of final keyword if for method parameters. If you want to emphasize that a method doesnt change its input parameters, mark the properties as \ufb01nal. public int sumupfinal ListInteger ints This emphasizes that the sumup method is not going to change the ints . Inner class Access If your anonymous inner class wants to access a variable, the variable should be marked final public IPrintName printName String name return new IPrintName Override public void printName System.out.printlnname This class doesnt compile, as the variable name , is not \ufb01nal. Version Java SE 8 E\ufb00ectively \ufb01nal variables are an exception. These are local variables that are written to only once and could therefore be made \ufb01nal. E\ufb00ectively \ufb01nal variables can be accessed from anonymus classes too. final static variable Even though the code below is completely legal when final variable foo is not static , in case of static it will not compile class TestFinal private final static List foo GoalKicker.com Java Notes", "for Professionals 659 public Test foo new ArrayList The reason is, lets repeat again, \ufb01nal variable cannot be reassigned . Since foo is static, it is shared among all instances of class TestFinal . When a new instance of a class TestFinal is created, its constructor is invoked and therefore foo gets reassigned which compiler does not allow. A correct way to initialize variable foo in this case is either class TestFinal private static final List foo new ArrayList .. or by using a static initializer class TestFinal private static final List foo static foo new ArrayList .. final methods are useful when base class implements some important functionality that derived class is not supposed to change it. They are also faster than non-\ufb01nal methods, because there is no concept of virtual table involved. All wrapper classes in Java are \ufb01nal, such as Integer , Long etc. Creators of these classes didnt want that anyone can e.g. extend Integer into his own class and change the basic behavior of Integer class. One of the requirements to make a class immutable is that subclasses may not override methods. The simplest way to do this is to declare the class as", "final . Section 122.2 static The static keyword is used on a class, method, or \ufb01eld to make them work independently of any instance of the class. Static \ufb01elds are common to all instances of a class. They do not need an instance to access them. Static methods can be run without an instance of the class they are in. However, they can only access static \ufb01elds of that class. Static classes can be declared inside of other classes. They do not need an instance of the class they are in to be instantiated. public class TestStatic static int staticVariable static This block of code is run when the class first loads staticVariable 11 int nonStaticVariable 5 static void doSomething GoalKicker.com Java Notes for Professionals 660 We can access static variables from static methods staticVariable 10 void add We can access both static and non-static variables from non-static methods nonStaticVariable staticVariable static class StaticInnerClass int number public StaticInnerClass int number number number void doSomething We can access number and staticVariable, but not nonStaticVariable number staticVariable int getNumber return number Static fields and methods TestStatic object1 new TestStatic System.out.printlnobject1. staticVariable 11 System.out.printlnTestStatic. staticVariable 11 TestStatic. doSomething TestStatic object2 new TestStatic", "System.out.printlnobject1. staticVariable 10 System.out.printlnobject2. staticVariable 10 System.out.printlnTestStatic. staticVariable 10 object1. add System.out.printlnobject1. nonStaticVariable 15 System.out.printlnobject2. nonStaticVariable 10 Static inner classes StaticInnerClass object3 new TestStatic. StaticInnerClass 100 StaticInnerClass object4 new TestStatic. StaticInnerClass 200 System.out.printlnobject3. getNumber 100 System.out.printlnobject4. getNumber 200 object3. doSomething System.out.printlnobject3. getNumber 110 System.out.printlnobject4. getNumber 200 Section 122.3 abstract Abstraction is a process of hiding the implementation details and showing only functionality to the user. An abstract GoalKicker.com Java Notes for Professionals 661class can never be instantiated. If a class is declared as abstract then the sole purpose is for the class to be extended. abstract class Car abstract void tagLine class Honda extends Car void tagLine System.out.printlnStart Something Special class Toyota extends Car void tagLine System.out.printlnDrive Your Dreams Section 122.4 strictfp Version Java SE 1.2 strictfp modi\ufb01er is used for \ufb02oating-point calculations. This modi\ufb01er makes \ufb02oating point variable more consistent across multiple platforms and ensure all the \ufb02oating point calculations are done according to IEEE 754 standards to avoid errors of calculation round-o\ufb00 errors, over\ufb02ows and under\ufb02ows on both 32bit and 64bit architecture. This cannot be applied on abstract methods, variables or constructors. strictfp keyword can be applied on methods, classes and interfaces. strictfp class A strictfp interface", "M class A strictfp void m Section 122.5 volatile The volatile modi\ufb01er is used in multi threaded programming. If you declare a \ufb01eld as volatile it is a signal to threads that they must read the most recent value, not a locally cached one. Furthermore, volatile reads and writes are guaranteed to be atomic access to a non- volatile long or double is not atomic, thus avoiding certain readwrite errors between multiple threads. public class MyRunnable implements Runnable private volatile boolean active public void run run is called in one thread active true while active some code here GoalKicker.com Java Notes for Professionals 662 public void stop stop is called from another thread active false Section 122.6 synchronized Synchronized modi\ufb01er is used to control the access of a particular method or a block by multiple threads. Only one thread can enter into a method or a block which is declared as synchronized. synchronized keyword works on intrinsic lock of an object, in case of a synchronized method current objects lock and static method uses class object. Any thread trying to execute a synchronized block must acquire the object lock \ufb01rst. class Shared int i synchronized void SharedMethod Thread t", "Thread.currentThread forint i 0 i 1000 i System.out.printlnt.getName i void SharedMethod2 synchronized this System.out.printlnThais access to currect object is synchronize this public class ThreadsInJava public static void mainString args final Shared s1 new Shared Thread t1 new ThreadThread - 1 Override public void run s1. SharedMethod Thread t2 new ThreadThread - 2 Override public void run s1. SharedMethod GoalKicker.com Java Notes for Professionals 663 t1. start t2. start Section 122.7 transient A variable which is declared as transient will not be serialized during object serialization. public transient int limit 55 will not persist public int b will persist GoalKicker.com Java Notes for Professionals 664Chapter 123 Process Section 123.1 Pitfall Runtime.exec, Process and ProcessBuilder dont understand shell syntax The Runtime.execString ... and Runtime.execString methods allow you to execute a command as an external process1. In the \ufb01rst version, you supply the command name and the command arguments as separate elements of the string array, and the Java runtime requests the OS runtime system to start the external command. The second version is deceptively easy to use, but it has some pitfalls. First of all, here is an example of using execString being used safely Process p Runtime.execmkdir tmptestDir p.waitFor if", "p.exitValue 0 System.out.printlncreated the directory Spaces in pathnames Suppose that we generalize the example above so that we can create an arbitrary directory Process p Runtime.execmkdir dirPath ... This will typically work, but it will fail if dirPath is for example homeuserMy Documents. The problem is that execString splits the string into a command and arguments by simply looking for whitespace. The command string mkdir homeuserMy Documents will be split into mkdir, homeuserMy , Documents and this will cause the mkdir command to fail because it expects one argument, not two. Faced with this, some programmers try to add quotes around the pathname. This doesnt work either mkdir homeuserMy Documents will be split into mkdir, homeuserMy , Documents The extra double-quote characters that were added in attempt to quote the spaces are treated like any other non- whitespace characters. Indeed, anything we do quote or escape the spaces is going to fail. The way to deal with this particular problems is to use the execString ... overload. Process p Runtime.execmkdir, dirPath ... GoalKicker.com Java Notes for Professionals 665This will work if dirpath includes whitespace characters because this overload of exec does not attempt to split the arguments. The strings", "are passed through to the OS exec system call as-is. Redirection, pipelines and other shell syntax Suppose that we want to redirect an external commands input or output, or run a pipeline. For example Process p Runtime.execfind -name .java -print 2devnull or Process p Runtime.execfind source -name .java xargs grep package The \ufb01rst example lists the names of all Java \ufb01les in the \ufb01le system, and the second one prints the package statements2 in the Java \ufb01les in the source tree. These are not going to work as expected. In the \ufb01rst case, the \ufb01nd command will be run with 2devnull as a command argument. It will not be interpreted as a redirection. In the second example, the pipe character and the works following it will be given to the \ufb01nd command. The problem here is that the exec methods and ProcessBuilder do not understand any shell syntax. This includes redirections, pipelines, variable expansion, globbing, and so on. In a few cases for example, simple redirection you can easily achieve the desired e\ufb00ect using ProcessBuilder . However, this is not true in general. An alternative approach is to run the command line in a shell for example Process p", "Runtime.execbash, -c, find -name .java -print 2devnull or Process p Runtime.execbash, -c, find source -name .java xargs grep package But note that in the second example, we needed to escape the wildcard character because we want the wildcard to be interpreted by \ufb01nd rather than the shell. Shell builtin commands dont work Suppose the following examples wont work on a system with a UNIX-like shell Process p Runtime.execcd, tmp Change java apps home directory or Process p Runtime.execexport , NAMEvalue Export NAME to the java apps environment There are a couple of reasons why this wont work On cd and export commands are shell builtin commands. They dont exist as distinct executables.1. For shell builtins to do what they are supposed to do e.g. change the working directory, update the2. environment, they need to change the place where that state resides. For a normal application including a Java application the state is associated with the application process. So for example, the child process that would run the cd command could not change the working directory of its parent java process. Similarly, GoalKicker.com Java Notes for Professionals 666one exec d process cannot change the working directory for a process that", "follows it. This reasoning applies to all shell builtin commands. 1 - You can use ProcessBuilder as well, but that is not relevant to the point of this example. 2 - This is a bit rough and ready ... but once again, the failings of this approach are not relevant to the example. Section 123.2 Simple example Java version 1.5 This example will call the windows calculator. Its important to notice that the exit code will vary accordingly to the programscript that is being called. package process.example import java.io.IOException public class App public static void mainString args try Executes windows calculator Process p Runtime.getRuntime .execcalc.exe Wait for process until it terminates int exitCode p.waitFor System.out.printlnexitCode catch IOException e e. printStackTrace catch InterruptedException e e. printStackTrace GoalKicker.com Java Notes for Professionals 667Chapter 124 Java Native Access Section 124.1 Introduction to JNA What is JNA? Java Native Access JNA is a community-developed library providing Java programs an easy access to native shared libraries .dll \ufb01les on windows, .so \ufb01les on Unix ... How can I use it? Firstly, download the latest release of JNA and reference its jna.jar in your projects CLASSPATH. Secondly, copy, compile and run the Java code below", "For the purpose of this introduction, we suppose the native platform in use is Windows. If youre running on another platform simply replace the string msvcrt with the string c in the code below. The small Java program below will print a message on the console by calling the C printf function. CRuntimeLibrary.java package jna.introduction import com.sun.jna.Library import com.sun.jna.Native We declare the printf function we need and the library containing it msvcrt... public interface CRuntimeLibrary extends Library CRuntimeLibrary INSTANCE CRuntimeLibrary Native.loadLibrary msvcrt , CRuntimeLibrary. class void printfString format, Object... args MyFirstJNAProgram.java package jna.introduction Now we call the printf function... public class MyFirstJNAProgram public static void mainString args CRuntimeLibrary. INSTANCE .printfHello World from JNA ! Where to go now? Jump into another topic here or jump to the o\ufb03cial site . GoalKicker.com Java Notes for Professionals 668Chapter 125 Modules Section 125.1 De\ufb01ning a basic module Modules are de\ufb01ned in a \ufb01le named module-info.java , named a module descriptor. It should be placed in the source-code root -- module-info.java -- com -- example -- foo -- Foo.java -- bar -- Bar.java Here is a simple module descriptor module com. example requires java. httpclient exports com. example.foo The module name should be", "unique and it is recommended that you use the same Reverse-DNS naming notation as used by packages to help ensure this. The module java.base , which contains Javas basic classes, is implicitly visible to any module and does not need to be included. The requires declaration allows us to use other modules, in the example the module java.httpclient is imported. A module can also specify which packages it exports and therefore makes it visible to other modules. The package com.example.foo declared in the exports clause will be visible to other modules. Any sub-packages of com.example.foo will not be exported, they need their own export declarations. Conversely, com.example.bar which is not listed in exports clauses will not be visible to other modules. GoalKicker.com Java Notes for Professionals 669Chapter 126 Concurrent Programming Threads Concurrent computing is a form of computing in which several computations are executed concurrently instead of sequentially. Java language is designed to support concurrent programming through the usage of threads. Objects and resources can be accessed by multiple threads each thread can potentially access any object in the program and the programmer must ensure read and write access to objects is properly synchronized between threads. Section 126.1 Callable", "and Future While Runnable provides a means to wrap code to be executed in a di\ufb00erent thread, it has a limitation in that it cannot return a result from the execution. The only way to get some return value from the execution of a Runnable is to assign the result to a variable accessible in a scope outside of the Runnable . Callable was introduced in Java 5 as a peer to Runnable . Callable is essentially the same except it has a call method instead of run. The call method has the additional capability to return a result and is also allowed to throw checked exceptions. The result from a Callable task submission is available to be tapped via a Future Future can be considered a container of sorts that houses the result of the Callable computation. Computation of the callable can carry on in another thread, and any attempt to tap the result of a Future will block and will only return the result once it is available. Callable Interface public interface Callable V V call throws Exception Future interface FutureV V get V get long timeout, TimeUnit unit boolean cancelboolean mayInterruptIfRunning boolean isCancelled boolean isDone Using", "Callable and Future example public static void mainString args throws Exception ExecutorService es Executors. newSingleThreadExecutor System.out.printlnTime At Task Submission new Date Future String result es.submitnew ComplexCalculator the call to Future.get blocks until the result is available.So we are in for about a 10 sec wait now System.out.printlnResult of Complex Calculation is result. get System.out.printlnTime At the Point of Printing the Result new Date Our Callable that does a lengthy computation GoalKicker.com Java Notes for Professionals 670public class ComplexCalculator implements Callable String Override public String call throws Exception just sleep for 10 secs to simulate a lengthy computation Thread.sleep10000 System.out.printlnResult after a lengthy 10sec calculation return Complex Result the result Output Time At Task Submission Thu Aug 04 150515 EDT 2016 Result after a lengthy 10sec calculation Result of Complex Calculation is Complex Result Time At the Point of Printing the Result Thu Aug 04 150525 EDT 2016 Other operations permitted on Future While get is the method to extract the actual result Future has provision getlong timeout, TimeUnit unit de\ufb01nes maximum time period during current thread will wait for a result To cancel the task call cancelmayInterruptIfRunning . The \ufb02ag mayInterrupt indicates that task should be interrupted if it", "was started and is running right now To check if task is completed\ufb01nished by calling isDone To check if the lengthy task were cancelled isCancelled . Section 126.2 CountDownLatch CountDownLatch A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. A CountDownLatch is initialized with a given count. 1. The await methods block until the current count reaches zero due to invocations of the countDown method, 2. after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon the count cannot be reset. If you need a version that resets the count, 3. consider using a CyclicBarrier . Key Methods public void await throws InterruptedException Causes the current thread to wait until the latch has counted down to zero, unless the thread is interrupted. public void countDown GoalKicker.com Java Notes for Professionals 671Decrements the count of the latch, releasing all waiting threads if the count reaches zero. Example import java.util.concurrent. class DoSomethingInAThread implements Runnable CountDownLatch latch public DoSomethingInAThread CountDownLatch latch this.latch latch public void run try System.out.printlnDo some thing latch. countDown catchException err err. printStackTrace public class CountDownLatchDemo", "public static void mainString args try int numberOfThreads 5 if args.length 1 System.out.printlnUsage java CountDownLatchDemo numberOfThreads return try numberOfThreads Integer.parseInt args0 catchNumberFormatException ne CountDownLatch latch new CountDownLatch numberOfThreads for int n 0 n numberOfThreads n Thread t new Threadnew DoSomethingInAThread latch t. start latch. await System.out.printlnIn Main thread after completion of numberOfThreads threads catchException err err. printStackTrace output java CountDownLatchDemo 5 Do some thing Do some thing Do some thing Do some thing Do some thing In Main thread after completion of 5 threads Explanation GoalKicker.com Java Notes for Professionals 672CountDownLatch is initialized with a counter of 5 in Main thread 1. Main thread is waiting by using await method. 2. Five instances of DoSomethingInAThread have been created. Each instance decremented the counter with 3. countDown method. Once the counter becomes zero, Main thread will resume4. Section 126.3 Basic Multithreading If you have many tasks to execute, and all these tasks are not dependent of the result of the precedent ones, you can use Multithreading for your computer to do all this tasks at the same time using more processors if your computer can. This can make your program execution faster if you have some big independent tasks. class", "CountAndPrint implements Runnable private final String name CountAndPrint String name this.name name This is what a CountAndPrint will do Override public void run for int i 0 i 10000 i System.out.printlnthis.name i public static void mainString args Launching 4 parallel threads for int i 1 i 4 i start method will call the run method of CountAndPrint in another thread new Threadnew CountAndPrint Instance i.start Doing some others tasks in the main Thread for int i 0 i 10000 i System.out.printlnMain i The code of the run method of the various CountAndPrint instances will execute in non predictable order. A snippet of a sample execution might look like this Instance 4 1 Instance 2 1 Instance 4 2 Instance 1 1 Instance 1 2 Main 1 Instance 4 3 Main 2 Instance 3 1 Instance 4 4 ... GoalKicker.com Java Notes for Professionals 673Section 126.4 Locks as Synchronisation aids Prior to Java 5s concurrent package introduction threading was more low level.The introduction of this package provided several higher level concurrent programming aidsconstructs. Locks are thread synchronisation mechanisms that essentially serve the same purpose as synchronized blocks or key words. Intrinsic Locking int count 0 shared among multiple threads public", "void doSomething synchronized this count a non-atomic operation Synchronisation using Locks int count 0 shared among multiple threads Lock lockObj new ReentrantLock public void doSomething try lockObj. lock count a non-atomic operation finally lockObj. unlock sure to release the lock without fail Locks also have functionality available that intrinsic locking does not o\ufb00er, such as locking but remaining responsive to interruption, or trying to lock, and not block when unable to. Locking, responsive to interruption class Locky int count 0 shared among multiple threads Lock lockObj new ReentrantLock public void doSomething try try lockObj. lockInterruptibly count a non-atomic operation catch InterruptedException e Thread.currentThread .interrupt stopping finally if !Thread.currentThread .isInterrupted lockObj. unlock sure to release the lock without fail GoalKicker.com Java Notes for Professionals 674Only do something when able to lock public class Locky2 int count 0 shared among multiple threads Lock lockObj new ReentrantLock public void doSomething boolean locked lockObj. tryLock returns true upon successful lock if locked try count a non-atomic operation finally lockObj. unlock sure to release the lock without fail There are several variants of lock available.For more details refer the api docs here Section 126.5 Semaphore A Semaphore is a high-level synchronizer that maintains a", "set of permits that can be acquired and released by threads. A Semaphore can be imagined as a counter of permits that will be decremented when a thread acquires, and incremented when a thread releases. If the amount of permits is 0 when a thread attempts to acquire, then the thread will block until a permit is made available or until the thread is interrupted. A semaphore is initialized as Semaphore semaphore new Semaphore 1 The int value being the number of permits The Semaphore constructor accepts an additional boolean parameter for fairness. When set false, this class makes no guarantees about the order in which threads acquire permits. When fairness is set true, the semaphore guarantees that threads invoking any of the acquire methods are selected to obtain permits in the order in which their invocation of those methods was processed. It is declared in the following manner Semaphore semaphore new Semaphore 1, true Now lets look at an example from javadocs, where Semaphore is used to control access to a pool of items. A Semaphore is used in this example to provide blocking functionality in order to ensure that there are always items to be obtained when", "getItem is called. class Pool Note that this DOES NOT bound the amount that may be released! This is only a starting value for the Semaphore and has no other significant meaning UNLESS you enforce this inside of the getNextAvailableItem and markAsUnused methods private static final int MAXAVAILABLE 100 private final Semaphore available new Semaphore MAXAVAILABLE, true Obtains the next available item and reduces the permit count by 1. If there are no items available, block. public Object getItem throws InterruptedException GoalKicker.com Java Notes for Professionals 675 available. acquire return getNextAvailableItem Puts the item into the pool and add 1 permit. public void putItem Object x if markAsUnused x available. release private Object getNextAvailableItem Implementation private boolean markAsUnused Object o Implementation Section 126.6 Synchronization In Java, there is a built-in language-level locking mechanism the synchronized block, which can use any Java object as an intrinsic lock i.e. every Java object may have a monitor associated with it. Intrinsic locks provide atomicity to groups of statements. To understand what that means for us, lets have a look at an example where synchronized is useful private static int t 0 private static Object mutex new Object public static void mainString args", "ExecutorService executorService Executors. newFixedThreadPool 400 The high thread count is for demonstration purposes. for int i 0 i 100 i executorService. execute - synchronized mutex t System.out.printlnMessageFormat .formatt 0 , t executorService. shutdown In this case, if it werent for the synchronized block, there would have been multiple concurrency issues involved. The \ufb01rst one would be with the post increment operator it isnt atomic in itself, and the second would be that we would be observing the value of t after an arbitrary amount of other threads has had the chance to modify it. However, since we acquired an intrinsic lock, there will be no race conditions here and the output will contain numbers from 1 to 100 in their normal order. Intrinsic locks in Java are mutexes i.e. mutual execution locks. Mutual execution means that if one thread has acquired the lock, the second will be forced to wait for the \ufb01rst one to release it before it can acquire the lock for itself. Note An operation that may put the thread into the wait sleep state is called a blocking operation . Thus, acquiring a lock is a blocking operation. Intrinsic locks in Java are reentrant .", "This means that if a thread attempts to acquire a lock it already owns, it will not GoalKicker.com Java Notes for Professionals 676block and it will successfully acquire it. For instance, the following code will not block when called public void bar synchronized this ... public void foo synchronized this bar Beside synchronized blocks, there are also synchronized methods. The following blocks of code are practically equivalent even though the bytecode seems to be di\ufb00erent synchronized block on this 1. public void foo synchronized this doStuff synchronized method 2. public synchronized void foo doStuff Likewise for static methods, this class MyClass ... public static void bar synchronized MyClass. class doSomeOtherStuff has the same e\ufb00ect as this class MyClass ... public static synchronized void bar doSomeOtherStuff Section 126.7 Runnable Object The Runnable interface de\ufb01nes a single method, run, meant to contain the code executed in the thread. The Runnable object is passed to the Thread constructor. And Threads start method is called. GoalKicker.com Java Notes for Professionals 677Example public class HelloRunnable implements Runnable Override public void run System.out.printlnHello from a thread public static void mainString args new Threadnew HelloRunnable .start Example in Java8 public static void mainString args Runnable r", "- System.out.printlnHello world new Threadr.start Runnable vs Thread subclass A Runnable object employment is more general, because the Runnable object can subclass a class other than Thread . Thread subclassing is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of Thread . A Runnable object is applicable to the high-level thread management APIs. Section 126.8 Creating basic deadlocked system A deadlock occurs when two competing actions wait for the other to \ufb01nish, and thus neither ever does. In java there is one lock associated with each object. To avoid concurrent modi\ufb01cation done by multiple threads on single object we can use synchronized keyword, but everything comes at a cost. Using synchronized keyword wrongly can lead to stuck systems called as deadlocked system. Consider there are 2 threads working on 1 instance, Lets call threads as First and Second, and lets say we have 2 resources R1 and R2. First acquires R1 and also needs R2 for its completion while Second acquires R2 and needs R1 for completion. so say at time t0, First has R1 and Second has R2. now First is waiting for R2 while Second", "is waiting for R1. this wait is inde\ufb01nite and this leads to deadlock. public class Example2 public static void mainString args throws InterruptedException final DeadLock dl new DeadLock Thread t1 new Threadnew Runnable Override public void run TODO Auto-generated method stub dl. methodA GoalKicker.com Java Notes for Professionals 678 Thread t2 new Threadnew Runnable Override public void run TODO Auto-generated method stub try dl. method2 catch InterruptedException e TODO Auto-generated catch block e. printStackTrace t1. setNameFirst t2. setNameSecond t1. start t2. start class DeadLock Object mLock1 new Object Object mLock2 new Object public void methodA System.out.printlnmethodA wait for mLock1 Thread.currentThread .getName synchronized mLock1 System.out.printlnmethodA mLock1 acquired Thread.currentThread .getName try Thread.sleep100 method2 catch InterruptedException e TODO Auto-generated catch block e. printStackTrace public void method2 throws InterruptedException System.out.printlnmethod2 wait for mLock2 Thread.currentThread .getName synchronized mLock2 System.out.printlnmethod2 mLock2 acquired Thread.currentThread .getName Thread.sleep100 method3 public void method3 throws InterruptedException System.out.printlnmethod3 mLock1 Thread.currentThread .getName synchronized mLock1 System.out.printlnmethod3 mLock1 acquired Thread.currentThread .getName Output of this program methodA wait for mLock1 First GoalKicker.com Java Notes for Professionals 679method2 wait for mLock2 Second method2 mLock2 acquired Second methodA mLock1 acquired First method3 mLock1 Second method2 wait for mLock2 First Section 126.9 Creating a java.lang.Thread instance There are", "two main approaches to creating a thread in Java. In essence, creating a thread is as easy as writing the code that will be executed in it. The two approaches di\ufb00er in where you de\ufb01ne that code. In Java, a thread is represented by an object - an instance of java.lang.Thread or its subclass. So the \ufb01rst approach is to create that subclass and override the run method. Note Ill use Thread to refer to the java.lang.Thread class and thread to refer to the logical concept of threads. class MyThread extends Thread Override public void run for int i 0 i 10 i System.out.printlnThread running! Now since weve already de\ufb01ned the code to be executed, the thread can be created simply as MyThread t new MyThread The Thread class also contains a constructor accepting a string, which will be used as the threads name. This can be particulary useful when debugging a multi thread program. class MyThread extends Thread public MyThread String name supername Override public void run for int i 0 i 10 i System.out.printlnThread running! MyThread t new MyThread Greeting Producer The second approach is to de\ufb01ne the code using java.lang.Runnable and its only method run .", "The Thread class then allows you to execute that method in a separated thread. To achieve this, create the thread using a constructor accepting an instance of the Runnable interface. Thread t new ThreadaRunnable This can be very powerful when combined with lambdas or methods references Java 8 only Thread t new Threadoperator hardWork GoalKicker.com Java Notes for Professionals 680You can specify the threads name, too. Thread t new Threadoperator hardWork, Pi operator Practicaly speaking, you can use both approaches without worries. However the general wisdom says to use the latter. For every of the four mentioned constructors, there is also an alternative accepting an instance of java.lang.ThreadGroup as the \ufb01rst parameter. ThreadGroup tg new ThreadGroup Operators Thread t new Threadtg, operator hardWork, PI operator The ThreadGroup represents a set of threads. You can only add a Thread to a ThreadGroup using a Thread s constructor. The ThreadGroup can then be used to manage all its Thread s together, as well as the Thread can gain information from its ThreadGroup . So to sumarize, the Thread can be created with one of these public constructors Thread ThreadString name ThreadRunnable target ThreadRunnable target, String name ThreadThreadGroup group, String name ThreadThreadGroup", "group, Runnable target ThreadThreadGroup group, Runnable target, String name ThreadThreadGroup group, Runnable target, String name, long stackSize The last one allows us to de\ufb01ne desired stack size for the new thread. Often the code readability su\ufb00ers when creating and con\ufb01guring many Threads with same properties or from the same pattern. Thats when java.util.concurrent.ThreadFactory can be used. This interface allows you to encapsulate the procedure of creating the thread through the factory pattern and its only method newThreadRunnable . class WorkerFactory implements ThreadFactory private int id 0 Override public Thread newThread Runnable r return new Threadr, Worker id Section 126.10 Atomic operations An atomic operation is an operation that is executed all at once, without any chance of other threads observing or modifying state during the atomic operations execution. Lets consider a BAD EXAMPLE . private static int t 0 public static void mainString args ExecutorService executorService Executors. newFixedThreadPool 400 The high thread count is for demonstration purposes. for int i 0 i 100 i GoalKicker.com Java Notes for Professionals 681 executorService. execute - t System.out.printlnMessageFormat .formatt 0 , t executorService. shutdown In this case, there are two issues. The \ufb01rst issue is that the post increment operator is not", "atomic. It is comprised of multiple operations get the value, add 1 to the value, set the value. Thats why if we run the example, it is likely that we wont see t 100 in the output - two threads may concurrently get the value, increment it, and set it lets say the value of t is 10, and two threads are incrementing t. Both threads will set the value of t to 11, since the second thread observes the value of t before the \ufb01rst thread had \ufb01nished incrementing it. The second issue is with how we are observing t. When we are printing the value of t, the value may have already been changed by a di\ufb00erent thread after this threads increment operation. To \ufb01x those issues, well use the java.util.concurrent .atomic.AtomicInteger , which has many atomic operations for us to use. private static AtomicInteger t new AtomicInteger 0 public static void mainString args ExecutorService executorService Executors. newFixedThreadPool 400 The high thread count is for demonstration purposes. for int i 0 i 100 i executorService. execute - int currentT t.incrementAndGet System.out.printlnMessageFormat .formatt 0 , currentT executorService. shutdown The incrementAndGet method of AtomicInteger atomically increments and returns the", "new value, thus eliminating the previous race condition. Please note that in this example the lines will still be out of order because we make no e\ufb00ort to sequence the println calls and that this falls outside the scope of this example, since it would require synchronization and the goal of this example is to show how to use AtomicInteger to eliminate race conditions concerning state. Section 126.11 Exclusive write Concurrent read access It is sometimes required for a process to concurrently write and read the same data. The ReadWriteLock interface, and its ReentrantReadWriteLock implementation allows for an access pattern that can be described as follow There can be any number of concurrent readers of the data. If there is at least one reader access granted,1. then no writer access is possible. There can be at most one single writer to the data. If there is a writer access granted, then no reader can2. access the data. An implementation could look like import java.util.concurrent.locks.ReadWriteLock import java.util.concurrent.locks.ReentrantReadWriteLock GoalKicker.com Java Notes for Professionals 682public class Sample Our lock. The constructor allows a fairness setting, which guarantees the chronology of lock attributions. protected static final ReadWriteLock RWLOCK new ReentrantReadWriteLock This is a", "typical data that needs to be protected for concurrent access protected static int data 0 This will write to the data, in an exclusive access public static void writeToData RWLOCK. writeLock .lock try data finally RWLOCK. writeLock .unlock public static int readData RWLOCK. readLock .lock try return data finally RWLOCK. readLock .unlock NOTE 1 This precise use case has a cleaner solution using AtomicInteger , but what is described here is an access pattern, that works regardless of the fact that data here is an integer that as an Atomic variant. NOTE 2 The lock on the reading part is really needed, although it might not look so to the casual reader. Indeed, if you do not lock on the reader side, any number of things can go wrong, amongst which The writes of primitive values are not guaranteed to be atomic on all JVMs, so the reader could see e.g. only1. 32bits of a 64bits write if data were a 64bits long type The visibility of the write from a thread that did not perform it is guaranteed by the JVM only if we establish2. Happen Before relationship between the writes and the reads. This relationship is established", "when both readers and writers use their respective locks, but not otherwise Version Java SE 8 In case higher performance is required, an under certain types of usage, there is a faster lock type available, called the StampedLock , that amongst other things implements an optimistic lock mode. This lock works very di\ufb00erently from the ReadWriteLock , and this sample is not transposable. Section 126.12 Producer-Consumer A simple example of producer-consumer problem solution. Notice that JDK classes AtomicBoolean and BlockingQueue are used for synchronization, which reduces the chance of creating an invalid solution. Consult Javadoc for various types of BlockingQueue choosing di\ufb00erent implementation may drastically change the behavior of this example like DelayQueue or Priority Queue . public class Producer implements Runnable GoalKicker.com Java Notes for Professionals 683 private final BlockingQueue ProducedData queue public Producer BlockingQueue ProducedData queue this.queue queue public void run int producedCount 0 try while true producedCount put throws an InterruptedException when the thread is interrupted queue. putnew ProducedData catch InterruptedException e the thread has been interrupted cleanup and exit producedCount -- re-interrupt the thread in case the interrupt flag is needeed higher up Thread.currentThread .interrupt System.out.printlnProduced producedCount objects public class Consumer implements Runnable private final", "BlockingQueue ProducedData queue public Consumer BlockingQueue ProducedData queue this.queue queue public void run int consumedCount 0 try while true put throws an InterruptedException when the thread is interrupted ProducedData data queue.poll10, TimeUnit. MILLISECONDS process data consumedCount catch InterruptedException e the thread has been interrupted cleanup and exit consumedCount -- re-interrupt the thread in case the interrupt flag is needeed higher up Thread.currentThread .interrupt System.out.printlnConsumed consumedCount objects public class ProducerConsumerExample static class ProducedData empty data object public static void mainString args throws InterruptedException BlockingQueue ProducedData queue new ArrayBlockingQueue ProducedData 1000 choice of queue determines the actual behavior see various BlockingQueue implementations Thread producer new Threadnew Producer queue GoalKicker.com Java Notes for Professionals 684 Thread consumer new Threadnew Consumer queue producer. start consumer. start Thread.sleep1000 producer. interrupt Thread.sleep10 consumer. interrupt Section 126.13 Visualizing readwrite barriers while using synchronized volatile As we know that we should use synchronized keyword to make execution of a method or block exclusive. But few of us may not be aware of one more important aspect of using synchronized and volatile keyword apart from making a unit of code atomic, it also provides read write barrier . What is this read write barrier? Lets discuss this using", "an example class Counter private Integer count 10 public synchronized void incrementCount count public Integer getCount return count Lets suppose a thread A calls incrementCount \ufb01rst then another thread B calls getCount . In this scenario there is no guarantee that B will see updated value of count . It may still see count as 10, even it is also possible that it never sees updated value of count ever. To understand this behavior we need to understand how Java memory model integrates with hardware architecture. In Java, each thread has its own thread stack. This stack contains method call stack and local variable created in that thread. In a multi core system, it is quite possible that two threads are running concurrently in separate cores. In such scenario it is possible that part of a threads stack lies inside register cache of a core. If inside a thread, an object is accessed using synchronized or volatile keyword, after synchronized block that thread syncs its local copy of that variable with the main memory. This creates a read write barrier and makes sure that the thread is seeing the latest value of that object. But in our case, since", "thread B has not used synchronized access to count , it might be refering value of count stored in register and may never see updates from thread A. To make sure that B sees latest value of count we need to make getCount synchronized as well. public synchronized Integer getCount return count Now when thread A is done with updating count it unlocks Counter instance, at the same time creates write barrier and \ufb02ushes all changes done inside that block to the main memory. Similarly when thread B acquires lock on the same instance of Counter , it enters into read barrier and reads value of count from main memory and sees all GoalKicker.com Java Notes for Professionals 685updates. Same visibility e\ufb00ect goes for volatile read writes as well. All variables updated prior to write to volatile will be \ufb02ushed to main memory and all reads after volatile variable read will be from main memory. Section 126.14 Get status of all threads started by your program excluding system threads Code snippet import java.util.Set public class ThreadStatus public static void mainString args throws Exception for int i 0 i 5 i Thread t new Threadnew MyThread t. setNameMyThread i t.", "start int threadCount 0 Set Thread threadSet Thread.getAllStackTraces .keySet for Thread t threadSet if t.getThreadGroup Thread.currentThread .getThreadGroup System.out.printlnThread t state t.getState threadCount System.out.printlnThread count started by Main thread threadCount class MyThread implements Runnable public void run try Thread.sleep2000 catchException err GoalKicker.com Java Notes for Professionals 686 err. printStackTrace Output Thread ThreadMyThread1,5,mainstateTIMEDWAITING Thread ThreadMyThread3,5,mainstateTIMEDWAITING Thread Threadmain,5,mainstateRUNNABLE Thread ThreadMyThread4,5,mainstateTIMEDWAITING Thread ThreadMyThread0,5,mainstateTIMEDWAITING Thread ThreadMyThread2,5,mainstateTIMEDWAITING Thread count started by Main thread6 Explanation Thread.getAllStackTraces .keySet returns all Thread s including application threads and system threads. If you are interested only in status of Threads, started by your application, iterate the Thread set by checking Thread Group of a particular thread against your main program thread. In absence of above ThreadGroup condition, the program returns status of below System Threads Reference Handler Signal Dispatcher Attach Listener Finalizer Section 126.15 Using ThreadLocal A useful tool in Java Concurrency is ThreadLocal this allows you to have a variable that will be unique to a given thread. Thus, if the same code runs in di\ufb00erent threads, these executions will not share the value, but instead each thread has its own variable that is local to the thread . For example, this is frequently used to establish the context", "such as authorization information of handling a request in a servlet. You might do something like this private static final ThreadLocal MyUserContext contexts new ThreadLocal public static MyUserContext getContext return contexts. get get returns the variable unique to this thread public void doGet... MyUserContext context magicGetContextFromRequest request contexts. putcontext save that context to our thread-local - other threads making this call dont overwrite ours try business logic finally contexts. remove ensure removal of thread-local variable Now, instead of passing MyUserContext into every single method, you can instead use MyServlet. getContext where you need it. Now of course, this does introduce a variable that needs to be documented, but it s thread-safe, GoalKicker.com Java Notes for Professionals 687which eliminates a lot of the downsides to using such a highly scoped variable. The key advantage here is that every thread has its own thread local variable in that contexts container. As long as you use it from a de\ufb01ned entry point like demanding that each servlet maintains its context, or perhaps by adding a servlet \ufb01lter you can rely on this context being there when you need it. Section 126.16 Multiple producerconsumer example with shared global queue Below code showcases multiple", "ProducerConsumer program. Both Producer and Consumer threads share same global queue. import java.util.concurrent. import java.util.Random public class ProducerConsumerWithES public static void mainString args BlockingQueue Integer sharedQueue new LinkedBlockingQueue Integer ExecutorService pes Executors. newFixedThreadPool 2 ExecutorService ces Executors. newFixedThreadPool 2 pes. submitnew Producer sharedQueue, 1 pes. submitnew Producer sharedQueue, 2 ces. submitnew Consumer sharedQueue, 1 ces. submitnew Consumer sharedQueue, 2 pes. shutdown ces. shutdown Different producers produces a stream of integers continuously to a shared queue, which is shared between all Producers and consumers class Producer implements Runnable private final BlockingQueue Integer sharedQueue private int threadNo private Random random new Random public Producer BlockingQueue Integer sharedQueue, int threadNo this.threadNo threadNo this.sharedQueue sharedQueue Override public void run Producer produces a continuous stream of numbers for every 200 milli seconds while true try int number random. nextInt1000 System.out.printlnProduced number by thread threadNo sharedQueue. putnumber Thread.sleep200 catch Exception err err. printStackTrace Different consumers consume data from shared queue, which is shared by both producer and consumer threads GoalKicker.com Java Notes for Professionals 688class Consumer implements Runnable private final BlockingQueue Integer sharedQueue private int threadNo public Consumer BlockingQueue Integer sharedQueue, int threadNo this.sharedQueue sharedQueue this.threadNo threadNo Override public void run Consumer consumes numbers generated", "from Producer threads continuously whiletrue try int num sharedQueue. take System.out.printlnConsumed num by thread threadNo catch Exception err err. printStackTrace output Produced69by thread2 Produced553by thread1 Consumed 69by thread1 Consumed 553by thread2 Produced41by thread2 Produced796by thread1 Consumed 41by thread1 Consumed 796by thread2 Produced728by thread2 Consumed 728by thread1 and so on ................ Explanation sharedQueue , which is a LinkedBlockingQueue is shared among all Producer and Consumer threads. 1. Producer threads produces one integer for every 200 milli seconds continuously and append it to2. sharedQueue Consumer thread consumes integer from sharedQueue continuously. 3. This program is implemented with-out explicit synchronized or Lock constructs. BlockingQueue is the key to 4. achieve it. BlockingQueue implementations are designed to be used primarily for producer-consumer queues. BlockingQueue implementations are thread-safe. All queuing methods achieve their e\ufb00ects atomically using internal locks or other forms of concurrency control. Section 126.17 Add two int arrays using a Threadpool A Threadpool has a Queue of tasks, of which each will be executed on one these Threads. GoalKicker.com Java Notes for Professionals 689The following example shows how to add two int arrays using a Threadpool. Version Java SE 8 int firstArray 2, 4, 6, 8 int secondArray 1, 3, 5, 7", "int result 0, 0, 0, 0 ExecutorService pool Executors. newCachedThreadPool Setup the ThreadPool for each element in the array, submit a worker to the pool that adds elements for int i 0 i result. length i final int worker i pool. submit - resultworker firstArray worker secondArray worker Wait for all Workers to finish try execute all submitted tasks pool. shutdown waits until all workers finish, or the timeout ends pool. awaitTermination 12, TimeUnit. SECONDS catch InterruptedException e pool. shutdownNow kill thread System.out.printlnArrays.toString result Notes This example is purely illustrative. In practice, there wont be any speedup by using threads for a task this1. small. A slowdown is likely, since the overheads of task creation and scheduling will swamp the time taken to run a task. If you were using Java 7 and earlier, you would use anonymous classes instead of lambdas to implement the2. tasks. Section 126.18 Pausing Execution Thread.sleep causes the current thread to suspend execution for a speci\ufb01ed period. This is an e\ufb03cient means of making processor time available to the other threads of an application or other applications that might be running on a computer system. There are two overloaded sleep methods in the Thread", "class. One that speci\ufb01es the sleep time to the millisecond public static void sleeplong millis throws InterruptedException One that speci\ufb01es the sleep time to the nanosecond public static void sleeplong millis, int nanos Pausing Execution for 1 second Thread.sleep1000 It is important to note that this is a hint to the operating systems kernels scheduler. This may not necessarily be GoalKicker.com Java Notes for Professionals 690precise, and some implementations do not even consider the nanosecond parameter possibly rounding to the nearest millisecond. It is recommended to enclose a call to Thread.sleep in trycatch and catch InterruptedException . Section 126.19 Thread Interruption Stopping Threads Each Java Thread has an interrupt \ufb02ag, which is initially false. Interrupting a thread, is essentially nothing more than setting that \ufb02ag to true. The code running on that thread can check the \ufb02ag on occasion and act upon it. The code can also ignore it completely. But why would each Thread have such a \ufb02ag? After all, having a boolean \ufb02ag on a thread is something we can just organize ourselves, if and when we need it. Well, there are methods that behave in a special way when the thread theyre running on is interrupted.", "These methods are called blocking methods. These are methods that put the thread in the WAITING or TIMEDWAITING state. When a thread is in this state, interrupting it, will cause an InterruptedException to be thrown on the interrupted thread, rather than the interrupt \ufb02ag being set to true, and the thread becomes RUNNABLE again. Code that invokes a blocking method is forced to deal with the InterruptedException, since it is a checked exception. So, and hence its name, an interrupt can have the e\ufb00ect of interrupting a WAIT, e\ufb00ectively ending it. Note that not all methods that are somehow waiting e.g. blocking IO respond to interruption in that way, as they dont put the thread in a waiting state. Lastly a thread that has its interrupt \ufb02ag set, that enters a blocking method i.e. tries to get into a waiting state, will immediately throw an InterruptedException and the interrupt \ufb02ag will be cleared. Other than these mechanics, Java does not assign any special semantic meaning to interruption. Code is free to interpret an interrupt any way it likes. But most often interruption is used to signal to a thread it should stop running at its earliest convenience. But, as", "should be clear from the above, it is up to the code on that thread to react to that interruption appropriately in order to stop running. Stopping a thread is a collaboration. When a thread is interrupted its running code can be several levels deep into the stacktrace. Most code doesnt call a blocking method, and \ufb01nishes timely enough to not delay the stopping of the thread unduly. The code that should mostly be concerned with being responsive to interruption, is code that is in a loop handling tasks until there are none left, or until a \ufb02ag is set signalling it to stop that loop. Loops that handle possibly in\ufb01nite tasks i.e. they keep running in principle should check the interrupt \ufb02ag in order to exit the loop. For \ufb01nite loops the semantics may dictate that all tasks must be \ufb01nished before ending, or it may be appropriate to leave some tasks unhandled. Code that calls blocking methods will be forced to deal with the InterruptedException. If at all semantically possible, it can simply propagate the InterruptedException and declare to throw it. As such it becomes a blocking method itself in regard to its callers. If it cannot", "propagate the exception, it should at the very least set the interrupted \ufb02ag, so callers higher up the stack also know the thread was interrupted. In some cases the method needs to continue waiting regardless of the InterruptedException, in which case it must delay setting the interrupted \ufb02ag until after it is done waiting, this may involve setting a local variable, which is to be checked prior to exiting the method to then interrupt its thread. Examples Example of code that stops handling tasks upon interruption class TaskHandler implements Runnable private final BlockingQueue Task queue TaskHandler BlockingQueue Task queue this.queue queue Override public void run while !Thread.currentThread .isInterrupted check for interrupt flag, exit loop GoalKicker.com Java Notes for Professionals 691when interrupted try Task task queue.take blocking call, responsive to interruption handle task catch InterruptedException e Thread.currentThread .interrupt cannot throw InterruptedException due to Runnable interface restriction so indicating interruption by setting the flag private void handleTask task actual handling Example of code that delays setting the interrupt \ufb02ag until completely done class MustFinishHandler implements Runnable private final BlockingQueue Task queue MustFinishHandler BlockingQueue Task queue this.queue queue Override public void run boolean shouldInterrupt false while true try Task task queue.take if", "task.isEndOfTasks if shouldInterrupt Thread.currentThread .interrupt return handle task catch InterruptedException e shouldInterrupt true must finish, remember to set interrupt flag when were done private void handleTask task actual handling Example of code that has a \ufb01xed list of tasks but may quit early when interrupted class GetAsFarAsPossible implements Runnable private final ListTask tasks new ArrayList Override public void run for Task task tasks GoalKicker.com Java Notes for Professionals 692 if Thread.currentThread .isInterrupted return handle task private void handleTask task actual handling GoalKicker.com Java Notes for Professionals 693Chapter 127 Executor, ExecutorService and Thread pools The Executor interface in Java provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. With Executors, developers wont have to signi\ufb01cantly rewrite their code to be able to easily tune their programs task-execution policy. Section 127.1 ThreadPoolExecutor A common Executor used is the ThreadPoolExecutor , which takes care of Thread handling. You can con\ufb01gure the minimal amount of Threads the executor always has to maintain when theres not much to do its called core size and a maximal Thread size to", "which the Pool can grow, if there is more work to do. Once the workload declines, the Pool slowly reduces the Thread count again until it reaches min size. ThreadPoolExecutor pool new ThreadPoolExecutor 1, keep at least one thread ready, even if no Runnables are executed 5, at most five RunnablesThreads executed in parallel 1, TimeUnit. MINUTES, idle Threads terminated after one minute, when min Pool size exceeded new ArrayBlockingQueue Runnable 10 outstanding Runnables are kept here pool.executenew Runnable Override public void run code to run Note If you con\ufb01gure the ThreadPoolExecutor with an unbounded queue, then the thread count will not exceed corePoolSize since new threads are only created if the queue is full ThreadPoolExecutor with all parameters ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler from JavaDoc If there are more than corePoolSize but less than maximumPoolSize threads running, a new thread will be created only if the queue is full. Advantages BlockingQueue size can be controlled and out-of-memory scenarios can be avoided. Application1. performance wont be degraded with limited bounded queue size. You can use existing or create new Rejection Handler policies.2. In the default ThreadPoolExecutor.AbortPolicy, the handler", "throws a runtime1. GoalKicker.com Java Notes for Professionals 694RejectedExecutionException upon rejection. In ThreadPoolExecutor. CallerRunsPolicy , the thread that invokes execute itself runs the task. This 2. provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted. In ThreadPoolExecutor. DiscardPolicy , a task that cannot be executed is simply dropped. 3. In ThreadPoolExecutor. DiscardOldestPolicy , if the executor is not shut down, the task at the head 4. of the work queue is dropped, and then execution is retried which can fail again, causing this to be repeated. Custom ThreadFactory can be con\ufb01gured, which is useful 3. To set a more descriptive thread name1. To set thread daemon status2. To set thread priority3. Here is a example of how to use ThreadPoolExecutor Section 127.2 Retrieving value from computation - Callable If your computation produces some return value which later is required, a simple Runnable task isnt su\ufb03cient. For such cases you can use ExecutorService. submitCallable T which returns a value after execution completes. The Service will return a Future which you can use to retrieve the result of the task execution. Submit a callable for execution ExecutorService pool anExecutorService FutureInteger future pool.submitnew Callable", "Integer Override public Integer call do some computation return new Random.nextInt ... perform other tasks while future is executed in a different thread When you need to get the result of the future, call future.get Wait inde\ufb01nitely for future to \ufb01nish with a result. try Blocks current thread until future is completed Integer result future. get catch InterruptedException ExecutionException e handle appropriately Wait for future to \ufb01nish, but no longer than speci\ufb01ed time. try Blocks current thread for a maximum of 500 milliseconds. If the future finishes before that, result is returned, otherwise TimeoutException is thrown. Integer result future. get500, TimeUnit. MILLISECONDS catch InterruptedException ExecutionException TimeoutException e GoalKicker.com Java Notes for Professionals 695 handle appropriately If the result of a scheduled or running task is no longer required, you can call Future.cancelboolean to cancel it. Calling cancelfalse will just remove the task from the queue of tasks to be run. Calling canceltrue will also interrupt the task if it is currently running. Section 127.3 submit vs execute exception handling dierences Generally execute command is used for \ufb01re and forget calls without need of analyzing the result and submit command is used for analyzing the result of Future object. We", "should be aware of key di\ufb00erence of Exception Handling mechanisms between these two commands. Exceptions from submit are swallowed by framework if you did not catch them. Code example to understand the di\ufb00erence Case 1 submit the Runnable with execute command, which reports the Exception. import java.util.concurrent. import java.util. public class ExecuteSubmitDemo public ExecuteSubmitDemo System.out.printlncreating service ExecutorService service Executors. newFixedThreadPool 2 ExtendedExecutor service new ExtendedExecutor for int i 0 i 2 i service. executenew Runnable public void run int a 4, b 0 System.out.printlna and b a b System.out.printlnab a b System.out.printlnThread Name in Runnable after divide by zeroThread.currentThread .getName service. shutdown public static void mainString args ExecuteSubmitDemo demo new ExecuteSubmitDemo class ExtendedExecutor extends ThreadPoolExecutor public ExtendedExecutor super1, 1, 60, TimeUnit. SECONDS, new ArrayBlockingQueue Runnable 100 ... protected void afterExecute Runnable r, Throwable t super.afterExecute r, t if t null r instanceof Future? try Object result Future? r.get GoalKicker.com Java Notes for Professionals 696 catch CancellationException ce t ce catch ExecutionException ee t ee.getCause catch InterruptedException ie Thread.currentThread .interrupt ignorereset if t ! null System.out.printlnt output creating service a and b40 a and b40 Exception in thread pool-1-thread-1 Exception in thread pool-1-thread-2 java.lang.ArithmeticException by zero at ExecuteSubmitDemo1.runExecuteSubmitDemo.java15 at java.util.concurrent.ThreadPoolExecutor.runWorkerThreadPoolExecutor.java1145", "at java.util.concurrent.ThreadPoolExecutorWorker.runThreadPoolExecutor.java615 at java.lang.Thread.runThread.java744 java.lang.ArithmeticException by zero at ExecuteSubmitDemo1.runExecuteSubmitDemo.java15 at java.util.concurrent.ThreadPoolExecutor.runWorkerThreadPoolExecutor.java1145 at java.util.concurrent.ThreadPoolExecutorWorker.runThreadPoolExecutor.java615 at java.lang.Thread.runThread.java744 Case 2 Replace execute with submit service. submitnew Runnable In this case, Exceptions are swallowed by framework since run method did not catch them explicitly. output creating service a and b40 a and b40 Case 3 Change the newFixedThreadPool to ExtendedExecutor ExecutorService service Executors.newFixedThreadPool2 ExtendedExecutor service new ExtendedExecutor output creating service a and b40 java.lang.ArithmeticException by zero a and b40 java.lang.ArithmeticException by zero I have demonstrated this example to cover two topics Use your custom ThreadPoolExecutor and handle Exectpion with custom ThreadPoolExecutor. GoalKicker.com Java Notes for Professionals 697Other simple solution to above problem When you are using normal ExecutorService submit command, get the Future object from submit command call get API on Future. Catch the three exceptions, which have been quoted in afterExecute method implementation. Advantage of custom ThreadPoolExecutor over this approach You have to handle Exception handling mechanism in only one place - Custom ThreadPoolExecutor. Section 127.4 Handle Rejected Execution If you try to submit tasks to a shutdown Executor or1. the queue is saturated only possible with bounded ones and maximum number of Threads has been2. reached, RejectedExecutionHandler. rejectedExecution Runnable , ThreadPoolExecutor", "will be called. The default behavior is that youll get a RejectedExecutionException thrown at the caller. But there are more prede\ufb01ned behaviors available ThreadPoolExecutor.AbortPolicy default, will throw REE ThreadPoolExecutor.CallerRunsPolicy executes task on callers thread - blocking it ThreadPoolExecutor.DiscardPolicy silently discard task ThreadPoolExecutor.DiscardOldestPolicy silently discard oldest task in queue and retry execution of the new task You can set them using one of the ThreadPool constructors public ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, RejectedExecutionHandler handler -- public ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler -- You can as well implement your own behavior by extending RejectedExecutionHandler interface void rejectedExecution Runnable r, ThreadPoolExecutor executor Section 127.5 Fire and Forget - Runnable Tasks Executors accept a java.lang.Runnable which contains potentially computationally or otherwise long-running or heavy code to be run in another Thread. Usage would be Executor exec anExecutor exec.executenew Runnable Override public void run offloaded work, no need to get result back GoalKicker.com Java Notes for Professionals 698 Note that with this executor, you have no means to get any computed value back. With Java 8, one can utilize lambdas to shorten the code example. Version", "Java SE 8 Executor exec anExecutor exec.execute - offloaded work, no need to get result back Section 127.6 Use cases for dierent types of concurrency constructs ExecutorService1. ExecutorService executor Executors. newFixedThreadPool 50 It is simple and easy to use. It hides low level details of ThreadPoolExecutor . I prefer this one when number of Callable Runnable tasks are small in number and piling of tasks in unbounded queue does not increase memory degrade the performance of the system. If you have CPUMemory constraints, I prefer to use ThreadPoolExecutor with capacity constraints RejectedExecutionHandler to handle rejection of tasks. CountDownLatch2. CountDownLatch will be initialized with a given count. This count is decremented by calls to the countDown method. Threads waiting for this count to reach zero can call one of the await methods. Calling await blocks the thread until the count reaches zero. This class enables a java thread to wait until other set of threads completes their tasks. Use cases Achieving Maximum Parallelism Sometimes we want to start a number of threads at the same time to1. achieve maximum parallelism Wait N threads to completes before start execution2. Deadlock detection.3. ThreadPoolExecutor It provides more control. If application is constrained by", "number of pending 3. RunnableCallable tasks, you can use bounded queue by setting the max capacity. Once the queue reaches maximum capacity, you can de\ufb01ne RejectionHandler. Java provides four types of RejectedExecutionHandler policies . ThreadPoolExecutor. AbortPolicy , the handler throws a runtime RejectedExecutionException upon 1. rejection. ThreadPoolExecutor.CallerRunsPolicy, the thread that invokes execute itself runs the task. This2. provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted. GoalKicker.com Java Notes for Professionals 699In ThreadPoolExecutor. DiscardPolicy , a task that cannot be executed is simply dropped. 3. ThreadPoolExecutor. DiscardOldestPolicy , if the executor is not shut down, the task at the head of 4. the work queue is dropped, and then execution is retried which can fail again, causing this to be repeated. If you want to simulate CountDownLatch behaviour, you can use invokeAll method. One more mechanism you did not quote is ForkJoinPool 4. The ForkJoinPool was added to Java in Java 7. The ForkJoinPool is similar to the Java ExecutorService but with one di\ufb00erence. The ForkJoinPool makes it easy for tasks to split their work up into smaller tasks which are then submitted to the ForkJoinPool too. Task stealing happens in", "ForkJoinPool when free worker threads steal tasks from busy worker thread queue. Java 8 has introduced one more API in ExecutorService to create work stealing pool. You dont have to create RecursiveTask and RecursiveAction but still can use ForkJoinPool . public static ExecutorService newWorkStealingPool Creates a work-stealing thread pool using all available processors as its target parallelism level. By default, it will take number of CPU cores as parameter. All these four mechanism are complimentary to each other. Depending on level of granularity you want to control, you have to chose right ones. Section 127.7 Wait for completion of all tasks in ExecutorService Lets have a look at various options to wait for completion of tasks submitted to Executor ExecutorService invokeAll 1. Executes the given tasks, returning a list of Futures holding their status and results when everything is completed. Example import java.util.concurrent. import java.util. public class InvokeAllDemo public InvokeAllDemo System.out.printlncreating service ExecutorService service Executors. newFixedThreadPool Runtime.getRuntime .availableProcessors List MyCallable futureList new ArrayList MyCallable GoalKicker.com Java Notes for Professionals 700 for int i 0 i 10 i MyCallable myCallable new MyCallable longi futureList. addmyCallable System.out.printlnStart try List FutureLong futures service. invokeAll futureList catchException err err. printStackTrace System.out.printlnCompleted service. shutdown", "public static void mainString args InvokeAllDemo demo new InvokeAllDemo class MyCallable implements Callable Long Long id 0L public MyCallable Long val this.id val public Long call Add your business logic return id CountDownLatch2. A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier . ForkJoinPool or newWorkStealingPool in Executors 3. Iterate through all Future objects created after submitting to ExecutorService 4. Recommended way of shutdown from oracle documentation page of ExecutorService 5. void shutdownAndAwaitTermination ExecutorService pool pool. shutdown Disable new tasks from being submitted try Wait a while for existing tasks to terminate if !pool.awaitTermination 60, TimeUnit. SECONDS pool. shutdownNow Cancel currently executing tasks Wait a while for tasks to respond to being cancelled if !pool.awaitTermination 60, TimeUnit. SECONDS System.err.printlnPool did not terminate", "GoalKicker.com Java Notes for Professionals 701 catch InterruptedException ie Re-Cancel if current thread also interrupted pool. shutdownNow Preserve interrupt status Thread.currentThread .interrupt shutdown Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. shutdownNow Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. In above example, if your tasks are taking more time to complete, you can change if condition to while condition Replace if !pool.awaitTermination 60, TimeUnit. SECONDS with while!pool.awaitTermination 60, TimeUnit. SECONDS Thread.sleep60000 Section 127.8 Use cases for dierent types of ExecutorService Executors returns di\ufb00erent type of ThreadPools catering to speci\ufb01c need. public static ExecutorService newSingleThreadExecutor 1. Creates an Executor that uses a single worker thread operating o\ufb00 an unbounded queue There is a di\ufb00erence between newFixedThreadPool 1 and newSingleThreadExecutor as the java doc says for the latter Unlike the otherwise equivalent newFixedThreadPool1 the returned executor is guaranteed not to be recon\ufb01gurable to use additional threads. Which means that a newFixedThreadPool can be recon\ufb01gured later in the program by ThreadPoolExecutor fixedThreadPool .setMaximumPoolSize 10 This is not possible for newSingleThreadExecutor Use cases You want to", "execute the submitted tasks in a sequence.1. You need only one Thread to handle all your request2. GoalKicker.com Java Notes for Professionals 702Cons Unbounded queue is harmful1. public static ExecutorService newFixedThreadPool int nThreads 2. Creates a thread pool that reuses a \ufb01xed number of threads operating o\ufb00 a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available Use cases E\ufb00ective use of available cores. Con\ufb01gure nThreads as 1. Runtime.getRuntime .availableProcessors When you decide that number of thread should not exceed a number in the thread pool2. Cons Unbounded queue is harmful.1. public static ExecutorService newCachedThreadPool 3. Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available Use cases For short-lived asynchronous tasks1. Cons Unbounded queue is harmful.1. Each new task will create a new thread if all existing threads are busy. If the task is taking long2. duration, more number of threads will be created,which will degrade the performance of the system. Alternative in this case newFixedThreadPool public static ScheduledExecutorService newScheduledThreadPool int", "corePoolSize 4. Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically. Use cases Handling recurring events with delays, which will happen in future at certain interval of times1. Cons Unbounded queue is harmful.1. 5.public static ExecutorService newWorkStealingPool GoalKicker.com Java Notes for Professionals 703Creates a work-stealing thread pool using all available processors as its target parallelism level Use cases For divide and conquer type of problems.1. E\ufb00ective use of idle threads. Idle threads steals tasks from busy threads.2. Cons Unbounded queue size is harmful.1. You can see one common drawbacks in all these ExecutorService unbounded queue. This will be addressed with ThreadPoolExecutor ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler With ThreadPoolExecutor , you can Control Thread pool size dynamically1. Set the capacity for BlockingQueue 2. De\ufb01ne RejectionExecutionHander when queue is full 3. CustomThreadFactory to add some additional functionality during Thread creation public Thread 4. newThread Runnable r Section 127.9 Scheduling tasks to run at a \ufb01xed time, after a delay or repeatedly The ScheduledExecutorService class provides a methods for scheduling single or repeated tasks in a number of ways. The following code", "sample assume that pool has been declared and initialized as follows ScheduledExecutorService pool Executors. newScheduledThreadPool 2 In addition to the normal ExecutorService methods, the ScheduledExecutorService API adds 4 methods that schedule tasks and return ScheduledFuture objects. The latter can be used to retrieve results in some cases and cancel tasks. Starting a task after a \ufb01xed delay The following example schedules a task to start after ten minutes. ScheduledFuture Integer future pool.schedule new Callable Override public Integer call do something return 42 , 10, TimeUnit. MINUTES Starting tasks at a \ufb01xed rate The following example schedules a task to start after ten minutes, and then repeatedly at a rate of once every one minute. GoalKicker.com Java Notes for Professionals 704ScheduledFuture ? future pool.scheduleAtFixedRate new Runnable Override public void run do something , 10, 1, TimeUnit. MINUTES Task execution will continue according to the schedule until the pool is shut down, the future is canceled, or one of the tasks encounters an exception. It is guaranteed that the tasks scheduled by a given scheduledAtFixedRate call will not overlap in time. If a task takes longer than the prescribed period, then the next and subsequent task executions may start late. Starting", "tasks with a \ufb01xed delay The following example schedules a task to start after ten minutes, and then repeatedly with a delay of one minute between one task ending and the next one starting. ScheduledFuture ? future pool.scheduleWithFixedDelay new Runnable Override public void run do something , 10, 1, TimeUnit. MINUTES Task execution will continue according to the schedule until the pool is shut down, the future is canceled, or one of the tasks encounters an exception. Section 127.10 Using Thread Pools Thread Pools are used mostly calling methods in ExecutorService . The following methods can be used to submit work for execution Method Description submit Executes a the submitted work and return a future which can be used to get the result execute Execute the task sometime in the future without getting any return value invokeAll Execute a list of tasks and return a list of Futures invokeAny Executes all the but return only the result of one that has been successful without exceptions Once you are done with the Thread Pool you can call shutdown to terminate the Thread Pool. This executes all pending tasks. To wait for all tasks to execute you can can loop around", "awaitTermination or isShutdown . GoalKicker.com Java Notes for Professionals 705Chapter 128 ThreadLocal Section 128.1 Basic ThreadLocal usage Java ThreadLocal is used to create thread local variables. It is known that threads of an Object share it s variables, so the variable is not thread safe. We can use synchronization for thread safety but if we want to avoid synchronization,ThreadLocal allows us to create variables which are local to the thread, i.e. only that thread can read or write to those variables, so the other threads executing the same piece of code will not be able to access each others ThreadLocal variables. This can be usedwe can use ThreadLocal variables. in situations where you have a thread pool like for example in a web service. For example, Creating a SimpleDateFormat object every time for every request is time consuming and a Static one cannot be created as SimpleDateFormat is not thread safe, so we can create a ThreadLocal so that we can perform thread safe operations without the overhead of creating SimpleDateFormat every time. The below piece of code shows how it can be used Every thread has it s own ThreadLocal variable and they can use it s get", "and set methods to get the default value or change it s value local to Thread. ThreadLocal instances are typically private static \ufb01elds in classes that wish to associate state with a thread. Here is a small example showing use of ThreadLocal in java program and proving that every thread has it s own copy of ThreadLocal variable. package com.examples.threads import java.text.SimpleDateFormat import java.util.Random public class ThreadLocalExample implements Runnable SimpleDateFormat is not thread-safe, so give one to each thread SimpleDateFormat is not thread-safe, so give one to each thread private static final ThreadLocal SimpleDateFormat formatter new ThreadLocal SimpleDateFormat Override protected SimpleDateFormat initialValue return new SimpleDateFormat yyyyMMdd HHmm public static void mainString args throws InterruptedException ThreadLocalExample obj new ThreadLocalExample forint i0 i10 i Thread t new Threadobj, i Thread.sleepnew Random.nextInt1000 t. start Override public void run System.out.printlnThread Name Thread.currentThread .getName default Formatter formatter. get.toPattern try GoalKicker.com Java Notes for Professionals 706 Thread.sleepnew Random.nextInt1000 catch InterruptedException e e. printStackTrace formatter. setnew SimpleDateFormat System.out.printlnThread Name Thread.currentThread .getName formatter formatter. get.toPattern Output Thread Name 0 default Formatter yyyyMMdd HHmm Thread Name 1 default Formatter yyyyMMdd HHmm Thread Name 0 formatter Mdyy hmm a Thread Name 2 default Formatter yyyyMMdd HHmm Thread Name 1", "formatter Mdyy hmm a Thread Name 3 default Formatter yyyyMMdd HHmm Thread Name 4 default Formatter yyyyMMdd HHmm Thread Name 4 formatter Mdyy hmm a Thread Name 5 default Formatter yyyyMMdd HHmm Thread Name 2 formatter Mdyy hmm a Thread Name 3 formatter Mdyy hmm a Thread Name 6 default Formatter yyyyMMdd HHmm Thread Name 5 formatter Mdyy hmm a Thread Name 6 formatter Mdyy hmm a Thread Name 7 default Formatter yyyyMMdd HHmm Thread Name 8 default Formatter yyyyMMdd HHmm Thread Name 8 formatter Mdyy hmm a Thread Name 7 formatter Mdyy hmm a Thread Name 9 default Formatter yyyyMMdd HHmm Thread Name 9 formatter Mdyy hmm a As we can see from the output that Thread-0 has changed the value of formatter but still thread-2 default formatter is same as the initialized value. Section 128.2 ThreadLocal Java 8 functional initialization public static class ThreadLocalExample GoalKicker.com Java Notes for Professionals 707 private static final ThreadLocal SimpleDateFormat format ThreadLocal .withInitial - new SimpleDateFormat yyyyMMddHHmm public String formatDate Date date return format. get.formatdate Section 128.3 Multiple threads with one shared object In this example we have only one object but it is shared betweenexecuted on di\ufb00erent threads. Ordinary usage of", "\ufb01elds to save state would not be possible because the other thread would see that too or probably not see. public class Test public static void mainString args Foo foo new Foo new Threadfoo, Thread 1 .start new Threadfoo, Thread 2 .start In Foo we count starting from zero. Instead of saving the state to a \ufb01eld we store our current number in the ThreadLocal object which is statically accessible. Note that the synchronization in this example is not related to the usage of ThreadLocal but rather ensures a better console output. public class Foo implements Runnable private static final int ITERATIONS 10 private static final ThreadLocal Integer threadLocal new ThreadLocal Integer Override protected Integer initialValue return 0 Override public void run for int i 0 i ITERATIONS i synchronized threadLocal Although accessing a static field, we get our own previously saved value. int value threadLocal. get System.out.printlnThread.currentThread .getName value Update our own variable threadLocal. setvalue 1 try threadLocal. notifyAll if i ITERATIONS - 1 threadLocal. wait catch InterruptedException ex From the output we can see that each thread counts for itself and does not use the value of the other one GoalKicker.com Java Notes for Professionals 708Thread 1", "0 Thread 2 0 Thread 1 1 Thread 2 1 Thread 1 2 Thread 2 2 Thread 1 3 Thread 2 3 Thread 1 4 Thread 2 4 Thread 1 5 Thread 2 5 Thread 1 6 Thread 2 6 Thread 1 7 Thread 2 7 Thread 1 8 Thread 2 8 Thread 1 9 Thread 2 9 GoalKicker.com Java Notes for Professionals 709Chapter 129 Using ThreadPoolExecutor in MultiThreaded applications. When creating a performant and data-driven application, it can be very helpful to complete time-intensive tasks in an asynchronous manner and to have multiple tasks running concurrently. This topic will introduce the concept of using ThreadPoolExecutors to complete multiple ansynchronous tasks concurrently. Section 129.1 Performing Asynchronous Tasks Where No Return Value Is Needed Using a Runnable Class Instance Some applications may want to create so-called Fire Forget tasks which can be periodically triggered and do not need to return any type of value returned upon completion of the assigned task for example, purging old temp \ufb01les, rotating logs, autosaving state. In this example, we will create two classes One which implements the Runnable interface, and one which contains a main method. AsyncMaintenanceTaskCompleter.java import lombok.extern.java.Log import java.util.concurrent.ThreadLocalRandom import java.util.concurrent.TimeUnit Log", "public class AsyncMaintenanceTaskCompleter implements Runnable private int taskNumber public AsyncMaintenanceTaskCompleter int taskNumber this.taskNumber taskNumber public void run int timeout ThreadLocalRandom. current.nextInt1, 20 try log. infoString.formatTask d is sleeping for d seconds , taskNumber, timeout TimeUnit. SECONDS.sleeptimeout log. infoString.formatTask d is done sleeping , taskNumber catch InterruptedException e log. warninge.getMessage AsyncExample1 import java.util.concurrent.ExecutorService import java.util.concurrent.Executors public class AsyncExample1 public static void mainString args ExecutorService executorService Executors. newCachedThreadPool forint i 0 i 10 i executorService. executenew AsyncMaintenanceTaskCompleter i GoalKicker.com Java Notes for Professionals 710 executorService. shutdown Running AsyncExample1.main resulted in the following output Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 8 is sleeping for 18 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 6 is sleeping for 4 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 2 is sleeping for 6 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 3 is sleeping for 4 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 9 is sleeping for 14 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 4 is sleeping for 9 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 5 is sleeping for 10 seconds Dec 28, 2016", "22103 PM AsyncMaintenanceTaskCompleter run INFO Task 0 is sleeping for 7 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 1 is sleeping for 9 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 7 is sleeping for 8 seconds Dec 28, 2016 22107 PM AsyncMaintenanceTaskCompleter run INFO Task 6 is done sleeping Dec 28, 2016 22107 PM AsyncMaintenanceTaskCompleter run INFO Task 3 is done sleeping Dec 28, 2016 22109 PM AsyncMaintenanceTaskCompleter run INFO Task 2 is done sleeping Dec 28, 2016 22110 PM AsyncMaintenanceTaskCompleter run INFO Task 0 is done sleeping Dec 28, 2016 22111 PM AsyncMaintenanceTaskCompleter run INFO Task 7 is done sleeping Dec 28, 2016 22112 PM AsyncMaintenanceTaskCompleter run INFO Task 4 is done sleeping Dec 28, 2016 22112 PM AsyncMaintenanceTaskCompleter run INFO Task 1 is done sleeping Dec 28, 2016 22113 PM AsyncMaintenanceTaskCompleter run INFO Task 5 is done sleeping Dec 28, 2016 22117 PM AsyncMaintenanceTaskCompleter run INFO Task 9 is done sleeping Dec 28, 2016 22121 PM AsyncMaintenanceTaskCompleter run INFO Task 8 is done sleeping Process finished with exit code 0 Observations of Note There are several things to note in the output above, The tasks did not execute in a predictable", "order.1. Since each task was sleeping for a pseudorandom amount of time, they did not necessarily complete in the2. order in which they were invoked. Section 129.2 Performing Asynchronous Tasks Where a Return Value Is Needed Using a Callable Class Instance It is often necessary to execute a long-running task and use the result of that task once it has completed. GoalKicker.com Java Notes for Professionals 711In this example, we will create two classes One which implements the CallableT interface where T is the type we wish to return, and one which contains a main method. AsyncValueTypeTaskCompleter.java import lombok.extern.java.Log import java.util.concurrent.Callable import java.util.concurrent.ThreadLocalRandom import java.util.concurrent.TimeUnit Log public class AsyncValueTypeTaskCompleter implements Callable Integer private int taskNumber public AsyncValueTypeTaskCompleter int taskNumber this.taskNumber taskNumber Override public Integer call throws Exception int timeout ThreadLocalRandom. current.nextInt1, 20 try log. infoString.formatTask d is sleeping , taskNumber TimeUnit. SECONDS.sleeptimeout log. infoString.formatTask d is done sleeping , taskNumber catch InterruptedException e log. warninge.getMessage return timeout AsyncExample2.java import lombok.extern.java.Log import java.util.ArrayList import java.util.List import java.util.concurrent.ExecutionException import java.util.concurrent.ExecutorService import java.util.concurrent.Executors import java.util.concurrent.Future Log public class AsyncExample2 public static void mainString args ExecutorService executorService Executors. newCachedThreadPool List FutureInteger futures new ArrayList for int i 0 i 10 i Future Integer", "submittedFuture executorService. submitnew AsyncValueTypeTaskCompleter i futures. addsubmittedFuture executorService. shutdown while!futures. isEmpty forint j 0 j futures. size j Future Integer f futures. getj iff.isDone try GoalKicker.com Java Notes for Professionals 712 int timeout f.get log. infoString.formatA task just completed after sleeping for d seconds , timeout futures. removef catch InterruptedException ExecutionException e log. warninge.getMessage Running AsyncExample2.main resulted in the following output Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 7 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 8 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 2 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 1 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 4 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 9 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 0 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 6 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 5 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 3 is sleeping Dec 28, 2016 30716 PM AsyncValueTypeTaskCompleter call INFO Task 8 is done sleeping Dec 28, 2016 30716 PM", "AsyncExample2 main INFO A task just completed after sleeping for 1 seconds Dec 28, 2016 30717 PM AsyncValueTypeTaskCompleter call INFO Task 2 is done sleeping Dec 28, 2016 30717 PM AsyncExample2 main INFO A task just completed after sleeping for 2 seconds Dec 28, 2016 30717 PM AsyncValueTypeTaskCompleter call INFO Task 9 is done sleeping Dec 28, 2016 30717 PM AsyncExample2 main INFO A task just completed after sleeping for 2 seconds Dec 28, 2016 30719 PM AsyncValueTypeTaskCompleter call INFO Task 3 is done sleeping Dec 28, 2016 30719 PM AsyncExample2 main INFO A task just completed after sleeping for 4 seconds Dec 28, 2016 30720 PM AsyncValueTypeTaskCompleter call INFO Task 0 is done sleeping Dec 28, 2016 30720 PM AsyncExample2 main INFO A task just completed after sleeping for 5 seconds Dec 28, 2016 30721 PM AsyncValueTypeTaskCompleter call INFO Task 5 is done sleeping Dec 28, 2016 30721 PM AsyncExample2 main INFO A task just completed after sleeping for 6 seconds Dec 28, 2016 30725 PM AsyncValueTypeTaskCompleter call INFO Task 1 is done sleeping Dec 28, 2016 30725 PM AsyncExample2 main GoalKicker.com Java Notes for Professionals 713INFO A task just completed after sleeping for 10 seconds Dec 28,", "2016 30727 PM AsyncValueTypeTaskCompleter call INFO Task 6 is done sleeping Dec 28, 2016 30727 PM AsyncExample2 main INFO A task just completed after sleeping for 12 seconds Dec 28, 2016 30729 PM AsyncValueTypeTaskCompleter call INFO Task 7 is done sleeping Dec 28, 2016 30729 PM AsyncExample2 main INFO A task just completed after sleeping for 14 seconds Dec 28, 2016 30731 PM AsyncValueTypeTaskCompleter call INFO Task 4 is done sleeping Dec 28, 2016 30731 PM AsyncExample2 main INFO A task just completed after sleeping for 16 seconds Observations of Note There are several things to note in the output above, Each call to ExecutorService.submit returned an instance of Future, which was stored in a list for later use1. Future contains a method called isDone which can be used to check whether our task has been completed2. before attempting to check its return value. Calling the Future.get method on a Future that is not yet done will block the current thread until the task is complete, potentially negating many bene\ufb01ts gained from performing the task Asynchronously. The executorService.shutdown method was called prior to checking the return values of the Future objects.3. This is not required, but was done in", "this way to show that it is possible. The executorService.shutdown method does not prevent the completion of tasks which have already been submitted to the ExecutorService, but rather prevents new tasks from being added to the Queue. Section 129.3 De\ufb01ning Asynchronous Tasks Inline using Lambdas While good software design often maximizes code reusability, sometimes it can be useful to de\ufb01ne asynchronous tasks inline in your code via Lambda expressions to maximize code readability. In this example, we will create a single class which contains a main method. Inside this method, we will use Lambda expressions to create and execute instances of Callable and RunnableT. AsyncExample3.java import lombok.extern.java.Log import java.util.ArrayList import java.util.List import java.util.concurrent. Log public class AsyncExample3 public static void mainString args ExecutorService executorService Executors. newCachedThreadPool List FutureInteger futures new ArrayList forint i 0 i 5 i final int index i executorService. execute - int timeout getTimeout log. infoString.formatRunnable d has been submitted and will sleep for d seconds , index, timeout try GoalKicker.com Java Notes for Professionals 714 TimeUnit. SECONDS.sleeptimeout catch InterruptedException e log. warninge.getMessage log. infoString.formatRunnable d has finished sleeping , index Future Integer submittedFuture executorService. submit - int timeout getTimeout log. infoString.formatCallable d will begin sleeping", ", index try TimeUnit. SECONDS.sleeptimeout catch InterruptedException e log. warninge.getMessage log. infoString.formatCallable d is done sleeping , index return timeout futures. addsubmittedFuture executorService. shutdown while!futures. isEmpty forint j 0 j futures. size j Future Integer f futures. getj iff.isDone try int timeout f.get log. infoString.formatA task just completed after sleeping for d seconds , timeout futures. removef catch InterruptedException ExecutionException e log. warninge.getMessage public static int getTimeout return ThreadLocalRandom. current.nextInt1, 20 Observations of Note There are several things to note in the output above, Lambda expressions have access to variables and methods which are available to the scope in which they are1. de\ufb01ned, but all variables must be \ufb01nal or e\ufb00ectively \ufb01nal for use inside a lambda expression. We do not have to specify whether our Lambda expression is a Callable or a RunnableT explicitly, the2. return type is inferred automatically by the return type. GoalKicker.com Java Notes for Professionals 715Chapter 130 Common Java Pitfalls This topic outlines some of the common mistakes made by beginners in Java. This includes any common mistakes in use of the Java language or understanding of the run-time environment. Mistakes associated with speci\ufb01c APIs can be described in topics speci\ufb01c to those APIs.", "Strings are a special case theyre covered in the Java Language Speci\ufb01cation. Details other than common mistakes can be described in this topic on Strings. Section 130.1 Pitfall using to compare primitive wrappers objects such as Integer This pitfall applies equally to all primitive wrapper types, but we will illustrate it for Integer and int. When working with Integer objects, it is tempting to use to compare values, because that is what you would do with int values. And in some cases this will seem to work Integer int11 Integer.valueOf1 Integer int12 Integer.valueOf1 System.out.printlnint11 int12 int11 int12 true System.out.printlnint11 equals int12 int11. equalsint12 true Here we created two Integer objects with the value 1 and compare them In this case we created one from a String and one from an int literal. There are other alternatives. Also, we observe that the two comparison methods and equals both yield true . This behavior changes when we choose di\ufb00erent values Integer int21 Integer.valueOf1000 Integer int22 Integer.valueOf1000 System.out.printlnint21 int22 int21 int22 false System.out.printlnint21 equals int22 int21. equalsint22 true In this case, only the equals comparison yields the correct result. The reason for this di\ufb00erence in behavior is, that the JVM maintains a", "cache of Integer objects for the range -128 to 127. The upper value can be overridden with the system property java.lang.Integer.IntegerCache.high or the JVM argument -XXAutoBoxCacheMaxsize. For values in this range, the Integer.valueOf will return the cached value rather than creating a new one. Thus, in the \ufb01rst example the Integer.valueOf1 and Integer.valueOf1 calls returned the same cached Integer instance. By contrast, in the second example the Integer.valueOf1000 and Integer.valueOf1000 both created and returned new Integer objects. The operator for reference types tests for reference equality i.e. the same object. Therefore, in the \ufb01rst example int11 int12 is true because the references are the same. In the second example int21 int22 is false because the references are di\ufb00erent. Section 130.2 Pitfall using to compare strings A common mistake for Java beginners is to use the operator to test if two strings are equal. For example GoalKicker.com Java Notes for Professionals 716public class Hello public static void mainString args if args.length 0 if args0 hello System.out.printlnHello back to you else System.out.printlnAre you feeling grumpy today? The above program is supposed to test the \ufb01rst command line argument and print di\ufb00erent messages when it and isnt the word hello. But the", "problem is that it wont work. That program will output Are you feeling grumpy today? no matter what the \ufb01rst command line argument is. In this particular case the String hello is put in the string pool while the String args0 resides on the heap. This means there are two objects representing the same literal, each with its reference. Since tests for references, not actual equality, the comparison will yield a false most of the times. This doesnt mean that it will always do so. When you use to test strings, what you are actually testing is if two String objects are the same Java object. Unfortunately, that is not what string equality means in Java. In fact, the correct way to test strings is to use the equalsObject method. For a pair of strings, we usually want to test if they consist of the same characters in the same order. public class Hello2 public static void mainString args if args.length 0 if args0.equalshello System.out.printlnHello back to you else System.out.printlnAre you feeling grumpy today? But it actually gets worse. The problem is that will give the expected answer in some circumstances. For example public class Test1 public static void", "mainString args String s1 hello String s2 hello if s1 s2 System.out.printlnsame else System.out.printlndifferent Interestingly, this will print same, even though we are testing the strings the wrong way. Why is that? Because the Java Language Speci\ufb01cation Section 3.10.5 String Literals stipulates that any two string literals consisting of the same characters will actually be represented by the same Java object. Hence, the test will give true for equal literals. The string literals are interned and added to a shared string pool when your code is loaded, but that is actually an implementation detail. GoalKicker.com Java Notes for Professionals 717To add to the confusion, the Java Language Speci\ufb01cation also stipulates that when you have a compile-time constant expression that concatenates two string literals, that is equivalent to a single literal. Thus public class Test1 public static void mainString args String s1 hello String s2 hel lo String s3 mum if s1 s2 System.out.println1. same else System.out.println1. different if s1 s3 hello mum System.out.println2. same else System.out.println2. different This will output 1. same and 2. di\ufb00erent. In the \ufb01rst case, the expression is evaluated at compile time and we compare one String object with itself. In the second case, it", "is evaluated at run time and we compare two di\ufb00erent String objects In summary, using to test strings in Java is almost always incorrect, but it is not guaranteed to give the wrong answer. Section 130.3 Pitfall forgetting to free resources Every time a program opens a resource, such as a \ufb01le or network connection, it is important to free the resource once you are done using it. Similar caution should be taken if any exception were to be thrown during operations on such resources. One could argue that the FileInputStream has a \ufb01nalizer that invokes the close method on a garbage collection event however, since we can t be sure when a garbage collection cycle will start, the input stream can consume computer resources for an inde\ufb01nite period of time. The resource must be closed in a finally section of a try-catch block Version Java SE 7 private static void printFileJava6 throws IOException FileInputStream input try input new FileInputStream file.txt int data input.read while data ! -1 System.out.printchar data data input.read finally if input ! null input. close Since Java 7 there is a really useful and neat statement introduced in Java 7 particularly for this case, called", "try-with- resources Version Java SE 7 GoalKicker.com Java Notes for Professionals 718private static void printFileJava7 throws IOException try FileInputStream input new FileInputStream file.txt int data input.read while data ! -1 System.out.printchar data data input.read The try-with-resources statement can be used with any object that implements the Closeable or AutoCloseable interface. It ensures that each resource is closed by the end of the statement. The di\ufb00erence between the two interfaces is, that the close method of Closeable throws an IOException which has to be handled in some way. In cases where the resource has already been opened but should be safely closed after use, one can assign it to a local variable inside the try-with-resources Version Java SE 7 private static void printFileJava7 InputStream extResource throws IOException try InputStream input extResource ... access resource The local resource variable created in the try-with-resources constructor is e\ufb00ectively \ufb01nal. Section 130.4 Pitfall testing a \ufb01le before attempting to open it Some people recommend that you should apply various tests to a \ufb01le before attempting to open it either to provide better diagnostics or avoid dealing with exceptions. For example, this method attempts to check if path corresponds to a readable \ufb01le public static", "File getValidatedFile String path throws IOException File f new Filepath if !f.exists throw new IOException Error not found path if !f.isFile throw new IOException Error Is a directory path if !f.canRead throw new IOException Error cannot read file path return f You might use the above method like this File f null try f getValidatedFile somefile catch IOException ex System.err.printlnex.getMessage return try InputStream is new FileInputStream file Read data etc. The \ufb01rst problem is in the signature for FileInputStream File because the compiler will still insist we catch IOException here, or further up the stack. GoalKicker.com Java Notes for Professionals 719The second problem is that checks performed by getValidatedFile do not guarantee that the FileInputStream will succeed. Race conditions another thread or a separate process could rename the \ufb01le, delete the \ufb01le, or remove read access after the getValidatedFile returns. That would lead to a plain IOException without the custom message. There are edge cases not covered by those tests. For example, on a system with SELinux in enforcing mode, an attempt to read a \ufb01le can fail despite canRead returning true . The third problem is that the tests are ine\ufb03cient. For example, the exists , isFile and", "canRead calls will each make a syscall to perform the required check. Another syscall is then made to open the \ufb01le, which repeats the same checks behind the scenes. In short, methods like getValidatedFile are misguided. It is better to simply attempt to open the \ufb01le and handle the exception try InputStream is new FileInputStream somefile Read data etc. catch IOException ex System.err.printlnIO Error processing somefile ex.getMessage return If you wanted to distinguish IO errors thrown while opening and reading, you could use a nested try catch. If you wanted to produce better diagnostics for open failures, you could perform the exists , isFile and canRead checks in the handler. Section 130.5 Pitfall thinking of variables as objects No Java variable represents an object. String foo NOT AN OBJECT Neither does any Java array contain objects. String bar new String100 No member is an object. If you mistakenly think of variables as objects, the actual behavior of the Java language will surprise you. For Java variables which have a primitive type such as int or float the variable holds a copy of the value. All copies of a primitive value are indistinguishable i.e. there is only one int value", "for the number one. Primitive values are not objects and they do not behave like objects. For Java variables which have a reference type either a class or an array type the variable holds a reference. All copies of a reference are indistinguishable. References may point to objects, or they may be null which means that they point to no object. However, they are not objects and they dont behave like objects. Variables are not objects in either case, and they dont contain objects in either case. They may contain references to objects , but that is saying something di\ufb00erent. Example class The examples that follow use this class, which represents a point in 2D space. GoalKicker.com Java Notes for Professionals 720public final class MutableLocation public int x public int y public MutableLocation int x, int y this.x x this.y y public boolean equalsObject other if !other instanceof MutableLocation return false MutableLocation that MutableLocation other return this.x that.x this.y that.y An instance of this class is an object that has two \ufb01elds x and y which have the type int. We can have many instances of the MutableLocation class. Some will represent the same locations in 2D space i.e.", "the respective values of x and y will match. Others will represent di\ufb00erent locations. Multiple variables can point to the same object MutableLocation here new MutableLocation 1, 2 MutableLocation there here MutableLocation elsewhere new MutableLocation 1, 2 In the above, we have declared three variables here , there and elsewhere that can hold references to MutableLocation objects. If you incorrectly think of these variables as being objects, then you are likely to misread the statements as saying Copy the location 1, 2 to here 1. Copy the location 1, 2 to there 2. Copy the location 1, 2 to elsewhere 3. From that, you are likely to infer we have three independent objects in the three variables. In fact there are only two objects created by the above. The variables here and there actually refer to the same object. We can demonstrate this. Assuming the variable declarations as above System.out.printlnBEFORE here.x is here.x , there.x is there.x elsewhere.x is elsewhere. x here.x 42 System.out.printlnAFTER here.x is here.x , there.x is there.x elsewhere.x is elsewhere. x This will output the following BEFORE here.x is 1, there.x is 1, elsewhere.x is 1 AFTER here.x is 42, there.x is 42, elsewhere.x is", "1 We assigned a new value to here.x and it changed the value that we see via there.x. They are referring to the same object. But the value that we see via elsewhere. x has not changed, so elsewhere must refer to a di\ufb00erent GoalKicker.com Java Notes for Professionals 721object. If a variable was an object, then the assignment here.x 42 would not change there.x. The equality operator does NOT test that two objects are equal Applying the equality operator to reference values tests if the values refer to the same object. It does not test whether two di\ufb00erent objects are equal in the intuitive sense. MutableLocation here new MutableLocation 1, 2 MutableLocation there here MutableLocation elsewhere new MutableLocation 1, 2 if here there System.out.printlnhere is there if here elsewhere System.out.printlnhere is elsewhere This will print here is there, but it wont print here is elsewhere. The references in here and elsewhere are for two distinct objects. By contrast, if we call the equalsObject method that we implemented above, we are going to test if two MutableLocation instances have an equal location. if here.equalsthere System.out.printlnhere equals there if here.equalselsewhere System.out.printlnhere equals elsewhere This will print both messages. In particular,", "here.equalselsewhere returns true because the semantic criteria we chose for equality of two MutableLocation objects has been satis\ufb01ed. Method calls do NOT pass objects at all Java method calls use pass by value 1 to pass arguments and return a result. When you pass a reference value to a method, youre actually passing a reference to an object by value , which means that it is creating a copy of the object reference. As long as both object references are still pointing to the same object, you can modify that object from either reference, and this is what causes confusion for some. However, you are not passing an object by reference2. The distinction is that if the object reference copy is modi\ufb01ed to point to another object, the original object reference will still point to the original object. void fMutableLocation foo foo new MutableLocation 3, 4 Point local foo at a different object. void g MutableLocation foo MutableLocation 1, 2 ffoo System.out.printlnfoo.x is foo.x Prints foo.x is 1. GoalKicker.com Java Notes for Professionals 722 Neither are you passing a copy of the object. void fMutableLocation foo foo. x 42 void g MutableLocation foo new MutableLocation 0, 0 ffoo System.out.printlnfoo.x", "is foo.x Prints foo.x is 42 1 - In languages like Python and Ruby, the term pass by sharing is preferred for pass by value of an object reference. 2 - The term pass by reference or call by reference has a very speci\ufb01c meaning in programming language terminology. In e\ufb00ect, it means that you pass the address of a variable or an array element , so that when the called method assigns a new value to the formal argument, it changes the value in the original variable. Java does not support this. For a more fulsome description of di\ufb00erent mechanisms for passing parameters, please refer to httpsen.wikipedia.orgwikiEvaluationstrategy . Section 130.6 Pitfall memory leaks Java manages memory automatically. You are not required to free memory manually. An objects memory on the heap may be freed by a garbage collector when the object is no longer reachable by a live thread. However, you can prevent memory from being freed, by allowing objects to be reachable that are no longer needed. Whether you call this a memory leak or memory packratting, the result is the same -- an unnecessary increase in allocated memory. Memory leaks in Java can happen in various", "ways, but the most common reason is everlasting object references, because the garbage collector can t remove objects from the heap while there are still references to them. Static \ufb01elds One can create such a reference by de\ufb01ning class with a static \ufb01eld containing some collection of objects, and forgetting to set that static \ufb01eld to null after the collection is no longer needed. static \ufb01elds are considered GC roots and are never collected. Another issue is leaks in non-heap memory when JNI is used. Classloader leak By far, though, the most insidious type of memory leak is the classloader leak . A classloader holds a reference to every class it has loaded, and every class holds a reference to its classloader. Every object holds a reference to its class as well. Therefore, if even a single object of a class loaded by a classloader is not garbage, not a single class that that classloader has loaded can be collected. Since each class also refers to its static \ufb01elds, they cannot be collected either. Accumulation leak The accumulation leak example could look like the following final ScheduledExecutorService scheduledExecutorService Executors. newScheduledThreadPool 1 final DequeBigDecimal numbers new LinkedBlockingDeque final BigDecimal divisor", "new BigDecimal 51 scheduledExecutorService. scheduleAtFixedRate - GoalKicker.com Java Notes for Professionals 723 BigDecimal number numbers. peekLast if number ! null number. remainder divisor.byteValue 0 System.out.printlnNumber number System.out.printlnDeque size numbers. size , 10, 10, TimeUnit. MILLISECONDS scheduledExecutorService. scheduleAtFixedRate - numbers. addnew BigDecimal System.currentTimeMillis , 10, 10, TimeUnit. MILLISECONDS try scheduledExecutorService. awaitTermination 1, TimeUnit. DAYS catch InterruptedException e e.printStackTrace This example creates two scheduled tasks. The \ufb01rst task takes the last number from a deque called numbers , and, if the number is divisible by 51, it prints the number and the deques size. The second task puts numbers into the deque. Both tasks are scheduled at a \ufb01xed rate, and they run every 10 ms. If the code is executed, you ll see that the size of the deque is permanently increasing. This will eventually cause the deque to be \ufb01lled with objects that consume all available heap memory. To prevent this while preserving the semantics of this program, we can use a di\ufb00erent method for taking numbers from the deque pollLast . Contrary to the method peekLast , pollLast returns the element and removes it from the deque while peekLast only returns the last element. Section 130.7 Pitfall Not", "understanding that String is an immutable class New Java programmers often forget, or fail to fully comprehend, that the Java String class is immutable. This leads to problems like the one in the following example public class Shout public static void mainString args for String s args s. toUpperCase System.out.prints System.out.print System.out.println The above code is supposed to print command line arguments in upper case. Unfortunately, it does not work, the case of the arguments is not changed. The problem is this statement s.toUpperCase You might think that calling toUpperCase is going to change s to an uppercase string. It doesnt. It cant! String objects are immutable. They cannot be changed. In reality, the toUpperCase method returns a String object which is an uppercase version of the String that you call it on. This will probably be a new String object, but if s was already all uppercase, the result could be the existing string. GoalKicker.com Java Notes for Professionals 724So in order to use this method e\ufb00ectively, you need to use the object returned by the method call for example s s.toUpperCase In fact, the strings never change rule applies to all String methods. If you remember that,", "then you can avoid a whole category of beginners mistakes. Section 130.8 Pitfall combining assignment and side-eects Occasionally we see StackOver\ufb02ow Java questions and C or C questions that ask what something like this i ai bi-- evaluates to ... for some known initial states of i, a and b. Generally speaking for Java the answer is always speci\ufb01ed1, but non-obvious, and often di\ufb03cult to \ufb01gure out for C and C the answer is often unspeci\ufb01ed. Such examples are often used in exams or job interviews as an attempt to see if the student or interviewee understands how expression evaluation really works in the Java programming language. This is arguably legitimate as a test of knowledge, but that does not mean that you should ever do this in a real program. To illustrate, the following seemingly simple example has appeared a few times in StackOver\ufb02ow questions like this one. In some cases, it appears as a genuine mistake in someones code. int a 1 a a System.out.printlna What does this print. Most programmers including Java experts reading those statements quickly would say that it outputs 2. In fact, it outputs 1. For a detailed explanation of why, please read", "this Answer . However the real takeaway from this and similar examples is that any Java statement that both assigns to and side- e\ufb00ects the same variable is going to be at best hard to understand, and at worst downright misleading. You should avoid writing code like this. 1 - modulo potential issues with the Java Memory Model if the variables or objects are visible to other threads. GoalKicker.com Java Notes for Professionals 725Chapter 131 Java Pitfalls - Exception usage Several Java programming language misusage might conduct a program to generate incorrect results despite being compiled correctly. This topic main purpose is to list common pitfalls related to exception handling , and to propose the correct way to avoid having such pitfalls. Section 131.1 Pitfall - Catching Throwable, Exception, Error or RuntimeException A common thought pattern for inexperienced Java programmers is that exceptions are a problem or a burden and the best way to deal with this is catch them all1 as soon as possible. This leads to code like this .... try InputStream is new FileInputStream fileName process the input catch Exception ex System.out.printlnCould not open file fileName The above code has a signi\ufb01cant \ufb02aw. The catch is", "actually going to catch more exceptions than the programmer is expecting. Suppose that the value of the fileName is null , due to a bug elsewhere in the application. This will cause the FileInputStream constructor to throw a NullPointerException . The handler will catch this, and report to the user Could not open file null which is unhelpful and confusing. Worse still, suppose that the it was the process the input code that threw the unexpected exception checked or unchecked!. Now the user will get the misleading message for a problem that didnt occur while opening the \ufb01le, and may not be related to IO at all. The root of the problem is that the programmer has coded a handler for Exception . This is almost always a mistake Catching Exception will catch all checked exceptions, and most unchecked exceptions as well. Catching RuntimeException will catch most unchecked exceptions. Catching Error will catch unchecked exceptions that signal JVM internal errors. These errors are generally not recoverable, and should not be caught. Catching Throwable will catch all possible exceptions. The problem with catching too broad a set of exceptions is that the handler typically cannot handle all of them appropriately.", "In the case of the Exception and so on, it is di\ufb03cult for the programmer to predict what could be caught i.e. what to expect. In general, the correct solution is to deal with the exceptions that are thrown. For example, you can catch them and handle them in situ try InputStream is new FileInputStream fileName process the input catch FileNotFoundException ex System.out.printlnCould not open file fileName GoalKicker.com Java Notes for Professionals 726or you can declare them as thrown by the enclosing method. There are very few situations where catching Exception is appropriate. The only one that arises commonly is something like this public static void mainString args try do stuff catch Exception ex System.err.printlnUnfortunately an error has occurred. Please report this to X Y Z Write stacktrace to a log file. System.exit1 Here we genuinely want to deal with all exceptions, so catching Exception or even Throwable is correct. 1 - Also known as Pokemon Exception Handling . Section 131.2 Pitfall - Ignoring or squashing exceptions This example is about deliberately ignoring or squashing exceptions. Or to be more precise, it is about how to catch and handle an exception in a way that ignores it. However, before", "we describe how to do this, we should \ufb01rst point out that squashing exceptions is generally not the correct way to deal with them. Exceptions are usually thrown by something to notify other parts of the program that some signi\ufb01cant i.e. exceptional event has occurred. Generally though not always an exception means that something has gone wrong. If you code your program to squash the exception, there is a fair chance that the problem will reappear in another form. To make things worse, when you squash the exception, you are throwing away the information in the exception object and its associated stack trace. That is likely to make it harder to \ufb01gure out what the original source of the problem was. In practice, exception squashing frequently happens when you use an IDEs auto-correction feature to \ufb01x a compilation error caused by an unhandled exception. For example, you might see code like this try inputStream new FileInputStream someFile catch IOException e add exception handling code here Clearly, the programmer has accepted the IDEs suggestion to make the compilation error go away, but the suggestion was inappropriate. If the \ufb01le open has failed, the program should most likely do something about", "it. With the above correction, the program is liable to fail later e.g. with a NullPointerException because inputStream is now null . Having said that, here is an example of deliberately squashing an exception. For the purposes of argument, assume that we have determined that an interrupt while showing the sel\ufb01e is harmless. The comment tells the reader that we squashed the exception deliberately, and why we did that. try selfie. show catch InterruptedException e It doesnt matter if showing the selfie is interrupted. GoalKicker.com Java Notes for Professionals 727 Another conventional way to highlight that we are deliberately squashing an exception without saying why is to indicate this with the exception variables name, like this try selfie. show catch InterruptedException ignored Some IDEs like IntelliJ IDEA wont display a warning about the empty catch block if the variable name is set to ignored . Section 131.3 Pitfall - Throwing Throwable, Exception, Error or RuntimeException While catching the Throwable , Exception , Error and RuntimeException exceptions is bad, throwing them is even worse. The basic problem is that when your application needs to handle exceptions, the presence of the top level exceptions make it hard to discriminate between di\ufb00erent", "error conditions. For example try InputStream is new FileInputStream someFile could throw IOException ... if somethingBad throw new Exception WRONG catch IOException ex System.err.printlncannot open ... catch Exception ex System.err.printlnsomething bad happened WRONG The problem is that because we threw an Exception instance, we are forced to catch it. However as described in another example, catching Exception is bad. In this situation, it becomes di\ufb03cult to discriminate between the expected case of an Exception that gets thrown if somethingBad is true , and the unexpected case where we actually catch an unchecked exception such as NullPointerException . If the top-level exception is allowed to propagate, we run into other problems We now have to remember all of the di\ufb00erent reasons that we threw the top-level, and discriminate handle them. In the case of Exception and Throwable we also need to add these exceptions to the throws clause of methods if we want the exception to propagate. This is problematic, as described below. In short, dont throw these exceptions. Throw a more speci\ufb01c exception that more closely describes the exceptional event that has happened. If you need to, de\ufb01ne and use a custom exception class. Declaring Throwable or Exception in", "a methods throws is problematic. It is tempting to replace a long list of thrown exceptions in a methods throws clause with Exception or even Throwable. This is a bad idea It forces the caller to handle or propagate Exception . 1. We can no longer rely on the compiler to tell us about speci\ufb01c checked exceptions that need to be handled.2. GoalKicker.com Java Notes for Professionals 728Handling Exception properly is di\ufb03cult. It is hard to know what actual exceptions may be caught, and if you 3. dont know what could be caught, it is hard to know what recovery strategy is appropriate. Handling Throwable is even harder, since now you also have to cope with potential failures that should never 4. be recovered from. This advice means that certain other patterns should be avoided. For example try doSomething catch Exception ex report ex throw ex The above attempts to log all exceptions as they pass, without de\ufb01nitively handling them. Unfortunately, prior to Java 7, the throw ex statement caused the compiler to think that any Exception could be thrown. That could force you to declare the enclosing method as throws Exception . From Java 7 onwards, the compiler", "knows that the set of exceptions that could be re-thrown there is smaller. Section 131.4 Pitfall - Using exceptions for normal \ufb02owcontrol There is a mantra that some Java experts are wont to recite Exceptions should only be used for exceptional cases. For example httpprogrammers.stackexchange.comquestions184654 The essence of this is that is it is a bad idea in Java to use exceptions and exception handling to implement normal \ufb02ow control. For example, compare these two ways of dealing with a parameter that could be null. public String truncateWordOrNull String word, int maxLength if word null return else return word.substring 0, Math.minword.length, maxLength public String truncateWordOrNull String word, int maxLength try return word.substring 0, Math.minword.length, maxLength catch NullPointerException ex return In this example, we are by design treating the case where word is null as if it is an empty word. The two versions deal with null either using conventional if ... else and or try ... catch . How should we decide which version is better? The \ufb01rst criterion is readability. While readability is hard to quantify objectively, most programmers would agree that the essential meaning of the \ufb01rst version is easier to discern. Indeed, in order to truly", "understand the second form, you need to understand that a NullPointerException cannot be thrown by the Math.min or String.substring methods. The second criterion is e\ufb03ciency. In releases of Java prior to Java 8, the second version is signi\ufb01cantly orders of GoalKicker.com Java Notes for Professionals 729magnitude slower than the \ufb01rst version. In particular, the construction of an exception object entails capturing and recording the stackframes, just in case the stacktrace is required. On the other hand, there are many situations where using exceptions is more readable, more e\ufb03cient and sometimes more correct than using conditional code to deal with exceptional events. Indeed, there are rare situations where it is necessary to use them for non-exceptional events i.e. events that occur relatively frequently. For the latter, it is worth looking at ways to reduce the overheads of creating exception objects. Section 131.5 Pitfall - Directly subclassing Throwable Throwable has two direct subclasses, Exception and Error . While its possible to create a new class that extends Throwable directly, this is inadvisable as many applications assume only Exception and Error exist. More to the point there is no practical bene\ufb01t to directly subclassing Throwable , as the resulting class is, in", "e\ufb00ect, simply a checked exception. Subclassing Exception instead will result in the same behavior, but will more clearly convey your intent. Section 131.6 Pitfall - Catching InterruptedException As already pointed out in other pitfalls, catching all exceptions by using try Some code catch Exception Some error handling Comes with a lot of di\ufb00erent problems. But one perticular problem is that it can lead to deadlocks as it breaks the interrupt system when writing multi-threaded applications. If you start a thread you usually also need to be able to stop it abruptly for various reasons. Thread t new Threadnew Runnable public void run while true Do something indefinetely t.start Do something else The thread should be canceld if it is still active. A Better way to solve this is with a shared variable that is tested regularily by the thread for a clean exit, but for this example we try to forcibly interrupt this thread. if t.isAlive t.interrupt t.join Continue with program The t.interrupt will raise an InterruptedException in that thread, than is intended to shut down the thread. But what if the Thread needs to clean up some resources before its completely stopped? For this it can catch the", "GoalKicker.com Java Notes for Professionals 730InterruptedException and do some cleanup. Thread t new Threadnew Runnable public void run try while true Do something indefinetely catch InterruptedException ex Do some quick cleanup In this case a simple return would do. But if you are not 100 sure that the thread ends after catching the InterruptedException you will need to raise another one for the layers surrounding this code. Thread.currentThread .interrupt But if you have a catch-all expression in your code, the InterruptedException will be caught by it as well and the interruption will not continue. Which in this case could lead to a deadlock as the parent thread waits inde\ufb01nitely for this thead to stop with t.join. Thread t new Threadnew Runnable public void run try while true try Do something indefinetely catch Exception ex ex. printStackTrace catch InterruptedException ex Dead code as the interrupt exception was already caught in the inner try-catch Thread.currentThread .interrupt So it is better to catch Exceptions individually, but if you insist on using a catch-all, at least catch the InterruptedException individually beforehand. Thread t new Threadnew Runnable public void run try while true try Do something indefinetely catch InterruptedException ex throw ex Send it", "up in the chain catch Exception ex ex. printStackTrace catch InterruptedException ex Some quick cleanup code GoalKicker.com Java Notes for Professionals 731 Thread.currentThread .interrupt Section 131.7 Pitfall - Excessive or inappropriate stacktraces One of the more annoying things that programmers can do is to scatter calls to printStackTrace throughout their code. The problem is that the printStackTrace is going to write the stacktrace to standard output. For an application that is intended for end-users who are not Java programmers, a stacktrace is uninformative at best, and alarming at worst. For a server-side application, the chances are that nobody will look at the standard output. A better idea is to not call printStackTrace directly, or if you do call it, do it in a way that the stack trace is written to a log \ufb01le or error \ufb01le rather than to the end-users console. One way to do this is to use a logging framework, and pass the exception object as a parameter of the log event. However, even logging the exception can be harmful if done injudiciously. Consider the following public void method1 throws SomeException try method2 Do something catch SomeException ex Logger. getLogger .warnSomething bad in method1 ,", "ex throw ex public void method2 throws SomeException try Do something else catch SomeException ex Logger. getLogger .warnSomething bad in method2 , ex throw ex If the exception is thrown in method2 , you are likely to see two copies of the same stacktrace in the log\ufb01le, corresponding to the same failure. In short, either log the exception or re-throw it further possibly wrapped with another exception. Dont do both. GoalKicker.com Java Notes for Professionals 732Chapter 132 Java Pitfalls - Language syntax Several Java programming language misusage might conduct a program to generate incorrect results despite being compiled correctly. This topic main purpose is to list common pitfalls with their causes, and to propose the correct way to avoid falling in such problems. Section 132.1 Pitfall - Missing a break in a switch case These Java issues can be very embarrassing, and sometimes remain undiscovered until run in production. Fallthrough behavior in switch statements is often useful however, missing a break keyword when such behavior is not desired can lead to disastrous results. If you have forgotten to put a break in case 0 in the code example below, the program will write Zero followed by One, since the", "control \ufb02ow inside here will go through the entire switch statement until it reaches a break . For example public static void switchCasePrimer int caseIndex 0 switch caseIndex case 0 System.out.printlnZero case 1 System.out.printlnOne break case 2 System.out.printlnTwo break default System.out.printlnDefault In most cases, the cleaner solution would be to use interfaces and move code with speci\ufb01c behaviour into separate implementations composition over inheritance If a switch-statement is unavoidable it is recommended to document expected fallthroughs if they occur. That way you show fellow developers that you are aware of the missing break, and that this is expected behaviour. switchcaseIndex ... case 2 System.out.printlnTwo fallthrough default System.out.printlnDefault Section 132.2 Pitfall - Declaring classes with the same names as standard classes Sometimes, programmers who are new to Java make the mistake of de\ufb01ning a class with a name that is the same as a widely used class. For example package com.example GoalKicker.com Java Notes for Professionals 733 My string utilities public class String .... Then they wonder why they get unexpected errors. For example package com.example public class Test public static void mainString args System.out.printlnHello world! If you compile and then attempt to run the above classes you will get", "an error javac com example.java java com.example.Test Error Main method not found in class test.Test, please define the main method as public static void mainString args or a JavaFX application class must extend javafx.application.Application Someone looking at the code for the Test class would see the declaration of main and look at its signature and wonder what the java command is complaining about. But in fact, the java command is telling the truth. When we declare a version of String in the same package as Test , this version takes precedence over the automatic import of java.lang.String . Thus, the signature of the Test.main method is actually void maincom.example.String args instead of void mainjava.lang.String args and the java command will not recognize that as an entrypoint method. Lesson Do not de\ufb01ne classes that have the same name as existing classes in java.lang , or other commonly used classes in the Java SE library. If you do that, you are setting yourself open for all sorts of obscure errors. Section 132.3 Pitfall - Leaving out braces the dangling if and dangling else problems The latest version of the Oracle Java style guide mandates that the then and else statements in", "an if statement should always be enclosed in braces or curly brackets. Similar rules apply to the bodies of various loop statements. if a - open brace doSomething doSomeMore - close brace This is not actually required by Java language syntax. Indeed, if the then part of an if statement is a single statement, it is legal to leave out the braces GoalKicker.com Java Notes for Professionals 734if a doSomething or even if a doSomething However there are dangers in ignoring Java style rules and leaving out the braces. Speci\ufb01cally, you signi\ufb01cantly increase the risk that code with faulty indentation will be misread. The dangling if problem Consider the example code from above, rewritten without braces. if a doSomething doSomeMore This code seems to say that the calls to doSomething and doSomeMore will both occur if and only if a is true . In fact, the code is incorrectly indented. The Java Language Speci\ufb01cation that the doSomeMore call is a separate statement following the if statement. The correct indentation is as follows if a doSomething doSomeMore The dangling else problem A second problem appears when we add else to the mix. Consider the following example with missing braces. if", "a if b doX else if c doY else doZ The code above seems to say that doZ will be called when a is false . In fact, the indentation is incorrect once again. The correct indentation for the code is if a if b doX else if c doY else doZ If the code was written according to the Java style rules, it would actually look like this if a if b doX else if c doY else GoalKicker.com Java Notes for Professionals 735 doZ To illustrate why that is better, suppose that you had accidentally mis-indented the code. You might end up with something like this if a if a if b if b doX doX else if c else if c doY doY else else doZ doZ But in both cases, the mis-indented code looks wrong to the eye of an experienced Java programmer. Section 132.4 Pitfall - Octal literals Consider the following code snippet Print the sum of the numbers 1 to 10 int count 0 for int i 1 i 010 i Mistake here .... count count i System.out.printlnThe sum of 1 to 10 is count A Java beginner might be surprised to know", "that the above program prints the wrong answer. It actually prints the sum of the numbers 1 to 8. The reason is that an integer literal that starts with the digit zero 0 is interpreted by the Java compiler as an octal literal, not a decimal literal as you might expect. Thus, 010 is the octal number 10, which is 8 in decimal. Section 132.5 Pitfall - Using to test a boolean Sometimes a new Java programmer will write code like this public void checkboolean ok if ok true Note ok true System.out.printlnIt is OK An experienced programmer would spot that as being clumsy and want to rewrite it as public void checkboolean ok if ok System.out.printlnIt is OK However, there is more wrong with ok true than simple clumsiness. Consider this variation public void checkboolean ok GoalKicker.com Java Notes for Professionals 736 if ok true Oooops! System.out.printlnIt is OK Here the programmer has mistyped as ... and now the code has a subtle bug. The expression x true unconditionally assigns true to x and then evaluates to true . In other words, the check method will now print It is OK no matter what the parameter was. The", "lesson here is to get out of the habit of using false and true . In addition to being verbose, they make your coding more error prone. Note A possible alternative to ok true that avoids the pitfall is to use Yoda conditions i.e. put the literal on the left side of the relational operator, as in true ok. This works, but most programmers would probably agree that Yoda conditions look odd. Certainly ok or !ok is more concise and more natural. Section 132.6 Pitfall - Ignoring method visibility Even experienced Java developers tend to think that Java has only three protection modi\ufb01ers. The language actually has four! The package private a.k.a. default level of visibility is often forgotten. You should pay attention to what methods you make public. The public methods in an application are the application s visible API. This should be as small and compact as possible, especially if you are writing a reusable library see also the SOLID principle. It is important to similarly consider the visibility of all methods, and to only use protected or package private access where appropriate. When you declare methods that should be private as public, you expose the internal", "implementation details of the class. A corollary to this is that you only unit test the public methods of your class - in fact you can only test public methods. It is bad practice to increase the visibility of private methods just to be able to run unit tests against those methods. Testing public methods that call the methods with more restrictive visibility should be su\ufb03cient to test an entire API. You should never expand your API with more public methods only to allow unit testing. Section 132.7 Pitfall Using assert for argument or user input validation A question that occasionally on StackOver\ufb02ow is whether it is appropriate to use assert to validate arguments supplied to a method, or even inputs provided by the user. The simple answer is that it is not appropriate. Better alternatives include Throwing an IllegalArgumentException using custom code. Using the Preconditions methods available in Google Guava library. Using the Validate methods available in Apache Commons Lang3 library. This is what the Java Language Speci\ufb01cation JLS 14.10, for Java 8 advises on this matter Typically, assertion checking is enabled during program development and testing, and disabled for deployment, to improve performance. Because assertions may be", "disabled, programs must not assume that the expressions contained in GoalKicker.com Java Notes for Professionals 737assertions will be evaluated. Thus, these boolean expressions should generally be free of side e\ufb00ects. Evaluating such a boolean expression should not a\ufb00ect any state that is visible after the evaluation is complete. It is not illegal for a boolean expression contained in an assertion to have a side e\ufb00ect, but it is generally inappropriate, as it could cause program behavior to vary depending on whether assertions were enabled or disabled. In light of this, assertions should not be used for argument checking in public methods. Argument checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled. A secondary problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception such as IllegalArgumentException , ArrayIndexOutOfBoundsException , or NullPointerException . An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate. It is intended that AssertionError never be caught, but it is possible to do so, thus the rules", "for try statements should treat assertions appearing in a try block similarly to the current treatment of throw statements. Section 132.8 Pitfall - Wildcard imports can make your code fragile Consider the following partial example import com.example.somelib. import com.acme.otherlib. public class Test private Context x new Context from com.example.somelib ... Suppose that when when you \ufb01rst developed the code against version 1.0 of somelib and version 1.0 of otherlib . Then at some later point, you need to upgrade your dependencies to a later versions, and you decide to use otherlib version 2.0. Also suppose that one of the changes that they made to otherlib between 1.0 and 2.0 was to add a Context class. Now when you recompile Test , you will get a compilation error telling you that Context is an ambiguous import. If you are familiar with the codebase, this probably is just a minor inconvenience. If not, then you have some work to do to address this problem, here and potentially elsewhere. The problem here is the wildcard imports. On the one hand, using wildcards can make your classes a few lines shorter. On the other hand Upwards compatible changes to other parts of your", "codebase, to Java standard libraries or to 3rd party libraries can lead to compilation errors. Readability su\ufb00ers. Unless you are using an IDE, \ufb01guring out which of the wildcard imports is pulling in a named class can be di\ufb03cult. The lesson is that it is a bad idea to use wildcard imports in code that needs to be long lived. Speci\ufb01c non-wildcard imports are not much e\ufb00ort to maintain if you use an IDE, and the e\ufb00ort is worthwhile. GoalKicker.com Java Notes for Professionals 738Section 132.9 Pitfall - Misplaced semicolons and missing braces This is a mistake that causes real confusion for Java beginners, at least the \ufb01rst time that they do it. Instead of writing this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown they accidentally write this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown and are puzzled when the Java compiler tells them that the else is misplaced. The Java compiler with interpret the above as follows if feeling HAPPY empty statement System.out.printlnSmile This is unconditional else This is misplaced. A statement cannot start with else System.out.printlnFrown In other cases, there will be no be compilation errors, but the code wont do what the programmer intends. For example for int", "i 0 i 5 i System.out.printlnHello only prints Hello once. Once again, the spurious semicolon means that the body of the for loop is an empty statement. That means that the println call that follows is unconditional. Another variation for int i 0 i 5 i System.out.printlnThe number is i This will give a Cannot \ufb01nd symbol error for i. The presence of the spurious semicolon means that the println call is attempting to use i outside of its scope. In those examples, there is a straight-forward solution simply delete the spurious semicolon. However, there are some deeper lessons to be drawn from these examples The semicolon in Java is not syntactic noise. The presence or absence of a semicolon can change the1. meaning of your program. Dont just add them at the end of every line. Dont trust your codes indentation. In the Java language, extra whitespace at the beginning of a line is2. ignored by the compiler. Use an automatic indenter. All IDEs and many simple text editors understand how to correctly indent Java3. GoalKicker.com Java Notes for Professionals 739code. This is the most important lesson. Follow the latest Java style guidelines, and put braces around the", "then4. and else statements and the body statement of a loop. The open brace should not be on a new line. If the programmer followed the style rules then the if example with a misplaced semicolons would look like this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown That looks odd to an experienced eye. If you auto-indented that code, it would probably look like this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown which should stand out as wrong to even a beginner. Section 132.10 Pitfall - Overloading instead of overriding Consider the following example public final class Person private final String firstName private final String lastName public PersonString firstName, String lastName this.firstName firstName null ? firstName this.lastName lastName null ? lastName public boolean equalsString other if !other instanceof Person return false Person p Person other return firstName. equalsp.firstName lastName. equalsp.lastName public int hashcode return firstName. hashCode 31 lastName. hashCode This code is not going to behave as expected. The problem is that the equals and hashcode methods for Person do not override the standard methods de\ufb01ned by Object . The equals method has the wrong signature. It should be declared as equalsObject not equalsString. The hashcode method has the wrong name.", "It should be hashCode note the capital C. These mistakes mean that we have declared accidental overloads, and these wont be used if Person is used in a GoalKicker.com Java Notes for Professionals 740polymorphic context. However, there is a simple way to deal with this from Java 5 onwards. Use the Override annotation whenever you intend your method to be an override Version Java SE 5 public final class Person ... Override public boolean equalsString other .... Override public hashcode .... When we add an Override annotation to a method declaration, the compiler will check that the method does override or implement a method declared in a superclass or interface. So in the example above, the compiler will give us two compilation errors, which should be enough to alert us to the mistake. Section 132.11 Pitfall of Auto-Unboxing Null Objects into Primitives public class Foobar public static void mainString args example Boolean ignore null if ignore false System.out.printlnDo not ignore! The pitfall here is that null is compared to false . Since were comparing a primitive boolean against a Boolean , Java attempts to unbox the the Boolean Object into a primitive equivalent, ready for comparison. However, since that", "value is null , a NullPointerException is thrown. Java is incapable of comparing primitive types against null values, which causes a NullPointerException at runtime. Consider the primitive case of the condition false null this would generate a compile time error incomparable types int and null. GoalKicker.com Java Notes for Professionals 741Chapter 133 Java Pitfalls - Threads and Concurrency Section 133.1 Pitfall - Extending java.lang.Thread The javadoc for the Thread class shows two ways to de\ufb01ne and use a thread Using a custom thread class class PrimeThread extends Thread long minPrime PrimeThread long minPrime this.minPrime minPrime public void run compute primes larger than minPrime . . . PrimeThread p new PrimeThread 143 p.start Using a Runnable class PrimeRun implements Runnable long minPrime PrimeRun long minPrime this.minPrime minPrime public void run compute primes larger than minPrime . . . PrimeRun p new PrimeRun 143 new Threadp.start Source java.lang.Thread javadoc . The custom thread class approach works, but it has a few problems It is awkward to use PrimeThread in a context that uses a classic thread pool, an executor, or the ForkJoin 1. framework. It is not impossible, because PrimeThread indirectly implements Runnable , but using a custom Thread class as", "a Runnable is certainly clumsy, and may not be viable ... depending on other aspects of the class. There is more opportunity for mistakes in other methods. For example, if you declared a2. PrimeThread. start without delegating to Thread.start, you would end up with a thread that ran on the current thread. The approach of putting the thread logic into a Runnable avoids these problems. Indeed, if you use an anonymous class Java 1.1 onwards to implement the Runnable the result is more succinct, and more readable than the GoalKicker.com Java Notes for Professionals 742examples above. final long minPrime ... new Threadnew Runnable public void run compute primes larger than minPrime . . . .start With a lambda expression Java 8 onwards, the above example would become even more elegant final long minPrime ... new Thread - compute primes larger than minPrime . . . .start Section 133.2 Pitfall - Too many threads makes an application slower A lot of people who are new to multi-threading think that using threads automatically make an application go faster. In fact, it is a lot more complicated than that. But one thing that we can state with certainty is that for any", "computer there is a limit on the number of threads that can be run at the same time A computer has a \ufb01xed number of cores or hyperthreads . A Java thread has to be scheduled to a core or hyperthread in order to run. If there are more runnable Java threads than available cores hyperthreads, some of them must wait. This tells us that simply creating more and more Java threads cannot make the application go faster and faster. But there are other considerations as well Each thread requires an o\ufb00-heap memory region for its thread stack. The typical default thread stack size is 512Kbytes or 1Mbytes. If you have a signi\ufb01cant number of threads, the memory usage can be signi\ufb01cant. Each active thread will refer to a number of objects in the heap. That increases the working set of reachable objects, which impacts on garbage collection and on physical memory usage. The overheads of switching between threads is non-trivial. It typically entails a switch into the OS kernel space to make a thread scheduling decision. The overheads of thread synchronization and inter-thread signaling e.g. wait, notify notifyAll can be signi\ufb01cant. Depending on the details of your application,", "these factors generally mean that there is a sweet spot for the number of threads. Beyond that, adding more threads gives minimal performance improvement, and can make performance worse. If your application create for each new task, then an unexpected increase in the workload e.g. a high request rate can lead to catastrophic behavior. A better way to deal with this is to use bounded thread pool whose size you can control statically or dynamically. When there is too much work to do, the application needs to queue the requests. If you use an ExecutorService , it will take care of the thread pool management and task queuing. GoalKicker.com Java Notes for Professionals 743Section 133.3 Pitfall incorrect use of wait notify The methods object.wait, object.notify and object.notifyAll are meant to be used in a very speci\ufb01c way. see httpstackover\ufb02ow.comdocumentationjava5409wait-notifyt20160811161648303307 The Lost Noti\ufb01cation problem One common beginner mistake is to unconditionally call object.wait private final Object lock new Object public void myConsumer synchronized lock lock. wait DONT DO THIS!! doSomething The reason this is wrong is that it depends on some other thread to call lock.notify or lock.notifyAll , but nothing guarantees that the other thread did not make that", "call before the consumer thread called lock.wait. lock.notify and lock.notifyAll do not do anything at all if some other thread is not already waiting for the noti\ufb01cation. The thread that calls myConsumer in this example will hang forever if it is too late to catch the noti\ufb01cation. The Illegal Monitor State bug If you call wait or notify on an object without holding the lock, then the JVM will throw IllegalMonitorStateException . public void myConsumer lock. wait throws exception consume public void myProducer produce lock. notify throws exception The design for wait notify requires that the lock is held because this is necessary to avoid systemic race conditions. If it was possible to call wait or notify without locking, then it would be impossible to implement the primary use-case for these primitives waiting for a condition to occur. Wait notify is too low-level The best way to avoid problems with wait and notify is to not use them. Most synchronization problems can be solved by using the higher-level synchronization objects queues, barriers, semaphores, etc. that are available in the java.utils.concurrent package. Section 133.4 Pitfall Shared variables require proper synchronization Consider this example public class ThreadTest implements Runnable GoalKicker.com Java", "Notes for Professionals 744 private boolean stop false public void run long counter 0 while !stop counter counter 1 System.out.printlnCounted counter public static void mainString args ThreadTest tt new ThreadTest new Threadtt.start Create and start child thread Thread.sleep1000 tt. stop true Tell child thread to stop. The intent of this program is intended to start a thread, let it run for 1000 milliseconds, and then cause it to stop by setting the stop \ufb02ag. Will it work as intended? Maybe yes, may be no. An application does not necessarily stop when the main method returns. If another thread has been created, and that thread has not been marked as a daemon thread, then the application will continue to run after the main thread has ended. In this example, that means that the application will keep running until child thread ends. That should happens when tt.stop is set to true . But that is actually not strictly true. In fact, the child thread will stop after it has observed stop with the value true . Will that happen? Maybe yes, maybe no. The Java Language Speci\ufb01cation guarantees that memory reads and writes made in a thread are visible to that", "thread, as per the order of the statements in the source code. However, in general, this is NOT guaranteed when one thread writes and another thread subsequently reads. To get guaranteed visibility, there needs to be a chain of happens-before relations between a write and a subsequent read. In the example above, there is no such chain for the update to the stop \ufb02ag, and therefore it is not guaranteed that the child thread will see stop change to true . Note to authors There should be a separate Topic on the Java Memory Model to go into the deep technical details. How do we \ufb01x the problem? In this case, there are two simple ways to ensure that the stop update is visible Declare stop to be volatile i.e. 1. private volatile boolean stop false For a volatile variable, the JLS speci\ufb01es that there is a happens-before relation between a write by one thread and a later read by a second thread. Use a mutex to synchronize as follows2. public class ThreadTest implements Runnable GoalKicker.com Java Notes for Professionals 745 private boolean stop false public void run long counter 0 while true synchronize this if stop break counter", "counter 1 System.out.printlnCounted counter public static void mainString args ThreadTest tt new ThreadTest new Threadtt.start Create and start child thread Thread.sleep1000 synchronize tt tt. stop true Tell child thread to stop. In addition to ensuring that there is mutual exclusion, the JLS speci\ufb01es that there is a happens-before relation between the releasing a mutex in one thread and gaining the same mutex in a second thread. But isnt assignment atomic? Yes it is! However, that fact does not mean that the e\ufb00ects of update will be visible simultaneously to all threads. Only a proper chain of happens-before relations will guarantee that. Why did they do this? Programmers doing multi-threaded programming in Java for the \ufb01rst time \ufb01nd the Memory Model is challenging. Programs behave in an unintuitive way because the natural expectation is that writes are visible uniformly. So why the Java designers design the Memory Model this way. It actually comes down to a compromise between performance and ease of use for the programmer. A modern computer architecture consists of multiple processors cores with individual register sets. Main memory is accessible either to all processors or to groups of processors. Another property of modern computer hardware is that", "access to registers is typically orders of magnitude faster to access than access to main memory. As the number of cores scales up, it is easy to see that reading and writing to main memory can become a systems main performance bottleneck. This mismatch is addressed by implementing one or more levels of memory caching between the processor cores and main memory. Each core access memory cells via its cache. Normally, a main memory read only happens when there is a cache miss, and a main memory write only happens when a cache line needs to be \ufb02ushed. For an application where each cores working set of memory locations will \ufb01t into its cache, the core speed is no longer limited by main memory speed bandwidth. But that gives us a new problem when multiple cores are reading and writing shared variables. The latest version of a variable may sit in one cores cache. Unless the that core \ufb02ushes the cache line to main memory, AND other cores GoalKicker.com Java Notes for Professionals 746invalidate their cached copy of older versions, some of them are liable to see stale versions of the variable. But if the caches were \ufb02ushed to", "memory each time there is a cache write just in case there was a read by another core that would consume main memory bandwidth unnecessarily. The standard solution used at the hardware instruction set level is to provide instructions for cache invalidation and a cache write-through, and leave it to the compiler to decide when to use them. Returning to Java. the Memory Model is designed so that the Java compilers are not required to issue cache invalidation and write-through instructions where they are not really needed. The assumption is that the programmer will use an appropriate synchronization mechanism e.g. primitive mutexes, volatile , higher-level concurrency classes and so on to indicate that it needs memory visibility. In the absence of a happens-before relation, the Java compilers are free to assume that no cache operations or similar are required. This has signi\ufb01cant performance advantages for multi-threaded applications, but the downside is that writing correct multi-threaded applications is not a simple matter. The programmer does have to understand what he or she is doing. Why cant I reproduce this? There are a number of reasons why problems like this are di\ufb03cult to reproduce As explained above, the consequence of not", "dealing with memory visibility issues problems properly is1. typically that your compiled application does not handle the memory caches correctly. However, as we alluded to above, memory caches often get \ufb02ushed anyway. When you change the hardware platform, the characteristics of the memory caches may change. This can2. lead to di\ufb00erent behavior if your application does not synchronize correctly. You may be observing the e\ufb00ects of serendipitous synchronization. For example, if you add traceprints, their 3. is typically some synchronization happening behind the scenes in the IO streams that causes cache \ufb02ushes. So adding traceprints often causes the application to behave di\ufb00erently. Running an application under a debugger causes it to be compiled di\ufb00erently by the JIT compiler.4. Breakpoints and single stepping exacerbate this. These e\ufb00ects will often change the way an application behaves. These things make bugs that are due to inadequate synchronization particularly di\ufb03cult to solve. Section 133.5 Pitfall - Thread creation is relatively expensive Consider these two micro-benchmarks The \ufb01rst benchmark simply creates, starts and joins threads. The threads Runnable does no work. public class ThreadTest public static void mainString args throws Exception while true long start System.nanoTime for int i 0 i 100000 i Thread", "t new Threadnew Runnable public void run t. start t. join long end System.nanoTime GoalKicker.com Java Notes for Professionals 747 System.out.printlnend - start 100000.0 java ThreadTest 34627.91355 33596.66021 33661.19084 33699.44895 33603.097 33759.3928 33671.5719 33619.46809 33679.92508 33500.32862 33409.70188 33475.70541 33925.87848 33672.89529 C On a typical modern PC running Linux with 64bit Java 8 u101, this benchmark shows an average time taken to create, start and join thread of between 33.6 and 33.9 microseconds. The second benchmark does the equivalent to the \ufb01rst but using an ExecutorService to submit tasks and a Future to rendezvous with the end of the task. import java.util.concurrent. public class ExecutorTest public static void mainString args throws Exception ExecutorService exec Executors. newCachedThreadPool while true long start System.nanoTime for int i 0 i 100000 i Future ? future exec.submitnew Runnable public void run future. get long end System.nanoTime System.out.printlnend - start 100000.0 java ExecutorTest 6714.66053 5418.24901 5571.65213 5307.83651 5294.44132 5370.69978 5291.83493 5386.23932 5384.06842 5293.14126 5445.17405 5389.70685 GoalKicker.com Java Notes for Professionals 748C As you can see, the averages are between 5.3 and 5.6 microseconds. While the actual times will depend on a variety of factors, the di\ufb00erence between these two results is signi\ufb01cant. It is clearly faster", "to use a thread pool to recycle threads than it is to create new threads. GoalKicker.com Java Notes for Professionals 749Chapter 134 Java Pitfalls - Nulls and NullPointerException Section 134.1 Pitfall - Making good unexpected nulls On StackOver\ufb02ow, we often see code like this in Answers public String joinStrings String a, String b if a null a if b null b return a b Often, this is accompanied with an assertion that is best practice to test for null like this to avoid NullPointerException . Is it best practice? In short No. There are some underlying assumptions that need to be questioned before we can say if it is a good idea to do this in our joinStrings What does it mean for a or b to be null? A String value can be zero or more characters, so we already have a way of representing an empty string. Does null mean something di\ufb00erent to ? If no, then it is problematic to have two ways to represent an empty string. Did the null come from an uninitialized variable? A null can come from an uninitialized \ufb01eld, or an uninitialized array element. The value could be uninitialized by design,", "or by accident. If it was by accident then this is a bug. Does the null represent a dont know or missing value? Sometimes a null can have a genuine meaning e.g. that the real value of a variable is unknown or unavailable or optional. In Java 8, the Optional class provides a better way of expressing that. If this is a bug or a design error should we make good? One interpretation of the code is that we are making good an unexpected null by using an empty string in its place. Is the correct strategy? Would it be better to let the NullPointerException happen, and then catch the exception further up the stack and log it as a bug? The problem with making good is that it is liable to either hide the problem, or make it harder to diagnose. Is this e\ufb03cient good for code quality? If the make good approach is used consistently, your code is going to contain a lot of defensive null tests. This is going to make it longer and harder to read. Furthermore, all of this testing and making good is liable to impact on the performance of your application. In", "summary GoalKicker.com Java Notes for Professionals 750If null is a meaningful value, then testing for the null case is the correct approach. The corollary is that if a null value is meaningful, then this should be clearly documented in the javadocs of any methods that accept the null value or return it. Otherwise, it is a better idea to treat an unexpected null as a programming error, and let the NullPointerException happen so that the developer gets to know there is a problem in the code. Section 134.2 Pitfall - Using null to represent an empty array or collection Some programmers think that it is a good idea to save space by using a null to represent an empty array or collection. While it is true that you can save a small amount of space, the \ufb02ipside is that it makes your code more complicated, and more fragile. Compare these two versions of a method for summing an array The \ufb01rst version is how you would normally code the method Sum the values in an array of integers. arg values the array to be summed return the sum public int sumint values int sum 0 for int value values", "sum value return sum The second version is how you need to code the method if you are in the habit of using null to represent an empty array. Sum the values in an array of integers. arg values the array to be summed, or null. return the sum, or zero if the array is null. public int sumint values int sum 0 if values ! null for int value values sum value return sum As you can see, the code is a bit more complicated. This is directly attributable to the decision to use null in this way. Now consider if this array that might be a null is used in lots of places. At each place where you use it, you need to consider whether you need to test for null . If you miss a null test that needs to be there, you risk a NullPointerException . Hence, the strategy of using null in this way leads to your application being more fragile i.e. more vulnerable to the consequences of programmer errors. The lesson here is to use empty arrays and empty lists when that is what you mean. GoalKicker.com Java Notes for Professionals 751int values", "new int0 always empty ListInteger list new ArrayList initially empty ListInteger list Collections .emptyList always empty The space overhead is small, and there are other ways to minimize it if this this is a worthwhile thing to do. Section 134.3 Pitfall - Not checking if an IO stream isnt even initialized when closing it To prevent memory leaks, one should not forget to close an input stream or an output stream whose job is done. This is usually done with a try-catch -finally statement without the catch part void writeNullBytesToAFile int count, String filename throws IOException FileOutputStream out null try out new FileOutputStream filename for count 0 count-- out. write0 finally out. close While the above code might look innocent, it has a \ufb02aw that can make debugging impossible. If the line where out is initialized out new FileOutputStream filename throws an exception, then out will be null when out.close is executed, resulting in a nasty NullPointerException ! To prevent this, simply make sure the stream isnt null before trying to close it. void writeNullBytesToAFile int count, String filename throws IOException FileOutputStream out null try out new FileOutputStream filename for count 0 count-- out. write0 finally if out !", "null out. close An even better approach is to try-with-resources, since itll automatically close the stream with a probability of 0 to throw an NPE without the need of a finally block. void writeNullBytesToAFile int count, String filename throws IOException try FileOutputStream out new FileOutputStream filename for count 0 count-- out. write0 Section 134.4 Pitfall - Returning null instead of throwing an exception Some Java programmers have a general aversion to throwing or propagating exceptions. This leads to code like the following GoalKicker.com Java Notes for Professionals 752public Reader getReader String pathname try return new BufferedReader FileReader pathname catch IOException ex System.out.printlnOpen failed ex.getMessage return null So what is the problem with that? The problem is that the getReader is returning a null as a special value to indicate that the Reader could not be opened. Now the returned value needs to be tested to see if it is null before it is used. If the test is left out, the result will be a NullPointerException . There are actually three problems here The IOException was caught too soon. 1. The structure of this code means that there is a risk of leaking a resource.2. A null was used", "then returned because no real Reader was available to return. 3. In fact, assuming that the exception did need to be caught early like this, there were a couple of alternatives to returning null It would be possible to implement a NullReader class e.g. one where APIs operations behaves as if the 1. reader was already at the end of \ufb01le position. With Java 8, it would be possible to declare getReader as returning an Optional Reader. 2. Section 134.5 Pitfall - Unnecessary use of Primitive Wrappers can lead to NullPointerExceptions Sometimes, programmers who are new Java will use primitive types and wrappers interchangeably. This can lead to problems. Consider this example public class MyRecord public int a, b public Integer c, d ... MyRecord record new MyRecord record.a 1 OK record.b record. b 1 OK record.c 1 OK record.d record. d 1 throws a NullPointerException Our MyRecord class1 relies on default initialization to initialize the values on its \ufb01elds. Thus, when we new a record, the a and b \ufb01elds will be set to zero, and the c and d \ufb01elds will be set to null . When we try to use the default initialized \ufb01elds, we see", "that the int \ufb01elds works all of the time, but the Integer \ufb01elds work in some cases and not others. Speci\ufb01cally, in the case that fails with d, what happens is that the expression on the right-hand side attempts to unbox a null reference, and that is what causes the NullPointerException to be thrown. There are a couple of ways to look at this GoalKicker.com Java Notes for Professionals 753If the \ufb01elds c and d need to be primitive wrappers, then either we should not be relying on default initialization, or we should be testing for null . For former is the correct approach unless there is a de\ufb01nite meaning for the \ufb01elds in the null state. If the \ufb01elds dont need to be primitive wrappers, then it is a mistake to make them primitive wrappers. In addition to this problem, the primitive wrappers have extra overheads relative to primitive types. The lesson here is to not use primitive wrapper types unless you really need to. 1 - This class is not an example of good coding practice. For instance, a well-designed class would not have public \ufb01elds. However, that is not the point of this example. Section 134.6", "Pitfall - Using Yoda notation to avoid NullPointerException A lot of example code posted on StackOver\ufb02ow includes snippets like this if A.equalssomeString do something This does prevent or avoid a possible NullPointerException in the case that someString is null . Furthermore, it is arguable that A.equalssomeString is better than someString ! null someString. equalsA It is more concise, and in some circumstances it might be more e\ufb03cient. However, as we argue below, conciseness could be a negative. However, the real pitfall is using the Yoda test to avoid NullPointerExceptions as a matter of habit. When you write A.equalssomeString you are actually making good the case where someString happens to be null . But as another example Pitfall - Making good unexpected nulls explains, making good null values can be harmful for a variety of reasons. This means that Yoda conditions are not best practice1. Unless the null is expected, it is better to let the NullPointerException happen so that you can get a unit test failure or a bug report. That allows you to \ufb01nd and \ufb01x the bug that caused the unexpected unwanted null to appear. Yoda conditions should only be used in cases where the null is", "expected because the object you are testing has come from an API that is documented as returning a null . And arguably, it could be better to use one of the less pretty ways expressing the test because that helps to highlight the null test to someone who is reviewing your code. 1 - According to Wikipedia Best coding practices are a set of informal rules that the software development community has learned over time which can help improve the quality of software. . Using Yoda notation does not achieve this. In a lot of situations, it makes the code worse. GoalKicker.com Java Notes for Professionals 754Chapter 135 Java Pitfalls - Performance Issues This topic describes a number of pitfalls i.e. mistakes that novice java programmers make that relate to Java application performance. Section 135.1 Pitfall - String concatenation in a loop does not scale Consider the following code as an illustration public String joinWords ListString words String message for String word words message message word return message Unfortunate this code is ine\ufb03cient if the words list is long. The root of the problem is this statement message message word For each loop iteration, this statement creates a new", "message string containing a copy of all characters in the original message string with extra characters appended to it. This generates a lot of temporary strings, and does a lot of copying. When we analyse joinWords , assuming that there are N words with an average length of M, we \ufb01nd that ON temporary strings are created and OM.N2 characters will be copied in the process. The N2 component is particularly troubling. The recommended approach for this kind of problem1 is to use a StringBuilder instead of string concatenation as follows public String joinWords2 ListString words StringBuilder message new StringBuilder for String word words message. append .appendword return message. toString The analysis of joinWords2 needs to take account of the overheads of growing the StringBuilder backing array that holds the builders characters. However, it turns out that the number of new objects created is OlogN and that the number of characters copied is OM.N characters. The latter includes characters copied in the \ufb01nal toString call. It may be possible to tune this further, by creating the StringBuilder with the correct capacity to start with. However, the overall complexity remains the same. Returning to the original joinWords method, it turns", "out that the critical statement will be optimized by a typical Java compiler to something like this StringBuilder tmp new StringBuilder GoalKicker.com Java Notes for Professionals 755 tmp.appendmessage.append .appendword message tmp.toString However, the Java compiler will not hoist the StringBuilder out of the loop, as we did by hand in the code for joinWords2 . Reference Is Javas String operator in a loop slow? 1 - In Java 8 and later, the Joiner class can be used to solve this particular problem. However, that is not what this example is really supposed to be about . Section 135.2 Pitfall - Using size to test if a collection is empty is inecient The Java Collections Framework provides two related methods for all Collection objects size returns the number of entries in a Collection , and isEmpty method returns true if and only if the Collection is empty. Both methods can be used to test for collection emptiness. For example Collection String strings new ArrayList boolean isEmptywrong strings. size 0 Avoid this boolean isEmpty strings. isEmpty Best While these approaches look the same, some collection implementations do not store the size. For such a collection, the implementation of size needs to", "calculate the size each time it is called. For instance A simple linked list class but not the java.util.LinkedList might need to traverse the list to count the elements. The ConcurrentHashMap class needs to sum the entries in all of the maps segments. A lazy implementation of a collection might need to realize the entire collection in memory in order to count the elements. By contrast, an isEmpty method only needs to test if there is at least one element in the collection. This does not entail counting the elements. While size 0 is not always less e\ufb03cient that isEmpty, it is inconceivable for a properly implemented isEmpty to be less e\ufb03cient than size 0. Hence isEmpty is preferred. Section 135.3 Pitfall - Interning strings so that you can use is a bad idea When some programmers see this advice Testing strings using is incorrect unless the strings are interned their initial reaction is to intern strings so that they can use . After all is faster than calling String.equals..., isnt it. This is the wrong approach, from a number of perspectives GoalKicker.com Java Notes for Professionals 756Fragility First of all, you can only safely use if you know", "that all of the String objects you are testing have been interned. The JLS guarantees that String literals in your source code will have been interned. However, none of the standard Java SE APIs guarantee to return interned strings, apart from String.internString itself. If you miss just one source of String objects that havent been interned, your application will be unreliable. That unreliability will manifest itself as false negatives rather than exceptions which is liable to make it harder to detect. Costs of using intern Under the hood, interning works by maintaining a hash table that contains previously interned String objects. Some kind of weak reference mechanism is used so that the interning hash table does not become a storage leak. While the hash table is implemented in native code unlike HashMap , HashTable and so on, the intern calls are still relatively costly in terms of CPU and memory used. This cost has to be compared with the saving of we are going to get by using instead of equals . In fact, we are not going to break even unless each interned string is compared with other strings a few times. Aside the few situations where interning", "is worthwhile tend to be about reducing the memory foot print of an application where the same strings recur many times, and those strings have a long lifetime. The impact on garbage collection In addition to the direct CPU and memory costs described above, interned Strings impact on the garbage collector performance. For versions of Java prior to Java 7, interned strings are held in the PermGen space which is collected infrequently. If PermGen needs to be collected, this typically triggers a full garbage collection. If the PermGen space \ufb01lls completely, the JVM crashes, even if there was free space in the regular heap spaces. In Java 7, the string pool was moved out of PermGen into the normal heap. However, the hash table is still going to be a long-lived data structure, which is going to cause any interned strings to be long-lived. Even if the interned string objects were allocated in Eden space they would most likely be promoted before they were collected. Thus in all cases, interning a string is going to prolong its lifetime relative to an ordinary string. That will increase the garbage collection overheads over the lifetime of the JVM. The second issue", "is that the hash table needs to use a weak reference mechanism of some kind to prevent string interning leaking memory. But such a mechanism is more work for the garbage collector. These garbage collection overheads are di\ufb03cult to quantify, but there is little doubt that they do exist. If you use intern extensively, they could be signi\ufb01cant. The string pool hashtable size According to this source , from Java 6 onwards, the string pool is implemented as \ufb01xed sized hash table with chains to deal with strings that hash to the same bucket. In early releases of Java 6, the hash table had a hard-wired constant size. A tuning parameter -XXStringTableSize was added as a mid-life update to Java 6. Then in a mid- life update to Java 7, the default size of the pool was changed from 1009 to 60013 . The bottom line is that if you do intend to use intern intensively in your code, it is advisable to pick a version of Java where the hashtable size is tunable and make sure that you tune the size it appropriately. Otherwise, the performance of intern is liable to degrade as the pool gets larger. Interning", "as a potential denial of service vector GoalKicker.com Java Notes for Professionals 757The hashcode algorithm for strings is well-known. If you intern strings supplied by malicious users or applications, this could be used as part of a denial of service DoS attack. If the malicious agent arranges that all of the strings it provides have the same hash code, this could lead to an unbalanced hash table and ON performance for intern ... where N is the number of collided strings. There are simpler more e\ufb00ective ways to launch a DoS attack against a service. However, this vector could be used if the goal of the DoS attack is to break security, or to evade \ufb01rst-line DoS defences. Section 135.4 Pitfall - Using new to create primitive wrapper instances is inecient The Java language allows you to use new to create instances Integer , Boolean and so on, but it is generally a bad idea. It is better to either use autoboxing Java 5 and later or the valueOf method. Integer i1 new Integer1 BAD Integer i2 2 BEST autoboxing Integer i3 Integer.valueOf3 OK The reason that using new Integerint explicitly is a bad idea is that it creates", "a new object unless optimized out by JIT compiler. By contrast, when autoboxing or an explicit valueOf call are used, the Java runtime will try to reuse an Integer object from a cache of pre-existing objects. Each time the runtime has a cache hit, it avoids creating an object. This also saves heap memory and reduces GC overheads caused by object churn. Notes In recent Java implementations, autoboxing is implemented by calling valueOf , and there are caches for 1. Boolean , Byte , Short , Integer , Long and Character . The caching behavior for the integral types is mandated by the Java Language Speci\ufb01cation.2. Section 135.5 Pitfall - Eciency concerns with regular expressions Regular expression matching is a powerful tool in Java, and in other contexts but it does have some drawbacks. One of these that regular expressions tends to be rather expensive. Pattern and Matcher instances should be reused Consider the following example Test if all strings in a list consist of English letters and numbers. param strings the list to be checked return true if an only if all strings satisfy the criteria throws NullPointerException if strings is null or a null element. public boolean", "allAlphanumeric ListString strings for String s strings if !s.matchesA-Za-z0-9 return false return true This code is correct, but it is ine\ufb03cient. The problem is in the matches... call. Under the hood, s.matchesA- GoalKicker.com Java Notes for Professionals 758Za-z0-9 is equivalent to this Pattern. matchess, A-Za-z0-9 which is in turn equivalent to Pattern. compileA-Za-z0-9 .matchers.matches The Pattern. compileA-Za-z0-9 call parses the regular expression, analyze it, and construct a Pattern object that holds the data structure that will be used by the regex engine. This is a non-trivial computation. Then a Matcher object is created to wrap the s argument. Finally we call match to do the actual pattern matching. The problem is that this work is all repeated for each loop iteration. The solution is to restructure the code as follows private static Pattern ALPHANUMERIC Pattern. compileA-Za-z0-9 public boolean allAlphanumeric ListString strings Matcher matcher ALPHANUMERIC. matcher for String s strings matcher. resets if !matcher. matches return false return true Note that the javadoc for Pattern states Instances of this class are immutable and are safe for use by multiple concurrent threads. Instances of the Matcher class are not safe for such use. Dont use match when you should use \ufb01nd", "Suppose you want to test if a string s contains three or more digits in a row. You cn express this in various ways including if s.matches.0-93. System.out.printlnmatches or if Pattern. compile0-93 .matchers.find System.out.printlnmatches The \ufb01rst one is more concise, but it is also likely to be less e\ufb03cient. On the face of it, the \ufb01rst version is going to try to match the entire string against the pattern. Furthermore, since . is a greedy pattern, the pattern matcher is likely to advance eagerly try to the end of the string, and backtrack until it \ufb01nds a match. By contrast, the second version will search from left to right and will stop searching as soon as it \ufb01nds the 3 digits in a row. GoalKicker.com Java Notes for Professionals 759Use more e\ufb03cient alternatives to regular expressions Regular expressions are a powerful tool, but they should not be your only tool. A lot of tasks can be done more e\ufb03ciently in other ways. For example Pattern. compileABC.matchers.find does the same thing as s.contains ABC except that the latter is a lot more e\ufb03cient. Even if you can amortize the cost of compiling the regular expression. Often, the non-regex form is", "more complicated. For example, the test performed by the matches call the earlier allAlplanumeric method can be rewritten as public boolean matches String s for char c s if c A c Z c a c z c 0 c 9 return false return true Now that is more code than using a Matcher , but it is also going to be signi\ufb01cantly faster. Catastrophic Backtracking This is potentially a problem with all implementations of regular expressions, but we will mention it here because it is a pitfall for Pattern usage. Consider this contrived example Pattern pat Pattern. compileAB System.out.printlnpat.matcherAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB .matches System.out.printlnpat.matcherAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC .matches The \ufb01rst println call will quickly print true . The second one will print false . Eventually. Indeed, if you experiment with the code above, you will see that each time you add an A before the C, the time take will double. This is behavior is an example of catastrophic backtracking . The pattern matching engine that implements the regex matching is fruitlessly trying all of the possible ways that the pattern might match. Let us look at what AB actually means. Super\ufb01cially, it seems to say one or more A characters followed by a", "B value, but in reality it says one or more groups, each of which consists of one or more A characters. So, for example AB matches one way only AB AAB matches two ways AAB or AAB AAAB matches four ways AAAB or AAAB or AAAB or AAAB and so on In other words, the number of possible matches is 2N where N is the number of A characters. GoalKicker.com Java Notes for Professionals 760The above example is clearly contrived, but patterns that exhibit this kind of performance characteristics i.e. O2N or ONK for a large K arise frequently when ill-considered regular expressions are used. There are some standard remedies Avoid nesting repeating patterns within other repeating patterns. Avoid using too many repeating patterns. Use non-backtracking repetition as appropriate. Dont use regexes for complicated parsing tasks. Write a proper parser instead. Finally, beware of situations where a user or an API client can supply a regex string with pathological characteristics. That can lead to accidental or deliberate denial of service. References The Regular Expressions tag, particularly httpstackover\ufb02ow.comdocumentationregex977backtrackingt201610010339131361163 and httpstackover\ufb02ow.comdocumentationregex4527when-you-should-not-use-regular-expressionst2016 10010339593564913 Regex Performance by Je\ufb00 Atwood. How to kill Java with a Regular Expression by Andreas Hau\ufb02er. Section 135.6 Pitfall", "- Small reads writes on unbuered streams are inecient Consider the following code to copy one \ufb01le to another import java.io. public class FileCopy public static void mainString args throws Exception try InputStream is new FileInputStream args0 OutputStream os new FileOutputStream args1 int octet while octet is.read ! -1 os. writeoctet We have deliberated omitted normal argument checking, error reporting and so on because they are not relevant to point of this example. If you compile the above code and use it to copy a huge \ufb01le, you will notice that it is very slow. In fact, it will be at least a couple of orders of magnitude slower than the standard OS \ufb01le copy utilities. Add actual performance measurements here! The primary reason that the example above is slow in the large \ufb01le case is that it is performing one-byte reads and one-byte writes on unbu\ufb00ered byte streams. The simple way to improve performance is to wrap the streams with bu\ufb00ered streams. For example import java.io. public class FileCopy GoalKicker.com Java Notes for Professionals 761 public static void mainString args throws Exception try InputStream is new BufferedInputStream new FileInputStream args0 OutputStream os new BufferedOutputStream new FileOutputStream args1 int", "octet while octet is.read ! -1 os. writeoctet These small changes will improve data copy rate by at least a couple of orders of magnitude, depending on various platform-related factors. The bu\ufb00ered stream wrappers cause the data to be read and written in larger chunks. The instances both have bu\ufb00ers implemented as byte arrays. With is, data is read from the \ufb01le into the bu\ufb00er a few kilobytes at a time. When read is called, the implementation will typically return a byte from the bu\ufb00er. It will only read from the underlying input stream if the bu\ufb00er has been emptied. The behavior for os is analogous. Calls to os.writeint write single bytes into the bu\ufb00er. Data is only written to the output stream when the bu\ufb00er is full, or when os is \ufb02ushed or closed. What about character-based streams? As you should be aware, Java IO provides di\ufb00erent APIs for reading and writing binary and text data. InputStream and OutputStream are the base APIs for stream-based binary IO Reader and Writer are the base APIs for stream-based text IO. For text IO, BufferedReader and BufferedWriter are the equivalents for BufferedInputStream and BufferedOutputStream . Why do bu\ufb00ered streams make this", "much di\ufb00erence? The real reason that bu\ufb00ered streams help performance is to do with the way that an application talks to the operating system Java method in a Java application, or native procedure calls in the JVMs native runtime libraries are fast. They typically take a couple of machine instructions and have minimal performance impact. By contrast, JVM runtime calls to the operating system are not fast. They involve something known as a syscall. The typical pattern for a syscall is as follows Put the syscall arguments into registers.1. Execute a SYSENTER trap instruction.2. The trap handler switched to privileged state and changes the virtual memory mappings. Then it3. dispatches to the code to handle the speci\ufb01c syscall. The syscall handler checks the arguments, taking care that it isnt being told to access memory that the4. user process should not see. The syscall speci\ufb01c work is performed. In the case of a read syscall, this may involve 5. checking that there is data to be read at the \ufb01le descriptors current position1. calling the \ufb01le system handler to fetch the required data from disk or wherever it is stored into2. the bu\ufb00er cache, copying data from the bu\ufb00er cache", "to the JVM-supplied address3. GoalKicker.com Java Notes for Professionals 762adjusting thstream pointerse \ufb01le descriptor position4. Return from the syscall. This entails changing VM mappings again and switching out of privileged state.6. As you can imagine, performing a single syscall can thousands of machine instructions. Conservatively, at least two orders of magnitude longer than a regular method call. Probably three or more. Given this, the reason that bu\ufb00ered streams make a big di\ufb00erence is that they drastically reduce the number of syscalls. Instead of doing a syscall for each read call, the bu\ufb00ered input stream reads a large amount of data into a bu\ufb00er as required. Most read calls on the bu\ufb00ered stream do some simple bounds checking and return a byte that was read previously. Similar reasoning applies in the output stream case, and also the character stream cases. Some people think that bu\ufb00ered IO performance comes from the mismatch between the read request size and the size of a disk block, disk rotational latency and things like that. In fact, a modern OS uses a number of strategies to ensure that the application typically doesnt need to wait for the disk. This is not the real explanation. Are", "bu\ufb00ered streams always a win? Not always. Bu\ufb00ered streams are de\ufb01nitely a win if your application is going to do lots of small reads or writes. However, if your application only needs to perform large reads or writes to from a large byte or char, then bu\ufb00ered streams will give you no real bene\ufb01ts. Indeed there might even be a tiny performance penalty. Is this the fastest way to copy a \ufb01le in Java? No it isnt. When you use Javas stream-based APIs to copy a \ufb01le, you incur the cost of at least one extra memory-to- memory copy of the data. It is possible to avoid this if your use the NIO ByteBuffer and Channel APIs. Add a link to a separate example here. Section 135.7 Pitfall - Over-use of primitive wrapper types is inecient Consider these two pieces of code int a 1000 int b a 1 and Integer a 1000 Integer b a 1 Question Which version is more e\ufb03cient? Answer The two versions look almost the identical, but the \ufb01rst version is a lot more e\ufb03cient than the second one. The second version is using a representation for the numbers that uses more space, and", "is relying on auto-boxing and auto-unboxing behind the scenes. In fact the second version is directly equivalent to the following code Integer a Integer.valueOf1000 box 1000 Integer b Integer.valueOfa.intValue 1 unbox 1000, add 1, box 1001 Comparing this to the other version that uses int, there are clearly three extra method calls when Integer is used. In the case of valueOf , the calls are each going to create and initialize a new Integer object. All of this extra boxing and unboxing work is likely to make the second version an order of magnitude slower than the \ufb01rst one. GoalKicker.com Java Notes for Professionals 763In addition to that, the second version is allocating objects on the heap in each valueOf call. While the space utilization is platform speci\ufb01c, it is likely to be in the region of 16 bytes for each Integer object. By contrast, the int version needs zero extra heap space, assuming that a and b are local variables. Another big reason why primitives are faster then their boxed equivalent is how their respective array types are laid out in memory. If you take int and Integer as an example, in the case of an int the", "int values are contiguously laid out in memory. But in the case of an Integer its not the values that are laid out, but references pointers to Integer objects, which in turn contain the actual int values. Besides being an extra level of indirection, this can be a big tank when it comes to cache locality when iterating over the values. In the case of an int the CPU could fetch all the values in the array, into its cache at once, because they are contiguous in memory. But in the case of an Integer the CPU potentially has to do an additional memory fetch for each element, since the array only contains references to the actual values. In short, using primitive wrapper types is relatively expensive in both CPU and memory resources. Using them unnecessarily is in e\ufb03cient. Section 135.8 Pitfall - The overheads of creating log messages TRACE and DEBUG log levels are there to be able to convey high detail about the operation of the given code at runtime. Setting the log level above these is usually recommended, however some care must be taken for these statements to not a\ufb00ect performance even when seemingly turned o\ufb00.", "Consider this log statement Processing a request of some kind, logging the parameters LOG.debugRequest coming from myInetAddress. toString parameters Arrays.toString veryLongParamArray Even when the log level is set to INFO , arguments passed to debug will be evaluated on each execution of the line. This makes it unnecessarily consuming on several counts String concatenation multiple String instances will be created InetAddress might even do a DNS lookup. the veryLongParamArray might be very long - creating a String out of it consumes memory, takes time Solution Most logging framework provide means to create log messages using \ufb01x strings and object references. The log message will be evaluated only if the message is actually logged. Example No toString evaluation, no string concatenation if debug is disabled LOG.debugRequest coming from parameters , myInetAddress, parameters This works very well as long as all parameters can be converted to strings using String.valueOfObject . If the log message compuation is more complex, the log level can be checked before logging if LOG.isDebugEnabled Argument expression evaluated only when DEBUG is enabled LOG. debugRequest coming from , parameters , myInetAddress, Arrays.toString veryLongParamArray GoalKicker.com Java Notes for Professionals 764 Here, LOG.debug with the costly Arrays.toString Obect computation is", "processed only when DEBUG is actually enabled. Section 135.9 Pitfall - Iterating a Maps keys can be inecient The following example code is slower than it needs to be MapString, String map new HashMap for String key map.keySet String value map.getkey Do something with key and value That is because it requires a map lookup the get method for each key in the map. This lookup may not be e\ufb03cient in a HashMap, it entails calling hashCode on the key, then looking up the correct bucket in internal data structures, and sometimes even calling equals . On a large map, this may not be a trivial overhead. The correct way of avoiding this is to iterate on the maps entries, which is detailed in the Collections topic Section 135.10 Pitfall - Calling System.gc is inecient It is almost always a bad idea to call System.gc. The javadoc for the gc method speci\ufb01es the following Calling the gc method suggests that the Java Virtual Machine expend e\ufb00ort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the Java Virtual Machine has made a best e\ufb00ort", "to reclaim space from all discarded objects. There are a couple of important points that can be drawn from this The use of the word suggests rather than say tells means that the JVM is free to ignore the suggestion.1. The default JVM behavior recent releases is to follow the suggestion, but this can be overridden by setting - XXDisableExplicitGC when when launching the JVM. The phrase a best e\ufb00ort to reclaim space from all discarded objects implies that calling gc will trigger a 2. full garbage collection. So why is calling System.gc a bad idea? First, running a full garbage collection is expensive. A full GC involves visiting and marking every object that is still reachable i.e. every object that is not garbage. If you trigger this when there isnt much garbage to be collected, then the GC does a lot of work for relatively little bene\ufb01t. Second, a full garbage collection is liable to disturb the locality properties of the objects that are not collected. Objects that are allocated by the same thread at roughly the same time tend to be allocated close together in memory. This is good. Objects that are allocated at the same time", "are likely to be related i.e. reference each other. If your application uses those references, then the chances are that memory access will be faster because of various memory and page caching e\ufb00ects. Unfortunately, a full garbage collection tend to move objects around so that objects that were once close are now further apart. GoalKicker.com Java Notes for Professionals 765Third, running a full garbage collection is liable to make your application pause until the collection is complete. While this is happening, your application will be non-responsive. In fact, the best strategy is to let the JVM decide when to run the GC, and what kind of collection to run. If you dont interfere, the JVM will choose a time and collection type that optimizes throughput or minimizes GC pause times. At the beginning we said ... almost always a bad idea .... In fact there are a couple of scenarios where it might be a good idea If you are implementing a unit test for some code that is garbage collection sensitive e.g. something1. involving \ufb01nalizers or weak soft phantom references then calling System.gc may be necessary. In some interactive applications, there can be particular points in time where", "the user wont care if there is a2. garbage collection pause. One example is a game where there are natural pauses in the play e.g. when loading a new level. Section 135.11 Pitfall - Calling new StringString is inecient Using new StringString to duplicate a string is ine\ufb03cient and almost always unnecessary. String objects are immutable, so there is no need to copy them to protect against changes. In some older versions of Java, String objects can share backing arrays with other String objects. In those versions, it is possible to leak memory by creating a small substring of a large string and retaining it. However, from Java 7 onwards, String backing arrays are not shared. In the absence of any tangible bene\ufb01t, calling new StringString is simply wasteful Making the copy takes CPU time. The copy uses more memory which increases the applications memoru footprint and or increases GC overheads. Operations like equalsObject and hashCode can be slower if String objects are copied. GoalKicker.com Java Notes for Professionals 766Chapter 136 ServiceLoader Section 136.1 Simple ServiceLoader Example The ServiceLoader is a simple and easy to use built-in mechanism for dynamic loading of interface implementations. With the service loader -", "providing means for instantation but not the wiring - a simple dependency injection mechanism can be built in Java SE. With the ServiceLoader interface and implementation separation becomes natural and programs can be conveniently extended. Actually a lot of Java API are implented based on the ServiceLoader The basic concepts are Operating on interfaces of services Obtaining implementations of the service via ServiceLoader Providing implementation of servics Lets start with the interface and put it in a jar, named for example accounting -api.jar package example public interface AccountingService long getBalance Now we provide an implementation of that service in a jar named accounting -impl.jar, containing an implementation of the service package example.impl import example.AccountingService public interface DefaultAccountingService implements AccouningService public long getBalance return balanceFromDB private long balanceFromDB ... further, the accounting -impl.jar contains a \ufb01le declaring that this jar provides an implementation of AccountingService . The \ufb01le has to have a path starting with META-INFservices and must have the same name as the fully-quali\ufb01ed name of the interface META-INFservices example. AccountingService The content of the \ufb01le is the fully-qual\ufb01\ufb01ed name of the implementation example. impl.DefaultAccountingService Given both jars are in the classpath of the program, that consumes the AccountingService", ", an instance of the Service can be obtained by using the ServiceLauncher GoalKicker.com Java Notes for Professionals 767ServiceLoader AccountingService loader ServiceLoader. loadAccountingService. class AccountingService service loader. next long balance service. getBalance As the ServiceLoader is an Iterable , it supports multiple implementation providers, where the program may choose from ServiceLoader AccountingService loader ServiceLoader. loadAccountingService. class forAccountingService service loader ... Note that when invoking next a new instance will allways be created. If you want to re-use an instance, you have to use the iterator method of the ServiceLoader or the for-each loop as shown above. Section 136.2 Logger Service The following example shows how to instantiate a class for logging via the ServiceLoader . Service package servicetest import java.io.IOException public interface Logger extends AutoCloseable void logString message throws IOException Implementations of the service The following implementation simply writes the message to System.err package servicetest.logger import servicetest.Logger public class ConsoleLogger implements Logger Override public void logString message System.err.printlnmessage Override public void close The following implementation writes the messages to a text \ufb01le package servicetest.logger import java.io.BufferedWriter import java.io.FileWriter import java.io.IOException GoalKicker.com Java Notes for Professionals 768import servicetest.Logger public class FileLogger implements Logger private final BufferedWriter writer public FileLogger throws", "IOException writer new BufferedWriter new FileWriter log.txt Override public void logString message throws IOException writer. appendmessage writer. newLine Override public void close throws IOException writer. close META-INFservicesservicetest.Logger The META-INFservices servicetest. Logger \ufb01le lists the names of the Logger implementations. servicetest. logger.ConsoleLogger servicetest. logger.FileLogger Usage The following main method writes a message to all available loggers. The loggers are instantiated using ServiceLoader . public static void mainString args throws Exception final String message Hello World! get ServiceLoader for Logger ServiceLoader Logger loader ServiceLoader. loadservicetest. Logger.class iterate through instances of available loggers, writing the message to each one Iterator Logger iterator loader. iterator while iterator. hasNext try Logger logger iterator. next logger. logmessage GoalKicker.com Java Notes for Professionals 769Chapter 137 Classloaders Section 137.1 Implementing a custom classLoader Every custom loader must directly or indirectly extend the java.lang.ClassLoader class. The main extension points are the following methods findClass String - overload this method if your classloader follows the standard delegation model for class loading. loadClass String, boolean - overload this method to implement an alternative delegation model. findResource and findResources - overload these methods to customize resource loading. The defineClass methods which are responsible for actually loading the class from a byte", "array are final to prevent overloading. Any custom behavior needs to be performed prior to calling defineClass . Here is a simple that loads a speci\ufb01c class from a byte array public class ByteArrayClassLoader extends ClassLoader private String classname private byte classfile public ByteArrayClassLoader String classname, byte classfile this.classname classname this.classfile classfile. clone Override protected Class findClass String classname throws ClassNotFoundException if classname. equalsthis.classname return defineClass classname, classfile, 0, classfile. length else throw new ClassNotFoundException classname Since we have only overridden the findClass method, this custom class loader is going to behave as follows when loadClass is called. The classloaders loadClass method calls findLoadedClass to see if a class with this name has already been 1. loaded by this classloader. If that succeeds, the resulting Class object is returned to the requestor. The loadClass method then delegates to the parent classloader by calling its loadClass call. If the parent can 2. deal with the request, it will return a Class object which is then returned to the requestor. If the parent classloader cannot load the class, findClass then calls our override findClass method, passing 3. the name of the class to be loaded. If the requested name matches this.classname", ", we call defineClass to load the actual class from the 4. this.classfile byte array. The resulting Class object is then returned. If the name did not match, we throw ClassNotFoundException . 5. Section 137.2 Loading an external .class \ufb01le To load a class we \ufb01rst need to de\ufb01ne it. The class is de\ufb01ned by the ClassLoader . Theres just one problem, Oracle didnt write the ClassLoader s code with this feature available. To de\ufb01ne the class we will need to access a method named defineClass which is a private method of the ClassLoader . GoalKicker.com Java Notes for Professionals 770To access it, what we will do is create a new class, ByteClassLoader , and extend it to ClassLoader . Now that we have extended our class to ClassLoader , we can access the ClassLoader s private methods. To make defineClass available, we will create a new method that will act like a mirror for the private defineClass method. To call the private method we will need the class name, name , the class bytes, classBytes , the \ufb01rst bytes o\ufb00set, which will be 0 because classBytes data starts at classBytes 0, and the last bytes o\ufb00set, which will", "be classBytes. lenght because it represents the size of the data, which will be the last o\ufb00set. public class ByteClassLoader extends ClassLoader public Class? defineClass String name, byte classBytes return defineClass name, classBytes, 0, classBytes. length Now, we have a public defineClass method. It can be called by passing the name of the class and the class bytes as arguments. Lets say we have class named MyClass in the package stackoverflow ... To call the method we need the class bytes so we create a Path object representing our class path by using the Paths.get method and passing the path of the binary class as an argument. Now, we can get the class bytes with Files.readAllBytes path. So we create a ByteClassLoader instance and use the method we created, defineClass . We already have the class bytes but to call our method we also need the class name which is given by the package name dot the class canonical name, in this case stackoverflow. MyClass . Path path Paths.getMyClass.class ByteClassLoader loader new ByteClassLoader loader.defineClass stackoverflow.MyClass , Files. readAllBytes path Note The defineClass method returns a Class? object. You can save it if you want. To load the class, we", "just call loadClass and pass the class name. This method can throw an ClassNotFoundException so we need to use a try cath block try loader. loadClass stackoverflow.MyClass catchClassNotFoundException e e.printStackTrace Section 137.3 Instantiating and using a classloader This basic example shows how an application can instantiate a classloader and use it to dynamically load a class. URL urls new URL new URLfilehomemeextras.jar Classloader loader new URLClassLoader urls Class? myObjectClass loader. findClass com.example.MyObject The classloader created in this example will have the default classloader as its parent, and will \ufb01rst try to \ufb01nd any class in the parent classloader before looking in extra.jar. If the requested class has already been loaded, the findClass call will return the reference to the previously loaded class. The findClass call can fail in a variety of ways. The most common are GoalKicker.com Java Notes for Professionals 771If the named class cannot be found, the call with throw ClassNotFoundException . If the named class depends on some other class that cannot be found, the call will throw NoClassDefFoundError . GoalKicker.com Java Notes for Professionals 772Chapter 138 Creating Images Programmatically Section 138.1 Creating a simple image programmatically and displaying it class ImageCreationExample static Image createSampleImage instantiate", "a new BufferedImage subclass of Image instance BufferedImage img new BufferedImage 640, 480, BufferedImage .TYPEINTARGB draw something on the image paintOnImage img return img static void paintOnImage BufferedImage img get a drawable Graphics2D subclass of Graphics object Graphics2D g2d Graphics2D img.getGraphics some sample drawing g2d. setColor Color.BLACK g2d. fillRect 0, 0, 640, 480 g2d. setColor Color.WHITE g2d. drawLine 0, 0, 640, 480 g2d. drawLine 0, 480, 640, 0 g2d. setColor Color.YELLOW g2d. drawOval 200, 100, 240, 280 g2d. setColor Color.RED g2d. drawRect 150, 70, 340, 340 drawing on images can be very memory-consuming so its better to free resources early its not necessary, though g2d. dispose public static void mainString args JFrame frame new JFrame frame. setDefaultCloseOperation JFrame.EXITONCLOSE Image img createSampleImage ImageIcon icon new ImageIcon img frame. addnew JLabelicon frame. pack frame. setVisible true GoalKicker.com Java Notes for Professionals 773 Section 138.2 Save an Image to disk public static void saveImage String destination throws IOException method implemented in Creating a simple image Programmatically and displaying it example BufferedImage img createSampleImage ImageIO provides several write methods with different outputs ImageIO. writeimg, png, new Filedestination Section 138.3 Setting individual pixels color in BueredImage BufferedImage image new BufferedImage 256, 256, BufferedImage .TYPEINTARGB", "you dont have to use the Graphics object, you can read and set pixel color individually for int i 0 i 256 i for int j 0 j 256 j int alpha 255 dont forget this, or use BufferedImage.TYPEINTRGB instead int red i or any formula you like int green j or any formula you like int blue 50 or any formula you like int color alpha 24 red 16 green 8 blue image. setRGBi, j, color ImageIO. writeimage, png, new Filecomputed.png GoalKicker.com Java Notes for Professionals 774Output Section 138.4 Specifying image rendering quality static void setupQualityHigh Graphics2D g2d g2d. setRenderingHint RenderingHints .KEYANTIALIASING , RenderingHints .VALUEANTIALIASON g2d. setRenderingHint RenderingHints .KEYRENDERING , RenderingHints .VALUERENDERQUALITY many other RenderingHints KEYVALUE pairs to specify static void setupQualityLow Graphics2D g2d g2d. setRenderingHint RenderingHints .KEYANTIALIASING , RenderingHints .VALUEANTIALIASOFF g2d. setRenderingHint RenderingHints .KEYRENDERING , RenderingHints .VALUERENDERSPEED A comparison of QUALITY and SPEED rendering of the sample image GoalKicker.com Java Notes for Professionals 775 GoalKicker.com Java Notes for Professionals 776 Section 138.5 Creating an image with BueredImage class int width 256 in pixels int height 256 in pixels BufferedImage image new BufferedImage width, height, BufferedImage .TYPE4BYTEABGR BufferedImage.TYPE4BYTEABGR - store RGB color and visibility alpha, see javadoc for", "more info Graphics g image.createGraphics draw whatever you like, like you would in a drawComponentGraphics g method in an UI application g.setColor Color.RED g.fillRect 20, 30, 50, 50 g.setColor Color.BLUE g.drawOval 120, 120, 80, 40 g.dispose dispose graphics objects when they are no longer needed now image has programmatically generated content, you can use it in graphics.drawImage to draw it somewhere else or just simply save it to a file ImageIO. writeimage, png, new Filemyimage.png Output GoalKicker.com Java Notes for Professionals 777 Section 138.6 Editing and re-using image with BueredImage BufferedImage cat ImageIO. readnew Filecat.jpg read existing file modify it Graphics g cat.createGraphics g.setColor Color.RED g.drawString Cat, 10, 10 g.dispose now create a new image BufferedImage cats new BufferedImage 256, 256, BufferedImage .TYPE4BYTEABGR and draw the old one on it, 16 times g cats.createGraphics for int i 0 i 4 i for int j 0 j 4 j g. drawImage cat, i 64, j 64, null g.setColor Color.BLUE g.drawRect 0, 0, 255, 255 add some nice border g.dispose and done ImageIO. writecats, png, new Filecats.png Original cat \ufb01le Produced \ufb01le GoalKicker.com Java Notes for Professionals 778 Section 138.7 How to scale a BueredImage Resizes an image using a Graphics2D", "object backed by a BufferedImage. param srcImg - source image to scale param w - desired width param h - desired height return - the new resized image private BufferedImage getScaledImage Image srcImg, int w, int h Create a new image with good size that contains or might contain arbitrary alpha values between and including 0.0 and 1.0. BufferedImage resizedImg new BufferedImage w, h, BufferedImage .TRANSLUCENT Create a device-independant object to draw the resized image Graphics2D g2 resizedImg. createGraphics This could be changed, Cf. httpstackoverflow.comdocumentationjava5482creating-images-programmatically19498specifying-im age-rendering-quality g2.setRenderingHint RenderingHints .KEYINTERPOLATION , RenderingHints .VALUEINTERPOLATIONBILINEAR Finally draw the source image in the Graphics2D with the desired size. g2.drawImage srcImg, 0, 0, w, h, null Disposes of this graphics context and releases any system resources that it is using g2.dispose Return the image used to create the Graphics2D return resizedImg GoalKicker.com Java Notes for Professionals 779Chapter 139 Atomic Types Parameter Description set Volatile set of the \ufb01eld get Volatile read of the \ufb01eld lazySet This is a store ordered operation of the \ufb01eld compareAndSet If the value is the expeed value then sent it to the new value getAndSet get the current value and update Java Atomic Types are simple mutable types that", "provide basic operations that are thread-safe and atomic without resorting to locking. They are intended for use in cases where locking would be a concurrency bottleneck, or where there is risk of deadlock or livelock. Section 139.1 Creating Atomic Types For simple multi-threaded code, using synchronization is acceptable. However, using synchronization does have a liveness impact, and as a codebase becomes more complex, the likelihood goes up that you will end up with Deadlock , Starvation, or Livelock . In cases of more complex concurrency, using Atomic Variables is often a better alternative, as it allows an individual variable to be accessed in a thread-safe manner without the overhead of using synchronized methods or code blocks. Creating an AtomicInteger type AtomicInteger aInt new AtomicInteger Create with default value 0 AtomicInteger aInt new AtomicInteger 1 Create with initial value 1 Similarly for other instance types. AtomicIntegerArray aIntArray new AtomicIntegerArray 10 Create array of specific length AtomicIntegerArray aIntArray new AtomicIntegerArray new int 1, 2, 3 Initialize array with another array Similarly for other atomic types. There is a notable exception that there is no float and double types. These can be simulated through the use of Float.floatToIntBits float and Float.intBitsToFloat int", "for float as well as Double.doubleToLongBits double and Double.longBitsToDouble long for doubles. If you are willing to use sun.misc.Unsafe you can use any primitive variable as atomic by using the atomic operation in sun.misc.Unsafe . All primitive types should be converted or encoded in int or longs to so use it in this way. For more on this see sun.misc.Unsafe. Section 139.2 Motivation for Atomic Types The simple way to implement multi-threaded applications is to use Javas built-in synchronization and locking primitives e.g. the synchronized keyword. The following example shows how we might use synchronized to accumulate counts. public class Counters private final int counters GoalKicker.com Java Notes for Professionals 780 public Counters int nosCounters counters new intnosCounters Increments the integer at the given index public synchronized void countint number if number 0 number counters. length counters number Obtains the current count of the number at the given index, or if there is no number at that index, returns 0. public synchronized int getCount int number return number 0 number counters. length ? counters number 0 This implementation will work correctly. However, if you have a large number of threads making lots of simultaneous calls on the same Counters", "object, the synchronization is liable to be a bottleneck. Speci\ufb01cally Each synchronized method call will start with the current thread acquiring the lock for the Counters 1. instance. The thread will hold the lock while it checks number value and updates the counter. 2. Finally, the it will release the lock, allowing other threads access.3. If one thread attempts to acquire the lock while another one holds it, the attempting thread will be blocked stopped at step 1 until the lock is released. If multiple threads are waiting, one of them will get it, and the others will continue to be blocked. This can lead to a couple of problems If there is a lot of contention for the lock i.e. lots of thread try to acquire it, then some threads can be blocked for a long time. When a thread is blocked waiting for the lock, the operating system will typically try switch execution to a di\ufb00erent thread. This context switching incurs a relatively large performance impact on the processor. When there are multiple threads blocked on the same lock, there are no guarantees that any one of them will be treated fairly i.e. each thread is guaranteed", "to be scheduled to run. This can lead to thread starvation . How does one implement Atomic Types? Let us start by rewriting the example above using AtomicInteger counters public class Counters private final AtomicInteger counters public Counters int nosCounters counters new AtomicInteger nosCounters for int i 0 i nosCounters i counters i new AtomicInteger GoalKicker.com Java Notes for Professionals 781 Increments the integer at the given index public void countint number if number 0 number counters. length counters number.incrementAndGet Obtains the current count of the object at the given index, or if there is no number at that index, returns 0. public int getCount int number return number 0 number counters. length ? counters number.get 0 We have replaced the int with an AtomicInteger , and initialized it with an instance in each element. We have also added calls to incrementAndGet and get in place of operations on int values. But the most important thing is that we can remove the synchronized keyword because locking is no longer required. This works because the incrementAndGet and get operations are atomic and thread-safe . In this context, it means that Each counter in the array will only be observable in", "the either the before state for an operation like an increment or in the after state. Assuming that the operation occurs at time T, no thread will be able to see the before state after time T. Furthermore, while two threads might actually attempt to update the same AtomicInteger instance at the same time, the implementations of the operations ensure that only one increment happens at a time on the given instance. This is done without locking, often resulting in better performance. How do Atomic Types work? Atomic types typically rely on specialized hardware instructions in the instruction set of the target machine. For example, Intel-based instruction sets provide a CAS Compare and Swap instruction that will perform a speci\ufb01c sequence of memory operations atomically. These low-level instructions are are used to implement higher-level operations in the APIs of the respective AtomicXxx classes. For example, again, in C-like pseudocode private volatile num int increment while TRUE int old num int new old 1 if old compareandswap num, old, new return new GoalKicker.com Java Notes for Professionals 782If there is no contention on the AtomicXxxx , the if test will succeed and the loop will end immediately. If there is", "contention, then the if will fail for all but one of the threads, and they will spin in the loop for a small number of cycles of the loop. In practice, the spinning is orders of magnitude faster except at unrealistically high levels of contention, where synchronized performs better than atomic classes because when the CAS operation fails, then the retry will only add more contention than suspending the thread and switching to another one. Incidentally, CAS instructions are typically used by the JVM to implement uncontended locking . If the JVM can see that a lock is not currently locked, it will attempt to use a CAS to acquire the lock. If the CAS succeeds, then there is no need to do the expensive thread scheduling, context switching and so on. For more information on the techniques used, see Biased Locking in HotSpot . GoalKicker.com Java Notes for Professionals 783Chapter 140 RSA Encryption Section 140.1 An example using a hybrid cryptosystem consisting of OAEP and GCM The following example encrypts data by using a hybrid cryptosystem consisting of AES GCM and OAEP, using their default parameter sizes and an AES key size of 128 bits. OAEP is less", "vulnerable to padding oracle attacks than PKCS1 v1.5 padding. GCM is also protected against padding oracle attacks. Decryption can be performed by \ufb01rst retrieving the length of the encapsulated key and then by retrieving the encapsulated key. The encapsulated key can then be decrypted using the RSA private key that forms a key pair with the public key. After that the AESGCM encrypted ciphertext can be decrypted to the original plaintext. The protocol consists of a length \ufb01eld for the wrapped key RSAPrivateKey misses a getKeySize method 1. the wrappedencapsulated key, of the same size as the RSA key size in bytes2. the GCM ciphertext and 128 bit authentication tag automatically added by Java.3. Notes To correctly use this code you should supply an RSA key of at least 2048 bits, bigger is better but slower, especially during decryption To use AES-256 you should install the unlimited cryptography policy \ufb01les \ufb01rst Instead creating your own protocol you might want to use a container format such as the Cryptographic Message Syntax CMS PKCS7 or PGP instead. So heres the example Encrypts the data using a hybrid crypto-system which uses GCM to encrypt the data and OAEP to encrypt the AES", "key. The key size of the AES encryption will be 128 bit. All the default parameter choices are used for OAEP and GCM. param publicKey the RSA public key used to wrap the AES key param plaintext the plaintext to be encrypted, not altered return the ciphertext throws InvalidKeyException if the key is not an RSA public key throws NullPointerException if the plaintext is null public static byte encryptData PublicKey publicKey, byte plaintext throws InvalidKeyException , NullPointerException --- create the RSA OAEP cipher --- Cipher oaep try SHA-1 is the default and not vulnerable in this setting use OAEPParameterSpec to configure more than just the hash oaep Cipher. getInstance RSAECBOAEPwithSHA1andMGF1Padding catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for RSA cipher mandatory algorithm for runtimes , e GoalKicker.com Java Notes for Professionals 784 catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for OAEP padding present in the standard Java runtime sinze XX , e oaep. initCipher.WRAPMODE , publicKey --- wrap the plaintext in a buffer will throw NullPointerException if plaintext is null ByteBuffer plaintextBuffer ByteBuffer. wrapplaintext --- generate a new AES secret key --- KeyGenerator aesKeyGenerator try aesKeyGenerator KeyGenerator. getInstance AES catch NoSuchAlgorithmException e throw", "new RuntimeException Runtime doesnt have support for AES key generator mandatory algorithm for runtimes , e for AES-192 and 256 make sure youve got the rights install the Unlimited Crypto Policy files aesKeyGenerator. init128 SecretKey aesKey aesKeyGenerator. generateKey --- wrap the new AES secret key --- byte wrappedKey try wrappedKey oaep.wrapaesKey catch IllegalBlockSizeException e throw new RuntimeException AES key should always fit OAEP with normal sized RSA key , e --- setup the AES GCM cipher mode --- Cipher aesGCM try aesGCM Cipher. getInstance AESGCMNopadding we can get away with a zero nonce since the key is randomly generated 128 bits is the recommended maximum value for the tag size 12 bytes 96 bits is the default nonce size for GCM mode encryption GCMParameterSpec staticParameterSpec new GCMParameterSpec 128, new byte12 aesGCM. initCipher.ENCRYPTMODE , aesKey, staticParameterSpec catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for AES cipher mandatory algorithm for runtimes , e catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for GCM present in the standard Java runtime sinze XX, e catch InvalidAlgorithmParameterException e throw new RuntimeException IvParameterSpec not accepted by this implementation of GCM , e --- create a buffer of the right size", "for our own protocol --- GoalKicker.com Java Notes for Professionals 785 ByteBuffer ciphertextBuffer ByteBuffer. allocate Short.BYTES oaep.getOutputSize 128 Byte.SIZE aesGCM. getOutputSize plaintext. length - element 1 make sure that we know the size of the wrapped key ciphertextBuffer. putShort short wrappedKey. length - element 2 put in the wrapped key ciphertextBuffer. putwrappedKey - element 3 GCM encrypt into buffer try aesGCM. doFinalplaintextBuffer, ciphertextBuffer catch ShortBufferException IllegalBlockSizeException BadPaddingException e throw new RuntimeException Cryptographic exception, AESGCM encryption should not fail here, e return ciphertextBuffer. array Of course, encryption is not very useful without decryption. Note that this will return minimal information if decryption fails. Decrypts the data using a hybrid crypto-system which uses GCM to encrypt the data and OAEP to encrypt the AES key. All the default parameter choices are used for OAEP and GCM. param privateKey the RSA private key used to unwrap the AES key param ciphertext the ciphertext to be encrypted, not altered return the plaintext throws InvalidKeyException if the key is not an RSA private key throws NullPointerException if the ciphertext is null throws IllegalArgumentException with the message Invalid ciphertext if the ciphertext is invalid minimize information leakage public static byte decryptData PrivateKey privateKey, byte ciphertext", "throws InvalidKeyException , NullPointerException --- create the RSA OAEP cipher --- Cipher oaep try SHA-1 is the default and not vulnerable in this setting use OAEPParameterSpec to configure more than just the hash oaep Cipher. getInstance RSAECBOAEPwithSHA1andMGF1Padding catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for RSA cipher mandatory algorithm for runtimes , e catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for OAEP padding present in the standard Java runtime sinze XX , GoalKicker.com Java Notes for Professionals 786 e oaep. initCipher.UNWRAPMODE , privateKey --- wrap the ciphertext in a buffer will throw NullPointerException if ciphertext is null ByteBuffer ciphertextBuffer ByteBuffer. wrapciphertext sanity check 1 if ciphertextBuffer. remaining 2 throw new IllegalArgumentException Invalid ciphertext - element 1 the length of the encapsulated key int wrappedKeySize ciphertextBuffer. getShort 0xFFFF sanity check 2 if ciphertextBuffer. remaining wrappedKeySize 128 Byte.SIZE throw new IllegalArgumentException Invalid ciphertext --- unwrap the AES secret key --- byte wrappedKey new bytewrappedKeySize - element 2 the encapsulated key ciphertextBuffer. getwrappedKey SecretKey aesKey try aesKey SecretKey oaep.unwrapwrappedKey, AES, Cipher. SECRETKEY catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for AES cipher mandatory algorithm for runtimes , e catch InvalidKeyException e throw new", "RuntimeException Invalid ciphertext --- setup the AES GCM cipher mode --- Cipher aesGCM try aesGCM Cipher. getInstance AESGCMNopadding we can get away with a zero nonce since the key is randomly generated 128 bits is the recommended maximum value for the tag size 12 bytes 96 bits is the default nonce size for GCM mode encryption GCMParameterSpec staticParameterSpec new GCMParameterSpec 128, new byte12 aesGCM. initCipher.DECRYPTMODE , aesKey, staticParameterSpec catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for AES cipher mandatory algorithm for runtimes , e catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for GCM present in the standard Java runtime sinze XX, e catch InvalidAlgorithmParameterException e throw new RuntimeException GoalKicker.com Java Notes for Professionals 787 IvParameterSpec not accepted by this implementation of GCM , e --- create a buffer of the right size for our own protocol --- ByteBuffer plaintextBuffer ByteBuffer. allocate aesGCM . getOutputSize ciphertextBuffer. remaining - element 3 GCM ciphertext try aesGCM. doFinalciphertextBuffer, plaintextBuffer catch ShortBufferException IllegalBlockSizeException BadPaddingException e throw new RuntimeException Invalid ciphertext return plaintextBuffer. array GoalKicker.com Java Notes for Professionals 788Chapter 141 Secure objects Section 141.1 SealedObject javax.crypto.SealedObject This class enables a programmer to create an object and protect its", "con\ufb01dentiality with a cryptographic algorithm. Given any Serializable object, one can create a SealedObject that encapsulates the original object, in serialized format i.e., a deep copy, and seals encrypts its serialized contents, using a cryptographic algorithm such as AES, DES, to protect its con\ufb01dentiality. The encrypted content can later be decrypted with the corresponding algorithm using the correct decryption key and de-serialized, yielding the original object. Serializable obj new StringJohn Generate key KeyGenerator kgen KeyGenerator. getInstance AES kgen.init128 SecretKey aesKey kgen.generateKey Cipher cipher Cipher. getInstance AES cipher.initCipher.ENCRYPTMODE , aesKey SealedObject sealedObject new SealedObject obj, cipher System.out.printlnsealedObject- sealedObject System.out.printlnsealedObject Data- sealedObject. getObject aesKey Section 141.2 SignedObject java.security.SignedObject SignedObject is a class for the purpose of creating authentic runtime objects whose integrity cannot be compromised without being detected. More speci\ufb01cally, a SignedObject contains another Serializable object, the to-be-signed object and its signature. GoalKicker.com Java Notes for Professionals 789 Create a key KeyPairGenerator keyGen KeyPairGenerator .getInstance DSA, SUN SecureRandom random SecureRandom .getInstance SHA1PRNG , SUN keyGen.initialize 1024, random create a private key PrivateKey signingKey keyGen. generateKeyPair .getPrivate create a Signature Signature signingEngine Signature .getInstance DSA signingEngine. initSign signingKey create a simple object Serializable obj new StringJohn sign our object SignedObject signedObject new", "SignedObject obj, signingKey, signingEngine System.out.printlnsignedObject- signedObject System.out.printlnsignedObject Data- signedObject. getObject GoalKicker.com Java Notes for Professionals 790Chapter 142 Security Cryptography Section 142.1 Compute Cryptographic Hashes To compute the hashes of relatively small blocks of data using di\ufb00erent algorithms final MessageDigest md5 MessageDigest .getInstance MD5 final MessageDigest sha1 MessageDigest .getInstance SHA-1 final MessageDigest sha256 MessageDigest .getInstance SHA-256 final byte data FOO BAR .getBytes System.out.printlnMD5 hash DatatypeConverter. printHexBinary md5.digestdata System.out.printlnSHA1 hash DatatypeConverter. printHexBinary sha1.digestdata System.out.printlnSHA256 hash DatatypeConverter. printHexBinary sha256.digestdata Produces this output MD5 hash E99E768582F6DD5A3BA2D9C849DF736E SHA1 hash 0135FAA6323685BA8A8FF8D3F955F0C36949D8FB SHA256 hash 8D35C97BCD902B96D1B551741BBE8A7F50BB5A690B4D0225482EAA63DBFB9DED Additional algorithms may be available depending on your implementation of the Java platform. Section 142.2 Encrypt and Decrypt Data with Public Private Keys To encrypt data with a public key final Cipher rsa Cipher. getInstance RSA rsa.initCipher.ENCRYPTMODE , keyPair. getPublic rsa.updatemessage. getBytes final byte result rsa.doFinal System.out.printlnMessage message System.out.printlnEncrypted DatatypeConverter. printHexBinary result Produces output similar to Message Hello Encrypted 5641FBB9558ECFA9ED... Note that when creating the Cipher object, you have to specify a transformation that is compatible with the type of key being used. See JCA Standard Algorithm Names for a list of supported transformations.. For RSA encryption data message. getBytes length must be smaller than the key size. See this SO", "Answer for detail. To decrypt the data final Cipher rsa Cipher. getInstance RSA rsa.initCipher.DECRYPTMODE , keyPair. getPrivate rsa.updatecipherText final String result new Stringrsa.doFinal GoalKicker.com Java Notes for Professionals 791System.out.printlnDecrypted result Produces the following output Decrypted Hello Section 142.3 Generate Cryptographically Random Data To generate samples of cryptographically random data final byte sample new byte16 new SecureRandom .nextBytes sample System.out.printlnSample DatatypeConverter. printHexBinary sample Produces output similar to Sample E4F14CEA2384F70B706B53A6DF8C5EFE Note that the call to nextBytes may block while entropy is gathered depending on the algorithm being used. To specify the algorithm and provider final byte sample new byte16 final SecureRandom randomness SecureRandom .getInstance SHA1PRNG , SUN randomness. nextBytes sample System.out.printlnProvider randomness. getProvider System.out.printlnAlgorithm randomness. getAlgorithm System.out.printlnSample DatatypeConverter. printHexBinary sample Produces output similar to Provider SUN version 1.8 Algorithm SHA1PRNG Sample C80C44BAEB352FD29FBBE20489E4C0B9 Section 142.4 Generate Public Private Key Pairs To generate key pairs using di\ufb00erent algorithms and key sizes final KeyPairGenerator dhGenerator KeyPairGenerator .getInstance DiffieHellman final KeyPairGenerator dsaGenerator KeyPairGenerator .getInstance DSA final KeyPairGenerator rsaGenerator KeyPairGenerator .getInstance RSA dhGenerator. initialize 1024 dsaGenerator. initialize 1024 rsaGenerator. initialize 2048 final KeyPair dhPair dhGenerator. generateKeyPair final KeyPair dsaPair dsaGenerator. generateKeyPair final KeyPair rsaPair rsaGenerator. generateKeyPair GoalKicker.com Java Notes for Professionals 792Additional algorithms and key sizes", "may be available on your implementation of the Java platform. To specify a source of randomness to use when generating the keys final KeyPairGenerator generator KeyPairGenerator .getInstance RSA generator. initialize 2048, SecureRandom .getInstance SHA1PRNG , SUN final KeyPair pair generator. generateKeyPair Section 142.5 Compute and Verify Digital Signatures To compute a signature final PrivateKey privateKey keyPair. getPrivate final byte data FOO BAR .getBytes final Signature signer Signature .getInstance SHA1withRSA signer.initSign privateKey signer.updatedata final byte signature signer. sign Note that the signature algorithm must be compatible with the algorithm used to generate the key pair. To verify a signature final PublicKey publicKey keyPair. getPublic final Signature verifier Signature .getInstance SHA1withRSA verifier. initVerify publicKey verifier. updatedata System.out.printlnSignature verifier. verifysignature Produces this output Signature true GoalKicker.com Java Notes for Professionals 793Chapter 143 Security Cryptography Security practices in Java can be separated into two broad, vaguely de\ufb01ned categories Java platform security, and secure Java programming. Java platform security practices deal with managing the security and integrity of the JVM. It includes such topics as managing JCE providers and security policies. Secure Java programming practices concern the best ways to write secure Java programs. It includes such topics as using random numbers and cryptography,", "and preventing vulnerabilities. Section 143.1 The JCE The Java Cryptography Extension JCE is a framework built into the JVM to allow developers to easily and securely use cryptography in their programs. It does this by providing a simple, portable interface to programmers, while using a system of JCE Providers to securely implement the underlying cryptographic operations. Section 143.2 Keys and Key Management While the JCE secures cryptographic operations and key generation, it is up to the developer to actually manage their keys. More information needs to be provided here. One commonly-accepted best practice for handling keys at runtime is to store them only as byte arrays, and never as strings. This is because Java strings are immutable, and cannot be manually cleared or zeroed out in memory while a reference to a string can be removed, the exact string will remain in memory until its segment of memory is garbage-collected and reused. An attacker would have a large window in which they could dump the programs memory and easily \ufb01nd the key. Contrarily, byte arrays are mutable, and can have their contents overwritten in place it is a good idea to zero-out your keys as soon as you no", "longer need them. Section 143.3 Common Java vulnerabilities Section 143.4 Networking Concerns Section 143.5 Randomness and You For most applications, the java.utils.Random class is a perfectly \ufb01ne source of random data. If you need to choose a random element from an array, or generate a random string, or create a temporary unique identi\ufb01er, you should probably use Random . However, many cryptographic systems rely on randomness for their security, and the randomness provided by Random simply isnt of high enough quality. For any cryptographic operation that requires a random input, you should use SecureRandom instead. Section 143.6 Hashing and Validation A cryptographic hash function is a member of a class of functions with three vital properties consistency, uniqueness, and irreversibility. Consistency Given the same data, a hash function will always return the same value. That is, if X Y, fx will always equal fy for hash function f. Uniqueness No two inputs to a hash function will ever result in the same output. That is, if X ! Y, fx ! fy, for any GoalKicker.com Java Notes for Professionals 794values of X and Y. Irreversibility It is impractically di\ufb03cult, if not impossible, to reverse a hash function. That is,", "given only fX, there should be no way of \ufb01nding the original X short of putting every possible value of X through the function f brute-force. There should be no function f1 such that f1fX X. Many functions lack at least one of these attributes. For example, MD5 and SHA1 are known to have collisions, i.e. two inputs that have the same output, so they lack uniqueness. Some functions that are currently believed to be secure are SHA-256 and SHA-512. GoalKicker.com Java Notes for Professionals 795Chapter 144 SecurityManager Section 144.1 Sandboxing classes loaded by a ClassLoader The ClassLoader needs to provide a ProtectionDomain identifying the source of the code public class PluginClassLoader extends ClassLoader private final ClassProvider provider private final ProtectionDomain pd public PluginClassLoader ClassProvider provider this.provider provider Permissions permissions new Permissions this.pd new ProtectionDomain provider. getCodeSource , permissions, this, null Override protected Class? findClass String name throws ClassNotFoundException byte classDef provider. getClass name Class ? clazz defineClass name, classDef, 0, classDef. length, pd return clazz By overriding findClass rather than loadClass the delegational model is preserved, and the PluginClassLoader will \ufb01rst query the system and parent classloader for class de\ufb01nitions. Create a Policy public class PluginSecurityPolicy extends Policy", "private final Permissions appPermissions new Permissions private final Permissions pluginPermissions new Permissions public PluginSecurityPolicy amend this as appropriate appPermissions. addnew AllPermission add any permissions plugins should have to pluginPermissions Override public Provider getProvider return super.getProvider Override public String getType return super.getType Override public Parameters getParameters return super.getParameters Override GoalKicker.com Java Notes for Professionals 796 public PermissionCollection getPermissions CodeSource codesource return new Permissions Override public PermissionCollection getPermissions ProtectionDomain domain return isPlugin domain?pluginPermissions appPermissions private boolean isPlugin ProtectionDomain pd return pd.getClassLoader instanceof PluginClassLoader Finally, set the policy and a SecurityManager default implementation is \ufb01ne Policy.setPolicy new PluginSecurityPolicy System.setSecurityManager new SecurityManager Section 144.2 Enabling the SecurityManager Java Virtual Machines JVMs can be run with a SecurityManager installed. The SecurityManager governs what the code running in the JVM is allowed to do, based on factors such as where the code was loaded from and what certi\ufb01cates were used to sign the code. The SecurityManager can be installed by setting the java.security.manager system property on the command line when starting the JVM java -Djava.security .manager main class name or programmatically from within Java code System.setSecurityManager new SecurityManager The standard Java SecurityManager grants permissions on the basis of a Policy, which is de\ufb01ned in a", "policy \ufb01le. If no policy \ufb01le is speci\ufb01ed, the default policy \ufb01le under JAVAHOME libsecurity java.policy will be used. Section 144.3 Implementing policy deny rules It is occasionally desirable to deny a certain Permission to some ProtectionDomain , regardless of any other permissions that domain accrues. This example demonstrates just one of all the possible approaches for satisfying this kind of requirement. It introduces a negative permission class, along with a wrapper that enables the default Policy to be reused as a repository of such permissions. Notes The standard policy \ufb01le syntax and mechanism for permission assignment in general remain una\ufb00ected. This means that deny rules within policy \ufb01les are still expressed as grants . The policy wrapper is meant to speci\ufb01cally encapsulate the default \ufb01le-backed Policy assumed to be com.sun.security .provider .PolicyFile . Denied permissions are only processed as such at the policy level. If statically assigned to a domain, they will by default be treated by that domain as ordinary positive permissions. The DeniedPermission class package com.example GoalKicker.com Java Notes for Professionals 797import java.lang.reflect.Constructor import java.lang.reflect.InvocationTargetException import java.lang.reflect.Modifier import java.security.BasicPermission import java.security.Permission import java.security.UnresolvedPermission import java.text.MessageFormat A representation of a negative privilege. p A codeDeniedPermissioncode, when granted", "to some codeProtectionDomaincode andor codePrincipalcode, represents a privilege which emcannotem be exercised, regardless of any positive permissions codeAllPermissioncode included possessed. In other words, if a set of granted permissions, emPem, contains a permission of this class, emDem, then the set of effectively granted permissions isbr br nbspnbspnbspnbspem Psubimpliedsub - Dsubimpliedsub em. p p Each instance of this class encapsulates a emtarget permissionem, representing the positive permission being denied. p Denied permissions employ the following naming schemebr br nbspnbspnbspnbspemlttargetclassnamegtlttargetnamegtlttargetactionsgte mbr br where ul liemtargetclassnameem is the name of the target permissions class,li liemtargetnameem is the name of the target permission, andli liemtargetactionsem is, optionally, the actions string of the target permission.li ul A denied permission, having a target permission emtem, is said to emimplyem another permission empem, if ul lip emis notem itself a denied permission, and codet.impliesp truecode, orli lip emisem a denied permission, with a target emt1em, and codet.impliest1 truecode. ul p It is the responsibility of the policy decision point e.g., the codePolicycode provider to take denied permission semantics into account when issuing authorization statements. p public final class DeniedPermission extends BasicPermission private final Permission target private static final long serialVersionUID 473625163869800679L Instantiates a codeDeniedPermissioncode that encapsulates", "a target permission of the indicated class, specified name and, optionally, actions. throws IllegalArgumentException if ul licodetargetClassNamecode is codenullcode, the empty string, does not refer to a concrete codePermissioncode descendant, or refers to GoalKicker.com Java Notes for Professionals 798 codeDeniedPermission.classcode or codeUnresolvedPermission.classcode.li licodetargetNamecode is codenullcode.li licodetargetClassNamecode cannot be instantiated, and its the callers fault e.g., because codetargetNamecode andor codetargetActionscode do not adhere to the naming constraints of the target class or due to the target class not exposing a codeString namecode, or codeString name, String actionscode constructor, depending on whether codetargetActionscode is codenullcode or not.li ul public static DeniedPermission newDeniedPermission String targetClassName, String targetName, String targetActions if targetClassName null targetClassName. trim.isEmpty targetName null throw new IllegalArgumentException Null or empty targetClassName, or null targetName argument was supplied. StringBuilder sb new StringBuilder targetClassName .append.appendtargetName if targetName ! null sb. append.appendtargetName return new DeniedPermission sb.toString Instantiates a codeDeniedPermissioncode that encapsulates a target permission of the class, name and, optionally, actions, collectively provided as the codenamecode argument. throws IllegalArgumentException if ul licodenamecodes target permission class name component is empty, does not refer to a concrete codePermissioncode descendant, or refers to codeDeniedPermission.classcode or codeUnresolvedPermission.classcode.li licodenamecodes target name component is codeemptycodeli lithe target permission class", "cannot be instantiated, and its the callers fault e.g., because codenamecodes target name andor target actions components do not adhere to the naming constraints of the target class or due to the target class not exposing a codeString namecode, or codeString name, String actionscode constructor, depending on whether the target actions component is empty or not.li ul public DeniedPermission String name supername String comps name.split if comps.length 2 throw new IllegalArgumentException MessageFormat .formatMalformed name 0 argument. , name this.target initTarget comps0, comps1, comps.length 3 ? null comps2 GoalKicker.com Java Notes for Professionals 799 Instantiates a codeDeniedPermissioncode that encapsulates the given target permission. throws IllegalArgumentException if codetargetcode is codenullcode, a codeDeniedPermissioncode, or an codeUnresolvedPermissioncode. public static DeniedPermission newDeniedPermission Permission target if target null throw new IllegalArgumentException Null target argument. if target instanceof DeniedPermission target instanceof UnresolvedPermission throw new IllegalArgumentException target must not be a DeniedPermission or an UnresolvedPermission. StringBuilder sb new StringBuilder target.getClass .getName.append.appendtarget.getName String targetActions target. getActions if targetActions ! null sb. append.appendtargetActions return new DeniedPermission sb.toString , target private DeniedPermission String name, Permission target supername this.target target private Permission initTarget String targetClassName, String targetName, String targetActions Class ? targetClass try targetClass Class.forNametargetClassName catch ClassNotFoundException cnfe if targetClassName. trim.isEmpty", "targetClassName empty throw new IllegalArgumentException MessageFormat .formatTarget Permission class 0 not found. , targetClassName if !Permission .class.isAssignableFrom targetClass Modifier .isAbstract targetClass. getModifiers throw new IllegalArgumentException MessageFormat . formatTarget Permission class 0 is not a concrete Permission. , targetClassName if targetClass DeniedPermission. class targetClass UnresolvedPermission .class throw new IllegalArgumentException Target Permission class cannot be a DeniedPermission itself. Constructor ? targetCtor try if targetActions null targetCtor targetClass. getConstructor String.class else targetCtor targetClass. getConstructor String.class, String.class GoalKicker.com Java Notes for Professionals 800 catch NoSuchMethodException nsme throw new IllegalArgumentException MessageFormat .format Target Permission class 0 does not provide or expose a String name or String name, String actions constructor. , targetClassName try return Permission targetCtor . newInstance targetCtor. getParameterCount 1 ? new Object targetName new Object targetName, targetActions catch ReflectiveOperationException roe if roe instanceof InvocationTargetException if targetName null targetName null else if targetName. trim.isEmpty targetName empty if targetActions null targetActions null else if targetActions. trim.isEmpty targetActions empty throw new IllegalArgumentException MessageFormat .format Could not instantiate target Permission class 0 provided target name 1 andor target actions 2 potentially erroneous. , targetClassName, targetName, targetActions , roe throw new RuntimeException Could not instantiate target Permission class 0 an unforeseen error occurred - see attached cause", "for details , roe Checks whether the given permission is implied by this one, as per the link DeniedPermission overview. Override public boolean implies Permission p if p instanceof DeniedPermission return target. impliesDeniedPermission p.target return target. impliesp Returns this denied permissions target permission the actual positive permission which is not to be granted. public Permission getTargetPermission return target The DenyingPolicy class GoalKicker.com Java Notes for Professionals 801package com.example import java.security.CodeSource import java.security.NoSuchAlgorithmException import java.security.Permission import java.security.PermissionCollection import java.security.Policy import java.security.ProtectionDomain import java.security.UnresolvedPermission import java.util.Enumeration Wrapper that adds rudimentary link DeniedPermission processing capabilities to the standard file-backed codePolicycode. public final class DenyingPolicy extends Policy try defaultPolicy Policy.getInstance javaPolicy , null catch NoSuchAlgorithmException nsae throw new RuntimeException Could not acquire default Policy. , nsae private final Policy defaultPolicy Override public PermissionCollection getPermissions CodeSource codesource return defaultPolicy. getPermissions codesource Override public PermissionCollection getPermissions ProtectionDomain domain return defaultPolicy. getPermissions domain return ul licodetruecode ifli ul licodepermissioncode emis notem an instance of codeDeniedPermissioncode,li lian codeimpliesdomain, permissioncode invocation on the system-default codePolicycode yields codetruecode, andli licodepermissioncode emis notem implied by any codeDeniedPermissioncodes having potentially been assigned to codedomaincode.li ul licodefalsecode, otherwise. ul Override public boolean implies ProtectionDomain domain, Permission permission if permission instanceof DeniedPermission At", "the policy decision level, DeniedPermissions can only themselves imply, not be implied as they take away, rather than grant, privileges. Furthermore, clients arent supposed to use this GoalKicker.com Java Notes for Professionals 802 method for checking whether some domain does not have a permission which is what DeniedPermissions express after all. return false if !defaultPolicy. impliesdomain, permission permission not granted, so no need to check whether denied return false Permission granted--now check whether theres an overriding DeniedPermission. The following assumes that previousPolicy is a sun.security.provider.PolicyFile different implementations might not support getPermissionsProtectionDomain andor handle UnresolvedPermissions differently. Enumeration Permission perms defaultPolicy. getPermissions domain.elements while perms.hasMoreElements Permission p perms.nextElement DeniedPermissions will generally remain unresolved, as no code is expected to check whether other code has been granted such a permission. if p instanceof UnresolvedPermission UnresolvedPermission up UnresolvedPermission p if up.getUnresolvedType .equalsDeniedPermission. class.getName force resolution defaultPolicy. impliesdomain, up evaluate right away, to avoid reiterating over the collection p new DeniedPermission up.getUnresolvedName if p instanceof DeniedPermission p.impliespermission permission denied return false permission granted return true Override public void refresh defaultPolicy. refresh Demo package com.example import java.security.Policy public class Main public static void mainString... args Policy.setPolicy new DenyingPolicy GoalKicker.com Java Notes for Professionals 803 System.setSecurityManager", "new SecurityManager should fail System.getProperty foo.bar Assign some permissions grant codeBase filepathtoclassesbin- permission java. util.PropertyPermission , read,write permission com. example.DeniedPermission java.util.PropertyPermissionfoo.barread Lastly, run the Main and watch it fail, due to the deny rule the DeniedPermission overriding the grant its PropertyPermission . Note that a setProperty foo.baz , xyz invocation would instead have succeeded, since the denied permission only covers the read action, and solely for the foo.bar property. GoalKicker.com Java Notes for Professionals 804Chapter 145 JNDI Section 145.1 RMI through JNDI This example shows how JNDI works in RMI. It has two roles to provide the server with a bindunbindrebind API to the RMI Registry to provide the client with a lookuplist API to the RMI Registry. The RMI Registry is part of RMI, not JNDI. To make this simple, we will use java.rmi.registry .CreateRegistry to create the RMI Registry. Server.javathe JNDI server1. package com.neohope.jndi.test import javax.naming.Context import javax.naming.InitialContext import javax.naming.NamingException import java.io.IOException import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.util.Hashtable JNDI Server 1.create a registry on port 1234 2.bind JNDI 3.wait for connection 4.clean up and end public class Server private static Registry registry private static InitialContext ctx public static void initJNDI try registry LocateRegistry .createRegistry 1234 final Hashtable", "jndiProperties new Hashtable jndiProperties. putContext.INITIALCONTEXTFACTORY , com.sun.jndi.rmi.registry.RegistryContextFactory jndiProperties. putContext.PROVIDERURL , rmilocalhost1234 ctx new InitialContext jndiProperties catch NamingException e e. printStackTrace catch RemoteException e e. printStackTrace public static void bindJNDI String name, Object obj throws NamingException ctx. bindname, obj public static void unbindJNDI String name throws NamingException ctx. unbindname GoalKicker.com Java Notes for Professionals 805 public static void unInitJNDI throws NamingException ctx. close public static void mainString args throws NamingException , IOException initJNDI NMessage msg new NMessage Just A Message bindJNDI neohopejnditest01 , msg System.in.read unbindJNDI neohopejnditest01 unInitJNDI Client.javathe JNDI client2. package com.neohope.jndi.test import javax.naming.Context import javax.naming.InitialContext import javax.naming.NamingException import java.util.Hashtable 1.init context 2.lookup registry for the service 3.use the service 4.end public class Client public static void mainString args throws NamingException final Hashtable jndiProperties new Hashtable jndiProperties. putContext.INITIALCONTEXTFACTORY , com.sun.jndi.rmi.registry.RegistryContextFactory jndiProperties. putContext.PROVIDERURL , rmilocalhost1234 InitialContext ctx new InitialContext jndiProperties NMessage msg NeoMessage ctx.lookupneohopejnditest01 System.out.printlnmsg.message ctx. close NMessage.java RMI server class3. package com.neohope.jndi.test import java.io.Serializable import java.rmi.Remote NMessage RMI server class must implements Remote and Serializable public class NMessage implements Remote, Serializable public String message public NMessage String message this.message message GoalKicker.com Java Notes for Professionals 806 How to run the eaxmple build and start the server1. build and start", "the client2. Introduce The Java Naming and Directory Interface JNDI is a Java API for a directory service that allows Java software clients to discover and look up data and objects via a name. It is designed to be independent of any speci\ufb01c naming or directory service implementation. The JNDI architecture consists of an API Application Programming Interface and an SPI Service Provider Interface. Java applications use this API to access a variety of naming and directory services. The SPI enables a variety of naming and directory services to be plugged in transparently, allowing the Java application using the API of the JNDI technology to access their services. As you can see form the picture above, JNDI supports LDAP, DNS, NIS, NDS, RMI and CORBA. Of course, you can extend it. How it works In this example, the Java RMI use the JNDI API to look up objects in a network. If you want to look up a object, you need at least two pieces of information Where to \ufb01nd the object The RMI Registry manages the name bindings, it tells you where to \ufb01nd the object. The name of the object What is a objects name? It is", "usually a string, it can also be a object that implements the Name interface. GoalKicker.com Java Notes for Professionals 807Step by step First you need a registry, which manage the name binding. In this example, we use1. java.rmi.registry .LocateRegistry . This will start a registry on localhost, port 1234 registry LocateRegistry .createRegistry 1234 Both client and server need a Context. Server use the Context to bind the name and object. Client use the2. Context to lookup the name and get the object. We use com.sun.jndi.rmi.registry.RegistryContextFactory as the InitialContextFactory final Hashtable jndiProperties new Hashtable jndiProperties. putContext.INITIALCONTEXTFACTORY , com.sun.jndi.rmi.registry.RegistryContextFactory the registry usrl is rmilocalhost1234 jndiProperties. putContext.PROVIDERURL , rmilocalhost1234 InitialContext ctx new InitialContext jndiProperties The server bind the name and object3. The jndi name is neohopejnditest01 bindJNDI neohopejnditest01 , msg The client look up the object by the name neohopejnditest014. look up the object by name javacomneohopejnditest01 NeoMessage msg NeoMessage ctx.lookupneohopejnditest01 Now the client can use the object5. When the server is ending, need to clean up.6. ctx.unbindneohopejnditest01 ctx.close GoalKicker.com Java Notes for Professionals 808Chapter 146 sun.misc.Unsafe Section 146.1 Instantiating sun.misc.Unsafe via re\ufb02ection public static Unsafe getUnsafe try Field unsafe Unsafe. class.getDeclaredField theUnsafe unsafe. setAccessible true return Unsafe unsafe. getnull catch IllegalAccessException", "e Handle catch IllegalArgumentException e Handle catch NoSuchFieldException e Handle catch SecurityException e Handle sun.misc.Unsafe has a Private constructor, and the static getUnsafe method is guarded with a check of the classloader to ensure that the code was loaded with the primary classloader. Therefore, one method of loading the instance is to use re\ufb02ection to get the static \ufb01eld. Section 146.2 Instantiating sun.misc.Unsafe via bootclasspath public class UnsafeLoader public static Unsafe loadUnsafe return Unsafe. getUnsafe While this example will compile, it is likely to fail at runtime unless the Unsafe class was loaded with the primary classloader. To ensure that happens the JVM should be loaded with the appropriate arguments, like java -Xbootclasspath JAVAHOME jrelibrt.jar.UnsafeLoader. jar foo.bar.MyApp The foo.bar.MyApp class can then use UnsafeLoader. loadUnsafe . Section 146.3 Getting Instance of Unsafe Unsafe is stored as a private \ufb01eld that cannot be accessed directly. The constructor is private and the only method to access public static Unsafe getUnsafe has privileged access. By use of re\ufb02ection, there is a work-around to make private \ufb01elds accessible public static final Unsafe UNSAFE static Unsafe unsafe null try final PrivilegedExceptionAction Unsafe action - final Field f Unsafe. class.getDeclaredField theUnsafe f. setAccessible true return", "Unsafe f.getnull GoalKicker.com Java Notes for Professionals 809 unsafe AccessController .doPrivileged action catch final Throwable t throw new RuntimeException Exception accessing Unsafe , t UNSAFE unsafe Section 146.4 Uses of Unsafe Some uses of unsafe is s follows Use API O\ufb00 heap direct memory allocation, reallocation and deallocationallocateMemory bytes, reallocateMemory address, bytes and freeMemory address Memory fences loadFence , storeFence , fullFence Parking current thread parkisAbsolute, time , unparkthread Direct \ufb01eld and or memory access get and put family of methods Throwing unchecked exceptions throwException e CAS and Atomic Operations compareAndSwap family of methods Setting out memory setMemory Volatile or concurrent operations getVolatile , putVolatile , putOrdered The get and put family of methods are relative to a given object. If the object is null then it is treated as an absolute address. Putting a value to a field protected static long fieldOffset UNSAFE. objectFieldOffset getClass .getField theField UNSAFE.putLongthis, fieldOffset , newValue Puting an absolute value UNSAFE. putLongnull, address, newValue UNSAFE. putLongaddress, newValue Some methods are only de\ufb01ned for int and longs. You can use these methods on \ufb02oats and doubles using floatToRawIntBits , intBitsToFloat, doubleToRawLongBits ,longBitsToDouble GoalKicker.com Java Notes for Professionals 810Chapter 147 Java Memory Model Section 147.1", "Motivation for the Memory Model Consider the following example public class Example public int a, b, c, d public void doIt a b 1 c d 1 If this class is used is a single-threaded application, then the observable behavior will be exactly as you would expect. For instance public class SingleThreaded public static void mainString args Example eg new Example System.out.printlneg.a , eg.c eg. doIt System.out.printlneg.a , eg.c will output 0, 0 1, 1 As far as the main thread can tell , the statements in the main method and the doIt method will be executed in the order that they are written in the source code. This is a clear requirement of the Java Language Speci\ufb01cation JLS. Now consider the same class used in a multi-threaded application. public class MultiThreaded public static void mainString args final Example eg new Example new Threadnew Runnable public void run while true eg. doIt .start while true System.out.printlneg.a , eg.c What will this print? GoalKicker.com Java Notes for Professionals 811In fact, according to the JLS it is not possible to predict that this will print You will probably see a few lines of 0, 0 to start with. Then you probably", "see lines like N, N or N, N 1. You might see lines like N 1, N. In theory, you might even see that the 0, 0 lines continue forever1. 1 - In practice the presence of the println statements is liable to cause some serendipitous synchronization and memory cache \ufb02ushing. That is likely to hide some of the e\ufb00ects that would cause the above behavior. So how can we explain these? Reordering of assignments One possible explanation for unexpected results is that the JIT compiler has changed the order of the assignments in the doIt method. The JLS requires that statements appear to execute in order from the perspective of the current thread. In this case, nothing in the code of the doIt method can observe the e\ufb00ect of a hypothetical reordering of those two statement. This means that the JIT compiler would be permitted to do that. Why would it do that? On typical modern hardware, machine instructions are executed using a instruction pipeline which allows a sequence of instructions to be in di\ufb00erent stages. Some phases of instruction execution take longer than others, and memory operations tend to take a longer time. A smart compiler can", "optimize the instruction throughput of the pipeline by ordering the instructions to maximize the amount of overlap. This may lead to executing parts of statements out of order. The JLS permits this provided that not a\ufb00ect the result of the computation from the perspective of the current thread . E\ufb00ects of memory caches A second possible explanation is e\ufb00ect of memory caching. In a classical computer architecture, each processor has a small set of registers, and a larger amount of memory. Access to registers is much faster than access to main memory. In modern architectures, there are memory caches that are slower than registers, but faster than main memory. A compiler will exploit this by trying to keep copies of variables in registers, or in the memory caches. If a variable does not need to be \ufb02ushed to main memory, or does not need to be read from memory, there are signi\ufb01cant performance bene\ufb01ts in not doing this. In cases where the JLS does not require memory operations to be visible to another thread, the Java JIT compiler is likely to not add the read barrier and write barrier instructions that will force main memory reads and writes. Once", "again, the performance bene\ufb01ts of doing this are signi\ufb01cant. Proper synchronization So far, we have seen that the JLS allows the JIT compiler to generate code that makes single-threaded code faster by reordering or avoiding memory operations. But what happens when other threads can observe the state of the shared variables in main memory? The answer is, that the other threads are liable to observe variable states which would appear to be impossible ... based on the code order of the Java statements. The solution to this is to use appropriate synchronization. The three main approaches are Using primitive mutexes and the synchronized constructs. Using volatile variables. Using higher level concurrency support e.g. classes in the java.util.concurrent packages. GoalKicker.com Java Notes for Professionals 812But even with this, it is important to understand where synchronization is needed, and what e\ufb00ects that you can rely on. This is where the Java Memory Model comes in. The Memory Model The Java Memory Model is the section of the JLS that speci\ufb01es the conditions under which one thread is guaranteed to see the e\ufb00ects of memory writes made by another thread. The Memory Model is speci\ufb01ed with a fair degree of formal rigor", ", and as a result requires detailed and careful reading to understand. But the basic principle is that certain constructs create a happens-before relation between write of a variable by one thread, and a subsequent read of the same variable by another thread. If the happens before relation exists, the JIT compiler is obliged to generate code that will ensure that the read operation sees the value written by the write. Armed with this, it is possible to reason about memory coherency in a Java program, and decide whether this will be predictable and consistent for all execution platforms. Section 147.2 Happens-before relationships The following is a simpli\ufb01ed version of what the Java Language Speci\ufb01cation says. For a deeper understanding, you need to read the speci\ufb01cation itself. Happens-before relationships are the part of the Memory Model that allow us to understand and reason about memory visibility. As the JLS says JLS 17.4.5 Two actions can be ordered by a happens-before relationship. If one action happens-before another, then the \ufb01rst is visible to and ordered before the second. What does this mean? Actions The actions that the above quote refers to are speci\ufb01ed in JLS 17.4.2 . There are 5", "kinds of action listed de\ufb01ned by the spec Read Reading a non-volatile variable. Write Writing a non-volatile variable. Synchronization actions Volatile read Reading a volatile variable. Volatile write Writing a volatile variable. Lock. Locking a monitor Unlock. Unlocking a monitor. The synthetic \ufb01rst and last actions of a thread. Actions that start a thread or detect that a thread has terminated. External Actions. An action that has a result that depends on the environment in which the program. Thread divergence actions. These model the behavior of certain kinds of in\ufb01nite loop. GoalKicker.com Java Notes for Professionals 813Program Order and Synchronization Order These two orderings JLS 17.4.3 and JLS 17.4.4 govern the execution of statements in a Java Program order describes the order of statement execution within a single thread. Synchronization order describes the order of statement execution for two statements connected by a synchronization An unlock action on monitor synchronizes-with all subsequent lock actions on that monitor. A write to a volatile variable synchronizes-with all subsequent reads of the same variable by any thread. An action that starts a thread i.e. the call to Thread.start synchronizes-with the \ufb01rst action in the thread it starts i.e. the call to the", "threads run method. The default initialization of \ufb01elds synchronizes-with the \ufb01rst action in every thread. See the JLS for an explanation of this. The \ufb01nal action in a thread synchronizes-with any action in another thread that detects the termination e.g. the return of a join call or isTerminated call that returns true . If one thread interrupts another thread, the interrupt call in the \ufb01rst thread synchronizes-with the point where another thread detects that the thread was interrupted. Happens-before Order This ordering JLS 17.4.5 is what determines whether a memory write is guaranteed to be visible to a subsequent memory read. More speci\ufb01cally, a read of a variable v is guaranteed to observe a write to v if and only if writev happens-before readv AND there is no intervening write to v. If there are intervening writes, then the readv may see the results of them rather than the earlier one. The rules that de\ufb01ne the happens-before ordering are as follows Happens-Before Rule 1 - If x and y are actions of the same thread and x comes before y in program order , then x happens-before y. Happens-Before Rule 2 - There is a happens-before edge from the", "end of a constructor of an object to the start of a \ufb01nalizer for that object. Happens-Before Rule 3 - If an action x synchronizes-with a subsequent action y, then x happens-before y. Happens-Before Rule 4 - If x happens-before y and y happens-before z then x happens-before z. In addition, various classes in the Java standard libraries are speci\ufb01ed as de\ufb01ning happens-before relationships. You can interpret this as meaning that it happens somehow , without needing to know exactly how the guarantee is going to be met. Section 147.3 How to avoid needing to understand the Memory Model The Memory Model is di\ufb03cult to understand, and di\ufb03cult to apply. It is useful if you need to reason about the correctness of multi-threaded code, but you do not want to have to do this reasoning for every multi-threaded application that you write. GoalKicker.com Java Notes for Professionals 814If you adopt the following principals when writing concurrent code in Java, you can largely avoid the need to resort to happens-before reasoning. Use immutable data structures where possible. A properly implemented immutable class will be thread-safe, and will not introduce thread-safety issues when you use it with other classes. Understand and", "avoid unsafe publication. Use primitive mutexes or Lock objects to synchronize access to state in mutable objects that need to be thread-safe1. Use Executor ExecutorService or the fork join framework rather than attempting to create manage threads directly. Use the java.util.concurrent classes that provide advanced locks, semaphores, latches and barriers, instead of using waitnotifynotifyAll directly. Use the java.util.concurrent versions of maps, sets, lists, queues and deques rather than external synchonization of non-concurrent collections. The general principle is to try to use Javas built-in concurrency libraries rather than rolling your own concurrency. You can rely on them working, if you use them properly. 1 - Not all objects need to be thread safe. For example, if an object or objects is thread-con\ufb01ned i.e. it is only accessible to one thread, then its thread-safety is not relevant. Section 147.4 Happens-before reasoning applied to some examples We will present some examples to show how to apply happens-before reasoning to check that writes are visible to subsequent reads. Single-threaded code As you would expect, writes are always visible to subsequent reads in a single-threaded program. public class SingleThreadExample public int a, b public int add a 1 writea b 2 writeb return a", "b reada followed by readb By Happens-Before Rule 1 The writea action happens-before the writeb action. 1. The writeb action happens-before the reada action. 2. The reada action happens-before the reada action. 3. By Happens-Before Rule 4 writea happens-before writeb AND writeb happens-before reada IMPLIES writea happens-before 4. reada. GoalKicker.com Java Notes for Professionals 815writeb happens-before reada AND reada happens-before readb IMPLIES writeb happens-before 5. readb. Summing up The writea happens-before reada relation means that the a b statement is guaranteed to see the 6. correct value of a. The writeb happens-before readb relation means that the a b statement is guaranteed to see the 7. correct value of b. Behavior of volatile in an example with 2 threads We will use the following example code to explore some implications of the Memory Model for volatile. public class VolatileExample private volatile int a private int b NOT volatile public void updateint first, int second b first writeb a second write-volatilea public int observe return a b read-volatilea followed by readb First, consider the following sequence of statements involving 2 threads A single instance of VolatileExample is created call it ve, 1. ve.update1, 2 is called in one thread, and", "2. ve.observe is called in another thread. 3. By Happens-Before Rule 1 The writea action happens-before the volatile -writea action. 1. The volatile -reada action happens-before the readb action. 2. By Happens-Before Rule 2 The volatile -writea action in the \ufb01rst thread happens-before the volatile -reada action in the second 3. thread. By Happens-Before Rule 4 The writeb action in the \ufb01rst thread happens-before the readb action in the second thread. 4. In other words, for this particular sequence, we are guaranteed that the 2nd thread will see the update to the non- volatile variable b made by the \ufb01rst thread. However, it is should also be clear that if the assignments in the update method were the other way around, or the observe method read the variable b before a, then the happens-before chain would be broken. The chain would also be broken if volatile -reada in the second thread was not subsequent to the volatile -writea in the \ufb01rst thread. When the chain is broken, there is no guarantee that observe will see the correct value of b. Volatile with three threads GoalKicker.com Java Notes for Professionals 816Suppose we to add a third thread into the previous", "example A single instance of VolatileExample is created call it ve, 1. Two threads call update 2. ve.update1, 2 is called in one thread, ve.update3, 4 is called in the second thread, ve.observe is subsequently called in a third thread. 3. To analyse this completely, we need to consider all of the possible interleavings of the statements in thread one and thread two. Instead, we will consider just two of them. Scenario 1 - suppose that update1, 2 precedes update3,4 we get this sequence writeb, 1, write-volatile a, 2 first thread writeb, 3, write-volatile a, 4 second thread read-volatile a, readb third thread In this case, it is easy to see that there is an unbroken happens-before chain from writeb, 3 to readb. Furthermore there is no intervening write to b. So, for this scenario, the third thread is guaranteed to see b as having value 3. Scenario 2 - suppose that update1, 2 and update3,4 overlap and the ations are interleaved as follows writeb, 3 second thread writeb, 1 first thread write-volatile a, 2 first thread write-volatile a, 4 second thread read-volatile a, readb third thread Now, while there is a happens-before chain from writeb, 3 to readb,", "there is an intervening writeb, 1 action performed by the other thread. This means we cannot be certain which value readb will see. Aside This demonstrates that we cannot rely on volatile for ensuring visibility of non-volatile variables, except in very limited situations. GoalKicker.com Java Notes for Professionals 817Chapter 148 Java deployment There are a variety of technologies for packaging Java applications, webapps and so forth, for deployment to the platform on which they will run. They range from simple library or executable JAR \ufb01les, WAR and EAR \ufb01les, through to installers and self-contained executables. Section 148.1 Making an executable JAR from the command line To make a jar, you need one or more class \ufb01les. This should have a main method if it is to be run by a double click. For this example, we will use import javax.swing. import java.awt.Container public class HelloWorld public static void mainString args JFrame f new JFrameHello, World JLabel label new JLabelHello, World Container cont f.getContentPane cont. addlabel f. setSize400,100 f. setVisible true f. setDefaultCloseOperation JFrame.EXITONCLOSE It has been named HelloWorld.java Next, we want to compile this program. You may use any program you want to do this. To run from the", "command line, see the documentation on compiling and running your \ufb01rst java program. Once you have HelloWorld.class, make a new folder and call it whatever you want. Make another \ufb01le called manifest.txt and paste into it Main-Class HelloWorld Class-Path HelloWorld. jar Put it in the same folder with HelloWorld.class Use the command line to make your current directory cd CYourFolderPathHere on windows your folder. Use Terminal and change directory to the directory cd UsersuserDocuments Javajarfolder on Mac your folder When that is done, type in jar -cvfm HelloWorld. jar manifest. txt HelloWorld. class and press enter. This makes a jar \ufb01le in the folder with your manifest and HelloWorld.class using the .class \ufb01les speci\ufb01ed and named HelloWorld.jar. See the Syntax section for information about the options like -m and -v. After these steps, go to your directory with the manifest \ufb01le and you should \ufb01nd HelloWorld.jar Clicking on it should display Hello, World in a text box. GoalKicker.com Java Notes for Professionals 818Section 148.2 Creating an UberJAR for an application and its dependencies A common requirement for a Java application is that can be deployed by copying a single \ufb01le. For simple applications that depend only on the standard", "Java SE class libraries, this requirement is satis\ufb01ed by creating a JAR \ufb01le containing all of the compiled application classes. Things are not so straightforward if the application depends on third-party libraries. If you simply put dependency JAR \ufb01les inside an application JAR, the standard Java class loader will not be able to \ufb01nd the library classes, and your application will not start. Instead, you need to create a single JAR \ufb01le that contains the application classes and associated resources together with the dependency classes and resources. These need to be organized as a single namespace for the classloader to search. The such a JAR \ufb01le is often referred to as an UberJAR. Creating an UberJAR using the jar command The procedure for creating an UberJAR is straight-forward. I will use Linux commands for simplicity. The commands should be identical for Mac OS, and similar for Windows. Create a temporary directory, and change directory to it.1. mkdir tempDir cd tempDir For each dependent JAR \ufb01le, in the reverse order that they need to appear on the applications classpath, used 2. the jar command to unpack the JAR into the temporary directory. jar -xf pathtofile.jar Doing this for multiple JAR", "\ufb01les will overlay contents of the JARs. Copy the application classes from the build tree into the temporary directory3. cp -r pathtoclasses . Create the UberJAR from the contents of the temporary directory4. jar -cf ..myApplication. jar If you are creating an executable JAR \ufb01le, include an appropriate MANIFEST.MF as described here. Creating an UberJAR using Maven If your project is built using Maven, you can get it to create an UberJAR using either the maven-assembly or maven-shade plugins. See the Maven Assembly topic in the Maven documentation for details. The advantages and drawbacks of UberJARs Some of advantages of UberJARs are self-evident An UberJAR is easy to distribute. GoalKicker.com Java Notes for Professionals 819You cannot break the library dependencies for an UberJAR, since the libraries are self-contained. In addition, if you use an appropriate tooling to create the UberJAR, you will have the option of excluding library classes that are not used from the JAR \ufb01le. However, that this is typically done by static analysis of the classes. If your application uses re\ufb02ection, annotation processing and similar techniques, you need to be careful that classes are not excluded incorrectly. UberJARs also have some disadvantages If you have lots", "of UberJARs with the same dependencies, then each one will contain a copy of the dependencies. Some open source libraries have licenses which may preclude 1 their use in an UberJAR. 1 - Some open source library licenses allow you to use the library only of the end-user is able to replace one version of the library with another. UberJARs can make replacement of version dependencies di\ufb03cult. Section 148.3 Creating JAR, WAR and EAR \ufb01les The JAR, WAR and EAR \ufb01les types are fundamentally ZIP \ufb01les with a manifest \ufb01le and for WAR and EAR \ufb01les a particular internal directory \ufb01le structure. The recommended way to create these \ufb01les is to use a Java-speci\ufb01c build tool which understands the requirements for the respective \ufb01le types. If you dont use a build tool, then IDE export is the next option to try. Editorial note the descriptions of how to create these \ufb01les are best placed in the documentation for the respective tools. Put them there. Please show some self-restraint and DONT shoe-horn them into this example! Creating JAR and WAR \ufb01les using Maven Creating a JAR or WAR using Maven is simply a matter of putting the correct packaging element", "into the POM \ufb01le e,g, packaging jarpackaging or packaging warpackaging For more details. Maven can be con\ufb01gured to create executable JAR \ufb01les by adding the requisite information about the entry-point class and external dependencies as plugin properties for the maven jar plugin. There is even a plugin for creating uberJAR \ufb01les that combine an application and its dependencies into a single JAR \ufb01le. Please refer to the Maven documentation httpstackover\ufb02ow.comdocumentationmaventopics for more information. Creating JAR, WAR and EAR \ufb01les using Ant The Ant build tool has separate tasks for building JAR, WAR and EAR. Please refer to the Ant documentation httpstackover\ufb02ow.comdocumentationanttopics for more information. Creating JAR, WAR and EAR \ufb01les using an IDE The three most popular Java IDEs all have built-in support for creating deployment \ufb01les. The functionality is often described as exporting. GoalKicker.com Java Notes for Professionals 820Eclipse - httpstackover\ufb02ow.comdocumentationeclipsetopics NetBeans - httpstackover\ufb02ow.comdocumentationnetbeanstopics Intellij-IDEA - Exporting Creating JAR, WAR and EAR \ufb01les using the jar command. It is also possible to create these \ufb01les by hand using the jar command. It is simply a matter of assembling a \ufb01le tree with the correct component \ufb01les in the correct place, creating a manifest \ufb01le, and running jar to", "create the JAR \ufb01le. Please refer to the jar command Topic Creating and modifying JAR \ufb01les for more information Section 148.4 Introduction to Java Web Start The Oracle Java Tutorials summarize Web Start as follows Java Web Start software provides the power to launch full-featured applications with a single click. Users can download and launch applications, such as a complete spreadsheet program or an Internet chat client, without going through lengthy installation procedures. Other advantages of Java Web Start are support for signed code and explicit declaration of platform dependencies, and support for code caching and deployment of application updates. Java Web Start is also referred to as JavaWS and JAWS. The primary sources of information are The Java Tutorials - Lesson Java Web Start Java Web Start Guide Java Web Start FAQ JNLP Speci\ufb01cation javax.jnlp API Documentation Java Web Start Developers Site Prerequisites At a high level, Web Start works by distributing Java applications packed as JAR \ufb01les from a remote webserver. The prerequisites are A pre-existing Java installation JRE or JDK on the target machine where the application is to run. Java 1.2.2 or higher is required From Java 5.0 onwards, Web Start support is included in", "the JRE JDK. For earlier releases, Web Start support is installed separately. The Web Start infrastructure includes some Javascript that can be included in a web page to assist the user to install the necessary software. The webserver that hosts the software must be accessible to the target machine. If the user is going to launch a Web Start application using a link in a web page, then they need a compatible web browser, and for modern secure browsers, they need to be told how to tell the browser to allow Java to run ... without compromising web browser security. GoalKicker.com Java Notes for Professionals 821An example JNLP \ufb01le The following example is intended to illustrate the basic functionality of JNLP. ?xml version1.0 encoding UTF-8? jnlp spec1.0 codebase httpswww.example.comdemo hrefdemowebstart.jnlp information titleDemotitle vendorThe Example.com Team vendor information resources !-- Application Resources -- j2se version1.7 hrefhttpjava.sun.comproductsautodlj2se jar hrefDemo.jar maintrue resources application-desc nameDemo Application main-class com.example.jwsdemo.Main width300 height300 application-desc update checkbackground jnlp As you can see, a JNLP \ufb01le XML-based, and the information is all contained in the jnlp element. The spec attribute gives the version of the JNPL spec that this \ufb01le conforms to. The codebase attribute gives the base", "URL for resolving relative href URLs in the rest of the \ufb01le. The href attribute gives the de\ufb01nitive URL for this JNLP \ufb01le. The information element contains metadata the application including its title, authors, description and help website. The resources element describes the dependencies for the application including the required Java version, OS platform and JAR \ufb01les. The application-desc or applet-desc element provides information needed to launch the application. Setting up the web server The webserver must be con\ufb01gured to use application x-java-jnlp-file as the MIMEtype for .jnlp \ufb01les. The JNLP \ufb01le and the applications JAR \ufb01les must be installed on the webserver so that they are available using the URLs indicated by the JNLP \ufb01le. Enabling launch via a web page If the application is to be launched via a web link, the page that contains the link must be created on the webserver. If you can assume that Java Web Start is already installed on the users machine, then the web page simply needs to contain a link for launching the application. For example. a hrefhttpswww.example.comdemowebstart.jnlp Launch the application a Otherwise, the page should also include some scripting to detect the kind of browser the user is", "using and request to download and install the required version of Java. GoalKicker.com Java Notes for Professionals 822NOTE It is a bad idea to encourage users to encourage to install Java this way, or even to enable Java in their web browsers so that JNLP web page launch will work. Launching Web Start applications from the command line The instructions for launching an Web Start application from the command line are simple. Assuming that the user has a Java 5.0 JRE or JDK installed, the simply need to run this javaws url where url is the URL for the JNLP \ufb01le on the remote server. GoalKicker.com Java Notes for Professionals 823Chapter 149 Java plugin system implementations Section 149.1 Using URLClassLoader There are several ways to implement a plugin system for a Java application. One of the simplest is to use URLClassLoader . The following example will involve a bit of JavaFX code. Suppose we have a module of a main application. This module is supposed to load plugins in form of Jars from plugins folder. Initial code package main public class MainApplication extends Application Override public void startStage primaryStage throws Exception File pluginDirectory new Fileplugins arbitrary directory if!pluginDirectory. existspluginDirectory.", "mkdir VBox loadedPlugins new VBox6 a container to show the visual info later Rectangle2D screenbounds Screen.getPrimary .getVisualBounds Scene scene new SceneloadedPlugins,screenbounds. getWidth 2,screenbounds. getHeight 2 primaryStage. setScene scene primaryStage. show public static void mainString a launch a Then, we create an interface which will represent a plugin. package main public interface Plugin default void initialize System.out.printlnInitialized this.getClass .getName default String namereturn getClass .getSimpleName We want to load classes which implement this interface, so \ufb01rst we need to \ufb01lter \ufb01les which have a .jar extension File filespluginDirectory. listFiles dir, name - name.endsWith .jar If there are any \ufb01les, we need to create collections of URLs and class names iffiles!null files.length0 ArrayList String classes new ArrayList ArrayList URL urlsnew ArrayList files.length forFile filefiles GoalKicker.com Java Notes for Professionals 824 JarFile jarnew JarFilefile jar. stream.forEachjarEntry - ifjarEntry. getName.endsWith .class classes. addjarEntry. getName URL urlfile.toURI.toURL urls. addurl Lets add a static HashSet to MainApplication which will hold loaded plugins static HashSet Plugin plugins new HashSet Next, we instantiate a URLClassLoader , and iterate over class names, instantiating classes which implement Plugin interface URLClassLoader urlClassLoader new URLClassLoader urls.toArraynew URLurls.size classes. forEachclassName - try Class clsurlClassLoader. loadClass className. replaceAll ,..replace.class , transforming to binary name", "Class interfaces cls.getInterfaces forClass intface interfaces ifintface. equalsPlugin.class checking presence of Plugin interface Plugin plugin Plugin cls.newInstance instantiating the Plugin plugins. addplugin break catch Exception ee.printStackTrace Then, we can call plugins methods, for example, to initialize them if!plugins. isEmptyloadedPlugins. getChildren .addnew LabelLoaded plugins plugins. forEachplugin - plugin. initialize loadedPlugins. getChildren .addnew Labelplugin.name The \ufb01nal code of MainApplication package main public class MainApplication extends Application static HashSet Plugin plugins new HashSet Override public void startStage primaryStage throws Exception File pluginDirectory new Fileplugins if!pluginDirectory. existspluginDirectory. mkdir GoalKicker.com Java Notes for Professionals 825 File filespluginDirectory. listFiles dir, name - name.endsWith .jar VBox loadedPlugins new VBox6 loadedPlugins. setAlignment Pos.CENTER iffiles!null files.length0 ArrayList String classes new ArrayList ArrayList URL urlsnew ArrayList files.length forFile filefiles JarFile jarnew JarFilefile jar. stream.forEachjarEntry - ifjarEntry. getName.endsWith .class classes. addjarEntry. getName URL urlfile.toURI.toURL urls. addurl URLClassLoader urlClassLoader new URLClassLoader urls.toArraynew URLurls.size classes. forEachclassName - try Class clsurlClassLoader. loadClass className. replaceAll ,..replace.class , Class interfaces cls.getInterfaces forClass intface interfaces ifintface. equalsPlugin.class Plugin plugin Plugin cls.newInstance plugins. addplugin break catch Exception ee.printStackTrace if!plugins. isEmptyloadedPlugins. getChildren .addnew LabelLoaded plugins plugins. forEachplugin - plugin. initialize loadedPlugins. getChildren .addnew Labelplugin.name Rectangle2D screenbounds Screen.getPrimary .getVisualBounds Scene scene new SceneloadedPlugins,screenbounds. getWidth 2,screenbounds. getHeight 2 primaryStage. setScene", "scene primaryStage. show public static void mainString a launch a Lets create two plugins. Obviously, the plugins source should be in a separate module. package plugins import main.Plugin GoalKicker.com Java Notes for Professionals 826public class FirstPlugin implements Plugin this plugin has default behaviour Second plugin package plugins import main.Plugin public class AnotherPlugin implements Plugin Override public void initialize overrided to show users home directory System.out.printlnUser home directory System.getProperty user.home These plugins have to be packaged into standard Jars - this process depends on your IDE or other tools. When Jars will be put into plugins directly, MainApplication will detect them and instantiate appropriate classes. GoalKicker.com Java Notes for Professionals 827Chapter 150 JavaBean JavaBeans TM is a pattern for designing Java class APIs that allows instances beans to be used in various contexts and using various tools without explicitly writing Java code. The patterns consists of conventions for de\ufb01ning getters and setters for properties , for de\ufb01ning constructors, and for de\ufb01ning event listener APIs. Section 150.1 Basic Java Bean public class BasicJavaBean implements java.io.Serializable private int value1 private String value2 private boolean value3 public BasicJavaBean public void setValue1 int value1 this.value1 value1 public int getValue1 return value1 public void setValue2", "String value2 this.value2 value2 public String getValue2 return value2 public void setValue3 boolean value3 this.value3 value3 public boolean isValue3 return value3 GoalKicker.com Java Notes for Professionals 828Chapter 151 Java SE 7 Features In this topic youll \ufb01nd a summary of the new features added to the Java programming language in Java SE 7. There are many other new features in other \ufb01elds such as JDBC and Java Virtual Machine JVM that are not going to be covered in this topic. Section 151.1 New Java SE 7 programming language features Binary Literals The integral types byte, short, int, and long can also be expressed using the binary number system. To specify a binary literal, add the pre\ufb01x 0b or 0B to the number. Strings in switch Statements You can use a String object in the expression of a switch statement The try-with-resources Statement The try-with-resources statement is a try statement that declares one or more resources. A resource is as an object that must be closed after the program is \ufb01nished with it. The try- with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement", "java.io.Closeable, can be used as a resource. Catching Multiple Exception Types and Rethrowing Exceptions with Improved Type Checking a single catch block can handle more than one type of exception. This feature can reduce code duplication and lessen the temptation to catch an overly broad exception. Underscores in Numeric Literals Any number of underscore characters can appear anywhere between digits in a numerical literal. This feature enables you, for example, to separate groups of digits in numeric literals, which can improve the readability of your code. Type Inference for Generic Instance Creation You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond. Improved Compiler Warnings and Errors When Using Non-Rei\ufb01able Formal Parameters with Varargs Methods Section 151.2 Binary Literals An 8-bit byte value byte aByte byte0b00100001 A 16-bit short value short aShort short0b1010000101000101 Some 32-bit int values int anInt1 0b10100001010001011010000101000101 int anInt2 0b101 int anInt3 0B101 The B can be upper or lower case. A 64-bit long value. Note the L suffix long aLong", "0b1010000101000101101000010100010110100001010001011010000101000101L Section 151.3 The try-with-resources statement The example reads the \ufb01rst line from a \ufb01le. It uses an instance of BufferedReader to read data from the \ufb01le. BufferedReader is a resource that must be closed after the program is \ufb01nished with it static String readFirstLineFromFile String path throws IOException try BufferedReader br new BufferedReader new FileReader path return br.readLine GoalKicker.com Java Notes for Professionals 829 In this example, the resource declared in the try-with-resources statement is a BufferedReader . The declaration statement appears within parentheses immediately after the try keyword. The class BufferedReader , in Java SE 7 and later, implements the interface java.lang.AutoCloseable . Because the BufferedReader instance is declared in a try-with-resource statement, it will be closed regardless of whether the try statement completes normally or abruptly as a result of the method BufferedReader .readLine throwing an IOException . Section 151.4 Underscores in Numeric Literals The following example shows other ways you can use the underscore in numeric literals long creditCardNumber 1234567890123456L long socialSecurityNumber 999999999L float pi 3.1415F long hexBytes 0xFFECDE5E long hexWords 0xCAFEBABE long maxLong 0x7fffffffffffffffL byte nybbles 0b00100101 long bytes 0b11010010011010011001010010010010 You can place underscores only between digits you cannot place underscores in the following", "places At the beginning or end of a number Adjacent to a decimal point in a \ufb02oating point literal Prior to an F or L su\ufb03x In positions where a string of digits is expected Section 151.5 Type Inference for Generic Instance Creation You can use MapString, ListString myMap new HashMap instead of MapString, ListString myMap new HashMap String, ListString However, you cant use ListString list new ArrayList list.addA The following statement should fail since addAll expects Collection? extends String list.addAllnew ArrayList because it cant compile. Note that the diamond often works in method calls however, it is suggested that you use the diamond primarily for variable declarations. Section 151.6 Strings in switch Statements public String getTypeOfDayWithSwitchStatement String dayOfWeekArg String typeOfDay GoalKicker.com Java Notes for Professionals 830 switch dayOfWeekArg case Monday typeOfDay Start of work week break case Tuesday case Wednesday case Thursday typeOfDay Midweek break case Friday typeOfDay End of work week break case Saturday case Sunday typeOfDay Weekend break default throw new IllegalArgumentException Invalid day of the week dayOfWeekArg return typeOfDay GoalKicker.com Java Notes for Professionals 831Chapter 152 Java SE 8 Features In this topic youll \ufb01nd a summary of the new features added to the Java", "programming language in Java SE 8. There are many other new features in other \ufb01elds such as JDBC and Java Virtual Machine JVM that are not going to be covered in this topic. Section 152.1 New Java SE 8 programming language features Lambda Expressions , a new language feature, has been introduced in this release. They enable you to treat functionality as a method argument, or code as data. Lambda expressions let you express instances of single-method interfaces referred to as functional interfaces more compactly. Method references provide easy-to-read lambda expressions for methods that already have a name. Default methods enable new functionality to be added to the interfaces of libraries and ensure binary compatibility with code written for older versions of those interfaces. New and Enhanced APIs That Take Advantage of Lambda Expressions and Streams in Java SE 8 describe new and enhanced classes that take advantage of lambda expressions and streams. Improved Type Inference - The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. The target type of an expression is the data type that the Java compiler expects depending on where the expression appears. For example, you", "can use an assignment statements target type for type inference in Java SE 7. However, in Java SE 8, you can use the target type for type inference in more contexts. Target Typing in Lambda Expressions Type Inference Repeating Annotations provide the ability to apply the same annotation type more than once to the same declaration or type use. Type Annotations provide the ability to apply an annotation anywhere a type is used, not just on a declaration. Used with a pluggable type system, this feature enables improved type checking of your code. Method parameter re\ufb02ection - You can obtain the names of the formal parameters of any method or constructor with the method java.lang.reflect.Executable .getParameters . The classes Method and Constructor extend the class Executable and therefore inherit the method Executable. getParameters However, .class \ufb01les do not store formal parameter names by default. To store formal parameter names in a particular .class \ufb01le, and thus enable the Re\ufb02ection API to retrieve formal parameter names, compile the source \ufb01le with the -parameters option of the javac compiler. Date-time-api - Added new time api in java.time . If used this, you dont need to designate timezone. GoalKicker.com Java Notes for", "Professionals 832Chapter 153 Dynamic Method Dispatch What is Dynamic Method Dispatch? Dynamic Method Dispatch is a process in which the call to an overridden method is resolved at runtime rather than at compile-time. When an overridden method is called by a reference, Java determines which version of that method to execute based on the type of object it refer to. This is also know as runtime polymorphism. We will see this through an example. Section 153.1 Dynamic Method Dispatch - Example Code Abstract Class package base Abstract classes cannot be instantiated, but they can be subclassed public abstract class ClsVirusScanner With One Abstract method public abstract void fnStartScan protected void fnCheckForUpdateVersion System.out.printlnPerform Virus Scanner Version Check protected void fnBootTimeScan System.out.printlnPerform BootTime Scan protected void fnInternetSecutiry System.out.printlnScan for Internet Security protected void fnRealTimeScan System.out.printlnPerform RealTime Scan protected void fnVirusMalwareScan System.out.printlnDetect Virus Malware Overriding Abstract Method in Child Class import base.ClsVirusScanner All the 3 child classes inherits the base class ClsVirusScanner Child Class 1 class ClsPaidVersion extends ClsVirusScanner Override public void fnStartScan super.fnCheckForUpdateVersion super.fnBootTimeScan GoalKicker.com Java Notes for Professionals 833 super.fnInternetSecutiry super.fnRealTimeScan super.fnVirusMalwareScan ClsPaidVersion IS-A ClsVirusScanner Child Class 2 class ClsTrialVersion extends ClsVirusScanner Override public void fnStartScan super.fnInternetSecutiry super.fnVirusMalwareScan ClsTrialVersion IS-A", "ClsVirusScanner Child Class 3 class ClsFreeVersion extends ClsVirusScanner Override public void fnStartScan super.fnVirusMalwareScan ClsTrialVersion IS-A ClsVirusScanner DynamicLate Binding leads to Dynamic method dispatch Calling Class public class ClsRunTheApplication public static void mainString args final String VIRUSSCANNERVERSION TRIALVERSION Parent Refers Null ClsVirusScanner objVS null String Cases Supported from Java SE 7 switch VIRUSSCANNERVERSION case FREEVERSION Parent Refers Child Object 3 ClsFreeVersion IS-A ClsVirusScanner objVS new ClsFreeVersion Dynamic or Runtime Binding break case PAIDVERSION Parent Refers Child Object 1 ClsPaidVersion IS-A ClsVirusScanner objVS new ClsPaidVersion Dynamic or Runtime Binding break case TRIALVERSION Parent Refers Child Object 2 objVS new ClsTrialVersion Dynamic or Runtime Binding break Method fnStartScan is the Version of ClsTrialVersion objVS. fnStartScan GoalKicker.com Java Notes for Professionals 834 Result Scan for Internet Security Detect Virus Malware Upcasting objVS new ClsFreeVersion objVS new ClsPaidVersion objVS new ClsTrialVersion GoalKicker.com Java Notes for Professionals 835Chapter 154 Generating Java Code Section 154.1 Generate POJO From JSON Install JSON Model Genrator plugin of Intellij by searching in Intellij setting. Start the plugin from Tools Input the \ufb01eld of UI as following shows Path Source Package is required Click Generate button and your are done. GoalKicker.com Java Notes for Professionals 836Chapter 155 JShell JShell is", "an interactive REPL for Java added in JDK 9. It allows developers to instantly evaluate expressions, test classes, and experiment with the Java language. Early access for jdk 9 can be obtained from httpjdk.java.net9 Section 155.1 Editting Snippets The basic unit of code used by JShell is the snippet , or source entry . Every time you declare a local variable or de\ufb01ne a local method or class, you create a snippet whose name is the identi\ufb01er of the variablemethodclass. At any time, you can edit a snippet you have created with the edit command. For example, lets say I have created the class Foo with a single, method, bar jshell class Foo ... void bar ... ... Now, I want to \ufb01ll in the body of my method. Rather than rewrite the entire class, I can edit it jshell edit Foo By default, a swing editor will pop up with the most basic features possible. However you can change the editor that JShell uses jshell set editor emacs jshell set editor vi jshell set editor nano jshell set editor -default Note that if the new version of the snippet contains any syntax errors, it may not be saved.", "Likewise, a snippet is only created if the original declarationde\ufb01nition is syntactically correct the following does not work jshell String st String 3 error omitted jshell edit st No such snippet st However, snippets may be compiled and hence editable despite certain compile-time errors, such as mismatched types the following works jshell int i hello error omitted jshell edit i Finally, snippets may be deleted using the drop command jshell int i 13 jshell drop i jshell System.out.printlni Error cannot find symbol symbol variable i System.out.printlni GoalKicker.com Java Notes for Professionals 837To delete all snippets, thereby reseting the state of the JVM, use reset jshell int i 2 jshell String s hi jshell reset Resetting state. jshell i Error cannot find symbol symbol variable i i jshell s Error cannot find symbol symbol variable s s Section 155.2 Entering and Exiting JShell Starting JShell Before trying to start JShell, make sure your JAVAHOME environment variable points to a JDK 9 installation. To start JShell, run the following command jshell If all goes well, you should see a jshell prompt. Exiting JShell To exit JShell, run the following command from the JShell prompt jshell exit Section 155.3 Expressions Within JShell,", "you can evaluate Java expressions, with or without semicolons. These can range from basic expressions and statements to more complex ones jshell 42 jshell System.out.printfI am d years old. n, 421 Loops and conditionals are \ufb01ne, too jshell for int i 0 i3 i ... System.out.printlni ... It is important to note that expressions within blocks must have semicolons! GoalKicker.com Java Notes for Professionals 838Section 155.4 Methods and Classes You can de\ufb01ne methods and classes within JShell jshell void speak ... System.out.printlnhello ... jshell class MyClass ... void doNothing ... No access modi\ufb01ers are necessary. As with other blocks, semicolons are required inside of method bodies. Keep in mind that, as with variables, it is possible to rede\ufb01ne methods and classes. To see a list of methods or classes, enter methods or types at the JShell prompt, respectively. Section 155.5 Variables You can declare local variables within JShell jshell String s hi jshell int i s.length Keep in mind that variables can be redeclared with di\ufb00erent types this is perfectly valid in JShell jshell String var hi jshell int var 3 To see a list of variables, enter vars at the JShell prompt. GoalKicker.com Java Notes for Professionals 839Chapter", "156 Stack-Walking API Prior to Java 9, access to the thread stack frames was limited to an internal class sun.reflect.Reflection . Speci\ufb01cally the method sun.reflect.Reflection getCallerClass . Some libraries relies on this method which is deprecated. An alternative standard API is now provided in JDK 9 via the java.lang.StackWalker class, and is designed to be e\ufb03cient by allowing lazy access to the stack frames. Some applications may use this API to traverse the execution stack and \ufb01lter on classes. Section 156.1 Print all stack frames of the current thread The following prints all stack frames of the current thread 1 package test 2 3 import java.lang.StackWalker.StackFrame 4 import java.lang.reflect.InvocationTargetException 5 import java.lang.reflect.Method 6 import java.util.List 7 import java.util.stream.Collectors 8 9 public class StackWalkerExample 10 11 public static void mainString args throws NoSuchMethodException , SecurityException , IllegalAccessException , IllegalArgumentException , InvocationTargetException 12 Method fooMethod FooHelper. class.getDeclaredMethod foo, Class?null 13 fooMethod. invokenull, Object null 14 15 16 17 class FooHelper 18 protected static void foo 19 BarHelper. bar 20 21 22 23 class BarHelper 24 protected static void bar 25 List StackFrame stack StackWalker. getInstance 26 . walks - s.collectCollectors. toList 27 forStackFrame frame stack 28 System.out.printlnframe.getClassName frame.getLineNumber frame.getMethodName 29 30", "31 Output test.BarHelper 26 bar test.FooHelper 19 foo test.StackWalkerExample 13 main GoalKicker.com Java Notes for Professionals 840Section 156.2 Print current caller class The following prints the current caller class. Note that in this case, the StackWalker needs to be created with the option RETAINCLASSREFERENCE , so that Class instances are retained in the StackFrame objects. Otherwise an exception would occur. public class StackWalkerExample public static void mainString args FooHelper. foo class FooHelper protected static void foo BarHelper. bar class BarHelper protected static void bar System.out.printlnStackWalker. getInstance Option.RETAINCLASSREFERENCE .getCallerClass Output class test.FooHelper Section 156.3 Showing re\ufb02ection and other hidden frames A couple of other options allow stack traces to include implementation andor re\ufb02ection frames. This may be useful for debugging purposes. For instance, we can add the SHOWREFLECTFRAMES option to the StackWalker instance upon creation, so that the frames for the re\ufb02ective methods are printed as well package test import java.lang.StackWalker.Option import java.lang.StackWalker.StackFrame import java.lang.reflect.InvocationTargetException import java.lang.reflect.Method import java.util.List import java.util.stream.Collectors public class StackWalkerExample public static void mainString args throws NoSuchMethodException , SecurityException , IllegalAccessException , IllegalArgumentException , InvocationTargetException Method fooMethod FooHelper. class.getDeclaredMethod foo, Class?null fooMethod. invokenull, Object null class FooHelper protected static void foo GoalKicker.com Java Notes for Professionals", "841 BarHelper. bar class BarHelper protected static void bar show reflection methods List StackFrame stack StackWalker. getInstance Option.SHOWREFLECTFRAMES . walks - s.collectCollectors. toList forStackFrame frame stack System.out.printlnframe.getClassName frame.getLineNumber frame.getMethodName Output test.BarHelper 27 bar test.FooHelper 20 foo jdk.internal.reflect.NativeMethodAccessorImpl -2 invoke0 jdk.internal.reflect.NativeMethodAccessorImpl 62 invoke jdk.internal.reflect.DelegatingMethodAccessorImpl 43 invoke java.lang.reflect.Method 563 invoke test.StackWalkerExample 14 main Note that line numbers for some re\ufb02ection methods may not be available so StackFrame. getLineNumber may return negative values. GoalKicker.com Java Notes for Professionals 842Chapter 157 Sockets A socket is one end-point of a two-way communication link between two programs running on the network. Section 157.1 Read from socket String hostName args0 int portNumber Integer.parseInt args1 try Socket echoSocket new SockethostName, portNumber PrintWriter out new PrintWriter echoSocket. getOutputStream , true BufferedReader in new BufferedReader new InputStreamReader echoSocket. getInputStream BufferedReader stdIn new BufferedReader new InputStreamReader System.in Use the socket GoalKicker.com Java Notes for Professionals 843Chapter 158 Java Sockets Sockets are a low-level network interface that helps in creating a connection between two program mainly clients which may or may not be running on the same machine. Socket Programming is one of the most widely used networking concepts. Section 158.1 A simple TCP echo back server Our TCP echo back", "server will be a separate thread. Its simple as its a start. It will just echo back whatever you send it but in capitalised form. public class CAPECHOServer extends Thread This class implements server sockets. A server socket waits for requests to come in over the network only when it is allowed through the local firewall ServerSocket serverSocket public CAPECHOServer int port, int timeout try Create a new Server on specified port. serverSocket new ServerSocket port SoTimeout is basiacally the socket timeout. timeout is the time until socket timeout in milliseconds serverSocket. setSoTimeout timeout catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Override public void run try We want the server to continuously accept connections while!Thread.interrupted Close the server once done. serverSocket. close catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Now to accept connections. Lets update the run method. Override public void run while!Thread.interrupted try Log with the port number and machine ip Logger. getLogger this.getClass .getName.logLevel.INFO, Listening for Clients at 0 on 1 , new ObjectserverSocket. getLocalPort , InetAddress .getLocalHost .getHostAddress Socket client serverSocket. accept Accept client conncetion Now get DataInputStream and DataOutputStreams GoalKicker.com Java Notes for Professionals 844 DataInputStream istream new DataInputStream client.getInputStream From", "clients input stream DataOutputStream ostream new DataOutputStream client.getOutputStream Important Note The servers input is the clients output The clients input is the servers output Send a welcome message ostream. writeUTF Welcome! Close the connection istream. close ostream. close client. close catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Close the server once done try serverSocket. close catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Now if you can open telnet and try connecting Youll see a Welcome message. You must connect with the port you speci\ufb01ed and IP Adress. You should see a result similar to this Welcome! Connection to host lost. Well, the connection was lost because we terminated it. Sometimes we would have to program our own TCP client. In this case, we need a client to request input from the user and send it across the network, receive the capitalised input. If the server sends data \ufb01rst, then the client must read the data \ufb01rst. public class CAPECHOClient extends Thread Socket server Scanner key Scanner for input public CAPECHOClient String ip, int port try server new Socketip, port key new Scanner System.in catch IOException ex Logger. getLogger CAPECHOClient. class.getName.logLevel.SEVERE, null, ex Override GoalKicker.com Java", "Notes for Professionals 845 public void run DataInputStream istream null DataOutputStream ostream null try istream new DataInputStream server.getInputStream Familiar lines ostream new DataOutputStream server.getOutputStream System.out.printlnistream. readUTF Print what the server sends System.out.print String tosend key.nextLine ostream. writeUTF tosend Send whatever the user typed to the server System.out.printlnistream. readUTF Finally read what the server sends before exiting. catch IOException ex Logger. getLogger CAPECHOClient. class.getName.logLevel.SEVERE, null, ex finally try istream. close ostream. close server. close catch IOException ex Logger. getLogger CAPECHOClient. class.getName.logLevel.SEVERE, null, ex Now update the server ostream. writeUTF Welcome! String inString istream. readUTF Read what the user sent String outString inString. toUpperCase Change it to caps ostream. writeUTF outString Close the connection istream. close And now run the server and client, You should have an output similar to this Welcome! GoalKicker.com Java Notes for Professionals 846Chapter 159 FTP File Transfer Protocol Parameters Details host Either the host name or IP address of the FTP server port The FTP server port username The FTP server username password The FTP server password Section 159.1 Connecting and Logging Into a FTP Server To start using FTP with Java, you will need to create a new FTPClient and then connect and login to", "the server using .connectString server, int port and .loginString username, String password . import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply Import all the required resource for this project. public class FTPConnectAndLogin public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com Server can be either host name or IP address. int port 21 String user Username String pass Password FTPClient ftp new FTPClient ftp. connectserver, port ftp. loginuser, pass Now we have the basics done. But what if we have an error connecting to the server? Well want to know when something goes wrong and get the error message. Lets add some code to catch errors while connecting. try ftp. connectserver, port showServerReply ftp int replyCode ftp.getReplyCode if !FTPReply. isPositiveCompletion replyCode System.out.printInOperation failed. Server reply code replyCode return ftp. loginuser, pass catch Lets break down what we just did, step by step. showServerReply ftp This refers to a function we will be making in a later step. int replyCode ftp.getReplyCode GoalKicker.com Java Notes for Professionals 847This grabs the replyerror code from the server and stores it as an integer. if !FTPReply. isPositiveCompletion replyCode System.out.printInOperation failed. Server reply code replyCode return This checks the reply code", "to see if there was an error. If there was an error, it will simply print Operation failed. Server reply code followed by the error code. We also added a trycatch block which we will add to in the next step. Next, lets also create a function that checks ftp.login for errors. boolean success ftp.loginuser, pass showServerReply ftp if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER Lets break this block down too. boolean success ftp.loginuser, pass This will not just attempt to login to the FTP server, it will also store the result as a boolean. showServerReply ftp This will check if the server sent us any messages, but we will \ufb01rst need to create the function in the next step. if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER This statement will check if we logged in successfully if so, it will print LOGGED IN SERVER, otherwise it will print Failed to log into the server. This is our script so far import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply public class FTPConnectAndLogin public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com int port 21", "String user username String pass password FTPClient ftp new FTPClient try ftp. connectserver, port showServerReply ftp int replyCode ftpClient. getReplyCode if !FTPReply. isPositiveCompletion replyCode GoalKicker.com Java Notes for Professionals 848 System.out.printlnOperation failed. Server reply code replyCode return boolean success ftp.loginuser, pass showServerReply ftp if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER catch Now next lets create complete the Catch block in case we run into any errors with the whole process. catch IOException ex System.out.printlnOops! Something went wrong. ex.printStackTrace The completed catch block will now print Oops! Something went wrong. and the stacktrace if there is an error. Now our \ufb01nal step is to create the showServerReply we have been using for a while now. private static void showServerReply FTPClient ftp String replies ftp.getReplyStrings if replies ! null replies. length 0 for String aReply replies System.out.printlnSERVER aReply This function takes an FTPClient as a variable, and calls it ftp. After that it stores any server replies from the server in a string array. Next it checks if any messages were stored. If there is any, it prints each of them as SERVER reply. Now that we have that function done, this is the completed", "script import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply public class FTPConnectAndLogin private static void showServerReply FTPClient ftp String replies ftp.getReplyStrings if replies ! null replies. length 0 for String aReply replies System.out.printlnSERVER aReply public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com int port 21 String user username String pass password GoalKicker.com Java Notes for Professionals 849 FTPClient ftp new FTPClient try ftp. connectserver, port showServerReply ftp int replyCode ftpClient. getReplyCode if !FTPReply. isPositiveCompletion replyCode System.out.printlnOperation failed. Server reply code replyCode return boolean success ftp.loginuser, pass showServerReply ftp if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER catch IOException ex System.out.printlnOops! Something went wrong. ex. printStackTrace We \ufb01rst need to create a new FTPClient and try connecting to the server it and logging into it using .connectString server, int port and .loginString username, String password . It is important to connect and login using a trycatch block in case our code fails to connect with the server. We will also need to create a function that checks and displays any messages we may receive from the server as we try connecting and logging in. We will call this function showServerReply", "FTPClient ftp . import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply public class FTPConnectAndLogin private static void showServerReply FTPClient ftp if replies ! null replies. length 0 for String aReply replies System.out.printlnSERVER aReply public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com int port 21 String user username String pass password FTPClient ftp new FTPClient try ftp. connectserver, port showServerReply ftp int replyCode ftpClient. getReplyCode if !FTPReply. isPositiveCompletion replyCode System.out.printlnOperation failed. Server reply code replyCode return boolean success ftp.loginuser, pass showServerReply ftp GoalKicker.com Java Notes for Professionals 850 if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER catch IOException ex System.out.printlnOops! Something went wrong. ex. printStackTrace After this, you should now have your FTP server connected to you Java script. GoalKicker.com Java Notes for Professionals 851Chapter 160 Using Other Scripting Languages in Java Java in itself is an extremely powerful language, but its power can further be extended Thanks to JSR223 Java Speci\ufb01cation Request 223 introducing a script engine Section 160.1 Evaluating A JavaScript \ufb01le in -scripting mode of nashorn public class JSEngine Note Nashorn is only available for Java-8 onwards You can use rhino from ScriptEngineManager.getEngineByNamejs ScriptEngine engine ScriptContext context", "public Bindings scope Initialize the Engine from its factory in scripting mode public JSEngine engine new NashornScriptEngineFactory .getScriptEngine -scripting Script context is an interface so we need an implementation of it context new SimpleScriptContext Create bindings to expose variables into scope engine. createBindings Clear the bindings to remove the previous variables public void newBatch scope. clear public void execute String file try Get a buffered reader for input BufferedReader br new BufferedReader new FileReader file Evaluate code, with input as bufferdReader engine. evalbr catch FileNotFoundException ex Logger. getLogger JSEngine. class.getName.logLevel.SEVERE, null, ex catch ScriptException ex Script Exception is basically when there is an error in script Logger. getLogger JSEngine. class.getName.logLevel.SEVERE, null, ex public void evalString code try Engine.eval basically treats any string as a line of code and evaluates it, executes it engine. evalcode catch ScriptException ex Script Exception is basically when there is an error in script Logger. getLogger JSEngine. class.getName.logLevel.SEVERE, null, ex GoalKicker.com Java Notes for Professionals 852 Apply the bindings to the context and set the engines default context public void startBatch int SCP context. setBindings scope, SCP engine. setContext context We use the invocable interface to access methods from the script Invocable is an optional", "interface, please check if your engine implements it public Invocable invocable return Invocable engine Now the main method public static void mainString args JSEngine jse new JSEngine Create a new batch probably unecessary jse. newBatch Expose variable x into script with value of hello world jse. scope.putx, hello world Apply the bindings and start the batch jse. startBatch ScriptContext. ENGINESCOPE Evaluate the code jse. evalprintx Your output should be similar to this hello world As you can see the exposed variable x has been printed. Now testing with a \ufb01le. Here we have test.js printx function test print hello test.jstest test And the updated main method public static void mainString args JSEngine jse new JSEngine Create a new batch probably unecessary jse. newBatch Expose variable x into script with value of hello world jse. scope.putx, hello world Apply the bindings and start the batch jse. startBatch ScriptContext. ENGINESCOPE Evaluate the code jse. execute.test.js GoalKicker.com Java Notes for Professionals 853Assuming that test.js is in the same directory as your application You should have output similar to this hello world hello test.jstest GoalKicker.com Java Notes for Professionals 854Chapter 161 C Comparison Java and C are similar languages. This topic serves as", "a quick reference guide for Java and C Engineers. Section 161.1 Static Class Members Static members have class scope as opposed to object scope C Example define in header class Singleton public static Singleton getInstance private Singleton static Singleton instance initialize in .cpp Singleton Singleton instance 0 Java Example public class Singleton private static Singleton instance private Singleton public static Singleton getInstance ifinstance null instance new Singleton return instance Section 161.2 Classes De\ufb01ned within Other Constructs De\ufb01ned within Another Class C Nested Class ref needs a reference to enclosing class class Outer class Inner public Inner Outer o outero private Outer outer Java non-static Nested Class aka Inner Class or Member Class GoalKicker.com Java Notes for Professionals 855class OuterClass ... class InnerClass ... Statically De\ufb01ned within Another Class C Static Nested Class class Outer class Inner ... Java Static Nested Class aka Static Member Class ref class OuterClass ... static class StaticNestedClass ... De\ufb01ned within a Method e.g. event handling C Local Class ref void fun class Test members of Test class Java Local Class ref class Test void f new Threadnew Runnable public void run doSomethingBackgroundish .start GoalKicker.com Java Notes for Professionals 856Section 161.3 Pass-by-value Pass-by-reference Many argue", "that Java is ONLY pass-by-value, but its more nuanced than that. Compare the following C and Java examples to see the many \ufb02avors of pass-by-value aka copy and pass-by-reference aka alias. C Example complete code passes a COPY of the object static void passByCopy PassIt obj obj. i 22 only a local change passes a pointer static void passByPointer PassIt ptr ptr -i 33 ptr 0 better to use nullptr instead if 0 passes an alias aka reference static void passByAlias PassIt ref ref. i 44 This is an old-school way of doing it. Check out stdswap for the best way to do this static void swapPassIt pptr1, PassIt pptr2 PassIt tmp pptr1 pptr1 pptr2 pptr2 tmp Java Example complete code passes a copy of the variable NOTE in java only primitives are pass-by-copy public static void passByCopy int copy copy 33 only a local change No such thing as pointers in Java public static void passByPointerPassIt ptr ptr-i 33 ptr 0 better to use nullptr instead if 0 passes an alias aka reference public static void passByAlias PassIt ref ref. i 44 passes aliases aka references, but need to do manual, potentially expensive copies public static void swapPassIt", "ref1, PassIt ref2 PassIt tmp new PassItref1 ref1. copyref2 ref2. copytmp GoalKicker.com Java Notes for Professionals 857Section 161.4 Inheritance vs Composition C Java are both object-oriented languages, thus the following diagram applies to both. Section 161.5 Outcast Downcasting Beware of using downcasting - Downcasting is casting down the inheritance hierarchy from a base class to a subclass i.e. opposite of polymorphism. In general, use polymorphism overriding instead of instanceof downcasting. C Example explicit type case required Child pChild Child parent Java Example ifmySubClass instanceof SubClass SubClass mySubClass SubClass someBaseClass mySubClass. nonInheritedMethod Section 161.6 Abstract Methods Classes Abstract Method declared without an implementation C pure virtual method virtual void eatvoid 0 Java abstract method GoalKicker.com Java Notes for Professionals 858abstract void draw Abstract Class cannot be instantiated C cannot be instantiated has at least 1 pure virtual method class AB public virtual void f 0 Java cannot be instantiated can have non-abstract methods abstract class GraphicObject Interface no instance \ufb01elds C nothing comparable to Java Java very similar to abstract class, but 1 supports multiple inheritance 2 no instance \ufb01elds interface TestInterface GoalKicker.com Java Notes for Professionals 859Chapter 162 Audio Section 162.1 Play a MIDI \ufb01le MIDI \ufb01les can be", "played by using several classes from the javax.sound.midi package. A Sequencer performs playback of the MIDI \ufb01le, and many of its methods can be used to set playback controls such as loop count, tempo, track muting, and others. General playback of MIDI data can be done in this way import java.io.File import java.io.IOException import javax.sound.midi.InvalidMidiDataException import javax.sound.midi.MidiSystem import javax.sound.midi.MidiUnavailableException import javax.sound.midi.Sequence import javax.sound.midi.Sequencer public class MidiPlayback public static void mainString args try Sequencer sequencer MidiSystem .getSequencer Get the default Sequencer if sequencer null System.err.printlnSequencer device not supported return sequencer. open Open device Create sequence, the File must contain MIDI file data. Sequence sequence MidiSystem .getSequence new Fileargs0 sequencer. setSequence sequence load it into sequencer sequencer. start start the playback catch MidiUnavailableException InvalidMidiDataException IOException ex ex. printStackTrace To stop the playback use sequencer. stop Stop the playback A sequencer can be set to mute one or more of the sequences tracks during playback so none of the instruments in those speci\ufb01ed play. The following example sets the \ufb01rst track in the sequence to be muted import javax.sound.midi.Track ... Track track sequence. getTracks sequencer. setTrackMute track0 A sequencer can play a sequence repeatedly if the loop count is given. The following", "sets the sequencer to play a sequence four times and inde\ufb01nitely sequencer. setLoopCount 3 sequencer. setLoopCount Sequencer .LOOPCONTINUOUSLY The sequencer does not always have to play the sequence from the beginning, nor does it have to play the GoalKicker.com Java Notes for Professionals 860sequence until the end. It can start and end at any point by specifying the tick in the sequence to start and end at. It is also possible to specify manually which tick in the sequence the sequencer should play from sequencer. setLoopStartPoint 512 sequencer. setLoopEndPoint 32768 sequencer. setTickPosition 8192 Sequencers can also play a MIDI \ufb01le at a certain tempo, which can be controlled by specifying the tempo in beats per minute BPM or microseconds per quarter note MPQ. The factor at which the sequence is played can be adjusted as well. sequencer. setTempoInBPM 1250f sequencer. setTempoInMPQ 4750f sequencer. setTempoFactor 1.5f When you \ufb01nished using the Sequencer , remeber to close it sequencer. close Section 162.2 Play an Audio \ufb01le Looped Needed imports import javax.sound.sampled.AudioSystem import javax.sound.sampled.Clip This code will create a clip and play it continuously once started Clip clip AudioSystem .getClip clip.openAudioSystem .getAudioInputStream new URLfilename clip.start clip.loopClip.LOOPCONTINUOUSLY Get an Array with all supported", "\ufb01le types AudioFileFormat. Type audioFileTypes AudioSystem .getAudioFileTypes Section 162.3 Basic audio output The Hello Audio! of Java that plays a sound \ufb01le from local or internet storage looks as follows. It works for uncompressed .wav \ufb01les and should not be used for playing mp3 or compressed \ufb01les. import java.io. import java.net.URL import javax.sound.sampled. public class SoundClipTest Constructor public SoundClipTest try Open an audio input stream. File soundFile new FileusrsharesoundsalsaFrontCenter.wav you could also get the sound file with an URL AudioInputStream audioIn AudioSystem .getAudioInputStream soundFile AudioFormat format audioIn. getFormat GoalKicker.com Java Notes for Professionals 861 Get a sound clip resource. DataLine. Info info new DataLine. InfoClip.class, format Clip clip ClipAudioSystem .getLineinfo Open audio clip and load samples from the audio input stream. clip. openaudioIn clip. start catch UnsupportedAudioFileException e e. printStackTrace catch IOException e e. printStackTrace catch LineUnavailableException e e. printStackTrace public static void mainString args new SoundClipTest Section 162.4 Bare metal sound You can also go almost bare-metal when producing sound with java. This code will write raw binary data into the OS audio bu\ufb00er to generate sound. Its extremely important to understand the limitations and necessary calculations to generating sound like this. Since playback is basically instantaneous, calculations", "need to be performed at almost real-time. As such this method is unusable for more complicated sound-sampling. For such purposes using specialized tools is the better approach. The following method generates and directly outputs a rectangle-wave of a given frequency in a given volume for a given duration. public void rectangleWave byte volume, int hertz, int msecs final SourceDataLine dataLine 24 kHz x 8bit, single-channel, signed little endian AudioFormat AudioFormat af new AudioFormat 24000, 8, 1, true, false try dataLine AudioSystem .getSourceDataLine af dataLine. openaf, 10000 audio buffer size 10k samples catch LineUnavailableException e throw new RuntimeException e int waveHalf 24000 hertz samples for half a period byte buffer new bytewaveHalf 20 int samples msecs 24000 1000 24k samples sec 1000 mssec timems dataLine. start starts playback int sign 1 for int i 0 i samples i buffer. length for int j 0 j 20 j generate 10 waves into buffer sign -1 fill from the jth wave-half to the j1th wave-half with volume Arrays.fillbuffer, waveHalf j, waveHalf j1, byte volume sign dataLine. writebuffer, 0, buffer. length dataLine. drain forces buffer drain to hardware GoalKicker.com Java Notes for Professionals 862 dataLine. stop ends playback For a more di\ufb00erentiated way", "to generate di\ufb00erent soundwaves sinus calculations and possibly larger sample sizes are necessary. This results in signi\ufb01cantly more complex code and is accordingly omitted here. GoalKicker.com Java Notes for Professionals 863Chapter 163 Java Print Service The Java Print Service API provides functionalities to discover print services and send print requests for them. It includes extensible print attributes based on the standard attributes speci\ufb01ed in the Internet Printing Protocol IPP 1.1 from the IETF Speci\ufb01cation, RFC 2911 . Section 163.1 Building the Doc that will be printed Doc is an interface and the Java Print Service API provide a simple implementation called SimpleDoc . Every Doc instance is basically made of two aspects the print data content itself an E-mail, an image, a document etc the print data format, called DocFlavor MIME type Representation class. Before creating the Doc object, we need to load our document from somewhere. In the example, we will load an speci\ufb01c \ufb01le from the disk FileInputStream pdfFileInputStream new FileInputStream something.pdf So now, we have to choose a DocFlavor that matches our content. The DocFlavor class has a bunch of constants to represent the most usual types of data. Lets pick the INPUTSTREAM. PDF one DocFlavor", "pdfDocFlavor DocFlavor. INPUTSTREAM .PDF Now, we can create a new instance of SimpleDoc Doc doc new SimpleDoc pdfFileInputStream, pdfDocFlavor , null The doc object now can be sent to the print job request see Creating a print job from a print service. Section 163.2 Discovering the available print services To discovery all the available print services, we can use the PrintServiceLookup class. Lets see how import javax.print.PrintService import javax.print.PrintServiceLookup public class DiscoveringAvailablePrintServices public static void mainString args discoverPrintServices public static void discoverPrintServices PrintService allPrintServices PrintServiceLookup. lookupPrintServices null, null for Printservice printService allPrintServices System.out.printlnPrint service name printService. getName GoalKicker.com Java Notes for Professionals 864This program, when executed on a Windows environment, will print something like this Print service name Fax Print service name Microsoft Print to PDF Print service name Microsoft XPS Document Viewer Section 163.3 De\ufb01ning print request attributes Sometimes we need to determine some aspects of the print request. We will call them attribute . Are examples of print request attributes amount of copies 1, 2 etc, orientation portrait or landscape chromacity monochrome, color quality draft, normal, high sides one-sided, two-sided etc and so on... Before choosing one of them and which value each one will have, \ufb01rst", "we need to build a set of attributes PrintRequestAttributeSet pras new HashPrintRequestAttributeSet Now we can add them. Some examples are pras.addnew Copies5 pras.addMediaSize. ISOA4 pras.addOrientationRequested. PORTRAIT pras.addPrintQuality. NORMAL The pras object now can be sent to the print job request see Creating a print job from a print service. Section 163.4 Listening print job request status change For the most printing clients, is extremely useful to know if a print job has \ufb01nished or failed. The Java Print Service API provide some functionalities to get informed about these scenarios. All we have to do is provide an implementation for PrintJobListener interface and register this implementation at the print job. When the print job state changes, we will be noti\ufb01ed. We can do anything is needed, for example update a user interface, start another business process, record something in the database, or simply log it. In the example bellow, we will log every print job status change import javax.print.event.PrintJobEvent import javax.print.event.PrintJobListener public class LoggerPrintJobListener implements PrintJobListener GoalKicker.com Java Notes for Professionals 865 Your favorite Logger class goes here! private static final Logger LOG Logger. getLogger LoggerPrintJobListener. class public void printDataTransferCompleted PrintJobEvent pje LOG. infoPrint data transfer completed public void printJobCompleted", "PrintJobEvent pje LOG. infoPrint job completed public void printJobFailed PrintJobEvent pje LOG. infoPrint job failed public void printJobCanceled PrintJobEvent pje LOG. infoPrint job canceled public void printJobNoMoreEvents PrintJobEvent pje LOG. infoNo more events to the job public void printJobRequiresAttention PrintJobEvent pje LOG. infoPrint job requires attention O Finally, we can add our print job listener implementation on the print job before the print request itself, as follows DocPrintJob printJob printService. createPrintJob printJob. addPrintJobListener new LoggerPrintJobListener printJob. printdoc, pras The PrintJobEvent pje argument Notice that every method has a PrintJobEvent pje argument. We dont use it in this example for simplicity purposes, but you can use it to explore the status. For example pje.getPrintJob .getAttributes Will return a PrintJobAttributeSet object instance and you can run them in a for-each way. Another way to achieve the same goal Another option to achieve the same goal is extending the PrintJobAdapter class, as the name says, is an adapter for PrintJobListener . Implementing the interface we compulsorily have to implement all of them. The advantage of this way its we need to override only the methods we want. Lets see how it works import javax.print.event.PrintJobEvent import javax.print.event.PrintJobAdapter public class LoggerPrintJobAdapter extends PrintJobAdapter Your", "favorite Logger class goes here! GoalKicker.com Java Notes for Professionals 866 private static final Logger LOG Logger. getLogger LoggerPrintJobAdapter. class public void printJobCompleted PrintJobEvent pje LOG. infoPrint job completed public void printJobFailed PrintJobEvent pje LOG. infoPrint job failed Notice that we override only some speci\ufb01c methods. As the same way in the example implementing the interface PrintJobListener , we add the listener to the print job before sending it to print printJob. addPrintJobListener new LoggerPrintJobAdapter printJob. printdoc, pras Section 163.5 Discovering the default print service To discovery the default print service, we can use the PrintServiceLookup class. Lets see how import javax.print.PrintService import javax.print.PrintServiceLookup public class DiscoveringDefaultPrintService public static void mainString args discoverDefaultPrintService public static void discoverDefaultPrintService PrintService defaultPrintService PrintServiceLookup. lookupDefaultPrintService System.out.printlnDefault print service name defaultPrintService. getName Section 163.6 Creating a print job from a print service A print job is a request of printing something in a speci\ufb01c print service. It consists, basically, by the data that will be printed see Building the Doc that will be printed a set of attributes After picking-up the right print service instance, we can request the creation of a print job DocPrintJob printJob printService. createPrintJob The DocPrintJob interface provide us the", "print method printJob. printdoc, pras The doc argument is a Doc the data that will be printed. GoalKicker.com Java Notes for Professionals 867And the pras argument is a PrintRequestAttributeSet interface a set of PrintRequestAttribute . Are examples of print request attributes amount of copies 1, 2 etc, orientation portrait or landscape chromacity monochrome, color quality draft, normal, high sides one-sided, two-sided etc and so on... The print method may throw a PrintException . GoalKicker.com Java Notes for Professionals 868Chapter 164 CompletableFuture CompletableFuture is a class added to Java SE 8 which implements the Future interface from Java SE 5. In addition to supporting the Future interface it adds many methods that allow asynchronous callback when the future is completed. Section 164.1 Simple Example of CompletableFuture In the example below, the calculateShippingPrice method calculates shipping cost, which takes some processing time. In a real world example, this would e.g. be contacting another server which returns the price based on the weight of the product and the shipping method. By modeling this in an async way via CompletableFuture , we can continue di\ufb00erent work in the method i.e. calculating packaging costs. public static void mainString args int price 15 Lets keep", "it simple and work with whole number prices here int weightInGrams 900 calculateShippingPrice weightInGrams Here, we get the future . thenAccept shippingPrice - And then immediately work on it! This fluent style is very useful for keeping it concise System.out.printlnYour total price is price shippingPrice System.out.printlnPlease stand by. We are calculating your total price. public static CompletableFuture Integer calculateShippingPrice int weightInGrams return CompletableFuture. supplyAsync - supplyAsync is a factory method that turns a given SupplierU into a CompletableFutureU Lets just say each 200 grams is a new dollar on your shipping costs int shippingCosts weightInGrams 200 try Thread.sleep2000L Now lets simulate some waiting time... catchInterruptedException e We can safely ignore that return shippingCosts And send the costs back! GoalKicker.com Java Notes for Professionals 869Chapter 165 Runtime Commands Section 165.1 Adding shutdown hooks Sometimes you need a piece of code to execute when the program stops, such as releasing system resources that you open. You can make a thread run when the program stops with the addShutdownHook method Runtime.getRuntime .addShutdownHook new Thread - ImportantStuff. someImportantIOStream .close GoalKicker.com Java Notes for Professionals 870Chapter 166 Unit Testing Unit testing is an integral part of test-driven development, and an important feature for building", "any robust application. In Java, Unit testing is almost exclusively performed using external libraries and frameworks, most of which have their own documentation tag. This stub serves as a means of introducing the reader to the tools available, and their respective documentation. Section 166.1 What is Unit Testing? This is a bit of a primer. Its mostly put it in because documentation is forced to have an example, even if its intended as a stub article. If you already know unit-testing basics, feel free to skip forward to the remarks, where speci\ufb01c frameworks are mentioned. Unit testing is ensuring that a given module behaves as expected. In large-scale applications, ensuring the appropriate execution of modules in a vacuum is an integral part of ensuring application \ufb01delity. Consider the following trivial pseudo-example public class Example public static void main String args new Example Application-level test. public Example Consumer c new Consumer System.out.printlnVALUE c.getVal Your Module. class Consumer private Capitalizer c public Consumer c new Capitalizer public String getVal return c.getVal Another teams module. class Capitalizer private DataReader dr public Capitalizer dr new DataReader public String getVal return dr.readVal.toUpperCase Another teams module. class DataReader public String readVal GoalKicker.com Java Notes for", "Professionals 871 Refers to a file somewhere in your application deployment, or perhaps retrieved over a deployment-specific network. File f String s data ... Read data from f into s ... return s So this example is trivial DataReader gets the data from a \ufb01le, passes it to the Capitalizer , which converts all the characters to upper-case, which then gets passed to the Consumer . But the DataReader is heavily-linked to our application environment, so we defer testing of this chain until we are ready to deploy a test release. Now, assume, somewhere along the way in a release, for reasons unknown, the getVal method in Capitalizer changed from returning a toUpperCase String to a toLowerCase String Another teams module. class Capitalizer ... public String getVal return dr.readVal.toLowerCase Clearly, this breaks expected behavior. But, because of the arduous processes involved with execution of the DataReader , we wont notice this until our next test deployment. So daysweeksmonths go by with this bug sitting in our system, and then the product manager sees this, and instantly turns to you, the team leader associated with the Consumer . Why is this happening? What did you guys change? Obviously, youre clueless.", "You have no idea whats going on. You didnt change any code that should be touching this why is it suddenly broken? Eventually, after discussion between the teams and collaboration, the issue is traced, and the problem solved. But, it begs the question how could this have been prevented? There are two obvious things Tests need to be automated Our reliance upon manual testing let this bug go by unnoticed far too long. We need a way to automate the process under which bugs are introduced instantly . Not 5 weeks from now. Not 5 days from now. Not 5 minutes from now. Right now. You have to appreciate that, in this example, Ive expressed one very trivial bug that was introduced and unnoticed. In an industrial application, with dozens of modules constantly being updated, these can creep in all over the place. You \ufb01x something with one module, only to realize that the very behavior you \ufb01xed was relied upon in some manner elsewhere either internally or externally. Without rigorous validation, things will creep into the system. Its possible that, if neglected far enough, this will result in so much extra work trying to \ufb01x changes and then", "\ufb01xing those \ufb01xes, etc., that a product will actually increase in remaining work as e\ufb00ort is put into it. You do not want to be in this situation. Tests need to be \ufb01ne-grained The second problem noted in our above example is the amount of time it took to trace the bug. The product manager pinged you when the testers noticed it, you investigated and found that the Capitalizer was returning GoalKicker.com Java Notes for Professionals 872seemingly bad data, you pinged the Capitalizer team with your \ufb01ndings, they investigated, etc. etc. etc. The same point I made above about the quantity and di\ufb03culty of this trivial example hold here. Obviously anyone reasonably well-versed with Java could \ufb01nd the introduced problem quickly. But its often much, much more di\ufb03cult to trace and communicate issues. Maybe the Capitalizer team provided you a JAR with no source. Maybe theyre located on the other side of the world, and communication hours are very limited perhaps to e-mails that get sent once daily. It can result in bugs taking weeks or longer to trace and, again, there could be several of these for a given release. In order to mitigate against this, we want", "rigorous testing on as \ufb01ne a level as possible you also want coarse- grained testing to ensure modules interact properly, but thats not our focal point here. We want to rigorously specify how all outward-facing functionality at minimum operates, and tests for that functionality. Enter unit-testing Imagine if we had a test, speci\ufb01cally ensuring that the getVal method of Capitalizer returned a capitalized string for a given input string. Furthermore, imagine that test was run before we even committed any code. The bug introduced into the system that is, toUpperCase being replaced with toLowerCase would cause no issues because the bug would never be introduced into the system. We would catch it in a test, the developer would hopefully realize their mistake, and an alternative solution would be reached as to how to introduce their intended e\ufb00ect. Theres some omissions made here as to how to implement these tests, but those are covered in the framework- speci\ufb01c documentation linked in the remarks. Hopefully, this serves as an example of why unit testing is important. GoalKicker.com Java Notes for Professionals 873Chapter 167 Asserting Parameter Details expression1 The assertion statement throws an AssertionError if this expression evaluates to false . expression2", "Optional. When used, AssertionError s thrown by the assert statement have this message. Section 167.1 Checking arithmetic with assert a 1 - Math.abs1 - a 2 This will throw an error if my arithmetic above is wrong. assert a 0 a 1 Calculated value of a is outside of expected bounds return a GoalKicker.com Java Notes for Professionals 874Chapter 168 Multi-Release JAR Files One of the features introduced in Java 9 is the multi-release Jar MRJAR which allows bundling code targeting multiple Java releases within the same Jar \ufb01le. The feature is speci\ufb01ed in JEP 238 . Section 168.1 Example of a multi-release Jar \ufb01les contents By setting Multi-Release true in the MANIFEST.MF \ufb01le, the Jar \ufb01le becomes a multi-release Jar and the Java runtime as long as it supports the MRJAR format will pick the appropriate versions of classes depending on the current major version. The structure of such a Jar is the following jar root - A.class - B.class - C.class - D.class - META-INF - versions - 9 - A.class - B.class - 10 - A.class On JDKs 9, only the classes in the root entry are visible to the Java runtime. On a JDK 9,", "the classes A and B will be loaded from the directory rootMETA-INFversions 9, while C and D will be loaded from the base entry. On a JDK 10, class A would be loaded from the directory rootMETA-INFversions 10. Section 168.2 Creating a multi-release Jar using the jar tool The jar command can be used to create a multi-release Jar containing two versions of the same class compiled for both Java 8 and Java 9, albeit with a warning telling that the classes are identical CUsersmanouti jar --create --file MR. jar -C sampleproject -base demo --release 9 -C sampleproject -9 demo Warning entry META -INFversions 9demoSampleClass. class contains a class that is identical to an entry already in the jar The --release 9 option tells jar to include everything that follows the demo package inside the sampleproject -9 directory inside a versioned entry in the MRJAR, namely under rootMETA-INFversions 9. The result is the following contents jar root - demo - SampleClass. class - META-INF - versions - 9 - demo - SampleClass. class Let us now create a class called Main that prints the URL of the SampleClass , and add it for the Java 9 version GoalKicker.com Java", "Notes for Professionals 875package demo import java.net.URL public class Main public static void mainString args throws Exception URL url Main.class.getClassLoader .getResource demoSampleClass.class System.out.printlnurl If we compile this class and re-run the jar command, we get an error CUsersmanouti jar --create --file MR. jar -C sampleproject -base demo --release 9 -C sampleproject -9 demoentry META-INFversions 9demoMain.class, contains a new public class not found in base entries Warning entry META -INFversions 9demoMain.java, multiple resources with same name Warning entry META -INFversions 9demoSampleClass. class contains a class that is identical to an entry already in the jar invalid multi -release jar file MR. jar deleted The reason is that the jar tool prevents adding public classes to versioned entries if they are not added to the base entries as well. This is done so that the MRJAR exposes the same public API for the di\ufb00erent Java versions. Note that at runtime, this rule is not required. It may be only applied by tools like jar. In this particular case, the purpose of Main is to run sample code, so we can simply add a copy in the base entry. If the class were part of a newer implementation that we only need", "for Java 9, it could be made non-public. To add Main to the root entry, we \ufb01rst need to compile it to target a pre-Java 9 release. This can be done using the new --release option of javac CUsersmanoutisampleproject-basedemo javac --release 8 Main.java CUsersmanoutisampleproject-basedemo cd .... CUsersmanouti jar --create --file MR.jar -C sampleproject-base demo --release 9 -C sampleproject- 9 demo Running the Main class shows that the SampleClass gets loaded from the versioned directory CUsersmanouti java --class-path MR. jar demo.Main jarfileCUsersmanoutiMR.jar!META-INFversions 9demoSampleClass. class Section 168.3 URL of a loaded class inside a multi-release Jar Given the following multi-release Jar jar root - demo - SampleClass. class - META-INF - versions - 9 - demo - SampleClass. class The following class prints the URL of the SampleClass package demo GoalKicker.com Java Notes for Professionals 876import java.net.URL public class Main public static void mainString args throws Exception URL url Main.class.getClassLoader .getResource demoSampleClass.class System.out.printlnurl If the class is compiled and added on the versioned entry for Java 9 in the MRJAR, running it would result in CUsersmanouti java --class-path MR. jar demo.Main jarfileCUsersmanoutiMR.jar!META-INFversions 9demoSampleClass. class GoalKicker.com Java Notes for Professionals 877Chapter 169 Just in Time JIT compiler Section 169.1 Overview The Just-In-Time", "JIT compiler is a component of the Java Runtime Environment that improves the performance of Java applications at run time. Java programs consists of classes, which contain platform-neutral bytecodes that can be interpreted by a JVM on many di\ufb00erent computer architectures. At run time, the JVM loads the class \ufb01les, determines the semantics of each individual bytecode, and performs the appropriate computation. The additional processor and memory usage during interpretation means that a Java application performs more slowly than a native application. The JIT compiler helps improve the performance of Java programs by compiling bytecodes into native machine code at run time. GoalKicker.com Java Notes for Professionals 878The JIT compiler is enabled by default, and is activated when a Java method is called. The JIT compiler compiles the bytecodes of that method into native machine code, compiling it just in time to run. When a method has been compiled, the JVM calls the compiled code of that method directly instead of interpreting it. Theoretically, if compilation did not require processor time and memory usage, compiling every method could allow the speed of the Java program to approach that of a native application. JIT compilation does require processor time and", "memory usage. When the JVM \ufb01rst starts up, thousands of methods are called. Compiling all of these methods can signi\ufb01cantly a\ufb00ect startup time, even if the program eventually achieves very good peak performance. In practice, methods are not compiled the \ufb01rst time they are called. For each method, the JVM maintains a call count which is incremented every time the method is called. The JVM interprets a method until its call count exceeds a JIT compilation threshold. Therefore, often-used methods are compiled soon after the JVM has started, and less-used methods are compiled much later, or not at all. The JIT compilation threshold helps the JVM start quickly and still have improved performance. The threshold has been carefully selected to obtain an optimal balance between startup times and long term performance. After a method is compiled, its call count is reset to zero and subsequent calls to the method continue to increment its count. When the call count of a method reaches a JIT recompilation threshold, the JIT compiler compiles it a second time, applying a larger selection of optimizations than on the previous compilation. This process is repeated until the maximum optimization level is reached. The busiest methods", "of a Java program are always optimized most aggressively, maximizing the performance bene\ufb01ts of using the JIT compiler. The JIT compiler can also measure operational data at run time , and use that data to improve the quality of further recompilations. The JIT compiler can be disabled, in which case the entire Java program will be interpreted. Disabling the JIT compiler is not recommended except to diagnose or work around JIT compilation problems. GoalKicker.com Java Notes for Professionals 879Chapter 170 Bytecode Modi\ufb01cation Section 170.1 What is Bytecode? Bytecode is the set of instructions used by the JVM. To illustrate this lets take this Hello World program. public static void mainString args System.out.printlnHello World This is what it turns into when compiled into bytecode. public static mainLjavalangString argsV getstatic java langSystem out Ljava ioPrintStream ldc Hello World invokevirtual java ioPrintStream printLjavalangStringV Whats the logic behind this? getstatic - Retrieves the value of a static \ufb01eld of a class. In this case, the PrintStream Out of System . ldc - Push a constant onto the stack. In this case, the String Hello World invokevirtual - Invokes a method on a loaded reference on the stack and puts the result on the", "stack. Parameters of the method are also taken from the stack. Well, there has to be more right? There are 255 opcodes, but not all of them are implemented yet. A table with all of the current opcodes can be found here Java bytecode instruction listings . How can I write edit bytecode? Theres multiple ways to write and edit bytecode. You can use a compiler, use a library, or use a program. For writing Jasmin Krakatau For editing Libraries ASM Javassist BCEL - Doesnt support Java 8 Tools Bytecode-Viewer JBytedit reJ - Doesnt support Java 8 JBE - Doesnt support Java 8 Id like to learn more about bytecode! Theres probably a speci\ufb01c documentation page speci\ufb01cially for bytecode. This page focuses on the modi\ufb01cation of GoalKicker.com Java Notes for Professionals 880bytecode using di\ufb00erent libraries and tools. Section 170.2 How to edit jar \ufb01les with ASM Firstly the classes from the jar need to be loaded. Well use three methods for this process loadClassesFile readJarJarFile, JarEntry, Map getNodebyte MapString, ClassNode loadClasses File jarFile throws IOException MapString, ClassNode classes new HashMap String, ClassNode JarFile jar new JarFilejarFile Stream JarEntry str jar.stream str. forEachz - readJar jar, z, classes jar. close", "return classes MapString, ClassNode readJar JarFile jar, JarEntry entry, Map String, ClassNode classes String name entry.getName try InputStream jis jar.getInputStream entry if name.endsWith .class byte bytes IOUtils. toByteArray jis String cafebabe String.format02X02X02X02X , bytes0, bytes1, bytes2, bytes3 if !cafebabe. toLowerCase .equalscafebabe This class doesnt have a valid magic return classes try ClassNode cn getNode bytes classes. putcn.name, cn catch Exception e e. printStackTrace catch IOException e e. printStackTrace return classes ClassNode getNode byte bytes ClassReader cr new ClassReader bytes ClassNode cn new ClassNode try cr. acceptcn, ClassReader. EXPANDFRAMES catch Exception e e. printStackTrace cr null return cn With these methods loading and changing a jar \ufb01le becomes a simple matter of changing ClassNodes in a map. In this example we will replace all Strings in the jar with capitalized ones using the Tree API. File jarFile new Filesample.jar MapString, ClassNode nodes loadClasses jarFile GoalKicker.com Java Notes for Professionals 881 Iterate ClassNodes for ClassNode cn nodes.values Iterate methods in class for MethodNode mn cn.methods Iterate instructions in method for AbstractInsnNode ain mn.instructions .toArray If the instruction is loading a constant value if ain.getOpcode Opcodes. LDC Cast current instruction to Ldc If the constant is a string then capitalize it. LdcInsnNode", "ldc LdcInsnNode ain if ldc.cst instanceof String ldc. cst ldc.cst.toString .toUpperCase Now that all of the ClassNodes strings have been modi\ufb01ed we need to save the changes. In order to save the changes and have a working output a few things have to be done Export ClassNodes to bytes Load non-class jar entries Ex Manifest.mf other binary resources in jar as bytes Save all bytes to a new jar From the last portion above, well create three methods. processNodesMapString, ClassNode nodes loadNonClassesFile jarFile saveAsJarMapString, byte outBytes, String \ufb01leName Usage MapString, byte out process nodes, new HashMap String, MappedClass out.putAllloadNonClassEntries jarFile saveAsJar out, sample-edit.jar The methods used static MapString, byte processNodes MapString, ClassNode nodes, Map String, MappedClass mappings MapString, byte out new HashMap String, byte Iterate nodes and add them to the map of Class names , Class bytes Using ComputeFrames ensures that stack-frames will be re-calculated automatically for ClassNode cn nodes.values ClassWriter cw new ClassWriter ClassWriter. COMPUTEFRAMES out. putmappings. containsKey cn.name ? mappings. getcn.name.getNewName cn.name, cw.toByteArray return out static MapString, byte loadNonClasses File jarFile throws IOException MapString, byte entries new HashMap String, byte ZipInputStream jis new ZipInputStream new FileInputStream jarFile ZipEntry entry Iterate all entries while entry jis.getNextEntry !", "null GoalKicker.com Java Notes for Professionals 882 try String name entry.getName if !name.endsWith .class !entry.isDirectory Apache Commons - byte toByteArrayInputStream input Add each entry to the map Entry name , Entry bytes byte bytes IOUtils. toByteArray jis entries. putname, bytes catch Exception e e. printStackTrace finally jis. closeEntry jis. close return entries static void saveAsJar MapString, byte outBytes, String fileName try Create jar output stream JarOutputStream out new JarOutputStream new FileOutputStream fileName For each entry in the map, save the bytes for String entry outBytes. keySet Appent class names to class entries String ext entry.contains . ? .class out. putNextEntry new ZipEntry entry ext out. writeoutBytes. getentry out. closeEntry out. close catch IOException e e. printStackTrace Thats it. All the changes will be saved to sample-edit.jar. Section 170.3 How to load a ClassNode as a Class Load a class by from a ClassNode param cn ClassNode to load return public static Class? loadClassNode cn ClassWriter cw new ClassWriter ClassWriter. COMPUTEFRAMES return new ClassDefiner ClassLoader .getSystemClassLoader .getcn.name.replace, ., cw.toByteArray Classloader that loads a class from bytes. static class ClassDefiner extends ClassLoader public ClassDefiner ClassLoader parent superparent GoalKicker.com Java Notes for Professionals 883 public Class? getString name, byte bytes Class ?", "c defineClass name, bytes, 0, bytes. length resolveClass c return c Section 170.4 How to rename classes in a jar \ufb01le public static void mainString args throws Exception File jarFile new FileInput.jar MapString, ClassNode nodes JarUtils. loadClasses jarFile MapString, byte out JarUtils. loadNonClassEntries jarFile MapString, String mappings new HashMap String, String mappings. putmeexampleExampleClass , meexampleExampleRenamed out. putAllprocessnodes, mappings JarUtils. saveAsJar out, Input-new.jar static MapString, byte process MapString, ClassNode nodes, Map String, String mappings MapString, byte out new HashMap String, byte Remapper mapper new SimpleRemapper mappings for ClassNode cn nodes.values ClassWriter cw new ClassWriter ClassWriter. COMPUTEFRAMES ClassVisitor remapper new ClassRemapper cw, mapper cn. acceptremapper out. putmappings. containsKey cn.name ? mappings. getcn.name cn.name, cw.toByteArray return out SimpleRemapper is an existing class in the ASM library. However it only allows for class names to be changed. If you wish to rename \ufb01elds and methods you should create your own implemenation of the Remapper class. Section 170.5 Javassist Basic Javassist is a bytecode instrumentation library that allows you to modify bytecode injecting Java code that will be converted to bytecode by Javassist and added to the instrumented classmethod at runtime. Lets write the \ufb01rst transformer that actually take an hypothetical class com.my.to.be.instrumented.MyClass and", "add to the instructions of each method a log call. import java.lang.instrument.ClassFileTransformer import java.lang.instrument.IllegalClassFormatException import java.security.ProtectionDomain import javassist.ClassPool import javassist.CtClass import javassist.CtMethod public class DynamicTransformer implements ClassFileTransformer public byte transform ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte classfileBuffer throws IllegalClassFormatException byte byteCode classfileBuffer into the transformer will arrive every class loaded so we filter GoalKicker.com Java Notes for Professionals 884 to match only what we need if className. equalscommytobeinstrumentedMyClass try retrive default Javassist class pool ClassPool cp ClassPool. getDefault get from the class pool our class with this qualified name CtClass cc cp.getcom.my.to.be.instrumented.MyClass get all the methods of the retrieved class CtMethod methods cc.getDeclaredMethods forCtMethod meth methods The instrumentation code to be returned and injected final StringBuffer buffer new StringBuffer String name meth.getName just print into the buffer a log for example buffer. appendSystem.out.println Method name executed meth. insertBefore buffer.toString create the byteclode of the class byteCode cc.toBytecode remove the CtClass from the ClassPool cc. detach catch Exception ex ex. printStackTrace return byteCode Now in order to use this transformer so that our JVM will call the method transform on each class at load time we need to add this instrumentor this with an agent import java.lang.instrument.Instrumentation", "public class EasyAgent public static void premain String agentArgs, Instrumentation inst registers the transformer inst. addTransformer new DynamicTransformer Last step to start our \ufb01rst instrumentor experiment is to actually register this agent class to the JVM machine execution. The easiest way to actually do it is to register it with an option into the shell command java -javaagent myAgent. jar MyJavaApplication As we can see the agenttransformer project is added as a jar to the execution of any application named MyJavaApplication that is supposed to contain a class named com.my.to.be.instrumented.MyClass to actually execute our injected code. GoalKicker.com Java Notes for Professionals 885Chapter 171 Disassembling and Decompiling Name Description classes List of classes to disassemble. Can be in either package1. package2 .Classname format, or package1 package2 Classname format. Do not include the .class extension. -help , --help , -? Print this usage message -version Version information -v, -verbose Print additional information -l Print line number and local variable tables -public Show only public classes and members -protected Show protectedpublic classes and members -package Show packageprotectedpublic classes and members default -p, -private Show all classes and members -c Disassemble the code -s Print internal type signatures -sysinfo Show system info path,", "size, date, MD5 hash of class being processed -constants Show \ufb01nal constants -classpath path Specify where to \ufb01nd user class \ufb01les -cp path Specify where to \ufb01nd user class \ufb01les -bootclasspath pathOverride location of bootstrap class \ufb01les Section 171.1 Viewing bytecode with javap If you want to see the generated bytecode for a Java program, you can use the provided javap command to view it. Assuming that we have the following Java source \ufb01le package com.stackoverflow.documentation import org.springframework.stereotype.Service import java.io.IOException import java.io.InputStream import java.util.List Service public class HelloWorldService public void sayHello System.out.printlnHello, World! private Object pvtMethod ListString strings return new Objectstrings protected String tryCatchResources String filename throws IOException try InputStream inputStream getClass .getResourceAsStream filename byte bytes new byte8192 int read inputStream. readbytes return new Stringbytes, 0, read catch IOException RuntimeException e GoalKicker.com Java Notes for Professionals 886 e. printStackTrace throw e void stuff System.out.printlnstuff After compiling the source \ufb01le, the most simple usage is cd directory containing classes e.g. target classes javap com stackoverflow documentation SpringExample Which produces the output Compiled from HelloWorldService.java public class com.stackoverflow.documentation.HelloWorldService public com.stackoverflow.documentation.HelloWorldService public void sayHello protected java.lang.String tryCatchResourcesjava.lang.String throws java.io.IOException void stuff This lists all non-private methods in the class, but that is", "not particularly useful for most purposes. The following command is a lot more useful javap -p -c -s -constants -l -v comstackoverflow documentation HelloWorldService Which produces the output Classfile UserspivotalIdeaProjectsstackoverflow-spring- docstargetclassescomstackoverflowdocumentationHelloWorldService.class Last modified Jul 22, 2016 size 2167 bytes MD5 checksum 6e33b5c292ead21701906353b7f06330 Compiled from HelloWorldService.java public class com.stackoverflow.documentation.HelloWorldService minor version 0 major version 51 flags ACCPUBLIC, ACCSUPER Constant pool 1 Methodref 5.60 javalangObject.V 2 Fieldref 61.62 javalangSystem.outLjavaioPrintStream 3 String 63 Hello, World! 4 Methodref 64.65 javaioPrintStream.printlnLjavalangStringV 5 Class 66 javalangObject 6 Methodref 5.67 javalangObject.getClassLjavalangClass 7 Methodref 68.69 javalangClass.getResourceAsStreamLjavalangStringLjavaioInputStream 8 Methodref 70.71 javaioInputStream.readBI 9 Class 72 javalangString 10 Methodref 9.73 javalangString.BIIV 11 Methodref 70.74 javaioInputStream.closeV 12 Class 75 javalangThrowable 13 Methodref 12.76 javalangThrowable.addSuppressedLjavalangThrowableV 14 Class 77 javaioIOException 15 Class 78 javalangRuntimeException GoalKicker.com Java Notes for Professionals 88716 Methodref 79.80 javalangException.printStackTraceV 17 String 55 stuff 18 Class 81 comstackoverflowdocumentationHelloWorldService 19 Utf8 20 Utf8 V 21 Utf8 Code 22 Utf8 LineNumberTable 23 Utf8 LocalVariableTable 24 Utf8 this 25 Utf8 LcomstackoverflowdocumentationHelloWorldService 26 Utf8 sayHello 27 Utf8 pvtMethod 28 Utf8 LjavautilListLjavalangObject 29 Utf8 strings 30 Utf8 LjavautilList 31 Utf8 LocalVariableTypeTable 32 Utf8 LjavautilList 33 Utf8 Signature 34 Utf8 LjavautilListLjavalangObject 35 Utf8 tryCatchResources 36 Utf8 LjavalangStringLjavalangString 37 Utf8 bytes 38 Utf8 B 39 Utf8 read", "40 Utf8 I 41 Utf8 inputStream 42 Utf8 LjavaioInputStream 43 Utf8 e 44 Utf8 LjavalangException 45 Utf8 filename 46 Utf8 LjavalangString 47 Utf8 StackMapTable 48 Class 81 comstackoverflowdocumentationHelloWorldService 49 Class 72 javalangString 50 Class 82 javaioInputStream 51 Class 75 javalangThrowable 52 Class 38 B 53 Class 83 javalangException 54 Utf8 Exceptions 55 Utf8 stuff 56 Utf8 SourceFile 57 Utf8 HelloWorldService.java 58 Utf8 RuntimeVisibleAnnotations 59 Utf8 LorgspringframeworkstereotypeService 60 NameAndType 1920 V 61 Class 84 javalangSystem 62 NameAndType 8586 outLjavaioPrintStream 63 Utf8 Hello, World! 64 Class 87 javaioPrintStream 65 NameAndType 8889 printlnLjavalangStringV 66 Utf8 javalangObject 67 NameAndType 9091 getClassLjavalangClass 68 Class 92 javalangClass 69 NameAndType 9394 getResourceAsStreamLjavalangStringLjavaioInputStream 70 Class 82 javaioInputStream 71 NameAndType 3995 readBI 72 Utf8 javalangString 73 NameAndType 1996 BIIV 74 NameAndType 9720 closeV 75 Utf8 javalangThrowable 76 NameAndType 9899 addSuppressedLjavalangThrowableV 77 Utf8 javaioIOException 78 Utf8 javalangRuntimeException GoalKicker.com Java Notes for Professionals 88879 Class 83 javalangException 80 NameAndType 10020 printStackTraceV 81 Utf8 comstackoverflowdocumentationHelloWorldService 82 Utf8 javaioInputStream 83 Utf8 javalangException 84 Utf8 javalangSystem 85 Utf8 out 86 Utf8 LjavaioPrintStream 87 Utf8 javaioPrintStream 88 Utf8 println 89 Utf8 LjavalangStringV 90 Utf8 getClass 91 Utf8 LjavalangClass 92 Utf8 javalangClass 93 Utf8 getResourceAsStream 94 Utf8 LjavalangStringLjavaioInputStream 95 Utf8 BI 96 Utf8 BIIV 97", "Utf8 close 98 Utf8 addSuppressed 99 Utf8 LjavalangThrowableV 100 Utf8 printStackTrace public com.stackoverflow.documentation.HelloWorldService descriptor V flags ACCPUBLIC Code stack1, locals1, argssize1 0 aload0 1 invokespecial 1 Method javalangObject.V 4 return LineNumberTable line 10 0 LocalVariableTable Start Length Slot Name Signature 0 5 0 this LcomstackoverflowdocumentationHelloWorldService public void sayHello descriptor V flags ACCPUBLIC Code stack2, locals1, argssize1 0 getstatic 2 Field javalangSystem.outLjavaioPrintStream 3 ldc 3 String Hello, World! 5 invokevirtual 4 Method javaioPrintStream.printlnLjavalangStringV 8 return LineNumberTable line 13 0 line 14 8 LocalVariableTable Start Length Slot Name Signature 0 9 0 this LcomstackoverflowdocumentationHelloWorldService private java.lang.Object pvtMethodjava.util.List descriptor LjavautilListLjavalangObject flags ACCPRIVATE Code stack4, locals2, argssize2 0 iconst1 1 anewarray 5 class javalangObject 4 dup 5 iconst0 6 aload1 7 aastore GoalKicker.com Java Notes for Professionals 8898 areturn LineNumberTable line 17 0 LocalVariableTable Start Length Slot Name Signature 0 9 0 this LcomstackoverflowdocumentationHelloWorldService 0 9 1 strings LjavautilList LocalVariableTypeTable Start Length Slot Name Signature 0 9 1 strings LjavautilList Signature 34 LjavautilListLjavalangObject protected java.lang.String tryCatchResourcesjava.lang.String throws java.io.IOException descriptor LjavalangStringLjavalangString flags ACCPROTECTED Code stack5, locals10, argssize2 0 aload0 1 invokevirtual 6 Method javalangObject.getClassLjavalangClass 4 aload1 5 invokevirtual 7 Method javalangClass.getResourceAsStreamLjavalangStringLjavaioInputStream 8 astore2 9 aconstnull 10 astore3 11 sipush 8192 14 newarray byte 16", "astore 4 18 aload2 19 aload 4 21 invokevirtual 8 Method javaioInputStream.readBI 24 istore 5 26 new 9 class javalangString 29 dup 30 aload 4 32 iconst0 33 iload 5 35 invokespecial 10 Method javalangString.BIIV 38 astore 6 40 aload2 41 ifnull 70 44 aload3 45 ifnull 66 48 aload2 49 invokevirtual 11 Method javaioInputStream.closeV 52 goto 70 55 astore 7 57 aload3 58 aload 7 60 invokevirtual 13 Method javalangThrowable.addSuppressedLjavalangThrowableV 63 goto 70 66 aload2 67 invokevirtual 11 Method javaioInputStream.closeV 70 aload 6 72 areturn 73 astore 4 75 aload 4 77 astore3 78 aload 4 80 athrow 81 astore 8 83 aload2 84 ifnull 113 GoalKicker.com Java Notes for Professionals 89087 aload3 88 ifnull 109 91 aload2 92 invokevirtual 11 Method javaioInputStream.closeV 95 goto 113 98 astore 9 100 aload3 101 aload 9 103 invokevirtual 13 Method javalangThrowable.addSuppressedLjavalangThrowableV 106 goto 113 109 aload2 110 invokevirtual 11 Method javaioInputStream.closeV 113 aload 8 115 athrow 116 astore2 117 aload2 118 invokevirtual 16 Method javalangException.printStackTraceV 121 aload2 122 athrow Exception table from to target type 48 52 55 Class javalangThrowable 11 40 73 Class javalangThrowable 11 40 81 any 91 95 98 Class javalangThrowable 73 83 81 any 0 70", "116 Class javaioIOException 0 70 116 Class javalangRuntimeException 73 116 116 Class javaioIOException 73 116 116 Class javalangRuntimeException LineNumberTable line 21 0 line 22 11 line 23 18 line 24 26 line 25 40 line 21 73 line 25 81 line 26 117 line 27 121 LocalVariableTable Start Length Slot Name Signature 18 55 4 bytes B 26 47 5 read I 9 107 2 inputStream LjavaioInputStream 117 6 2 e LjavalangException 0 123 0 this LcomstackoverflowdocumentationHelloWorldService 0 123 1 filename LjavalangString StackMapTable numberofentries 9 frametype 255 fullframe offsetdelta 55 locals class comstackoverflowdocumentationHelloWorldService, class javalangString, class javaioInputStream, class javalangThrowable, class B, int, class javalangString stack class javalangThrowable frametype 10 same frametype 3 same frametype 255 fullframe offsetdelta 2 locals class comstackoverflowdocumentationHelloWorldService, class javalangString, class javaioInputStream, class javalangThrowable stack class javalangThrowable frametype 71 samelocals1stackitem stack class javalangThrowable GoalKicker.com Java Notes for Professionals 891frametype 255 fullframe offsetdelta 16 locals class comstackoverflowdocumentationHelloWorldService, class javalangString, class javaioInputStream, class javalangThrowable, top, top, top, top, class javalangThrowable stack class javalangThrowable frametype 10 same frametype 3 same frametype 255 fullframe offsetdelta 2 locals class comstackoverflowdocumentationHelloWorldService, class javalangString stack class javalangException Exceptions throws java.io.IOException void stuff descriptor V flags Code stack2, locals1, argssize1 0 getstatic 2 Field", "javalangSystem.outLjavaioPrintStream 3 ldc 17 String stuff 5 invokevirtual 4 Method javaioPrintStream.printlnLjavalangStringV 8 return LineNumberTable line 32 0 line 33 8 LocalVariableTable Start Length Slot Name Signature 0 9 0 this LcomstackoverflowdocumentationHelloWorldService SourceFile HelloWorldService.java RuntimeVisibleAnnotations 0 59 GoalKicker.com Java Notes for Professionals 892Chapter 172 JMX The JMX technology provides the tools for building distributed, Web-based, modular and dynamic solutions for managing and monitoring devices, applications, and service-driven networks. By design, this standard is suitable for adapting legacy systems, implementing new management and monitoring solutions, and plugging into those of the future. Section 172.1 Simple example with Platform MBean Server Lets say we have some server that registers new users and greets them with some message. And we want to monitor this server and change some of its parameters. First, we need an interface with our monitoring and control methods public interface UserCounterMBean long getSleepTime void setSleepTime long sleepTime int getUserCount void setUserCount int userCount String getGreetingString void setGreetingString String greetingString void stop And some simple implementation that will let us see how its working and how we a\ufb00ect it public class UserCounter implements UserCounterMBean, Runnable private AtomicLong sleepTime new AtomicLong 10000 private AtomicInteger userCount new AtomicInteger 0 private AtomicReference String", "greetingString new AtomicReference welcome private AtomicBoolean interrupted new AtomicBoolean false Override public long getSleepTime return sleepTime. get Override public void setSleepTime long sleepTime this.sleepTime .setsleepTime Override public int getUserCount return userCount. get Override public void setUserCount int userCount this.userCount .setuserCount GoalKicker.com Java Notes for Professionals 893 Override public String getGreetingString return greetingString. get Override public void setGreetingString String greetingString this.greetingString .setgreetingString Override public void stop this.interrupted .settrue Override public void run while !interrupted. get try System.out.printfUser d, sn , userCount. incrementAndGet , greetingString. get Thread.sleepsleepTime. get catch InterruptedException ignored For simple example with local or remote management, we need to register our MBean import javax.management.InstanceAlreadyExistsException import javax.management.MBeanRegistrationException import javax.management.MBeanServer import javax.management.MalformedObjectNameException import javax.management.NotCompliantMBeanException import javax.management.ObjectName import java.lang.management.ManagementFactory public class Main public static void mainString args throws MalformedObjectNameException, NotCompliantMBeanException, InstanceAlreadyExistsException, MBeanRegistrationException, InterruptedException final UserCounter userCounter new UserCounter final MBeanServer mBeanServer ManagementFactory. getPlatformMBeanServer final ObjectName objectName new ObjectName ServerManagertypeUserCounter mBeanServer. registerMBean userCounter, objectName final Thread thread new ThreaduserCounter thread. start thread. join After that we can run our application and connect to it via jConsole, which can be found in your JAVAHOME bin directory. First, we need to \ufb01nd our local java process with our application GoalKicker.com Java Notes for Professionals", "894 then switch to MBeans tab and \ufb01nd that MBean that we used in our Main class as an ObjectName in the example above its ServerManager . In Attributes section we can see out attributes. If you speci\ufb01ed get method only, attribute will be readable but not writeable. If you speci\ufb01ed both get and set methods, attribute would be readable and writeable. Speci\ufb01ed methods can be invoked in Operations section. GoalKicker.com Java Notes for Professionals 895 If you want to be able to use remote management, you will need additional JVM parameters, like -Dcom.sun.management .jmxremote true true by default -Dcom.sun.management .jmxremote .port36006 -Dcom.sun.management .jmxremote .authenticate false -Dcom.sun.management .jmxremote .sslfalse These parameters can be found in Chapter 2 of JMX guides . After that you will be able to connect to your application via jConsole remotely with jconsole host port or with specifying hostport or servicejmxrmijndirmihostNameportNumjmxrmi in jConsole GUI. Useful links JMX guides JMX Best practices GoalKicker.com Java Notes for Professionals 896Chapter 173 Java Virtual Machine JVM Section 173.1 These are the basics JVM is an abstract computing machine or Virtual machine that resides in your RAM. It has a platform- independent execution environment that interprets Java bytecode into native", "machine code. Javac is Java Compiler which compiles your Java code into Bytecode Java program will be running inside the JVM which is then mapped onto the underlying physical machine. It is one of programming tool in JDK. Byte code is platform-independent code which is run on every platform and Machine code is platform-speci\ufb01c code which is run in only speci\ufb01c platform such as windows or linux it depend on execution. Some of the components Class Loder - load the .class \ufb01le into RAM. Bytecode veri\ufb01er - check whether there are any access restriction violations in your code. Execution engine - convert the byte code into executable machine code. JITjust in time - JIT is part of JVM which used to improves the performance of JVM.It will dynamically compile or translate java bytecode into native machine code during execution time. Edited GoalKicker.com Java Notes for Professionals 897Chapter 174 XJC Parameter Details schema \ufb01le The xsd schema \ufb01le to convert to java XJC is a Java SE tool that compiles an XML schema \ufb01le into fully annotated Java classes. It is distributed within the JDK package and is located at binxjc path. Section 174.1 Generating Java code from simple XSD", "\ufb01le XSD schema schema.xsd The following xml schema xsd de\ufb01nes a list of users with attributes name and reputation . ?xml version1.0? xsschema version1.0 xmlnsxs httpwww.w3.org2001XMLSchema xmlnsns httpwww.stackoverflow.comusers elementFormDefault qualified targetNamespace httpwww.stackoverflow.comusers xselement nameusers typensUsers xscomplexType nameUsers xssequence xselement typensUser nameuser minOccurs 0 maxOccurs unbounded xssequence xscomplexType xscomplexType nameUser xsattribute namename userequired typexsstring xsattribute namereputation userequired xssimpleType xsrestriction basexsint xsminInclusive value1 xsrestriction xssimpleType xsattribute xscomplexType xsschema Using xjc This requires the path to the xjc tool JDK binaries to be in the OS path variable. The code generation can be started using xjc schema. xsd This will generate java \ufb01les in the working directory. Result \ufb01les There will be some additional comments, but basically the java \ufb01les generated look like this package com.stackoverflow.users GoalKicker.com Java Notes for Professionals 898import java.util.ArrayList import java.util.List import javax.xml.bind.annotation.XmlAccessType import javax.xml.bind.annotation.XmlAccessorType import javax.xml.bind.annotation.XmlType XmlAccessorType XmlAccessType. FIELD XmlType name Users, propOrder user public class Users protected ListUser user public ListUser getUser if user null user new ArrayList User return this.user package com.stackoverflow.users import javax.xml.bind.annotation.XmlAccessType import javax.xml.bind.annotation.XmlAccessorType import javax.xml.bind.annotation.XmlAttribute import javax.xml.bind.annotation.XmlType XmlAccessorType XmlAccessType. FIELD XmlType name User public class User XmlAttribute name name, required true protected String name XmlAttribute name reputation , required true protected int", "reputation public String getName return name public void setName String value this.name value public int getReputation return reputation public void setReputation int value this.reputation value package com.stackoverflow.users import javax.xml.bind.JAXBElement import javax.xml.bind.annotation.XmlElementDecl import javax.xml.bind.annotation.XmlRegistry import javax.xml.namespace.QName GoalKicker.com Java Notes for Professionals 899XmlRegistry public class ObjectFactory private final static QName UsersQNAME new QNamehttpwww.stackoverflow.comusers , users public ObjectFactory public Users createUsers return new Users public User createUser return new User XmlElementDecl namespace httpwww.stackoverflow.comusers , name users public JAXBElement Users createUsers Users value return new JAXBElement UsersUsersQNAME, Users. class, null, value package-info.java javax.xml.bind.annotation .XmlSchema namespace httpwww.stackoverflow.comusers , elementFormDefault javax.xml.bind.annotation .XmlNsForm .QUALIFIED package com.stackoverflow.users GoalKicker.com Java Notes for Professionals 900Chapter 175 JVM Flags Section 175.1 -XXaggressive -XXaggressive is a collection of con\ufb01gurations that make the JVM perform at a high speed and reach a stable state as soon as possible. To achieve this goal, the JVM uses more internal resources at startup however, it requires less adaptive optimization once the goal is reached. We recommend that you use this option for long-running, memory- intensive applications that work alone. Usage -XXaggressive param param Description optSchedules adaptive optimizations earlier and enables new optimizations, which are expected to be the default in future releases. memoryCon\ufb01gures the memory", "system for memory-intensive workloads and sets an expectation to enable large amounts of memory resources to ensure high throughput. JRockit JVM will also use large pages, if available. Section 175.2 -XXallocClearChunks This option allows you to clear a TLA for references and values at TLA allocation time and pre-fetch the next chunk. When an integer, a reference, or anything else is declared, it has a default value of 0 or null depending upon type. At the appropriate time, you will need to clear these references and values to free the memory on the heap so Java can use- or reuse- it. You can do either when the object is allocated or, by using this option, when you request a new TLA. Usage -XXallocClearChunks -XXallocClearChunks true false The above is a boolean option and is generally recommended on IA64 systems ultimately, its use depends upon the application. If you want to set the size of chunks cleared, combine this option with -XXallocClearChunkSize . If you use this \ufb02ag but do not specify a boolean value, the default is true . Section 175.3 -XXallocClearChunkSize When used with -XXallocClearChunkSize , this option sets the size of the chunks to be cleared. If", "this \ufb02ag is used but no value is speci\ufb01ed, the default is 512 bytes. Usage -XXallocClearChunks -XXallocClearChunkSize sizekKmMgG Section 175.4 -XXcallPro\ufb01ling This option enables the use of call pro\ufb01ling for code optimizations. Pro\ufb01ling records useful runtime statistics speci\ufb01c to the application and can in many cases increase performance because JVM can then act on those statistics. GoalKicker.com Java Notes for Professionals 901Note This option is supported with the JRockit JVM R27.3.0 and later version. It may become default in future versions. Usage java -XXcallProfiling myApp This option is disabled by default. You must enable it to use it. Section 175.5 -XXdisableFatSpin This option disables the fat lock spin code in Java, allowing threads that block trying to acquire a fat lock go to sleep directly. Objects in Java become a lock as soon as any thread enters a synchronized block on that object. All locks are held that is, stayed locked until released by the locking thread. If the lock is not going to be released very fast, it can be in\ufb02ated to a fat lock. Spinning occurs when a thread that wants a speci\ufb01c lock continuously checks that lock to see if it is still taken, spinning in", "a tight loop as it makes the check. Spinning against a fat lock is generally bene\ufb01cial although, in some instances, it can be expensive and might a\ufb00ect performance. -XXdisableFatSpin allows you to turn o\ufb00 spinning against a fat lock and eliminate the potential performance hit. Usage -XXdisableFatSpin Section 175.6 -XXdisableGCHeuristics This option disables the garbage collector strategy changes. Compaction heuristics and nursery size heuristics are not a\ufb00ected by this option. By default, the garbage collection heuristics are enabled. Usage -XXdisableFatSpin Section 175.7 -XXdumpSize This option causes a dump \ufb01le to be generated and allows you to specify the relative size of that \ufb01le that is, small, medium, or large. Usage -XXdumpsize size size Description none Does not generate a dump \ufb01le. smallOn Windows, a small dump \ufb01le is generated on Linux a full core dump is generated. A small dump only include the thread stacks including their traces and very little else. This was the default in the JRockit JVM 8.1 with service packs 1 and 2, as well as 7.0 with service pack 3 and higher. normalCauses a normal dump to be generated on all platforms. This dump \ufb01le includes all memory except the java heap. This is", "the default value for the JRockit JVM 1.4.2 and later. largeIncludes everything that is in memory, including the Java heap. This option makes -XXdumpSize equivalent to -XXdumpFullState . GoalKicker.com Java Notes for Professionals 902Section 175.8 -XXexitOnOutOfMemory This option makes JRockit JVM exit on the \ufb01rst occurrence of an out of memory error. It can be used if you prefer restarting an instance of JRockit JVM rather than handling out of memory errors. Enter this command at startup to force JRockit JVM to exit on the \ufb01rst occurrence of an out of memory error. Usage -XXexitOnOutOfMemory GoalKicker.com Java Notes for Professionals 903Chapter 176 JVM Tool Interface Section 176.1 Iterate over objects reachable from object Heap 1.0 include vector include string include agentutil.hpp this file can be found in Java SE Development Kit 8u101 Demos and Samples see httpdownload.oracle.comotn-pubjavajdk8u101-b13-demosjdk-8u101-windows-x64-demos.zip jdk1.8.0101.zip!demojvmtiversionChecksrcagentutil.h Struct used for jvmti-SetTagobject, pointer to tag httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlSetTag typedef struct Tag jlong referrertag jlong size char classSignature jint hashCode Tag Utility function jlong - Tag static Tag pointerToTag jlong tagptr if tagptr 0 return new Tag return Tagptrdifft voidtagptr Utility function Tag - jlong static jlong tagToPointer Tag tag return jlongptrdifft voidtag Heap 1.0 Callback httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmljvmtiObjectReferenceCallback static jvmtiIterationControl JNICALL heabObjectReferencesCallback jvmtiObjectReferenceKind", "referencekind, jlong classtag, jlong size, jlong tagptr, jlong referrertag, jint referrerindex, void userdata GoalKicker.com Java Notes for Professionals 904 iterate only over reference field if referencekind ! JVMTIHEAPREFERENCEFIELD return JVMTIITERATIONIGNORE auto tagptrlist stdvectorjlongptrdifft voiduserdata create and assign tag auto t pointerToTag tagptr t-referrertag referrertag t-size size tagptr tagToPointer t collect tag tagptrlist .pushback tagptr return JVMTIITERATIONCONTINUE Main function for demonstration of Iterate Over Objects Reachable From Object httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlIterateOverObjectsReachableFromObject void iterateOverObjectHeapReferences jvmtiEnv jvmti, JNIEnv env, jobject object stdvectorjlong tagptrlist auto t new Tag jvmti -SetTagobject, tagToPointer t tagptrlist. pushback tagToPointer t stdoutmessage tag list size before call callback d n, tagptrlist. size Call Callback for every reachable object reference see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlIterateOverObjectsReachableFromObject jvmti -IterateOverObjectsReachableFromObject object, heabObjectReferencesCallback, voidtagptrlist stdoutmessage tag list size after call callback d n, tagptrlist. size if tagptrlist. size 0 jint foundcount 0 jlong tags tagptrlist 0 jobject foundobjects jlong foundtags collect all tagged object via tagptr pointer to tag see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlGetObjectsWithTags jvmti -GetObjectsWithTags tagptrlist. size, tags, foundcount, foundobjects, foundtags stdoutmessage found d objects n, foundcount for auto i 0 i foundcount i jobject foundobject foundobjects i char classSignature jclass foundobjectclass env-GetObjectClass foundobject GoalKicker.com Java Notes for Professionals 905 Get string representation of foundobjectclass see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlGetClassSignature jvmti -GetClassSignature foundobjectclass,", "classSignature, nullptr jint hashCode Getting hash code for foundobject see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlGetObjectHashCode jvmti -GetObjectHashCode foundobject, hashCode save all it in Tag Tag t pointerToTag foundtags i t -classSignature classSignature t -hashCode hashCode print all saved information for auto i 0 i foundcount i auto t pointerToTag foundtags i auto rt pointerToTag t-referrertag if t-referrertag ! 0 stdoutmessage referrer object sd -- object sd size 2d n, rt -classSignature, rt -hashCode, t -classSignature, t -hashCode, t -size Section 176.2 Get JVMTI environment Inside AgentOnLoad method jvmtiEnv jvmti Get JVMTI environment vm-GetEnvreinterpretcast void jvmti, JVMTIVERSION Section 176.3 Example of initialization inside of AgentOnLoad method Callback for JVMTIEVENTVMINIT static void JNICALL vminit jvmtiEnv jvmti, JNIEnv env, jthread thread jint runtimeversion jvmti -GetVersionNumber runtimeversion stdoutmessage JVMTI Version d n, runtimeverision AgentOnLoad is called first, we prepare for a VMINIT event here. JNIEXPORT jint JNICALL AgentOnLoad JavaVM vm, char options, void reserved jint rc jvmtiEventCallbacks callbacks GoalKicker.com Java Notes for Professionals 906 jvmtiCapabilities capabilities jvmtiEnv jvmti Get JVMTI environment rc vm-GetEnvreinterpretcast void jvmti, JVMTIVERSION if rc ! JNIOK return -1 Immediately after getting the jvmtiEnv we need to ask for the capabilities this agent will need. jvmti -GetCapabilities capabilities capabilities. cantagobjects 1 jvmti -AddCapabilities capabilities", "Set callbacks and enable event notifications memset callbacks, 0, sizeof callbacks callbacks. VMInit vminit jvmti -SetEventCallbacks callbacks, sizeof callbacks jvmti -SetEventNotificationMode JVMTIENABLE, JVMTIEVENTVMINIT, nullptr return JNIOK GoalKicker.com Java Notes for Professionals 907Chapter 177 Java Memory Management Section 177.1 Setting the Heap, PermGen and Stack sizes When a Java virtual machine starts, it needs to know how big to make the Heap, and the default size for thread stacks. These can be speci\ufb01ed using command-line options on the java command. For versions of Java prior to Java 8, you can also specify the size of the PermGen region of the Heap. Note that PermGen was removed in Java 8, and if you attempt to set the PermGen size the option will be ignored with a warning message. If you dont specify Heap and Stack sizes explicitly, the JVM will use defaults that are calculated in a version and platform speci\ufb01c way. This may result in your application using too little or too much memory. This is typically OK for thread stacks, but it can be problematic for a program that uses a lot of memory. Setting the Heap, PermGen and default Stack sizes The following JVM options set the heap", "size -Xmssize - sets the initial heap size -Xmxsize - sets the maximum heap size -XXPermSize size - sets the initial PermGen size -XXMaxPermSize size - sets the maximum PermGen size -Xsssize - sets the default thread stack size The size parameter can be a number of bytes, or can have a su\ufb03x of k, m or g. The latter specify the size in kilobytes, megabytes and gigabytes respectively. Examples java -Xms512m -Xmx1024m JavaApp java -XXPermSize 64m -XXMaxPermSize 128m JavaApp java -Xss512k JavaApp Finding the default sizes The -XXprintFlagsFinal option can be used to print the values of all \ufb02ags before starting the JVM. This can be used to print the defaults for the heap and stack size settings as follows For Linux, Unix, Solaris and Mac OSX java -XXPrintFlagsFinal -version grep -iE HeapSizePermSizeThreadStackSize For Windows java -XXPrintFlagsFinal -version \ufb01ndstr i HeapSize PermSize ThreadStackSize The output of the above commands will resemble the following GoalKicker.com Java Notes for Professionals 908uintx InitialHeapSize 20655360 product uintx MaxHeapSize 331350016 product uintx PermSize 21757952 pd product uintx MaxPermSize 85983232 pd product intx ThreadStackSize 1024 pd product The sizes are given in bytes. Section 177.2 Garbage collection The C approach - new and delete", "In a language like C, the application program is responsible for managing the memory used by dynamically allocated memory. When an object is created in the C heap using the new operator, there needs to be a corresponding use of the delete operator to dispose of the object If program forgets to delete an object and just forgets about it, the associated memory is lost to the application. The term for this situation is a memory leak , and it too much memory leaks an application is liable to use more and more memory, and eventually crash. On the other hand, if an application attempts to delete the same object twice, or use an object after it has been deleted, then the application is liable to crash due to problems with memory corruption In a complicated C program, implementing memory management using new and delete can be time consuming. Indeed, memory management is a common source of bugs. The Java approach - garbage collection Java takes a di\ufb00erent approach. Instead of an explicit delete operator, Java provides an automatic mechanism known as garbage collection to reclaim the memory used by objects that are no longer needed. The Java runtime", "system takes responsibility for \ufb01nding the objects to be disposed of. This task is performed by a component called a garbage collector , or GC for short. At any time during the execution of a Java program, we can divide the set of all existing objects into two distinct subsets1 Reachable objects are de\ufb01ned by the JLS as follows A reachable object is any object that can be accessed in any potential continuing computation from any live thread. In practice, this means that there is a chain of references starting from an in-scope local variable or a static variable by which some code might be able to reach the object. Unreachable objects are objects that cannot possibly be reached as above. Any objects that are unreachable are eligible for garbage collection. This does not mean that they will be garbage collected. In fact An unreachable object does not get collected immediately on becoming unreachable1. An unreachable object may not ever be garbage collected. GoalKicker.com Java Notes for Professionals 909The Java language Speci\ufb01cation gives a lot of latitude to a JVM implementation to decide when to collect unreachable objects. It also in practice gives permission for a JVM implementation to", "be conservative in how it detects unreachable objects. The one thing that the JLS guarantees is that no reachable objects will ever be garbage collected. What happens when an object becomes unreachable First of all, nothing speci\ufb01cally happens when an object becomes unreachable. Things only happen when the garbage collector runs and it detects that the object is unreachable. Furthermore, it is common for a GC run to not detect all unreachable objects. When the GC detects an unreachable object, the following events can occur. If there are any Reference objects that refer to the object, those references will be cleared before the object 1. is deleted. If the object is \ufb01nalizable , then it will be \ufb01nalized. This happens before the object is deleted. 2. The object can be deleted, and the memory it occupies can be reclaimed.3. Note that there is a clear sequence in which the above events can occur, but nothing requires the garbage collector to perform the \ufb01nal deletion of any speci\ufb01c object in any speci\ufb01c time-frame. Examples of reachable and unreachable objects Consider the following example classes A node in simple open linked-list. public class Node private static int counter 0 public int", "nodeNumber counter public Node next public class ListTest public static void mainString args test M1 System.out.prinlnDone M2 private static void test Node n1 new Node T1 Node n2 new Node T2 Node n3 new Node T3 n1. next n2 T4 n2 null T5 n3 null T6 Let us examine what happens when test is called. Statements T1, T2 and T3 create Node objects, and the objects are all reachable via the n1, n2 and n3 variables respectively. Statement T4 assigns the reference to the 2nd Node object to the next \ufb01eld of the \ufb01rst one. When that is done, the 2nd Node is reachable via two paths n2 - Node2 GoalKicker.com Java Notes for Professionals 910 n1 - Node1, Node1. next - Node2 In statement T5, we assign null to n2. This breaks the \ufb01rst of the reachability chains for Node2 , but the second one remains unbroken, so Node2 is still reachable. In statement T6, we assign null to n3. This breaks the only reachability chain for Node3 , which makes Node3 unreachable. However, Node1 and Node2 are both still reachable via the n1 variable. Finally, when the test method returns, its local variables n1, n2 and n3", "go out of scope, and therefore cannot be accessed by anything. This breaks the remaining reachability chains for Node1 and Node2 , and all of the Node objects are nor unreachable and eligible for garbage collection. 1 - This is a simpli\ufb01cation that ignores \ufb01nalization, and Reference classes. 2 - Hypothetically, a Java implementation could do this, but the performance cost of doing this makes it impractical. Section 177.3 Memory leaks in Java In the Garbage collection example, we implied that Java solves the problem of memory leaks. This is not actually true. A Java program can leak memory, though the causes of the leaks are rather di\ufb00erent. Reachable objects can leak Consider the following naive stack implementation. public class NaiveStack private Object stack new Object100 private int top 0 public void pushObject obj if top stack.length throw new StackException stack overflow stack top obj public Object pop if top 0 throw new StackException stack underflow return stack--top public boolean isEmpty return top 0 When you push an object and then immediately pop it, there will still be a reference to the object in the stack array. The logic of the stack implementation means that that reference cannot be", "returned to a client of the API. If an object has been popped then we can prove that it cannot be accessed in any potential continuing computation from any live thread . The problem is that a current generation JVM cannot prove this. Current generation JVMs do not consider the logic of the program in determining whether references are reachable. For a start, it is not practical. But setting aside the issue of what reachability really means, we clearly have a situation here where the NaiveStack implementation is hanging onto objects that ought to be reclaimed. That is a memory leak. GoalKicker.com Java Notes for Professionals 911In this case, the solution is straightforward public Object pop if top 0 throw new StackException stack underflow Object popped stack--top stack top null Overwrite popped reference with null. return popped Caches can be memory leaks A common strategy for improving service performance is to cache results. The idea is that you keep a record of common requests and their results in an in-memory data structure known as a cache. Then, each time a request is made, you lookup the request in the cache. If the lookup succeeds, you return the corresponding saved", "results. This strategy can be very e\ufb00ective if implemented properly. However, if implemented incorrectly, a cache can be a memory leak. Consider the following example public class RequestHandler private MapTask, Result cache new HashMap public Result doRequest Task task Result result cache.gettask if result null result doRequestProcessing task cache. puttask, result return result The problem with this code is that while any call to doRequest could add a new entry to the cache, there is nothing to remove them. If the service is continually getting di\ufb00erent tasks, then the cache will eventually consume all available memory. This is a form of memory leak. One approach to solving this is to use a cache with a maximum size, and throw out old entries when the cache exceeds the maximum. Throwing out the least recently used entry is a good strategy. Another approach is to build the cache using WeakHashMap so that the JVM can evict cache entries if the heap starts getting too full. Section 177.4 Finalization A Java object may declare a finalize method. This method is called just before Java releases the memory for the object. It will typically look like this public class MyClass Methods for the", "class Override protected void finalize throws Throwable Cleanup code However, there some important caveats on the behavior of Java \ufb01nalization. GoalKicker.com Java Notes for Professionals 912Java makes no guarantees about when a finalize method will called. Java does not even guarantee that a finalize method will be called some time during the running applications lifetime. The only thing that is guaranteed is that the method will be called before the object is deleted ... if the object is deleted. The caveats above mean that it is a bad idea to rely on the finalize method to perform cleanup or other actions that must be performed in a timely fashion. Over reliance on \ufb01nalization can lead to storage leaks, memory leaks and other problems. In short, there are very few situation where \ufb01nalization is actually a good solution. Finalizers only run once Normally, an object is deleted after it has been \ufb01nalized. However, this doesnt happen all of the time. Consider the following example1 public class CaptainJack public static CaptainJack notDeadYet null protected void finalize Resurrection! notDeadYet this When an instance of CaptainJack becomes unreachable and the garbage collector attempts to reclaim it, the finalize method will assign a reference", "to the instance to the notDeadYet variable. That will make the instance reachable once more, and the garbage collector wont delete it. Question Is Captain Jack immortal? Answer No. The catch is the JVM will only run a \ufb01nalizer on an object once in its lifetime. If you assign null to notDeadYet causing a resurected instance to be unreachable once more, the garbage collector wont call finalize on the object. 1 - See httpsen.wikipedia.orgwikiJackHarkness . Section 177.5 Manually triggering GC You can manually trigger the Garbage Collector by calling System.gc However, Java does not guarantee that the Garbage Collector has run when the call returns. This method simply suggests to the JVM Java Virtual Machine that you want it to run the garbage collector, but does not force it to do so. It is generally considered a bad practice to attempt to manually trigger garbage collection. The JVM can be run with the -XXDisableExplicitGC option to disable calls to System.gc. Triggering garbage collection by calling System.gc can disrupt normal garbage management object promotion activities of the speci\ufb01c garbage collector implementation in use by the JVM. GoalKicker.com Java Notes for Professionals 913Chapter 178 Java Performance Tuning Section 178.1 An evidence-based", "approach to Java performance tuning Donald Knuth is often quoted as saying this Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at e\ufb03ciency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small e\ufb03ciencies, say about 97 of the time premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3. source Bearing that sage advice in mind, here is the recommended procedure for optimizing programs First of all, design and code your program or library with a focus on simplicity and correctness. To start with,1. dont spend much e\ufb00ort on performance. Get it to a working state, and ideally develop unit tests for the key parts of the codebase.2. Develop an application level performance benchmark. The benchmark should cover the performance critical3. aspects of your application, and should perform a range of tasks that are typical of how the application will be used in production. Measure the performance.4. Compare the measured performance against your criteria for how fast the application needs to be. Avoid5. unrealistic, unattainable or unquanti\ufb01able", "criteria such as as fast as possible. If you have met the criteria, STOP. You job is done. Any further e\ufb00ort is probably a waste of time.6. Pro\ufb01le the application while it is running your performance benchmark.7. Examine the pro\ufb01ling results and pick the biggest unoptimized performance hotspots i.e. sections of the8. code where the application seems to be spending the most time. Analyse the hotspot code section to try to understand why it is a bottleneck, and think of a way to make it9. faster. Implement that as a proposed code change, test and debug. 10. Rerun the benchmark to see if the code change has improved the performance 11. If Yes, then return to step 4. If No, then abandon the change and return to step 9. If you are making no progress, pick a di\ufb00erent hotspot for your attention. Eventually you will get to a point where the application is either fast enough, or you have considered all of the signi\ufb01cant hotspots. At this point you need to stop this approach. If a section of code is consuming say 1 of the overall time, then even a 50 improvement is only going to make the application", "0.5 faster overall. Clearly, there is a point beyond which hotspot optimization is a waste of e\ufb00ort. If you get to that point, you need to GoalKicker.com Java Notes for Professionals 914take a more radical approach. For example Look at the algorithmic complexity of your core algorithms. If the application is spending a lot of time garbage collection, look for ways to reduce the rate of object creation. If key parts of the application are CPU intensive and single-threaded, look for opportunities for parallelism. If the application is already multi-threaded, look for concurrency bottlenecks. But wherever possible, rely on tools and measurement rather than instinct to direct your optimization e\ufb00ort. Section 178.2 Reducing amount of Strings In Java, its too easy to create many String instances which are not needed. That and other reasons might cause your program to have lots of Strings that the GC is busy cleaning up. Some ways you might be creating String instances myString foo Or worse, in a loop or recursion for int i 0 i N i myString foo i The problem is that each creates a new String usually, since new compilers optimize some cases. A possible optimization can be made", "using StringBuilder or StringBuffer StringBuffer sb new StringBuffer myString for int i 0 i N i sb.appendfoo.appendi myString sb.toString If you build long Strings often SQLs for example, use a String building API. Other things to consider Reduce usage of replace , substring etc. Avoid String.toArray, especially in frequently accessed code. Log prints which are destined to be \ufb01ltered due to log level for example should not be generated log level should be checked in advance. Use libraries like this if necessary. StringBuilder is better if the variable is used in a non-shared manner across threads. Section 178.3 General approach The internet is packed with tips for performance improvement of Java programs. Perhaps the number one tip is awareness. That means Identify possible performance problems and bottlenecks. Use analyzing and testing tools. Know good practices and bad practices. GoalKicker.com Java Notes for Professionals 915The \ufb01rst point should be done during the design stage if speaking about a new system or module. If speaking about legacy code, analyzing and testing tools come into the picture. The most basic tool for analyzing your JVM performance is JVisualVM, which is included in the JDK. The third point is mostly about experience and", "extensive research, and of course raw tips that will show up on this page and others, like this. GoalKicker.com Java Notes for Professionals 916Chapter 179 Benchmarks Writing performance benchmarks in java is not as simple as getting System.currentTimeMillis in the beginning and in the end and calculating the di\ufb00erence. To write valid performance benchmarks, one should use proper tools. Section 179.1 Simple JMH example One of the tools for writing proper benchmark tests is JMH. Lets say we want to compare performance of searching an element in HashSet vs TreeSet . The easiest way to get JHM into your project - is to use maven and shade plugin. Also you can see pom.xml from JHM examples . build plugins plugin groupId org.apache.maven.plugins groupId artifactId maven-shade-plugin artifactId version 3.0.0version executions execution phasepackagephase goals goalshadegoal goals configuration finalName benchmarks finalName transformers transformer implementation org.apache.maven.plugins.shade.resource.ManifestResourceTransformer mainClass org.openjdk.jmh.Main mainClass transformer transformers filters filter artifact artifact excludes exclude META-INF.SF exclude exclude META-INF.DSA exclude exclude META-INF.RSA exclude excludes filter filters configuration execution executions plugin plugins build dependencies dependency groupId org.openjdk.jmh groupId artifactId jmh-core artifactId version 1.18version dependency dependency groupId org.openjdk.jmh groupId GoalKicker.com Java Notes for Professionals 917 artifactId jmh-generator-annprocess artifactId version 1.18version dependency dependencies After", "this you need to write benchmark class itself package benchmark import org.openjdk.jmh.annotations. import org.openjdk.jmh.infra.Blackhole import java.util.HashSet import java.util.Random import java.util.Set import java.util.TreeSet import java.util.concurrent.TimeUnit StateScope.Thread public class CollectionFinderBenchmarkTest private static final int SETSIZE 10000 private SetString hashSet private SetString treeSet private String stringToFind 8888 Setup public void setupCollections hashSet new HashSet SETSIZE treeSet new TreeSet for int i 0 i SETSIZE i final String value String.valueOfi hashSet. addvalue treeSet. addvalue stringToFind String.valueOfnew Random.nextIntSETSIZE Benchmark BenchmarkMode Mode.AverageTime OutputTimeUnit TimeUnit. NANOSECONDS public void testHashSet Blackhole blackhole blackhole. consumehashSet. contains stringToFind Benchmark BenchmarkMode Mode.AverageTime OutputTimeUnit TimeUnit. NANOSECONDS public void testTreeSet Blackhole blackhole blackhole. consumetreeSet. contains stringToFind Please keep in mind this blackhole. consume, well get back to it later. Also we need main class for running benchmark package benchmark GoalKicker.com Java Notes for Professionals 918import org.openjdk.jmh.runner.Runner import org.openjdk.jmh.runner.RunnerException import org.openjdk.jmh.runner.options.Options import org.openjdk.jmh.runner.options.OptionsBuilder public class BenchmarkMain public static void mainString args throws RunnerException final Options options new OptionsBuilder . includeCollectionFinderBenchmarkTest. class.getSimpleName . forks1 . build new Runneroptions.run And were all set. We just need to run mvn package it will create benchmarks. jar in your target folder and run our benchmark test java -cp target benchmarks. jar benchmark. BenchmarkMain And after some warmup", "and calculation iterations, we will have our results Run complete. Total time 000121 Benchmark Mode Cnt Score Error Units CollectionFinderBenchmarkTest. testHashSet avgt 20 9.940 0.270 nsop CollectionFinderBenchmarkTest. testTreeSet avgt 20 98.858 13.743 nsop About that blackhole. consume. If your calculations do not change the state of your application, java will most likely just ignore it. So, in order to avoid it, you can either make your benchmark methods return some value, or use Blackhole object to consume it. You can \ufb01nd more information about writing proper benchmarks in Aleksey Shipil \u00ebvs blog , in Jacob Jenkovs blog and in java-performance blog 1, 2. GoalKicker.com Java Notes for Professionals 919Chapter 180 FileUpload to AWS Upload File to AWS s3 bucket using spring rest API. Section 180.1 Upload \ufb01le to s3 bucket Here we will create a rest API which will take \ufb01le object as a multipart parameter from front end and upload it to S3 bucket using java rest API. Requirement secrete key and Access key for s3 bucket where you wanna upload your \ufb01le. code DocumentController.java RestController RequestMapping apiv2 public class DocumentController private static String bucketName pharmerz-chat private static String keyName Pharmerz UUID.randomUUID RequestMapping value upload , method RequestMethod.", "POST, consumes MediaType. MULTIPARTFORMDATA public URL uploadFileHandler RequestParam name String name, RequestParam file MultipartFile file throws IOException Printing all the possible parameter from RequestParam System.out.println System.out.printlnfile.getOriginalFilename file.getOriginalFilename System.out.printlnfile.getContentType file.getContentType System.out.printlnfile.getInputStream file.getInputStream System.out.printlnfile.toString file.toString System.out.printlnfile.getSize file.getSize System.out.printlnname name System.out.printlnfile.getBytes file.getBytes System.out.printlnfile.hashCode file.hashCode System.out.printlnfile.getClass file.getClass System.out.printlnfile.isEmpty file.isEmpty Parameters to b pass to s3 bucket put Object InputStream is file.getInputStream String keyName file.getOriginalFilename Credentials for Aws AWSCredentials credentials new BasicAWSCredentials AKIA , zr DocumentController.uploadfilecredentials AmazonS3 s3client new AmazonS3Client credentials try System.out.printlnUploading a new object to S3 from a file n File file new Fileawsuploadfile s3client. putObject new PutObjectRequest bucketName, keyName, is, new ObjectMetadata GoalKicker.com Java Notes for Professionals 920 URL url s3client. generatePresignedUrl bucketName, keyName, Date.fromInstant. now.plus5, ChronoUnit. MINUTES URL urls3client.generatePresignedUrlbucketName,keyName, Date.fromInstant.now.plus5, ChronoUnit. System.out.println System.out.printlnurl return url catch AmazonServiceException ase System.out.printlnCaught an AmazonServiceException, which means your request made it to Amazon S3, but was rejected with an error response for some reason. System.out.printlnError Message ase.getMessage System.out.printlnHTTP Status Code ase.getStatusCode System.out.printlnAWS Error Code ase.getErrorCode System.out.printlnError Type ase.getErrorType System.out.printlnRequest ID ase.getRequestId catch AmazonClientException ace System.out.printlnCaught an AmazonClientException, which means the client encountered an internal error while trying to communicate with S3, such as not being able to access the network. System.out.printlnError Message ace.getMessage return", "null Front end Function var form new FormData form.appendfile, image.jpeg var settings async true, crossDomain true, url httpurl , method POST, headers cache-control no-cache , processData false, contentType false, mimeType multipartform-data , data form .ajaxsettings .donefunction response console. logresponse GoalKicker.com Java Notes for Professionals 921Chapter 181 AppDynamics and TIBCO BusinessWorks Instrumentation for Easy Integration As AppDynamics aims to provide a way to measure application performance, speed of development, delivery deployment of applications is an essential factor in making DevOps e\ufb00orts a true success. Monitoring a TIBCO BW application with AppD is generally simple and not time consuming but when deploying large sets of applications rapid instrumentation is key. This guide shows how to instrument all of your BW applications in a single step without modifying each application before deploying. Section 181.1 Example of Instrumentation of all BW Applications in a Single Step for Appdynamics Locate and open your TIBCO BW bwengine.tra \ufb01le typlically under TIBCOHOMEbw5.12binbwengine.tra1. Linux environment Look for the line that states2. Common variables. Modify these only. Add the following line right after that section tibco.deploymenttibco.deployment3. Go to the end of the \ufb01le and add replace ? with your own values as needed or remove the \ufb02ag that", "does not4. apply java.extended.properties-javaagentoptappdcurrentappagentjavaagent.jar - Dappdynamics.http.proxyHost? -Dappdynamics.http.proxyPort? -Dappdynamics.agent.applicationName? -Dappdynamics.agent.tierName? -Dappdynamics.agent.nodeNametibco.deployment - Dappdynamics.controller.ssl.enabled? -Dappdynamics.controller.sslPort? -Dappdynamics.agent.logs.dir? - Dappdynamics.agent.runtime.dir? -Dappdynamics.controller.hostName? -Dappdynamics.controller.port? -Dappdynamics.agent.accountName? -Dappdynamics.agent.accountAccessKey? Save \ufb01le and redeploy. All your applications should now be instrumented automatically at deployment time.5. GoalKicker.com Java Notes for Professionals 922Appendix A Installing Java Standard Edition This documentation page gives access to instructions for installing java standard edition on Windows , Linux , and macOS computers. Section A.1 Setting PATH and JAVAHOME after installing on Windows Assumptions An Oracle JDK has been installed. The JDK was installed to the default directory. Setup steps Open Windows Explorer.1. In the navigation pane on the left right click on This PC or Computer for older Windows versions. There is a 2. shorter way without using the explorer in actual Windows versions Just press Win Pause In the newly opened Control Panel window, left click Advanced System Settings which should be in the top left 3. corner. This will open the System Properties window. Alternatively, type SystemPropertiesAdvanced case insensitive in the Run Win R , and hit Enter . In the Advanced tab of System Properties select the Environment Variables... button in the lower right 4. corner of the window. Add a New", "System Variable by clicking the New... button in System Variables with the name JAVAHOME 5. and whose value is the path to the directory where the JDK was installed. After entering these values, press OK . GoalKicker.com Java Notes for Professionals 923 Scroll down the list of System Variables and select the Path variable. 6. CAUTION Windows relies on Path to \ufb01nd important programs. If any or all of it is removed, 7. Windows may not be able to function properly. It must be modi\ufb01ed to allow Windows to run the JDK. With this in mind ,click the Edit... button with the Path variable selected. Add JAVAHOME bin to the beginning of the Path variable. It is better to append at the beginning of the line because Oracles software used to register their own version of Java in Path - This will cause your version to be ignored if it occurs after Oracles declaration. Check your work Open the command prompt by clicking Start then typing cmd and pressing Enter . 1. Enter javac -version into the prompt. If it was successful, then the version of the JDK will be printed to the 2. screen. Note If you have", "to try again, close the prompt before checking your work. This will force windows to get the new version of Path . Section A.2 Installing a Java JDK on Linux Using the Package Manager JDK andor JRE releases for OpenJDK or Oracle can be installed using the package manager on most mainstream Linux distribution. The choices that are available to you will depend on the distro. As a general rule, the procedure is to open terminal window and run the commands shown below. It is assumed that you have su\ufb03cient access to run commands as the root user ... which is what the sudo command does. If you do not, then please talk to your systems administrators. Using the package manager is recommended because it generally makes it easier to keep your Java installation up to date. apt-get, Debian based Linux distributions Ubuntu, etc The following instructions will install Oracle Java 8 sudo add-apt-repository ppawebupd8team java sudo apt-get update sudo apt-get install oracle-java8-installer GoalKicker.com Java Notes for Professionals 924Note To automatically set up the Java 8 environment variables, you can install the following package sudo apt-get install oracle-java8-set-default Creating a .deb \ufb01le If you prefer to create the .deb", "\ufb01le yourself from the .tar.gz \ufb01le downloaded from Oracle, do the following assuming youve downloaded the .tar.gz to .jdk.tar.gz sudo apt-get install java-package might not be available in default repos make-jpkg . jdk.tar.gz should not be run as root sudo dpkg -i j2sdk.deb Note This expects the input to be provided as a .tar.gz \ufb01le. slackpkg , Slackware based Linux distributions sudo slapt-get install default-jdk yum, RedHat, CentOS, etc sudo yum install java-1.8.0-openjdk-devel.x8664 dnf, Fedora On recent Fedora releases, yum has been superseded by dnf. sudo dnf install java-1.8.0-openjdk-devel.x8664 In recent Fedora releases, there are no packages for installing Java 7 and earlier. pacman , Arch based Linux distributions sudo pacman -S jdk8-openjdk Using sudo is not required if youre running as the root user. Gentoo Linux The Gentoo Java guide is maintained by the Gentoo Java team and keeps an updated wiki page including the correct portage packages and USE \ufb02ags needed. Installing Oracle JDKs on Redhat, CentOS, Fedora Installing JDK from an Oracle JDK or JRE tar.gz \ufb01le. Download the appropriate Oracle archive tar.gz \ufb01le for the desired release from the Oracle Java 1. downloads site . Change directory to the place where you want to put", "the installation2. Decompress the archive \ufb01le e.g.3. tar xzvf jdk -8u67-linux-x64.tar.gz GoalKicker.com Java Notes for Professionals 925Installing from an Oracle Java RPM \ufb01le. Retrieve the required RPM \ufb01le for the desired release from the Oracle Java downloads site . 1. Install using the rpm command. For example 2. sudo rpm -ivh jdk-8u67-linux-x644.rpm Section A.3 Installing a Java JDK on macOS Oracle Java 7 and Java 8 Java 7 and Java 8 for macOS are available from Oracle. This Oracle page answers a lot of questions about Java for Mac. Note that Java 7 prior to 7u25 have been disabled by Apple for security reasons. In general, Oracle Java Version 7 and later requires an Intel-based Mac running macOS 10.7.3 or later. Installation of Oracle Java Java 7 8 JDK and JRE installers for macOS can be downloaded from Oracle s website Java 8 - Java SE Downloads Java 7 - Oracle Java Archive. After downloading the relevant package, double click on the package and go through the normal installation process. A JDK should get installed here LibraryJavaJavaVirtualMachines version.jdkContents Home where corresponds to the installed version. Command-Line Switching When Java is installed, the installed version is automatically set as the", "default. To switch between di\ufb00erent, use export JAVAHOME usrlibexecjavahome -v 1.6 Or 1.7 or 1.8 The following functions can be added to the .bashprofile If you use the default Bash shell for ease of use function javaversion echo java -version function javaset if 1 6 then export JAVAHOME usrlibexecjavahome -v 1.6 echo Setting Java to version 6... echo JAVAHOME elif 1 7 then export JAVAHOME usrlibexecjavahome -v 1.7 echo Setting Java to version 7... echo JAVAHOME elif 1 8 then GoalKicker.com Java Notes for Professionals 926 export JAVAHOME usrlibexecjavahome -v 1.8 echo Setting Java to version 8... echo JAVAHOME fi Apple Java 6 on macOS On older versions of macOS 10.11 El Capitan and earlier, Apples release of Java 6 comes pre-installed. If installed, it can be be found at this location SystemLibraryJavaJavaVirtualMachines 1.6.0.jdkContents Home Note that Java 6 passed its end-of-life long ago, so upgrading to a newer version is recommended. There is more information on reinstalling Apple Java 6 on the Oracle website. Section A.4 Installing a Java JDK or JRE on Windows Only Oracle JDKs and JREs are available for Windows platforms. The installation procedure is straight-forward Visit the Oracle Java Downloads page 1. Click on", "either the JDK button, the JRE button or the Server JRE button. Note that to develop using Java you2. need JDK. To know the di\ufb00erence between JDK and JRE, see here Scroll down to the version you want to download. Generally speaking, the most recent one is3. recommended. Select the Accept License Agreement radio button.4. Download the Windows x86 32 bit or Windows x64 64 bit installer.5. Run the installer ... in the normal way for your version of Windows.6. An alternate way to install Java on Windows using the command prompt is to use Chocolately Install Chocolately from httpschocolatey.org 1. Open a cmd instance, for example hit Win R and then type cmd in the Run window followed by an 2. enter. In your cmd instance, run the following command to download and install a Java 8 JDK3. C choco install jdk8 Getting up and running with portable versions There are instances where you might want to install JDKJRE on a system with limited privileges like a VM or you might want to install and use multiple versions or architectures x64x86 of JDKJRE. The steps remain same till the point you download the installer .EXE. The steps after", "that are as follows The steps are applicable for JDKJRE 7 and above, for older versions they are slightly di\ufb00erent in the names of folders and \ufb01les Move the \ufb01le to an appropriate location where you would want your Java binaries to reside permanently.1. Install 7-Zip or its portable version if you have limited privileges.2. With 7-Zip, extract the \ufb01les from the Java installer EXE to the location.3. Open up command prompt there by holding Shift and Right-Click ing in the folder in explorer or navigate 4. to that location from anywhere. GoalKicker.com Java Notes for Professionals 927Navigate to the newly created folder. Lets say the folder name is jdk-7u25-windows-x64. So type cd 5. jdk-7u25-windows-x64 . Then type the following commands in order cd .rsrcJAVACAB10 extrac32 111 This will create a tools.zip \ufb01le in that location. Extract the tools.zip with 7-Zip so that the \ufb01les inside it are 6. now created under tools in the same directory. Now execute these commands on the already opened command prompt 7. cd tools for r x in .pack do .binunpack200 -r x dxpxnx.jar Wait for the command to complete. Copy the contents of tools to the location where you want your binaries", "8. to be. This way, you can install any versions of JDKJRE you need to be installed simultaneously. Original post httpstackover\ufb02ow.coma65717361448252 Section A.5 Con\ufb01guring and switching Java versions on Linux using alternatives Using Alternatives Many Linux distributions use the alternatives command for switching between di\ufb00erent versions of a command. You can use this for switching between di\ufb00erent versions of Java installed on a machine. In a command shell, set JDK to the pathname of a newly installed JDK e.g.1. JDKDatajdk1.8.067 Use alternatives --install to add the commands in the Java SDK to alternatives 2. sudo alternatives --install usrbinjava java JDKbinjava 2 sudo alternatives --install usrbinjavac javac JDKbinjavac 2 sudo alternatives --install usrbinjar jar JDKbinjar 2 And so on. Now you can switch between di\ufb00erent versions of a Java command as follows sudo alternatives --config javac There is 1 program that provides javac. Selection Command ----------------------------------------------- 1 usrlibjvmjava-1.8.0-openjdk-1.8.0.101- 1.b14.fc23.x8664 binjavac GoalKicker.com Java Notes for Professionals 928 2 Datajdk1.8.067 binjavac Enter to keep the current selection , or type selection number 2 For more information on using alternatives , refer to the alternatives8 manual entry. Arch based installs Arch Linux based installs come with the command archlinux -java to switch java", "versions. Listing installed environments archlinux -java status Available Java environments java-7-openjdk default java-8-openjdkjre Switching current environment archlinux -java set JAVAENVNAME Eg archlinux -java set java -8-openjdkjre More information can be found on the Arch Linux Wiki Section A.6 What do I need for Java Development A JDK installation and a text editor are the bare minimum for Java development. It is nice to have a text editor that can do Java syntax highlighting, but you can do without. However for serious development work it is recommended that you also use the following A Java IDE such as Eclipse, Intellij IDEA or NetBeans A Java build tool such as Ant, Gradle or Maven A version control system for managing your code base with appropriate backups, and o\ufb00-site replication Test tools and CI continuous integration tools Section A.7 Selecting an appropriate Java SE release There have been many releases of Java since the original Java 1.0 release in 1995. Refer to Java version history for a summary. However most releases have passed their o\ufb03cial End Of Life dates. This means that the vendor typically Oracle now has ceased new development for the release, and no longer provides public free patches for", "any bugs or security issues. Private patch releases are typically available for people organizations with a support contract contact your vendors sales o\ufb03ce. In general, the recommended Java SE release for use will be the latest update for the latest public version. Currently, this means the latest available Java 8 release. Java 9 is due for public release in 2017. Java 7 has passed its End Of Life and the last public release was in April 2015. Java 7 and earlier releases are not recommended. This recommendation applies for all new Java development, and anyone learning Java. It also applies to people who just want to run Java software provided by a third-party. Generally speaking, well-written Java code will work on a newer release of Java. But check the softwares release notes, and contact the author supplier vendor if you have doubts. GoalKicker.com Java Notes for Professionals 929If you are working on an older Java codebase, you would be advised to ensure that your code runs on the latest release of Java. Deciding when to start using the features of newer Java releases is more di\ufb03cult, as this will impact your ability to support customers who are unable or", "unwilling their Java installation. Section A.8 Java release and version naming Java release naming is a little confusing. There are actually two systems of naming and numbering, as shown in this table JDK version Marketing name jdk-1.0 JDK 1.0 jdk-1.1 JDK 1.1 jdk-1.2 J2SE 1.2 ... ... jdk-1.5 J2SE 1.5 rebranded Java SE 5 jdk-1.6 Java SE 6 jdk-1.7 Java SE 7 jdk-1.8 Java SE 8 jdk-91 Java SE 9 not released yet 1 - It appears that Oracle intends to break from their previous practice of using a semantic version number scheme in the Java version strings. It remains to be seen if they will follow through with this. The SE in the marketing names refers to Standard Edition. This is the base release for running Java on most laptops, PCs and servers apart from Android. There are two other o\ufb03cial editions of Java Java ME is the Micro Edition, and Java EE is the Enterprise Edition. The Android \ufb02avor of Java is also signi\ufb01cantly di\ufb00erent from Java SE. Java ME, Java EE and Android Java are outside of the scope of this Topic. The full version number for a Java release looks like this 1.8.0101 -b13 This", "says JDK 1.8.0, Update 101, Build 13. Oracle refers to this in the release notes as Java SE Development Kit 8, Update 101 JDK 8u101 The update number is important -- Oracle regularly issue updates to a major release with security patches, bug \ufb01xes and in some cases new features. The build number is usually irrelevant. Note that Java 8 and Java 1.8 refer to the same thing Java 8 is just the marketing name for Java 1.8. Section A.9 Installing Oracle Java on Linux with latest tar \ufb01le Follow the below steps to install Oracle JDK from the latest tar \ufb01le Download the latest tar \ufb01le from here - Current latest is Java SE Development Kit 8u112. 1. You need sudo privilages2. sudo su GoalKicker.com Java Notes for Professionals 930Create a dir for jdk install3. mkdir optjdk Extract downloaded tar into it4. tar -zxf jdk-8u5-linux-x64.tar.gz -C optjdk Verify if the \ufb01les are extracted5. ls optjdk Setting Oracle JDK as the default JVM6. update-alternatives --install usrbinjava java optjdkjdk1.8.005 binjava 100 and update-alternatives --install usrbinjavac javac optjdkjdk1.8.005 binjavac 100 Check Java version7. java -version Expected output java version 1.8.0111 JavaTM SE Runtime Environment build 1.8.0111-b14 Java HotSpotTM 64-Bit Server VM", "build 25.111-b14, mixed mode Section A.10 Post-installation checking and con\ufb01guration on Linux After installing a Java SDK, it is advisable to check that it is ready to use. You can do this by running these two commands, using your normal user account java -version javac -version These commands print out the version information for the JRE and JDK respectively that are on your shells command search path. Look for the JDK JRE version string. If either of the above commands fails, saying command not found, then the JRE or JDK is not on the search path at all go to Con\ufb01guring PATH directly below. If either of the above commands displays a di\ufb00erent version string to what you were expecting, then either your search path or the alternatives system needs adjusting go to Checking Alternatives If the correct version strings are displayed, you are nearly done skip to Checking JAVAHOME Con\ufb01guring PATH directly If there is no java or javac on the search path at the moment, then the simple solution is to add it to your search GoalKicker.com Java Notes for Professionals 931path. First, \ufb01nd where you installed Java see Where was Java installed? below if you have", "doubts. Next, assuming that bash is your command shell, use a text editor to add the following lines to the end of either .bashprofile or .bashrc If you use Bash as your shell. JAVAHOME installation directory PATHJAVAHOME binPATH export JAVAHOME export PATH ... replacing installation directory with the pathname for your Java installation directory. Note that the above assumes that the installation directory contains a bin directory, and the bin directory contains the java and javac commands that you are trying to use. Next, source the \ufb01le that you just edited, so that the environment variables for your current shell are updated. source .bashprofile Next, repeat the java and javac version checks. If there are still problems, use which java and which javac to verify that you have updates the environment variables correctly. Finally, logout and login again so that the updated environment variables ptopagate to all of your shells. You should now be done. Checking Alternatives If java -version or javac -version worked but gave an unexpected version number, you need to check where the commands are coming from. Use which and ls -l to \ufb01nd this out as follows ls -l which java If the output looks", "like this, lrwxrwxrwx. 1 root root 22 Jul 30 2218 usrbinjava - etcalternatives java then the alternatives version switching is being used. You needs to decide whether to continue using it, or simply override it by setting the PATH directly. Con\ufb01guring and Switching Java versions on Linux using alternatives See Con\ufb01guring PATH directly above. Where was Java installed? Java can be installed in a variety of places, depending on the installation method. The Oracle RPMs put the Java installation in usrjava. On Fedora, the default location is usrlibjvm. If Java was installed by hand from ZIP or JAR \ufb01les, the installation could be anywhere. If you are having di\ufb03cultly \ufb01nding the installation directory, We suggest that you use find or slocate to \ufb01nd the command. For example GoalKicker.com Java Notes for Professionals 932 find -name java -type f 2 devnull This gives you the pathnames for all \ufb01les called java on your system. The redirection of standard error to devnull suppresses messages about \ufb01les and directories that you cant access. GoalKicker.com Java Notes for Professionals 933Appendix B Java Editions, Versions, Releases and Distributions Section B.1 Dierences between Java SE JRE or Java SE JDK distributions Sun Oracle releases of", "Java SE come in two forms JRE and JDK. In simple terms, JREs support running Java applications, and JDKs also support Java development. Java Runtime Environment Java Runtime Environment or JRE distributions consist of the set of libraries and tools needed to run and manage Java applications. The tools in a typical modern JRE include The java command for running a Java program in a JVM Java Virtual Machine The jjs command for running the Nashorn Javascript engine. The keytool command for manipulating Java keystores. The policytool command for editing security sandbox security policies. The pack200 and unpack200 tools for packing and unpacking pack200 \ufb01le for web deployment. The orbd , rmid , rmiregistry and tnameserv commands that support Java CORBA and RMI applications. Desktop JRE installers include a Java plugin suitable for some web browser. This is deliberately left out of Server JRE installers.linux syscall read benchmarku From Java 7 update 6 onwards, JRE installers have included JavaFX version 2.2 or later. Java Development Kit A Java Development Kit or JDK distribution includes the JRE tools, and additional tools for developing Java software. The additional tools typically include The javac command, which compiles Java source code .java to", "bytecode \ufb01les .class. The tools for creating JAR \ufb01les such as jar and jarsigner Development tools such as appletviewer for running applets idlj the CORBA IDL to Java compiler javah the JNI stub generator native2ascii for character set conversion of Java source code schemagen the Java to XML schema generator part of JAXB serialver generate Java Object Serialization version string. the wsgen and wsimport support tools for JAX-WS Diagnostic tools such as jdb the basic Java debugger jmap and jhat for dumping and analysing a Java heap. jstack for getting a thread stack dump. javap for examining .class \ufb01les. Application management and monitoring tools such as jconsole a management console, jstat , jstatd , jinfo and jps for application monitoring A typical Sun Oracle JDK installation also includes a ZIP \ufb01le with the source code of the Java libraries. Prior to Java 6, this was the only publicly available Java source code. GoalKicker.com Java Notes for Professionals 934From Java 6 onwards, the complete source code for OpenJDK is available for download from the OpenJDK site. It is typically not included in Linux JDK packages, but is available as a separate package. Section B.2 Java SE Versions Java SE Version", "History The following table provides the timeline for the signi\ufb01cant major versions of the Java SE platform. Java SE Version1 Code Name End-of-life free2 Release Date Java SE 10 Early Access None future 2018-03-20 estimated Java SE 9 None future 2017-07-27 Java SE 8 None future 2014-03-18 Java SE 7 Dolphin 2015-04-14 2011-07-28 Java SE 6 Mustang 2013-04-16 2006-12-23 Java SE 5 Tiger 2009-11-04 2004-10-04 Java SE 1.4.2 Mantis prior to 2009-11-04 2003-06-26 Java SE 1.4.1 Hopper Grasshopper prior to 2009-11-04 2002-09-16 Java SE 1.4 Merlin prior to 2009-11-04 2002-02-06 Java SE 1.3.1 Ladybird prior to 2009-11-04 2001-05-17 Java SE 1.3 Kestrel prior to 2009-11-04 2000-05-08 Java SE 1.2 Playground prior to 2009-11-04 1998-12-08 Java SE 1.1 Sparkler prior to 2009-11-04 1997-02-19 Java SE 1.0 Oak prior to 2009-11-04 1996-01-21 Footnotes The links are to online copies of the respective releases documentation on Oracles website. The1. documentation for many older releases no longer online, though it typically can be downloaded from the Oracle Java Archives. Most historical versions of Java SE have passed their o\ufb03cial end of life dates. When a Java version passes2. this milestone, Oracle stop providing free updates for it. Updates are still available to customers", "with support contracts. Source JDK release dates by Roedy Green of Canadian Mind Products Java SE Version Highlights Java SE VersionHighlights Java SE 8Lambda expressions and MapReduce-inspired Streams. The Nashorn Javascript engine. Annotations on types and repeating annotations. Unsigned arithmetic extensions. New Date and Time APIs. Statically linked JNI libraries. JavaFX launcher. Removal of PermGen. Java SE 7String switches, try-with-resource , the diamond , numeric literal enhancements and exception handling rethrowing improvements. Concurrency library enhancements. Enhanced support for native \ufb01le systems. Timsort. ECC crypto algorithms. Improved 2D graphics GPU support. Pluggable annotations. Java SE 6Signi\ufb01cant performance enhancements to JVM platform and Swing. Scripting language API and Mozilla Rhino Javascript engine. JDBC 4.0. Compiler API. JAXB 2.0. Web Services support JAX-WS GoalKicker.com Java Notes for Professionals 935Java SE 5Generics, annotations, auto-boxing, enum classes, varargs, enhanced for loops and static imports. Speci\ufb01cation of the Java Memory Model. Swing and RMI enhancements. Addition of java.util.concurrent . package and Scanner . Java SE 1.4The assert keyword. Regular expression classes. Exception chaining. NIO APIs - non-blocking IO, Buffer and Channel . java.util.logging. API. Image IO API. Integrated XML and XSLT JAXP. Integrated security and cryptography JCE, JSSE, JAAS. Integrated Java Web Start. Preferences API.", "Java SE 1.3HotSpot JVM included. CORBA RMI integration. Java Naming and Directory Interface JNDI. Debugger framework JPDA. JavaSound API. Proxy API. Java SE 1.2The strictfp keyword. Swing APIs. The Java plugin for web browsers. CORBA interoperability. Collections framework. Java SE 1.1Inner classes. Re\ufb02ection. JDBC. RMI. Unicode character streams. Internationalization support. Overhaul of AWT event model. JavaBeans. Source Wikipedia Java version history Section B.3 Dierences between Java EE, Java SE, Java ME and JavaFX Java technology is both a programming language and a platform. The Java programming language is a high-level object-oriented language that has a particular syntax and style. A Java platform is a particular environment in which Java programming language applications run. There are several Java platforms. Many developers, even long-time Java programming language developers, do not understand how the di\ufb00erent platforms relate to each other. The Java Programming Language Platforms There are four platforms of the Java programming language Java Platform, Standard Edition Java SE Java Platform, Enterprise Edition Java EE Java Platform, Micro Edition Java ME Java FX All Java platforms consist of a Java Virtual Machine VM and an application programming interface API. The Java Virtual Machine is a program, for a particular hardware and", "software platform, that runs Java technology applications. An API is a collection of software components that you can use to create other software components or applications. Each Java platform provides a virtual machine and an API, and this allows applications written for that platform to run on any compatible system with all the advantages of the Java programming language platform-independence, power, stability, ease-of-development, and security. Java SE When most people think of the Java programming language, they think of the Java SE API. Java SEs API provides the core functionality of the Java programming language. It de\ufb01nes everything from the basic types and objects of the Java programming language to high-level classes that are used for networking, security, database access, graphical user interface GUI development, and XML parsing. In addition to the core API, the Java SE platform consists of a virtual machine, development tools, deployment technologies, and other class libraries and toolkits commonly used in Java technology applications. GoalKicker.com Java Notes for Professionals 936Java EE The Java EE platform is built on top of the Java SE platform. The Java EE platform provides an API and runtime environment for developing and running large-scale, multi-tiered, scalable, reliable, and secure", "network applications. Java ME The Java ME platform provides an API and a small-footprint virtual machine for running Java programming language applications on small devices, like mobile phones. The API is a subset of the Java SE API, along with special class libraries useful for small device application development. Java ME applications are often clients of Java EE platform services. Java FX Java FX technology is a platform for creating rich internet applications written in Java FX ScriptTM. Java FX Script is a statically-typed declarative language that is compiled to Java technology bytecode, which can then be run on a Java VM. Applications written for the Java FX platform can include and link to Java programming language classes, and may be clients of Java EE platform services. Taken from the Oracle documentation GoalKicker.com Java Notes for Professionals 937Appendix C The Classpath The classpath lists places where the Java runtime should look for classes and resources. The classpath is also used by the Java compiler to \ufb01nd previously compiled and external dependencies. Section C.1 Dierent ways to specify the classpath There are three ways to set the classpath. It can be set using the CLASSPATH environment variable 1. set CLASSPATH", "... Windows and csh export CLASSPATH ... Unix ksh bash It can be set on the command line as follows2. java -classpath ... javac -classpath ... Note that the -classpath or -cp option takes precedence over the CLASSPATH environment variable. The classpath for an executable JAR \ufb01le is speci\ufb01ed using the Class-Path element in MANIFEST. MF 3. Class-Path jar1-name jar2 -name directory -namejar3-name Note that this only applies when the JAR \ufb01le is executed like this java -jar some. jar ... In this mode of execution, the -classpath option and the CLASSPATH environment variable will be ignored, even if the JAR \ufb01le has no Class-Path element. If no classpath is speci\ufb01ed, then the default classpath is the selected JAR \ufb01le when using java -jar, or the current directory otherwise. Related httpsdocs.oracle.comjavasetutorialdeploymentjardownman.html httpdocs.oracle.comjavase7docstechnotestoolswindowsclasspath.html Section C.2 Adding all JARs in a directory to the classpath If you want to add all the JARs in directory to the classpath, you can do this concisely using classpath wildcard syntax for example someFolder This tells the JVM to add all JAR and ZIP \ufb01les in the someFolder directory to the classpath. This syntax can be used in a -cp argument, a CLASSPATH environment variable,", "or a Class-Path attribute in an executable JAR \ufb01les manifest \ufb01le.See Setting the Class Path Class Path Wild Cards for examples and caveats. GoalKicker.com Java Notes for Professionals 938Notes Classpath wildcards were \ufb01rst introduced in Java 6. Earlier versions of Java do not treat as a wildcard.1. You cannot put other characters before or after the e.g. someFolder .jar is not a wildcard. 2. A wildcard matches only \ufb01les with the su\ufb03x .jar or .JAR. ZIP \ufb01les are ignored, as are JAR \ufb01les with a3. di\ufb00erent su\ufb03xes. A wildcard matches only JAR \ufb01les in the directory itself, not in its subdirectories.4. When a group of JAR \ufb01les is matched by a wildcard entry, their relative order on the classpath is not speci\ufb01ed.5. Section C.3 Load a resource from the classpath It can be useful to load a resource image, text \ufb01le, properties, KeyStore, ... that is packaged inside a JAR. For this purpose, we can use the Class and ClassLoader s. Suppose we have the following project structure program.jar -com -project -file.txt -Test.class And we want to access the contents of file.txt from the Test class. We can do so by asking the classloader InputStream is Test.class.getClassLoader .getResourceAsStream comprojectfile.txt", "By using the classloader, we need to specify the fully quali\ufb01ed path of our resource each package. Or alternatively, we can ask the Test class object directly InputStream is Test.class.getResourceAsStream file.txt Using the class object, the path is relative to the class itself. Our Test.class being in the com.project package, the same as file.txt, we do not need to specify any path at all. We can, however, use absolute paths from the class object, like so is Test.class.getResourceAsStream comprojectfile.txt Section C.4 Classpath path syntax The classpath is a sequence of entries which are directory pathnames, JAR or ZIP \ufb01le pathnames, or JAR ZIP wildcard speci\ufb01cations. For a classpath speci\ufb01ed on the command line e.g. -classpath or as an environment variable, the entries must be separated with semicolon characters on Windows, or colon characters on other platforms Linux, UNIX, MacOSX and so on. For the Class-Path element in a JAR \ufb01les MANIFEST. MF, use a single space to separate the entries. Sometimes it is necessary to embed a space in a classpath entry GoalKicker.com Java Notes for Professionals 939When the classpath is speci\ufb01ed on the command line, it is simply a matter of using the appropriate shell quoting. For example", "export CLASSPATH homeuserMy JAR Filesfoo.jarsecond.jar The details may depend on the command shell that you use. When the classpath is speci\ufb01ed in a JAR \ufb01les a MANIFEST.MF \ufb01le, URL encoding must be used. Class-Path homeuserMy20JAR20Filesfoo.jar second. jar Section C.5 Dynamic Classpath Sometimes, just adding all the JARs from a folder isnt enough, for example when you have native code and need to select a subset of JARs. In this case, you need two main methods. The \ufb01rst one builds a classloader and then uses this classloader to call the second main. Here is an example which selects the correct SWT native JAR for your platform, adds all your applications JARs and then invokes the real main method Create cross platform Java SWT Application Section C.6 Mapping classnames to pathnames The standard Java toolchain and 3rd-party tools designed to interoperate with them have speci\ufb01c rules for mapping the names of classes to the pathnames of \ufb01les and other resources that represent them. The mappings are as follows For classes in the default package, the pathnames are simple \ufb01lenames. For classes in a named package, the package name components map to directories. For named nested and inner classes, the \ufb01lename component", "is formed by joining the class names with a character. For anonymous inner classes, numbers are used in place of names. This is illustrated in the following table Classname Source pathname Class\ufb01le pathname SomeClass SomeClass. java SomeClass. class com.example.SomeClass comexampleSomeClass. javacomexampleSomeClass. class SomeClass. Inner in SomeClass. java SomeClassInner. class SomeClass anon inner classes in SomeClass. java SomeClass1. class , SomeClass2. class , etc Section C.7 The bootstrap classpath The normal Java classloaders look for classes \ufb01rst in the bootstrap classpath, before checking for extensions and the application classpath. By default, the bootstrap classpath consists of the rt.jar \ufb01le and some other important JAR \ufb01les that are supplied by the JRE installation. These provide all of the classes in the standard Java SE class library, along with various internal implementation classes. Under normal circumstances, you dont need to concern yourself with this. By default, commands like java , javac and so on will use the appropriate versions of the runtime libraries. GoalKicker.com Java Notes for Professionals 940Very occasionally, it is necessary to override the normal behavior of the Java runtime by using an alternative version of a class in the standard libraries. For example, you might encounter a show stopper", "bug in the runtime libraries that you cannot work around by normal means. In such a situation, it is possible to create a JAR \ufb01le containing the altered class and then add it to the bootstrap classpath which launching the JVM. The java command provides the following -X options for modifying the bootstrap classpath -Xbootclasspath path replaces the current boot classpath with the path provided. -Xbootclasspath apath appends the provided path to the current boot classpath. -Xbootclasspath ppath prepends the provided path to the current boot classpath. Note that when use the bootclasspath options to replace or override a Java class etcetera, you are technically modifying Java. There may be licensing implications if you then distribute your code. Refer to the terms and conditions of the Java Binary License ... and consult a lawyer. Section C.8 What the classpath means how searches work The purpose of the classpath is to tell a JVM where to \ufb01nd classes and other resources. The meaning of the classpath and the search process are intertwined. The classpath is a form of search path which speci\ufb01es a sequence of locations to look for resources. In a standard classpath, these places are either, a directory", "in the host \ufb01le system, a JAR \ufb01le or a ZIP \ufb01le. In each cases, the location is the root of a namespace that will be searched. The standard procedure for searching for a class on the classpath is as follows Map the class name to a relative class\ufb01le pathname RP. The mapping for class names to class \ufb01lenames is 1. described elsewhere. For each entry E in the classpath 2. If the entry is a \ufb01lesystem directory Resolve RP relative to E to give an absolute pathname AP. Test if AP is a path for an existing \ufb01le. If yes, load the class from that \ufb01le If the entry is a JAR or ZIP \ufb01le Lookup RP in the JAR ZIP \ufb01le index. If the corresponding JAR ZIP \ufb01le entry exists, load the class from that entry. The procedure for searching for a resource on the classpath depends on whether the resource path is absolute or relative. For an absolute resource path, the procedure is as above. For a relative resource path resolved using Class.getResource or Class.getResourceAsStream , the path for the classes package is prepended prior to searching. Note these are the procedures implemented by the standard", "Java classloaders. A custom classloader might perform the search di\ufb00erently. GoalKicker.com Java Notes for Professionals 941Appendix D Resources on classpath Java allows the retrieval of \ufb01le-based resources stored inside of a JAR alongside compiled classes. This topic focuses on loading those resources and making them available to your code. Section D.1 Loading default con\ufb01guration To read default con\ufb01guration properties package com.example public class ExampleApplication private Properties getDefaults throws IOException Properties defaults new Properties try InputStream defaultsStream ExampleApplication. class.getResourceAsStream config.properties defaults. loaddefaultsStream return defaults Section D.2 Loading an image from a resource To load a bundled image package com.example public class ExampleApplication private Image getIcon throws IOException URL imageURL ExampleApplication. class.getResource icon.png return ImageIO. readimageURL Section D.3 Finding and reading resources using a classloader Resource loading in Java comprises the following steps Finding the Class or ClassLoader that will \ufb01nd the resource. 1. Finding the resource.2. Obtaining the byte stream for the resource.3. Reading and processing the byte stream.4. Closing the byte stream.5. The last three steps are typically accomplished by passing the URL to a library method or constructor to load the resource. You will typically use a getResource method in this case. It is also possible to read", "the resource data in application code. You will typically use getResourceAsStream in this case. Absolute and relative resource paths GoalKicker.com Java Notes for Professionals 942Resources that can be loaded from the classpath are denoted by a path . The syntax of the path is similar to a UNIX Linux \ufb01le path. It consists of simple names separated by forward slash characters. A relative path starts with a name, and an absolute path starts with a separator. As the Classpath examples describe, a JVMs classpath de\ufb01nes a namespace by overlaying the namespaces of the directories and JAR or ZIP \ufb01les in the classpath. When an absolute path is resolved, it the classloaders interpret the initial as meaning the root of the namespace. By contrast, a relative path may be resolved relative to any folder in the namespace. The folder used will depend on the object that you use to resolve the path. Obtaining a Class or Classloader A resource can be located using either a Class object or a ClassLoader object. A Class object can resolve relative paths, so you will typically use one of these if you have a class relative resource. There are a variety of ways to", "obtain a Class object. For example A class literal will give you the Class object for any class that you can name in Java source code e.g. String.class gives you the Class object for the String type. The Object.getClass will give you the Class object for the type od any object e.g. hello.getClass is another way to get Class of the String type. The Class.forNameString method will if necessary dynamically load a class and return its Class object e.g. Class.forNamejava.lang.String . A ClassLoader object is typically obtained by calling getClassLoader on a Class object. It is also possible to get hold of the JVMs default classloader using the static ClassLoader .getSystemClassLoader method. The get methods Once you have a Class or ClassLoader instance, you can \ufb01nd a resource, using one of the following methods Methods Description ClassLoader .getResource path ClassLoader .getResources pathReturns a URL which represents the location of the resource with the given path. ClassLoader .getResources path Class.getResources pathReturns an Enumeration URL giving the URLs which can be used to locate the foo.bar resource see below. ClassLoader .getResourceAsStream path Class.getResourceStream pathReturns an InputStream from which you can read the contents of the foo.bar resource as a sequence of", "bytes. Notes The main di\ufb00erence between the ClassLoader and Class versions of the methods is in the way that relative paths are interpreted. The Class methods resolve a relative path in the folder that corresponds to the classes package. The ClassLoader methods treat relative paths as if they were absolute i.e. the resolve them in the root folder of the classpath namespace. If the requested resource or resources cannot be found, the getResource and getResourceAsStream methods return null, and the getResources methods return an empty Enumeration. The URLs returned will be resolvable using URL.toStream . They could be file URLs or other conventional URLs, but if the resource resides in a JAR \ufb01le, they will be jar URLs that identify the JAR \ufb01le and a speci\ufb01c resource within it. GoalKicker.com Java Notes for Professionals 943If your code uses a getResourceAsStream method or URL.toStream to obtain an InputStream , it is responsible for closing the stream object. Failure to close the stream could lead to a resource leak. Section D.4 Loading same-name resource from multiple JARs Resource with same path and name may exist in more than one JAR \ufb01le on the classpath. Common cases are resources following a convention", "or that are part of a packaging speci\ufb01cation. Examples for such resources are META-INFMANIFEST.MF META-INFbeans.xml CDI Spec ServiceLoader properties containing implementation providers To get access to all of these resources in di\ufb00erent jars, one has to use a ClassLoader, which has a method for this. The returned Enumeration can be conveniently converted to a List using a Collections function. Enumeration URL resEnum MyClass. class.getClassLoader .getResources META-INFMANIFEST.MF ArrayList URL resources Collections .listresEnum GoalKicker.com Java Notes for Professionals 944Credits Thank you greatly to all the people from Stack Over\ufb02ow Documentation who helped provide this content, more changes can be sent to webpetercv.com for new content to be published or updated 100rabh Chapters 18 and 79 17slim Chapters 28, 40, 72 and 109 1d0m3n30 Chapters 9, 35, 45, 47 and 106 3442 Chapter 23 3751Creator Chapter 1 4castle Chapters 2 and 57 A Boschman Chapters 42 and 67 A.J. Brown Chapter 11 Aaron Digulla Chapters 47 and 184 Aaron Franke Chapter 56 Aasmund Eldhuset Chapter 46 ABDUL KHALIQ Chapter 90 Abhijeet Chapter 65 Abhishek Jain Chapters 11, 23 and 79 Abubakkar Chapters 11, 23, 57, 67 and 102 acdcjunior Chapters 23 and 57 Ad In\ufb01nitum Chapters 23, 24, 33, 43 and 73", "Adam Ratzman Chapter 11 Adeel Ansari Chapter 182 Adowrath Chapters 79 and 164 Adrian Krebs Chapters 11, 23, 54, 69, 74 and 111 afzalex Chapter 23 agilob Chapters 11, 23 and 69 agoeb Chapter 54 Aiden Deom Chapter 11 Aimee Borda Chapters 22 and 57 aioobe Chapters 35 and 117 ajablonski Chapter 182 AJNeufeld Chapter 74 akgrensoar Chapter 58 Akhil S K Chapters 1, 66, 69, 117 and 182 alain.janinm Chapters 16, 19 and 138 Alek Mieczkowski Chapters 20, 33 and 78 Alex A Chapter 182 Alex Meiburg Chapters 11 and 47 Alex Shesterov Chapters 11 and 20 Alex T. Chapter 132 Alexandre Grimaud Chapter 181 Alexey Lagunov Chapter 83 alexey semenyuk Chapters 47 and 117 Alexiy Chapter 149 Alon .G. Chapter 43 Alper F \u0131rat Kaya Chapter 77 alphaloop Chapter 144 altomnr Chapters 24 and 182 Amani Kilumanga Chapters 10, 11, 35, 40, 80 and 111 Amit Gujarathi Chapters 12, 29, 30, 31 and 180 GoalKicker.com Java Notes for Professionals 945Amit Gupta Chapter 73 Anatoly Yakimchuk Chapter 23 Andreas Chapters 40, 99 and 106 Andreas Fester Chapter 35 Andrew Chapters 23, 40, 73 and 79 Andrew Antipov Chapter 88 Andrew Brooke Chapter 74 Andrew Sklyarevsky Chapter 35 Andrii", "Abramov Chapters 41, 57, 73, 75, 81, 117 and 134 Androbin Chapter 33 Andy Thomas Chapters 11, 80, 85 and 130 Ani Menon Chapters 1, 42, 56 and 182 Anil Chapter 23 ankidaemon Chapter 23 Ankit Katiyar Chapters 73, 122 and 141 Ankur Anand Chapter 1 Anony Chapters 10, 11, 24, 35, 47, 73 and 89 anotherGatsby Chapter 23 Anthony Raymond Chapter 182 Anton Hlinisty Chapter 130 antonio Chapters 1 and 23 anuvab1911 Chapters 42 and 182 ar4ers Chapter 52 Arash Chapter 122 ArcticLord Chapters 103 and 105 arcy Chapters 16 and 68 Arkadiy Chapters 1 and 54 arpit pandey Chapter 21 ArsenArsen Chapter 57 Arthur Chapters 23, 71, 72, 77, 87, 93 and 110 Asaph Chapter 11 AshanPerera Chapter 74 Asiat Chapter 41 assylias Chapters 73 and 126 AstroCB Chapter 23 ata Chapters 28 and 77 Athari Chapters 23 and 57 augray Chapter 42 Aurasphere Chapter 77 Austin Chapter 11 Austin Day Chapter 11 AArnold Chapters 11, 16, 18 and 26 Bart Kummel Chapter 57 Batty Chapter 66 bcosynot Chapter 35 ben75 Chapter 97 Bhavik Patel Chapter 69 Bilbo Baggins Chapter 17 Bilesh Ganguly Chapters 10 and 66 Binary Nerd Chapter 28 Blubberguy22 Chapters 25 and 40 bn.", "Chapter 100 Bob Rivers Chapters 10, 16, 18, 24, 35, 70 and 123 GoalKicker.com Java Notes for Professionals 946BobasPett Chapter 85 Bohdan Korinnyi Chapter 107 Bohemian Chapters 15, 45 and 54 bowmore Chapters 17, 67 and 126 Bo\u017eo Stojkovi \u0107 Chapter 23 bpoiss Chapters 23 and 57 Brendon Dugan Chapter 129 Brett Kail Chapter 42 Brian Goetz Chapter 73 BrunoDM Chapter 41 Buddy Chapter 74 Burkhard Chapters 1, 6, 7, 11, 23, 54, 66, 69, 77 and 107 bwegs Chapter 23 c.uent Chapter 40 c1phr Chapter 23 Cache Staheli Chapters 11, 13, 23, 47 and 107 Ca\ufb00eineToCode Chapter 42 Caleb Brinkman Chapters 6 and 74 Caner Bal \u0131m Chapter 11 carloabelli Chapters 11 and 74 Carlton Chapter 1 CarManuel Chapter 71 Carter Brainerd Chapter 6 Cas Eli\u00ebns Chapter 74 Catalina Island Chapter 46 cdm Chapter 70 ced Chapters 24, 25, 26, 41 and 80 charlesreid1 Chapter 85 Charlie H Chapters 1, 23 and 67 Chetya Chapter 126 Chirag Parmar Chapters 24, 26, 78 and 86 Chris Midgley Chapter 40 Christian Chapter 19 Christian Wilkie Chapter 16 Christophe Weis Chapters 84, 103 and 115 Christopher Schneider Chapter 23 Claudia Chapter 40 Claudio Chapter 57 clinomaniac Chapter 24 code11 Chapter 47", "Codebender Chapters 24, 41 and 47 coder Chapters 11, 23 and 35 Co\ufb00ee Ninja Chapter 98 Co\ufb00eehouse Coder Chapters 1 and 74 Cold Fire Chapter 23 compuhosny Chapters 151 and 152 Con\ufb01qure Chapters 1, 23, 48, 85, 175 and 182 Constantine Chapters 35 and 57 corsiKa Chapter 126 CraftedCart Chapters 5, 74 and 182 cricket007 Chapter 42 cyberscientist Chapter 11 c\u029fs Chapter 1 GoalKicker.com Java Notes for Professionals 947D D Chapter 22 Daniel Chapter 10 Daniel K\u00e4fer Chapter 23 Daniel LIn Chapters 48 and 111 Daniel M. Chapters 35, 46, 57, 73, 80, 112 and 177 Daniel Nugent Chapters 81, 114, 130 and 139 Daniel Stradowski Chapters 11, 23, 24, 26 and 57 Daniel Wild Chapter 116 Danilo Guimaraes Chapters 35 and 163 Dariusz Chapters 23, 43, 54, 57, 82, 91, 102, 126, 128 and 138 DarkV1 Chapters 1, 11, 23 and 86 Datagrammar Chapter 95 Dave Ranjan Chapter 48 David Grinberg Chapter 54 David Soroko Chapter 87 DeepCoder Chapter 1 Demon Coldmist Chapter 43 demongolem Chapter 26 desilijic Chapter 176 devguy Chapter 79 devnull69 Chapter 93 DimaSan Chapters 26, 33, 50 and 126 dimo414 Chapters 69, 120 and 131 Display Name Chapters 113 and 170 Dmitriy Kotov Chapter", "28 dnup1092 Chapters 10 and 11 Do Nhu Vy Chapters 6 and 10 DonyorM Chapters 54, 57 and 93 dorukayhan Chapters 11, 20, 76, 87, 133 and 134 Draken Chapter 73 Drizzt321 Chapters 43 and 103 Duh Chapter 23 Durgpal Singh Chapters 23 and 28 Dushko Jovanovski Chapters 43, 57 and 130 Dushman Chapters 111, 114 and 173 DVarga Chapters 11, 23, 47, 54, 57 and 79 dwursteisen Chapter 57 Dylan Chapter 41 ebo Chapter 74 Eduard Wirch Chapter 120 Eilit Chapter 23 EJP Chapters 66 and 145 ekaerovets Chapter 97 Elazar Chapter 42 Emil Sier \u017c\u0119ga Chapters 23, 42, 115 and 182 Emily Mabrey Chapters 28 and 185 emotionlessbananas Chapters 66 and 120 Emre Bolat Chapters 1 and 23 Enamul Hassan Chapter 56 Eng.Fouad Chapter 23 engineercoding Chapter 33 Enigo Chapters 13, 24, 28, 42 and 77 enrico.bacis Chapters 1, 11, 23 and 57 GoalKicker.com Java Notes for Professionals 948Enwired Chapter 132 Eran Chapters 1, 23 and 24 erickson Chapter 117 Erik Minarini Chapter 23 Erkan Haspulat Chapter 56 esin88 Chapters 22, 172 and 179 Etki Chapter 23 explv Chapters 16, 23, 54 and 57 F. Stephen Q Chapters 87 and 143 fabian Chapters 10, 13, 40, 43,", "48, 74, 80, 85, 91, 103, 117, 122, 136 and 174 faraa Chapter 47 FFY00 Chapter 137 fgb Chapter 13 \ufb01kovnik Chapter 67 Fildor Chapters 3, 116, 126 and 127 Filip Smola Chapter 2 FlyingPiMonster Chapters 40, 77 and 122 FMC Chapter 69 foxt7ot Chapter 150 Francesco Menzani Chapters 1, 10 and 97 Freddie Coleman Chapter 126 Friederike Chapter 132 Functino Chapters 1 and 23 futureelite7 Chapter 40 fpuras Chapter 35 Gal Dreiman Chapters 23, 35, 57, 69, 73, 130, 131, 132 and 183 gar Chapters 10 and 73 garg10may Chapter 1 Garreth Golding Chapter 19 Gautam Jose Chapter 182 Gene Marin Chapters 23, 35 and 178 geniushkg Chapter 54 George Bailey Chapters 6 and 41 Gerald M\u00fccke Chapters 6, 22, 77, 130, 136 and 185 GhostCat Chapter 43 Gihan Chathuranga Chapter 86 GingerHead Chapters 1 and 23 giucal Chapter 117 glee8e Chapter 93 gontard Chapter 57 GPI Chapters 24, 28, 63, 73, 81, 108, 126, 135 and 184 GradAsso Chapter 66 granmirupa Chapters 23 and 25 Gray Chapter 11 GreenGiant Chapters 11, 69 and 88 Grexis Chapters 35 and 146 Grzegorz Oledzki Chapter 57 Gubbel Chapter 58 Guilherme Torres Castro Chapter 23 Gustavo Coelho Chapter 23 gwintrob Chapter", "67 Gytis Tenovimas Chapters 1 and 23 hamena314 Chapters 11 and 85 GoalKicker.com Java Notes for Professionals 949Hank D Chapters 57 and 73 Hay Chapter 77 Hazem Farahat Chapter 81 HCarrasko Chapter 116 hellrocker Chapter 126 hexafraction Chapters 47, 69, 73, 126 and 144 hirosht Chapter 54 Holger Chapter 137 HON95 Chapter 11 HTNW Chapters 82 and 130 Hulk Chapter 102 hzpz Chapter 67 Idcmp Chapter 45 iliketocode Chapters 1, 11, 23 and 57 Ilya Chapters 11, 23, 82, 93, 97, 118 and 126 Infuzion Chapter 11 InitializeSahib Chapter 97 inovaovao Chapter 79 intboolstring Chapters 23, 46, 74 and 79 Inzimam Tariq IT Chapter 74 ipsi Chapters 1, 10, 35, 171 and 182 iqbalcs Chapter 140 Ironcache Chapters 3 and 166 Ivan Vergiliev Chapter 73 J Atkin Chapters 10, 28, 43, 57, 58, 67, 73 and 89 J\u00e9r\u00e9mie Bolduc Chapter 23 J. Pichardo Chapter 150 J.D. Sandifer Chapter 117 Jabir Chapters 11, 16, 24, 28, 69, 72, 86 and 91 Jacob G. Chapter 61 JakeD Chapter 10 James Jensen Chapter 77 james large Chapters 42, 126 and 133 James Oswald Chapter 79 James Taylor Chapters 1 and 23 JamesENL Chapters 42 and 53 Jan Vladimir Mostert Chapters 25, 47", "and 79 janos Chapters 25 and 89 Jared Hooper Chapter 35 jatanp Chapter 178 Jatin Balodhi Chapter 5 javac Chapter 11 JAVAC Chapter 81 JavaHopper Chapters 1, 23, 40, 57, 69, 79 and 85 Javant Chapters 23 and 85 Javier Diaz Chapter 28 jayantS Chapter 56 JD9999 Chapters 25 and 59 Jean Chapter 16 Jean Vitor Chapter 1 Jeet Chapter 153 Je\ufb00 Coleman Chapter 182 Je\ufb00rey Bosboom Chapters 23, 28, 52 and 54 GoalKicker.com Java Notes for Professionals 950Je\ufb00rey Lin Chapters 1 and 11 Jens Schauder Chapters 1, 23, 47, 48, 58, 69, 74, 88, 126 and 127 Jeroen Vandevelde Chapter 73 Jeutnarg Chapter 23 Jim Garrison Chapter 23 jitendra varshney Chapter 23 jmattheis Chapter 23 Joe C Chapter 121 Johannes Chapters 23, 35, 79 and 126 John DiFini Chapters 64 and 161 John Fergus Chapter 1 John Nash Chapters 19, 21, 58 and 142 John Slegers Chapter 23 John Starich Chapter 135 johnnyaug Chapter 28 Jojodmo Chapters 10, 11, 23, 40 and 79 Jon Erickson Chapter 57 JonasCz Chapters 11, 69, 74, 78, 86 and 95 Jonathan Chapters 1, 23, 28, 46, 57, 79, 84, 88 and 125 Jonathan Barbero Chapters 96 and 119 Jonathan Lam Chapters 23", "and 182 JonK Chapter 88 jopasserat Chapter 25 Jordi Castilla Chapter 11 Jordy Baylac Chapter 77 Jorel Ali Chapter 71 Jorn Vernee Chapters 4, 11, 42, 43, 47, 54, 57, 75, 79, 104, 126 and 135 Joshua Carmody Chapter 2 JStef Chapter 23 Jude Niroshan Chapters 11, 57, 67 and 73 JudgingNotJudging Chapters 13 and 73 juergen d Chapter 74 jwd630 Chapter 177 K Chapter 184 k3b Chapter 35 kaartic Chapter 1 Kai Chapters 52, 54, 69 and 79 kajacx Chapter 138 kann Chapter 70 kaotikmynd Chapter 80 Kapep Chapters 11, 43 and 57 KartikKannapur Chapter 28 kasperjj Chapter 97 Kaushal28 Chapters 20, 26 and 86 Kaushik NP Chapter 11 kcoppock Chapter 47 KdgDev Chapter 10 Kelvin Kellner Chapter 159 Ken Y Chapter 122 Kenster Chapters 11, 25, 28 and 63 Kevin DiTraglia Chapter 54 Kevin Raoo\ufb01 Chapter 73 Kevin Thorne Chapters 6, 23, 40 and 69 GoalKicker.com Java Notes for Professionals 951Kichiin Chapter 87 kiedysktos Chapter 95 Kineolyan Chapter 22 Kip Chapter 58 KIRAN KUMAR MATAM Chapters 27, 30, 36, 37, 39, 49, 53, 58, 59 and 92 Kirill Sokolov Chapter 89 Kishore Tulsiani Chapter 164 kristyna Chapter 45 Krzysztof Kraso \u0144 Chapter 25 kstandell Chapters 11, 42", "and 79 KudzieChase Chapter 24 Kuroda Chapter 18 Lachlan Dowding Chapter 86 Lankymart Chapter 56 Laurel Chapters 79, 80 and 86 leaqui Chapter 77 Lernkurve Chapter 111 Li357 Chapter 106 Liju Thomas Chapters 23, 128 and 169 llamositopia Chapter 23 Loris Securo Chapters 19, 23 and 56 Luan Nico Chapters 23, 54, 89 and 103 Lukas Knuth Chapter 102 M M Chapter 14 Maarten Bodewes Chapters 20, 35, 86 and 140 Mac70 Chapter 40 madx Chapters 1, 35 and 103 Makoto Chapters 23, 70 and 74 Makyen Chapter 23 Malav Chapter 11 Malt Chapters 23, 32, 73, 88, 93 and 126 Manish Kothari Chapters 19 and 128 manouti Chapters 109, 156 and 168 Manuel Spigolon Chapter 11 Manuel Vieda Chapter 18 Marc Chapters 1 and 47 Mark Green Chapter 73 Mark Stewart Chapter 5 Mark Yisri Chapters 46 and 71 Maroun Chapter 24 Martin Frank Chapter 24 Marvin Chapters 11 and 23 MasterBlaster Chapters 48, 57 and 87 Matas Vaitkevicius Chapter 23 Mat\u011bj Kripner Chapter 126 mateuscb Chapter 77 Matsemann Chapter 88 Matt Chapters 1, 23 and 47 Matt Clark Chapters 11, 16, 58 and 86 matt freake Chapters 20, 43 and 52 Matthew Trout Chapter 73 Matthias Braun", "Chapter 11 Matthieu Chapter 94 GoalKicker.com Java Notes for Professionals 952Maxim Kreschishin Chapter 23 Maxim Plevako Chapters 11 and 23 Maximillian Laumeister Chapter 23 mayha Chapter 11 mayojava Chapters 10 and 85 MBorsch Chapter 10 Md. Nasir Uddin Bhuiyan Chapters 20 and 126 Michael Chapters 11 and 58 Michael Myers Chapters 35 and 103 Michael Piefel Chapters 23, 45 and 126 Michael von Wenckstern Chapter 7 Michael Wiles Chapter 67 michaelbahr Chapters 28, 69 and 87 Micha \u0142 Rybak Chapter 135 Mick Mnemonic Chapter 35 MikeW Chapter 79 Miles Chapters 11, 16 and 17 Miljen Mikic Chapters 23, 42, 69 and 122 Mimouni Chapter 23 Mimyck Chapter 23 MineStone Chapter 93 Minhas Kamal Chapter 23 Miroslav Bradic Chapter 88 Mitch Talmadge Chapters 1 and 23 mnoronha Chapter 1 Mo.Ashfaq Chapter 28 Mohamed Fadhl Chapter 23 Mrunal Pagnis Chapters 107 and 116 Mshnik Chapters 47, 50, 54 and 81 mszymborski Chapter 19 Muhammed Refaat Chapters 23 and 54 Mukund Chapter 1 Murat K. Chapter 126 Mureinik Chapters 57 and 59 Muto Chapter 57 Mykola Yashchenko Chapter 44 Myridium Chapter 69 NageN Chapters 23, 35, 40, 42, 46, 55, 95, 111 and 122 Nagesh Lakinepally Chapter 6 NamshubWriter Chapters 16 and", "88 Naresh Kumar Chapter 57 Nathaniel Ford Chapter 28 NatNgs Chapters 47 and 126 Nayuki Chapters 22, 23, 42 and 89 ncmathsadist Chapter 73 Nef10 Chapter 35 neohope Chapter 145 nhahtdh Chapter 80 nicael Chapter 23 Nicholas J Panella Chapter 107 Nick Donnelly Chapter 2 nickguletskii Chapter 126 Nicktar Chapters 16, 42 and 85 GoalKicker.com Java Notes for Professionals 953Nikhil R Chapters 158 and 160 Nikita Kurtin Chapters 69 and 107 Niklas Rosencrantz Chapter 162 NikolaB Chapter 11 Nishant123 Chapter 16 nishizawa23 Chapter 148 Nithanim Chapters 1, 128 and 182 niyasc Chapter 23 nobeh Chapter 73 Nolequen Chapters 35, 43 and 81 noscreenname Chapters 66 and 127 Nufail Chapter 20 Nuri Tasdemir Chapters 1, 11, 23, 40 and 57 nyarasha Chapter 1 Ocracoke Chapter 23 OldCurmudgeon Chapter 35 OldMcDonald Chapter 54 Oleg Sklyar Chapters 24, 25, 47 and 54 OliPro007 Chapter 35 Omar Ayala Chapter 114 Onur Chapters 11, 23, 47, 66 and 122 orccrusher99 Chapter 23 Ordiel Chapter 157 Ortomala Lokni Chapters 40, 43, 47 and 57 ostrichofevil Chapter 155 OverCoder Chapters 35 and 177 P.J.Meisch Chapters 11, 13, 35, 69, 100, 115 and 130 Pablo Chapter 24 Pace Chapter 42 padippist Chapter 177 paisanco Chapter 47 Panda", "Chapter 23 ParkerHalo Chapters 9, 10, 40 and 46 Paul Bellora Chapter 47 PavneetSingh Chapter 1 Pawan Chapters 57 and 111 Pawe \u0142 Albecki Chapters 23, 24, 35 and 47 PcAF Chapter 47 Peter Rader Chapter 132 peterh Chapter 72 Petter Friberg Chapters 3, 11, 24, 35, 42, 47, 56, 57, 69, 73, 82, 103, 117 and 162 phant0m Chapter 11 phat\ufb01ngers Chapter 28 philnate Chapters 47, 52, 73, 74 and 127 PirateJack Chapter 57 Piyush Baderia Chapters 11, 89 and 132 PizzaFrog Chapter 6 Polostor Chapter 24 Pops Chapter 1 Powerlord Chapters 24 and 63 ppeterka Chapters 11, 16, 23, 33, 57, 69, 70, 80, 91, 105, 107, 122 and 135 Prasad Reddy Chapter 24 Prem Singh Bist Chapter 107 GoalKicker.com Java Notes for Professionals 954P\u0159emysl \u0160\u0165astn\u00fd Chapter 11 Pseudonym Patel Chapter 148 PSN Chapter 23 PSo Chapters 11 and 86 Pujan Srivastava Chapter 73 QoP Chapters 11 and 23 qxz Chapter 40 Radek Posto \u0142owicz Chapters 10 and 69 Radiodef Chapters 23 and 24 Radouane ROUFID Chapters 1, 11, 23, 35, 47, 57, 69, 73 and 182 Rafael Pacheco Chapter 114 rahul tyagi Chapter 40 rajadilipkolli Chapter 24 Rajesh Chapter 23 Rakiti \u0107 Chapters 57 and 182", "rakwaht Chapter 170 Ralf Kleberho\ufb00 Chapters 16 and 41 Ram Chapters 1, 16, 23, 28, 42, 43, 48, 70, 74, 78, 80 and 91 RamenChef Chapters 1, 11, 23, 33, 40, 69, 73, 79, 86, 106, 126, 151 and 165 RAnders00 Chapters 10, 11, 60 and 77 Ravindra babu Chapters 54, 103, 111, 126 and 127 Ravindra HV Chapters 52 and 132 Raviteja Chapter 85 ravthiru Chapters 28, 57 and 82 rd22 Chapters 24, 33, 35, 47 and 126 rdonuk Chapters 24 and 69 Rednivrug Chapter 22 Redterd Chapter 78 Rens van der Heijden Chapter 116 reto Chapter 57 Reut Sharabani Chapters 1, 23, 40 and 57 richersoon Chapter 52 RobAu Chapters 57, 69 and 77 Robert Columbia Chapters 10, 23 and 42 Robin Chapter 75 Rocherlee Chapter 11 Rog\u00e9rio Chapter 47 rokonoid Chapters 66, 77 and 87 rolve Chapters 23, 47, 56 and 73 ronnyfm Chapter 182 Ronon Dex Chapter 35 RudolphEst Chapter 132 Ruslan Bes Chapter 20 RutledgePaulV Chapter 47 Ryan Cocuzzo Chapter 48 Ryan Hilbert Chapter 22 saagarjha Chapters 56 and 89 SachinSarawgi Chapters 1 and 131 Saclyr Barlonium Chapter 73 Sadiq Ali Chapter 71 Saif Chapter 80 Samk Chapters 33 and 35 Sanandrea Chapter 182", "GoalKicker.com Java Notes for Professionals 955Sandeep Chatterjee Chapter 182 sanjaykumar81 Chapter 117 Santhosh Ramanan Chapters 74 and 117 sargue Chapters 6 and 50 Sa\u0161a \u0160ijak Chapter 69 Saurabh Chapter 23 SaWo Chapter 150 scorpp Chapter 131 screab Chapters 130 and 183 Sergii Bishyr Chapters 23, 57 and 73 sevenforce Chapters 11, 23, 57 and 74 Shaan Chapter 86 Shettyh Chapter 127 shibli049 Chapter 142 ShivBuyya Chapters 11, 40 and 77 shmosel Chapters 23, 35, 43, 57, 67, 88 and 106 Shoe Chapters 11, 23 and 57 Siguza Chapters 1 and 47 Simon Chapter 17 Simulant Chapters 10 and 79 Siva Sainath Reddy Bandi Chapter 66 SjB Chapter 24 skia.heliou Chapter 16 Sky Chapter 11 Skylar Sutton Chapter 73 smichel Chapter 101 Smit Chapter 148 solidcell Chapters 11 and 23 someoneigna Chapter 79 Somnath Musib Chapters 26 and 85 Spina Chapters 35 and 57 SRJ Chapter 57 stackptr Chapters 1, 23 and 57 Stefan Dollase Chapter 57 stefanobaghino Chapter 88 ste\ufb00en Chapter 135 Stephan Chapter 124 Stephen CChapters 1, 5, 7, 8, 9, 10, 11, 13, 23, 25, 28, 33, 40, 42, 43, 45, 47, 50, 51, 54, 57, 59, 67, 69, 73, 77, 79, 81, 82, 85, 86, 88,", "89, 95, 102, 103, 106, 126, 127, 130, 131, 132, 133, 134, 135, 137, 139, 146, 147, 148, 169, 177, 178, 182, 183, 184 and 185 Stephen Leppik Chapters 1, 23, 47, 69 and 73 Steve K Chapter 57 stilllearning Chapters 54, 69, 77, 86 and 107 Stoyan Dekov Chapter 107 Sudhir Singh Chapters 54 and 126 Sugan Chapters 38 and 57 Sujith Niraikulathan Chapter 3 Suketu Patel Chapter 34 Suminda Sirinath S. DharmasenaChapters 127, 139, 146 and 147 sumit Chapter 85 svsav Chapter 93 GoalKicker.com Java Notes for Professionals 956S\u043d\u0430\u0111\u043e\u0448\u0192\u0430 Chapters 1, 5 and 182 taer Chapter 128 tainy Chapter 47 Tarun Maganti Chapters 17 and 35 TDG Chapter 11 thatguy Chapter 22 The Guy with The Hat Chapter 167 TheLostMind Chapter 11 ThePhantomGamer Chapters 9 and 11 Thisaru Guruge Chapters 3, 25 and 55 Thomas Chapters 23 and 47 Thomas Fritsch Chapter 91 Thomas Gerot Chapters 1 and 79 ThunderStruct Chapter 23 Tim Chapter 107 TMN Chapter 10 TNT Chapters 42 and 162 Tobias Friedinger Chapter 77 Tomasz Bawor Chapter 104 tonirush Chapters 40, 130, 162 and 182 Tony Chapter 154 Tony BenBrahim Chapters 11 and 103 Torsten Chapter 35 Tot Zam Chapters 80, 93 and 162", "tpunt Chapters 23 and 57 trashgod Chapter 184 Travis J Chapter 23 Tripta Kiroula Chapter 69 Tunaki Chapters 23, 57 and 73 TuringTux Chapters 76 and 100 Tyler Zika Chapter 48 tynn Chapters 41 and 50 Un3qual Chapter 23 Unihedron Chapters 23, 57, 67, 73, 74, 80 and 89 Universal Electricity Chapters 6 and 103 Uri Agassi Chapters 74 and 167 user1121883 Chapter 102 user1133275 Chapters 1 and 57 user140547 Chapters 67 and 125 user1803551 Chapters 10, 98 and 101 user187470 Chapter 79 user2296600 Chapter 63 user2314737 Chapter 10 user2683146 Chapters 57 and 67 user3105453 Chapters 88, 131 and 132 user6653173 Chapter 23 Uux Chapter 144 uzaif Chapters 1 and 23 vallismortis Chapter 91 Vasilis Vasilatos Chapters 25 and 66 Vasiliy Vlasov Chapters 24, 52 and 68 VatsalSura Chapters 75 and 97 Veedrac Chapter 10 GoalKicker.com Java Notes for Professionals 957Ven Chapter 23 VGR Chapters 11, 72, 114 and 185 Viacheslav Vedenin Chapters 28 and 62 Victor G. Chapters 23 and 35 victorantunes Chapter 104 Vin Chapter 1 Vince Emigh Chapter 79 vincentvanjoe Chapter 73 Vinod Kumar Kashyap Chapter 16 Vivek Anoop Chapter 18 Vlad Chapters 47 and 126 Vladimir Vagaytsev Chapter 89 Vogel612 Chapters 8, 20, 23, 28,", "41, 43, 58, 80, 104, 127 and 162 vorburger Chapter 123 vsminkov Chapter 107 vsnyc Chapter 57 Vucko Chapter 54 vvtx Chapter 11 webo80 Chapters 24 and 73 WillShackleford Chapters 102 and 164 Wilson Chapters 1, 11, 23, 47, 57 and 69 Wolfgang Chapter 73 xploreraj Chapters 24, 73 and 88 xTrollxDudex Chapters 126 and 139 xwoker Chapters 19 and 74 yitzih Chapter 123 yiwei Chapter 69 Yogesh Chapter 73 Yohanes Khosiawan \u8bb8\u5148 \u6c49Chapter 4 yuku Chapters 11 and 23 Yury Fedorov Chapters 23 and 107 Zachary David Saunders Chapter 1 Ze Rubeus Chapters 57 and 182 Zircon Chapters 79 and 134 \u0126\u011b\u0180\u0451 Chapters 78, 120 and 152 \u0141ukasz Piaszczyk Chapter 19 \u03a6Xoc\u0119 \uc6c3 \u041fepe\u00fapa \u30c4 Chapters 11, 17, 21, 23, 25, 43, 78 and 103 \u0280\u0274 Chapters 1 and 25 You may also like"], "sources": {"Java Notes for ProfessionalsJava Notes for Professionals GoalKicker.com Free Programming BooksDisclaimer This is an unocial free book created for educational purposes and is not aliated with ocial Java groups or companys. All trademarks and registered trademarks are the property of their respective owners 900 pages of professional hints and tricks Contents About 1 ................................................................................................................................................................................... Chapter 1 Getting started with Java Language 2 .......................................................................................... Section 1.1 Creating Your First Java Program 2 ........................................................................................................... Chapter 2 Type Conversion 8 .................................................................................................................................... Section 2.1 Numeric primitive casting 8 ......................................................................................................................... Section 2.2 Basic Numeric Promotion 8 ........................................................................................................................ Section 2.3 Non-numeric primitive casting 8 ................................................................................................................ Section 2.4 Object casting 9 ........................................................................................................................................... Section 2.5 Testing if an object can be cast using instanceof 9 ................................................................................. Chapter 3 Getters and Setters 10 ........................................................................................................................... Section 3.1 Using a setter or getter to implement a constraint 10 ............................................................................. Section 3.2 Why Use Getters and Setters? 10 .............................................................................................................. Section 3.3 Adding Getters and Setters 11 ................................................................................................................... Chapter 4 Reference Data Types 13 .................................................................................................................... Section 4.1 Dereferencing 13 .......................................................................................................................................... Section 4.2 Instantiating a reference type 13 ............................................................................................................... Chapter 5 Java Compiler - javac 14 .................................................................................................................... Section 5.1 The javac command - getting started 14 ................................................................................................ Section 5.2 Compiling for a dierent": "input.pdf", "version of Java 16 ............................................................................................ Chapter 6 Documenting Java Code 18 ................................................................................................................. Section 6.1 Building Javadocs From the Command Line 18 ....................................................................................... Section 6.2 Class Documentation 18 ............................................................................................................................. Section 6.3 Method Documentation 19 ......................................................................................................................... Section 6.4 Package Documentation 20 ....................................................................................................................... Section 6.5 Links 20 ......................................................................................................................................................... Section 6.6 Code snippets inside documentation 21 ................................................................................................... Section 6.7 Field Documentation 22 .............................................................................................................................. Section 6.8 Inline Code Documentation 22 ................................................................................................................... Chapter 7 Command line Argument Processing 24 ....................................................................................... Section 7.1 Argument processing using GWT ToolBase 24 ......................................................................................... Section 7.2 Processing arguments by hand 24 ............................................................................................................ Chapter 8 The Java Command - java and javaw 27 ................................................................................. Section 8.1 Entry point classes 27 .................................................................................................................................. Section 8.2 Troubleshooting the java command 27 .................................................................................................. Section 8.3 Running a Java application with library dependencies 29 ..................................................................... Section 8.4 Java Options 30 ........................................................................................................................................... Section 8.5 Spaces and other special characters in arguments 31 ........................................................................... Section 8.6 Running an executable JAR \ufb01le 33 ............................................................................................................ Section 8.7 Running a Java applications via a main class 33 ................................................................................. Chapter 9 Literals 35 ...................................................................................................................................................... Section 9.1 Using underscore to improve readability 35 ............................................................................................. Section 9.2 Hexadecimal, Octal and Binary literals 35 ................................................................................................ Section 9.3 Boolean literals 36 ....................................................................................................................................... Section 9.4 String literals": "input.pdf", "36 ........................................................................................................................................... Section 9.5 The Null literal 37 ......................................................................................................................................... Section 9.6 Escape sequences in literals 37 .................................................................................................................. Section 9.7 Character literals 38 .................................................................................................................................... Section 9.8 Decimal Integer literals 38 .......................................................................................................................... Section 9.9 Floating-point literals 39 ............................................................................................................................. Chapter 10 Primitive Data Types 42 ....................................................................................................................... Section 10.1 The char primitive 42 .................................................................................................................................. Section 10.2 Primitive Types Cheatsheet 42 ................................................................................................................. Section 10.3 The \ufb02oat primitive 43 ................................................................................................................................. Section 10.4 The int primitive 44 ..................................................................................................................................... Section 10.5 Converting Primitives 45 ............................................................................................................................ Section 10.6 Memory consumption of primitives vs. boxed primitives 45 .................................................................. Section 10.7 The double primitive 46 ............................................................................................................................. Section 10.8 The long primitive 47 ................................................................................................................................. Section 10.9 The boolean primitive 48 ........................................................................................................................... Section 10.10 The byte primitive 48 ................................................................................................................................ Section 10.11 Negative value representation 49 ............................................................................................................ Section 10.12 The short primitive 50 ............................................................................................................................... Chapter 11 Strings 51 ...................................................................................................................................................... Section 11.1 Comparing Strings 51 .................................................................................................................................. Section 11.2 Changing the case of characters within a String 53 ............................................................................... Section 11.3 Finding a String Within Another String 55 ................................................................................................. Section 11.4 String pool and heap storage 56 ............................................................................................................... Section 11.5 Splitting Strings 57 ....................................................................................................................................... Section 11.6 Joining Strings with a delimiter 59 ............................................................................................................ Section 11.7 String concatenation and StringBuilders 60 ............................................................................................. Section 11.8 Substrings 61": "input.pdf", "............................................................................................................................................... Section 11.9 Platform independent new line separator 62 ........................................................................................... Section 11.10 Reversing Strings 62 .................................................................................................................................. Section 11.11 Adding toString method for custom objects 63 .................................................................................... Section 11.12 Remove Whitespace from the Beginning and End of a String 64 ........................................................ Section 11.13 Case insensitive switch 64 ......................................................................................................................... Section 11.14 Replacing parts of Strings 65 ................................................................................................................... Section 11.15 Getting the length of a String 66 .............................................................................................................. Section 11.16 Getting the nth character in a String 66 .................................................................................................. Section 11.17 Counting occurrences of a substring or character in a string 66 ......................................................... Chapter 12 StringBuer 68 ......................................................................................................................................... Section 12.1 String Buer class 68 .................................................................................................................................. Chapter 13 StringBuilder 69 ........................................................................................................................................ Section 13.1 Comparing StringBuer, StringBuilder, Formatter and StringJoiner 69 ............................................... Section 13.2 Repeat a String n times 70 ........................................................................................................................ Chapter 14 String Tokenizer 71 ................................................................................................................................ Section 14.1 StringTokenizer Split by space 71 ............................................................................................................. Section 14.2 StringTokenizer Split by comma , 71 ...................................................................................................... Chapter 15 Splitting a string into \ufb01xed length parts 72 ............................................................................... Section 15.1 Break a string up into substrings all of a known length 72 .................................................................... Section 15.2 Break a string up into substrings all of variable length 72 .................................................................... Chapter 16 Date Class 73 ............................................................................................................................................. Section 16.1 Convert java.util.Date": "input.pdf", "to java.sql.Date 73 ................................................................................................. Section 16.2 A basic date output 73 ............................................................................................................................... Section 16.3 Java 8 LocalDate and LocalDateTime objects 74 .................................................................................. Section 16.4 Creating a Speci\ufb01c Date 75 ....................................................................................................................... Section 16.5 Converting Date to a certain String format 75 ....................................................................................... Section 16.6 LocalTime 76 ............................................................................................................................................... Section 16.7 Convert formatted string representation of date to Date object 76 .................................................... Section 16.8 Creating Date objects 77 ........................................................................................................................... Section 16.9 Comparing Date objects 77 ...................................................................................................................... Section 16.10 Converting String into Date 80 ................................................................................................................ Section 16.11 Time Zones and java.util.Date 80 ............................................................................................................. Chapter 17 Dates and Time java.time. 82 ....................................................................................................... Section 17.1 Calculate Dierence between 2 LocalDates 82 ....................................................................................... Section 17.2 Date and time 82 ........................................................................................................................................ Section 17.3 Operations on dates and times 82 ........................................................................................................... Section 17.4 Instant 82 ..................................................................................................................................................... Section 17.5 Usage of various classes of Date Time API 83 ........................................................................................ Section 17.6 Date Time Formatting 85 ........................................................................................................................... Section 17.7 Simple Date Manipulations 85 ................................................................................................................... Chapter 18 LocalTime 87 .............................................................................................................................................. Section 18.1 Amount of time between two LocalTime 87 ............................................................................................ Section 18.2 Intro 88 ........................................................................................................................................................ Section 18.3 Time Modi\ufb01cation 88 .................................................................................................................................. Section 18.4 Time Zones and their time dierence 88 ................................................................................................. Chapter 19 BigDecimal 90 ............................................................................................................................................ Section 19.1 Comparing BigDecimals 90": "input.pdf", "........................................................................................................................ Section 19.2 Using BigDecimal instead of \ufb02oat 90 ....................................................................................................... Section 19.3 BigDecimal.valueOf 91 ............................................................................................................................ Section 19.4 Mathematical operations with BigDecimal 91 ......................................................................................... Section 19.5 Initialization of BigDecimals with value zero, one or ten 94 ................................................................... Section 19.6 BigDecimal objects are immutable 94 ..................................................................................................... Chapter 20 BigInteger 96 ............................................................................................................................................ Section 20.1 Initialization 96 ............................................................................................................................................ Section 20.2 BigInteger Mathematical Operations Examples 97 ............................................................................... Section 20.3 Comparing BigIntegers 99 ........................................................................................................................ Section 20.4 Binary Logic Operations on BigInteger 100 ........................................................................................... Section 20.5 Generating random BigIntegers 101 ....................................................................................................... Chapter 21 NumberFormat 103 ................................................................................................................................. Section 21.1 NumberFormat 103 .................................................................................................................................... Chapter 22 Bit Manipulation 104 .............................................................................................................................. Section 22.1 Checking, setting, clearing, and toggling individual bits. Using long as bit mask 104 ........................ Section 22.2 java.util.BitSet class 104 ............................................................................................................................ Section 22.3 Checking if a number is a power of 2 105 .............................................................................................. Section 22.4 Signed vs unsigned shift 107 .................................................................................................................... Section 22.5 Expressing the power of 2 107 ................................................................................................................. Section 22.6 Packing unpacking values as bit fragments 108 ................................................................................ Chapter 23 Arrays 109 ................................................................................................................................................... Section 23.1 Creating and Initializing Arrays 109 ......................................................................................................... Section 23.2 Creating a List from an Array 115 ........................................................................................................... Section 23.3 Creating an Array from a Collection 117 ................................................................................................ Section 23.4 Multidimensional and": "input.pdf", "Jagged Arrays 117 .............................................................................................. Section 23.5 ArrayIndexOutOfBoundsException 119 .................................................................................................. Section 23.6 Array Covariance 120 ............................................................................................................................... Section 23.7 Arrays to Stream 121 ................................................................................................................................ Section 23.8 Iterating over arrays 121 .......................................................................................................................... Section 23.9 Arrays to a String 123 ............................................................................................................................... Section 23.10 Sorting arrays 124 .................................................................................................................................... Section 23.11 Getting the Length of an Array 126 ........................................................................................................ Section 23.12 Finding an element in an array 126 ....................................................................................................... Section 23.13 How do you change the size of an array? 127 ..................................................................................... Section 23.14 Converting arrays between primitives and boxed types 128 .............................................................. Section 23.15 Remove an element from an array 129 ................................................................................................ Section 23.16 Comparing arrays for equality 130 ........................................................................................................ Section 23.17 Copying arrays 130 .................................................................................................................................. Section 23.18 Casting Arrays 131 ................................................................................................................................... Chapter 24 Collections 133 ......................................................................................................................................... Section 24.1 Removing items from a List within a loop 133 ........................................................................................ Section 24.2 Constructing collections from existing data 135 .................................................................................... Section 24.3 Declaring an ArrayList and adding objects 137 ..................................................................................... Section 24.4 Iterating over Collections 137 .................................................................................................................. Section 24.5 Immutable Empty Collections 139 ........................................................................................................... Section 24.6 Sub Collections 139 ................................................................................................................................... Section 24.7 Unmodi\ufb01able Collection 140 ..................................................................................................................... Section 24.8 Pitfall concurrent modi\ufb01cation exceptions 141 ..................................................................................... Section 24.9 Removing matching items from Lists using Iterator 141 ...................................................................... Section": "input.pdf", "24.10 Join lists 142 ............................................................................................................................................. Section 24.11 Creating your own Iterable structure for use with Iterator or for-each loop 142 .............................. Section 24.12 Collections and Primitive Values 144 ..................................................................................................... Chapter 25 Lists 146 ....................................................................................................................................................... Section 25.1 Sorting a generic list 146 ........................................................................................................................... Section 25.2 Convert a list of integers to a list of strings 147 ..................................................................................... Section 25.3 Classes implementing List - Pros and Cons 147 ..................................................................................... Section 25.4 Finding common elements between 2 lists 150 ..................................................................................... Section 25.5 In-place replacement of a List element 150 ........................................................................................... Section 25.6 Making a list unmodi\ufb01able 151 ................................................................................................................ Section 25.7 Moving objects around in the list 151 ...................................................................................................... Section 25.8 Creating, Adding and Removing element from an ArrayList 152 ........................................................ Section 25.9 Creating a List 152 ..................................................................................................................................... Section 25.10 Positional Access Operations 153 .......................................................................................................... Section 25.11 Iterating over elements in a list 155 ........................................................................................................ Section 25.12 Removing elements from list B that are present in the list A 155 ....................................................... Chapter 26 Sets 157 ........................................................................................................................................................ Section 26.1 Initialization 157 .......................................................................................................................................... Section 26.2 Basics of Set 157 ........................................................................................................................................ Section 26.3 Types and Usage of Sets 158 ................................................................................................................... Section 26.4 Create a list from an existing Set 159 ...................................................................................................... Section 26.5 Eliminating duplicates using": "input.pdf", "Set 159 ....................................................................................................... Section 26.6 Declaring a HashSet with values 160 ...................................................................................................... Chapter 27 List vs Set 161 ........................................................................................................................................... Section 27.1 List vs Set 161 ............................................................................................................................................. Chapter 28 Maps 162 ...................................................................................................................................................... Section 28.1 Iterating Map Entries Eciently 162 ......................................................................................................... Section 28.2 Usage of HashMap 164 ............................................................................................................................ Section 28.3 Using Default Methods of Map from Java 8 165 ................................................................................... Section 28.4 Iterating through the contents of a Map 167 ......................................................................................... Section 28.5 Merging, combine and composing Maps 168 ........................................................................................ Section 28.6 Add multiple items 169 .............................................................................................................................. Section 28.7 Creating and Initializing Maps 171 ........................................................................................................... Section 28.8 Check if key exists 172 .............................................................................................................................. Section 28.9 Add an element 172 .................................................................................................................................. Section 28.10 Clear the map 173 .................................................................................................................................... Section 28.11 Use custom object as key 173 ................................................................................................................. Chapter 29 LinkedHashMap 175 ............................................................................................................................... Section 29.1 Java LinkedHashMap class 175 ............................................................................................................... Chapter 30 WeakHashMap 176 ................................................................................................................................. Section 30.1 Concepts of WeakHashmap 176 .............................................................................................................. Chapter 31 SortedMap 177 .......................................................................................................................................... Section 31.1 Introduction to sorted Map 177 ................................................................................................................. Chapter 32 TreeMap and TreeSet 178 .................................................................................................................. Section 32.1 TreeMap of a simple Java type 178 ........................................................................................................ Section 32.2 TreeSet of a simple Java Type 178 ......................................................................................................... Section 32.3 TreeMapTreeSet of a custom Java type 179 ....................................................................................... Section": "input.pdf", "32.4 TreeMap and TreeSet Thread Safety 180 .............................................................................................. Chapter 33 Queues and Deques 182 ...................................................................................................................... Section 33.1 The usage of the PriorityQueue 182 ......................................................................................................... Section 33.2 Deque 182 ................................................................................................................................................... Section 33.3 Stacks 183 ................................................................................................................................................... Section 33.4 BlockingQueue 184 .................................................................................................................................... Section 33.5 LinkedList as a FIFO Queue 185 ............................................................................................................... Section 33.6 Queue Interface 186 .................................................................................................................................. Chapter 34 Dequeue Interface 187 ........................................................................................................................ Section 34.1 Adding Elements to Deque 187 ................................................................................................................. Section 34.2 Removing Elements from Deque 187 ...................................................................................................... Section 34.3 Retrieving Element without Removing 187 ............................................................................................. Section 34.4 Iterating through Deque 187 .................................................................................................................... Chapter 35 Enums 189 ................................................................................................................................................... Section 35.1 Declaring and using a basic enum 189 .................................................................................................... Section 35.2 Enums with constructors 192 ................................................................................................................... Section 35.3 Enums with Abstract Methods 193 ........................................................................................................... Section 35.4 Implements Interface 194 ......................................................................................................................... Section 35.5 Implement Singleton pattern with a single-element enum 195 ............................................................ Section 35.6 Using methods and static blocks 196 ...................................................................................................... Section 35.7 Zero instance enum 196 ........................................................................................................................... Section 35.8 Enum as a bounded type parameter 197 ............................................................................................... Section 35.9 Documenting enums 197 .......................................................................................................................... Section 35.10 Enum constant speci\ufb01c body 198 ........................................................................................................... Section 35.11 Getting the values of an enum 199 ......................................................................................................... Section 35.12 Enum Polymorphism Pattern 200 ........................................................................................................... Section 35.13 Compare and": "input.pdf", "Contains for Enum values 201 ........................................................................................ Section 35.14 Get enum constant by name 201 ........................................................................................................... Section 35.15 Enum with properties \ufb01elds 202 ........................................................................................................... Section 35.16 Convert enum to String 203 .................................................................................................................... Section 35.17 Enums with static \ufb01elds 203 ..................................................................................................................... Chapter 36 Enum Map 205 ........................................................................................................................................... Section 36.1 Enum Map Book Example 205 .................................................................................................................. Chapter 37 EnumSet class 206 .................................................................................................................................. Section 37.1 Enum Set Example 206 .............................................................................................................................. Chapter 38 Enum starting with number 207 ...................................................................................................... Section 38.1 Enum with name at beginning 207 ........................................................................................................... Chapter 39 Hashtable 208 ........................................................................................................................................... Section 39.1 Hashtable 208 ............................................................................................................................................. Chapter 40 Operators 209 .......................................................................................................................................... Section 40.1 The IncrementDecrement Operators -- 209 ................................................................................ Section 40.2 The Conditional Operator ? 209 .......................................................................................................... Section 40.3 The Bitwise and Logical Operators , , , 211 .................................................................................. Section 40.4 The String Concatenation Operator 212 ........................................................................................... Section 40.5 The Arithmetic Operators , -, , , 214 ............................................................................................. Section 40.6 The Shift Operators , and 216 ............................................................................................... Section 40.7 The Instanceof Operator 217 ................................................................................................................... Section 40.8 The Assignment Operators , , -, , , , , , , , and 218 ............................. Section 40.9 The conditional-and and conditional-or Operators and 220 .................................................. Section 40.10 The Relational Operators , , , 221 ............................................................................................": "input.pdf", "Section 40.11 The Equality Operators , ! 222 ......................................................................................................... Section 40.12 The Lambda operator - 224 ............................................................................................................. Chapter 41 Constructors 225 ..................................................................................................................................... Section 41.1 Default Constructor 225 ............................................................................................................................. Section 41.2 Call parent constructor 226 ....................................................................................................................... Section 41.3 Constructor with Arguments 227 .............................................................................................................. Chapter 42 Object Class Methods and Constructor 229 ............................................................................. Section 42.1 hashCode method 229 ............................................................................................................................ Section 42.2 toString method 231 ............................................................................................................................... Section 42.3 equals method 232 ................................................................................................................................. Section 42.4 wait and notify methods 234 .............................................................................................................. Section 42.5 getClass method 236 .............................................................................................................................. Section 42.6 clone method 237 ................................................................................................................................... Section 42.7 Object constructor 238 .............................................................................................................................. Section 42.8 \ufb01nalize method 239 ................................................................................................................................ Chapter 43 Annotations 241 ...................................................................................................................................... Section 43.1 The idea behind Annotations 241 ............................................................................................................. Section 43.2 De\ufb01ning annotation types 241 ................................................................................................................. Section 43.3 Runtime annotation checks via re\ufb02ection 243 ....................................................................................... Section 43.4 Built-in annotations 243 ............................................................................................................................ Section 43.5 Compile time processing using annotation processor 246 ................................................................... Section 43.6 Repeating Annotations 250 ...................................................................................................................... Section 43.7 Inherited Annotations 251 ......................................................................................................................... Section 43.8 Getting Annotation values at run-time 252 ............................................................................................. Section 43.9 Annotations for this and receiver parameters 253 .............................................................................. Section 43.10 Add multiple annotation values 254 ....................................................................................................... Chapter 44 Immutable Class 255 ............................................................................................................................ Section 44.1 Example without mutable refs 255 ...........................................................................................................": "input.pdf", "Section 44.2 What is the advantage of immutability? 255 ......................................................................................... Section 44.3 Rules to de\ufb01ne immutable classes 255 ................................................................................................... Section 44.4 Example with mutable refs 256 ................................................................................................................ Chapter 45 Immutable Objects 257 ....................................................................................................................... Section 45.1 Creating an immutable version of a type using defensive copying 257 .............................................. Section 45.2 The recipe for an immutable class 257 ................................................................................................... Section 45.3 Typical design \ufb02aws which prevent a class from being immutable 258 ............................................. Chapter 46 Visibility controlling access to members of a class 262 ................................................. Section 46.1 Private Visibility 262 ................................................................................................................................... Section 46.2 Public Visibility 262 .................................................................................................................................... Section 46.3 Package Visibility 263 ................................................................................................................................ Section 46.4 Protected Visibility 263 .............................................................................................................................. Section 46.5 Summary of Class Member Access Modi\ufb01ers 264 ................................................................................. Section 46.6 Interface members 264 ............................................................................................................................. Chapter 47 Generics 265 .............................................................................................................................................. Section 47.1 Creating a Generic Class 265 .................................................................................................................... Section 47.2 Deciding between T, ? super T, and ? extends T 267 ........................................................................ Section 47.3 The Diamond 269 ....................................................................................................................................... Section 47.4 Declaring a Generic Method 269 .............................................................................................................. Section 47.5 Requiring multiple upper bounds extends A B 270 ....................................................................... Section 47.6 Obtain class that satis\ufb01es generic parameter at runtime 270 ............................................................. Section 47.7 Bene\ufb01ts of Generic class and interface 271 ........................................................................................... Section 47.8": "input.pdf", "Instantiating a generic type 272 .............................................................................................................. Section 47.9 Creating a Bounded Generic Class 272 ................................................................................................... Section 47.10 Referring to the declared generic type within its own declaration 274 ............................................. Section 47.11 Binding generic parameter to more than 1 type 275 ............................................................................ Section 47.12 Using Generics to auto-cast 276 ............................................................................................................. Section 47.13 Use of instanceof with Generics 276 ...................................................................................................... Section 47.14 Dierent ways for implementing a Generic Interface or extending a Generic Class 278 ............. Chapter 48 Classes and Objects 280 ..................................................................................................................... Section 48.1 Overloading Methods 280 ......................................................................................................................... Section 48.2 Explaining what is method overloading and overriding 281 ................................................................ Section 48.3 Constructors 283 ........................................................................................................................................ Section 48.4 Initializing static \ufb01nal \ufb01elds using a static initializer 284 ........................................................................ Section 48.5 Basic Object Construction and Use 285 .................................................................................................. Section 48.6 Simplest Possible Class 287 ...................................................................................................................... Section 48.7 Object Member vs Static Member 287 .................................................................................................... Chapter 49 Local Inner Class 289 ............................................................................................................................ Section 49.1 Local Inner Class 289 ................................................................................................................................. Chapter 50 Nested and Inner Classes 290 .......................................................................................................... Section 50.1 A Simple Stack Using a Nested Class 290 ............................................................................................... Section 50.2 Static vs Non Static Nested Classes 290 ................................................................................................. Section 50.3 Access Modi\ufb01ers for Inner Classes 292 ................................................................................................... Section 50.4 Anonymous Inner Classes 293 .................................................................................................................": "input.pdf", "Section 50.5 Create instance of non-static inner class from outside 294 ................................................................. Section 50.6 Method Local Inner Classes 295 .............................................................................................................. Section 50.7 Accessing the outer class from a non-static inner class 295 ................................................................ Chapter 51 The java.util.Objects Class 297 ......................................................................................................... Section 51.1 Basic use for object null check 297 ........................................................................................................... Section 51.2 Objects.nonNull method reference use in stream api 297 .................................................................. Chapter 52 Default Methods 298 ............................................................................................................................. Section 52.1 Basic usage of default methods 298 ........................................................................................................ Section 52.2 Accessing overridden default methods from implementing class 298 ............................................... Section 52.3 Why use Default Methods? 299 ............................................................................................................... Section 52.4 Accessing other interface methods within default method 299 ........................................................... Section 52.5 Default method multiple inheritance collision 300 ................................................................................. Section 52.6 Class, Abstract class and Interface method precedence 301 .............................................................. Chapter 53 Packages 303 ............................................................................................................................................ Section 53.1 Using Packages to create classes with the same name 303 ................................................................. Section 53.2 Using Package Protected Scope 303 ...................................................................................................... Chapter 54 Inheritance 305 ........................................................................................................................................ Section 54.1 Inheritance 305 ........................................................................................................................................... Section 54.2 Abstract Classes 306 ................................................................................................................................. Section 54.3 Using \ufb01nal to restrict inheritance and overriding 308 .......................................................................... Section 54.4 The Liskov Substitution Principle 309 ...................................................................................................... Section 54.5 Abstract class and Interface usage Is-a relation vs Has-a capability": "input.pdf", "310 ................................... Section 54.6 Static Inheritance 313 ................................................................................................................................ Section 54.7 Programming to an interface 314 ........................................................................................................... Section 54.8 Overriding in Inheritance 316 ................................................................................................................... Section 54.9 Variable shadowing 317 ........................................................................................................................... Section 54.10 Narrowing and Widening of object references 317 ............................................................................. Section 54.11 Inheritance and Static Methods 318 ........................................................................................................ Chapter 55 Reference Types 320 ............................................................................................................................ Section 55.1 Dierent Reference Types 320 ................................................................................................................. Chapter 56 Console IO 322 ........................................................................................................................................ Section 56.1 Reading user input from the console 322 ................................................................................................ Section 56.2 Aligning strings in console 323 ................................................................................................................. Section 56.3 Implementing Basic Command-Line Behavior 324 ................................................................................ Chapter 57 Streams 326 ............................................................................................................................................... Section 57.1 Using Streams 326 ..................................................................................................................................... Section 57.2 Consuming Streams 328 ........................................................................................................................... Section 57.3 Creating a Frequency Map 330 ................................................................................................................ Section 57.4 In\ufb01nite Streams 330 ................................................................................................................................... Section 57.5 Collect Elements of a Stream into a Collection 331 ............................................................................... Section 57.6 Using Streams to Implement Mathematical Functions 334 .................................................................. Section 57.7 Flatten Streams with \ufb02atMap 334 ......................................................................................................... Section 57.8 Parallel Stream 335 ................................................................................................................................... Section 57.9 Creating a Stream 336 .............................................................................................................................. Section 57.10 Finding Statistics about Numerical Streams 337 .................................................................................. Section 57.11 Converting an iterator to a stream 337 .................................................................................................. Section 57.12 Using IntStream to iterate over indexes 337 ......................................................................................... Section 57.13 Concatenate Streams": "input.pdf", "338 ....................................................................................................................... Section 57.14 Reduction with Streams 338 .................................................................................................................... Section 57.15 Using Streams of Map.Entry to Preserve Initial Values after Mapping 341 ....................................... Section 57.16 IntStream to String 341 ............................................................................................................................ Section 57.17 Finding the First Element that Matches a Predicate 341 ...................................................................... Section 57.18 Using Streams and Method References to Write Self-Documenting Processes 342 ........................ Section 57.19 Converting a Stream of Optional to a Stream of Values 343 .............................................................. Section 57.20 Get a Slice of a Stream 343 .................................................................................................................... Section 57.21 Create a Map based on a Stream 343 ................................................................................................... Section 57.22 Joining a stream to a single String 344 ................................................................................................ Section 57.23 Sort Using Stream 345 ............................................................................................................................ Section 57.24 Streams of Primitives 346 ....................................................................................................................... Section 57.25 Stream operations categories 346 ........................................................................................................ Section 57.26 Collect Results of a Stream into an Array 347 ..................................................................................... Section 57.27 Generating random Strings using Streams 347 ................................................................................... Chapter 58 InputStreams and OutputStreams 349 ....................................................................................... Section 58.1 Closing Streams 349 .................................................................................................................................. Section 58.2 Reading InputStream into a String 349 ................................................................................................... Section 58.3 Wrapping InputOutput Streams 350 ..................................................................................................... Section 58.4 DataInputStream Example 351 ................................................................................................................ Section 58.5 Writing bytes to an OutputStream 351 ................................................................................................... Section 58.6 Copying Input Stream to Output Stream 351 ......................................................................................... Chapter 59": "input.pdf", "Readers and Writers 353 .................................................................................................................... Section 59.1 BueredReader 353 ................................................................................................................................... Section 59.2 StringWriter Example 354 ......................................................................................................................... Chapter 60 Preferences 355 ....................................................................................................................................... Section 60.1 Using preferences 355 ............................................................................................................................... Section 60.2 Adding event listeners 355 ....................................................................................................................... Section 60.3 Getting sub-nodes of Preferences 356 .................................................................................................... Section 60.4 Coordinating preferences access across multiple application instances 357 .................................... Section 60.5 Exporting preferences 357 ....................................................................................................................... Section 60.6 Importing preferences 358 ....................................................................................................................... Section 60.7 Removing event listeners 359 .................................................................................................................. Section 60.8 Getting preferences values 360 ............................................................................................................... Section 60.9 Setting preferences values 360 ................................................................................................................ Chapter 61 Collection Factory Methods 361 ....................................................................................................... Section 61.1 ListE Factory Method Examples 361 ..................................................................................................... Section 61.2 SetE Factory Method Examples 361 ..................................................................................................... Section 61.3 MapK, V Factory Method Examples 361 .............................................................................................. Chapter 62 Alternative Collections 362 ................................................................................................................ Section 62.1 Multimap in Guava, Apache and Eclipse Collections 362 ....................................................................... Section 62.2 Apache HashBag, Guava HashMultiset and Eclipse HashBag 364 ...................................................... Section 62.3 Compare operation with collections - Create collections 366 .............................................................. Chapter 63 Concurrent Collections 371 ................................................................................................................ Section 63.1 Thread-safe Collections 371 ...................................................................................................................... Section 63.2 Insertion into ConcurrentHashMap 371 .................................................................................................. Section 63.3 Concurrent Collections 372 ....................................................................................................................... Chapter 64 Choosing Collections 374 .................................................................................................................... Section 64.1 Java Collections Flowchart 374 ................................................................................................................ Chapter 65 super keyword": "input.pdf", "375 ................................................................................................................................. Section 65.1 Super keyword use with examples 375 .................................................................................................... Chapter 66 Serialization 378 ...................................................................................................................................... Section 66.1 Basic Serialization in Java 378 .................................................................................................................. Section 66.2 Custom Serialization 379 .......................................................................................................................... Section 66.3 Versioning and serialVersionUID 382 ...................................................................................................... Section 66.4 Serialization with Gson 383 ....................................................................................................................... Section 66.5 Custom JSON Deserialization with Jackson 384 .................................................................................... Chapter 67 Optional 387 ............................................................................................................................................... Section 67.1 Map 387 ....................................................................................................................................................... Section 67.2 Return default value if Optional is empty 388 ........................................................................................ Section 67.3 Throw an exception, if there is no value 388 ........................................................................................... Section 67.4 Lazily provide a default value using a Supplier 388 .............................................................................. Section 67.5 Filter 389 ..................................................................................................................................................... Section 67.6 Using Optional containers for primitive number types 389 .................................................................. Section 67.7 Run code only if there is a value present 390 ......................................................................................... Section 67.8 FlatMap 390 ................................................................................................................................................ Chapter 68 Object References 391 ......................................................................................................................... Section 68.1 Object References as method parameters 391 ...................................................................................... Chapter 69 Exceptions and exception handling 394 ...................................................................................... Section 69.1 Catching an exception with try-catch 394 ............................................................................................... Section 69.2 The try-with-resources statement 395 .................................................................................................... Section 69.3 Custom Exceptions 398 ............................................................................................................................. Section 69.4 Handling InterruptedException 400 ......................................................................................................... Section 69.5 Return statements in try catch block 401 ............................................................................................... Section 69.6 Introduction 402 ......................................................................................................................................... Section": "input.pdf", "69.7 The Java Exception Hierarchy - Unchecked and Checked Exceptions 403 ........................................ Section 69.8 Creating and reading stacktraces 406 .................................................................................................... Section 69.9 Throwing an exception 409 ...................................................................................................................... Section 69.10 Advanced features of Exceptions 411 ................................................................................................... Section 69.11 The try-\ufb01nally and try-catch-\ufb01nally statements 412 ............................................................................ Section 69.12 The throws clause in a method declaration 414 ................................................................................. Chapter 70 Calendar and its Subclasses 416 .................................................................................................... Section 70.1 Creating Calendar objects 416 ................................................................................................................. Section 70.2 Increasing Decreasing calendar \ufb01elds 416 .......................................................................................... Section 70.3 Subtracting calendars 416 ........................................................................................................................ Section 70.4 Finding AMPM 416 ................................................................................................................................... Chapter 71 Using the static keyword 418 ............................................................................................................ Section 71.1 Reference to non-static member from static context 418 ..................................................................... Section 71.2 Using static to declare constants 418 ...................................................................................................... Chapter 72 Properties Class 420 .............................................................................................................................. Section 72.1 Loading properties 420 .............................................................................................................................. Section 72.2 Saving Properties as XML 420 .................................................................................................................. Section 72.3 Property \ufb01les caveat trailing whitespace 421 ........................................................................................ Chapter 73 Lambda Expressions 424 ..................................................................................................................... Section 73.1 Introduction to Java lambdas 424 ........................................................................................................... Section 73.2 Using Lambda Expressions to Sort a Collection 427 ............................................................................. Section 73.3 Method References 428 ............................................................................................................................ Section 73.4 Implementing multiple interfaces 430 ..................................................................................................... Section 73.5 Lambda - Listener Example 430 .............................................................................................................. Section 73.6 Java Closures with lambda": "input.pdf", "expressions 431 .......................................................................................... Section 73.7 Lambdas and memory utilization 432 ..................................................................................................... Section 73.8 Using lambda expression with your own functional interface 433 ...................................................... Section 73.9 Traditional style to Lambda style 433 ..................................................................................................... Section 73.10 return only returns from the lambda, not the outer method 434 ..................................................... Section 73.11 Lambdas and Execute-around Pattern 436 ........................................................................................... Section 73.12 Using lambda expressions predicates to get a certain values from a list 436 ........................... Chapter 74 Basic Control Structures 438 ............................................................................................................ Section 74.1 Switch statement 438 ................................................................................................................................. Section 74.2 do...while Loop 439 ..................................................................................................................................... Section 74.3 For Each 440 ............................................................................................................................................... Section 74.4 Continue Statement in Java 441 .............................................................................................................. Section 74.5 If Else If Else Control 441 ..................................................................................................................... Section 74.6 For Loops 441 ............................................................................................................................................. Section 74.7 Ternary Operator 442 ............................................................................................................................... Section 74.8 Try ... Catch ... Finally 443 .......................................................................................................................... Section 74.9 Break 443 .................................................................................................................................................... Section 74.10 While Loops 444 ....................................................................................................................................... Section 74.11 If Else 444 ................................................................................................................................................ Section 74.12 Nested break continue 444 .................................................................................................................. Chapter 75 BueredWriter 446 ................................................................................................................................ Section 75.1 Write a line of text to File 446 .................................................................................................................... Chapter 76 New File IO 447 ....................................................................................................................................... Section 76.1 Creating paths 447 ..................................................................................................................................... Section 76.2 Manipulating paths 447 ............................................................................................................................. Section 76.3 Retrieving information about a path": "input.pdf", "447 ................................................................................................ Section 76.4 Retrieving information using the \ufb01lesystem 448 .................................................................................... Section 76.5 Reading \ufb01les 449 ........................................................................................................................................ Section 76.6 Writing \ufb01les 449 .......................................................................................................................................... Chapter 77 File IO 450 ................................................................................................................................................. Section 77.1 Migrating from java.io.File to Java 7 NIO java.nio.\ufb01le.Path 450 .......................................................... Section 77.2 Reading an image from a \ufb01le 452 ........................................................................................................... Section 77.3 File ReadWrite Using FileInputStreamFileOutputStream 452 ........................................................... Section 77.4 Reading all bytes to a byte 453 ............................................................................................................ Section 77.5 Copying a \ufb01le using Channel 454 ............................................................................................................. Section 77.6 Writing a byte to a \ufb01le 454 ..................................................................................................................... Section 77.7 Stream vs WriterReader API 455 ............................................................................................................ Section 77.8 Reading a \ufb01le with a Scanner 456 ........................................................................................................... Section 77.9 Copying a \ufb01le using InputStream and OutputStream 457 .................................................................... Section 77.10 Reading from a binary \ufb01le 457 ............................................................................................................... Section 77.11 Reading a \ufb01le using Channel and Buer 457 ......................................................................................... Section 77.12 Adding Directories 458 ............................................................................................................................. Section 77.13 Blocking or redirecting standard output error 459 ............................................................................ Section 77.14 Reading a whole \ufb01le at once 460 ............................................................................................................ Section 77.15 Locking 460 ............................................................................................................................................... Section 77.16 Reading a \ufb01le using BueredInputStream 460 ..................................................................................... Section 77.17 Iterate over a directory printing subdirectories in it 461 ...................................................................... Section 77.18 Writing a \ufb01le using Channel and Buer 461": "input.pdf", ".......................................................................................... Section 77.19 Writing a \ufb01le using PrintStream 462 ....................................................................................................... Section 77.20 Iterating over a directory and \ufb01lter by \ufb01le extension 462 ................................................................... Section 77.21 Accessing the contents of a ZIP \ufb01le 463 ................................................................................................ Chapter 78 Scanner 464 ............................................................................................................................................... Section 78.1 General Pattern that does most commonly asked about tasks 464 .................................................... Section 78.2 Using custom delimiters 466 .................................................................................................................... Section 78.3 Reading system input using Scanner 466 ............................................................................................... Section 78.4 Reading \ufb01le input using Scanner 466 ...................................................................................................... Section 78.5 Read the entire input as a String using Scanner 467 ............................................................................. Section 78.6 Carefully Closing a Scanner 467 .............................................................................................................. Section 78.7 Read an int from the command line 468 ................................................................................................ Chapter 79 Interfaces 469 ........................................................................................................................................... Section 79.1 Implementing multiple interfaces 469 ...................................................................................................... Section 79.2 Declaring and Implementing an Interface 470 ....................................................................................... Section 79.3 Extending an interface 470 ....................................................................................................................... Section 79.4 Usefulness of interfaces 471 .................................................................................................................... Section 79.5 Default methods 473 ................................................................................................................................. Section 79.6 Modi\ufb01ers in Interfaces 475 ........................................................................................................................ Section 79.7 Using Interfaces with Generics 475 .......................................................................................................... Section 79.8 Strengthen bounded type parameters 478 ............................................................................................ Section 79.9 Implementing interfaces in an abstract class 478 ................................................................................. Chapter 80 Regular Expressions 480 ..................................................................................................................... Section 80.1 Using capture groups 480 ......................................................................................................................... Section 80.2 Using": "input.pdf", "regex with custom behaviour by compiling the Pattern with \ufb02ags 481 ................................... Section 80.3 Escape Characters 481 ............................................................................................................................. Section 80.4 Not matching a given string 482 ............................................................................................................. Section 80.5 Matching with a regex literal 482 ............................................................................................................. Section 80.6 Matching a backslash 482 ........................................................................................................................ Chapter 81 Comparable and Comparator 484 .................................................................................................. Section 81.1 Sorting a List using ComparableT or a ComparatorT 484 ............................................................. Section 81.2 The compareTo and compare Methods 487 .......................................................................................... Section 81.3 Natural comparable vs explicit comparator sorting 488 ................................................................. Section 81.4 Creating a Comparator using comparing method 489 ......................................................................... Section 81.5 Sorting Map entries 489 ............................................................................................................................. Chapter 82 Java Floating Point Operations 491 .............................................................................................. Section 82.1 Comparing \ufb02oating point values 491 ....................................................................................................... Section 82.2 OverFlow and UnderFlow 493 .................................................................................................................. Section 82.3 Formatting the \ufb02oating point values 494 ................................................................................................ Section 82.4 Strict Adherence to the IEEE Speci\ufb01cation 494 ....................................................................................... Chapter 83 Currency and Money 496 .................................................................................................................... Section 83.1 Add custom currency 496 ......................................................................................................................... Chapter 84 Object Cloning 497 ................................................................................................................................. Section 84.1 Cloning performing a deep copy 497 ...................................................................................................... Section 84.2 Cloning using a copy factory 498 ............................................................................................................ Section 84.3 Cloning using a copy constructor 498 ..................................................................................................... Section 84.4 Cloning by implementing Clonable interface 498 .................................................................................. Section 84.5 Cloning": "input.pdf", "performing a shallow copy 499 ................................................................................................. Chapter 85 Recursion 501 ............................................................................................................................................ Section 85.1 The basic idea of recursion 501 ................................................................................................................ Section 85.2 Deep recursion is problematic in Java 501 ............................................................................................ Section 85.3 Types of Recursion 503 ............................................................................................................................. Section 85.4 Computing the Nth Fibonacci Number 503 ............................................................................................ Section 85.5 StackOver\ufb02owError recursion to loop 504 .......................................................................................... Section 85.6 Computing the Nth power of a number 506 ........................................................................................... Section 85.7 Traversing a Tree data structure with recursion 506 ............................................................................ Section 85.8 Reverse a string using Recursion 507 ..................................................................................................... Section 85.9 Computing the sum of integers from 1 to N 507 .................................................................................... Chapter 86 Converting to and from Strings 508 ............................................................................................. Section 86.1 Converting String to other datatypes 508 ............................................................................................... Section 86.2 Conversion to from bytes 509 ............................................................................................................... Section 86.3 Base64 Encoding Decoding 509 ............................................................................................................ Section 86.4 Converting other datatypes to String 510 .............................................................................................. Section 86.5 Getting a String from an InputStream 511 .......................................................................................... Chapter 87 Random Number Generation 512 .................................................................................................. Section 87.1 Pseudo Random Numbers 512 ................................................................................................................. Section 87.2 Pseudo Random Numbers in Speci\ufb01c Range 512 ................................................................................. Section 87.3 Generating cryptographically secure pseudorandom numbers 513 ................................................... Section 87.4 Generating Random Numbers with a Speci\ufb01ed Seed 513 .................................................................... Section 87.5 Select random numbers": "input.pdf", "without duplicates 514 .................................................................................... Section 87.6 Generating Random number using apache-common lang3 515 ........................................................ Chapter 88 Singletons 516 .......................................................................................................................................... Section 88.1 Enum Singleton 516 ................................................................................................................................... Section 88.2 Singleton without use of Enum eager initialization 516 ...................................................................... Section 88.3 Thread-safe lazy initialization using holder class Bill Pugh Singleton implementation 517 ............ Section 88.4 Thread safe Singleton with double checked locking 517 ...................................................................... Section 88.5 Extending singleton singleton inheritance 518 .................................................................................... Chapter 89 Autoboxing 521 ......................................................................................................................................... Section 89.1 Using int and Integer interchangeably 521 ............................................................................................. Section 89.2 Auto-unboxing may lead to NullPointerException 522 .......................................................................... Section 89.3 Using Boolean in if statement 522 ........................................................................................................... Section 89.4 Dierent Cases When Integer and int can be used interchangeably 522 .......................................... Section 89.5 Memory and Computational Overhead of Autoboxing 524 ................................................................. Chapter 90 2D Graphics in Java 525 ...................................................................................................................... Section 90.1 Example 1 Draw and Fill a Rectangle Using Java 525 .......................................................................... Section 90.2 Example 2 Drawing and Filling Oval 527 ............................................................................................... Chapter 91 JAXB 528 ....................................................................................................................................................... Section 91.1 Reading an XML \ufb01le unmarshalling 528 ................................................................................................ Section 91.2 Writing an XML \ufb01le marshalling an object 528 ..................................................................................... Section 91.3 Manual \ufb01eldproperty XML mapping con\ufb01guration 529 ....................................................................... Section 91.4 Binding an XML namespace to a serializable": "input.pdf", "Java class 530 ............................................................... Section 91.5 Using XmlAdapter to generate desired xml format 530 ........................................................................ Section 91.6 Using XmlAdapter to trim string 532 ........................................................................................................ Section 91.7 Automatic \ufb01eldproperty XML mapping con\ufb01guration XmlAccessorType 532 ............................ Section 91.8 Specifying a XmlAdapter instance to reuse existing data 534 ........................................................... Chapter 92 Class - Java Re\ufb02ection 537 ................................................................................................................ Section 92.1 getClass method of Object class 537 .................................................................................................... Chapter 93 Networking 538 ........................................................................................................................................ Section 93.1 Basic Client and Server Communication using a Socket 538 ................................................................ Section 93.2 Basic ClientServer Communication using UDP Datagram 540 ........................................................ Section 93.3 Loading TrustStore and KeyStore from InputStream 541 .................................................................... Section 93.4 Socket example - reading a web page using a simple socket 542 ...................................................... Section 93.5 Temporarily disable SSL veri\ufb01cation for testing purposes 543 ......................................................... Section 93.6 Downloading a \ufb01le using Channel 543 .................................................................................................... Section 93.7 Multicasting 544 ......................................................................................................................................... Chapter 94 NIO - Networking 547 ........................................................................................................................... Section 94.1 Using Selector to wait for events example with OPCONNECT 547 ................................................. Chapter 95 HttpURLConnection 549 ...................................................................................................................... Section 95.1 Get response body from a URL as a String 549 ..................................................................................... Section 95.2 POST data 550 ........................................................................................................................................... Section 95.3 Delete resource 550 ................................................................................................................................... Section 95.4 Check if resource exists 551 ..................................................................................................................... Chapter": "input.pdf", "96 JAX-WS 553 ................................................................................................................................................ Section 96.1 Basic Authentication 553 ........................................................................................................................... Chapter 97 Nashorn JavaScript engine 554 ...................................................................................................... Section 97.1 Execute JavaScript \ufb01le 554 ........................................................................................................................ Section 97.2 Intercept script output 554 ....................................................................................................................... Section 97.3 Hello Nashorn 555 ..................................................................................................................................... Section 97.4 Evaluate Arithmetic Strings 555 ............................................................................................................... Section 97.5 Set global variables 555 ............................................................................................................................ Section 97.6 Set and get global variables 556 ............................................................................................................. Section 97.7 Usage of Java objects in JavaScript in Nashorn 556 ............................................................................ Section 97.8 Implementing an interface from script 557 ............................................................................................ Chapter 98 Java Native Interface 558 .................................................................................................................. Section 98.1 Calling C methods from Java 558 ........................................................................................................ Section 98.2 Calling Java methods from C callback 559 ..................................................................................... Section 98.3 Loading native libraries 561 ..................................................................................................................... Chapter 99 Functional Interfaces 563 ................................................................................................................... Section 99.1 List of standard Java Runtime Library functional interfaces by signature 563 .................................. Chapter 100 Fluent Interface 565 ............................................................................................................................ Section 100.1 Fluent programming style 565 ................................................................................................................ Section 100.2 Truth - Fluent Testing Framework 566 .................................................................................................. Chapter 101 Remote Method Invocation RMI 567 ......................................................................................... Section 101.1 Callback invoking methods on a client 567 ......................................................................................... Section 101.2 Simple RMI example with Client and Server implementation 571 ....................................................... Section 101.3 Client-Server invoking methods in one JVM from another 573 .......................................................... Chapter": "input.pdf", "102 Iterator and Iterable 576 .................................................................................................................. Section 102.1 Removing elements using an iterator 576 ............................................................................................. Section 102.2 Creating your own Iterable 576 .............................................................................................................. Section 102.3 Using Iterable in for loop 577 .................................................................................................................. Section 102.4 Using the raw iterator 578 ...................................................................................................................... Chapter 103 Re\ufb02ection API 579 ................................................................................................................................. Section 103.1 Dynamic Proxies 579 ................................................................................................................................ Section 103.2 Introduction 580 ....................................................................................................................................... Section 103.3 Evil Java hacks with Re\ufb02ection 581 ....................................................................................................... Section 103.4 Misuse of Re\ufb02ection API to change private and \ufb01nal variables 583 ................................................... Section 103.5 Getting and Setting \ufb01elds 584 ................................................................................................................. Section 103.6 Call constructor 585 ................................................................................................................................. Section 103.7 Call constructor of nested class 586 ...................................................................................................... Section 103.8 Invoking a method 586 ............................................................................................................................ Section 103.9 Get Class given its fully quali\ufb01ed name 587 ....................................................................................... Section 103.10 Getting the Constants of an Enumeration 587 .................................................................................... Section 103.11 Call overloaded constructors using re\ufb02ection 588 ............................................................................... Chapter 104 ByteBuer 590 ....................................................................................................................................... Section 104.1 Basic Usage - Using DirectByteBuer 590 ............................................................................................ Section 104.2 Basic Usage - Creating a ByteBuer 590 ............................................................................................. Section 104.3 Basic Usage - Write Data to the Buer 591 .......................................................................................... Chapter 105 Applets 592 ............................................................................................................................................... Section 105.1 Minimal Applet 592 ................................................................................................................................... Section 105.2 Creating a GUI 593 ................................................................................................................................... Section 105.3 Open links from": "input.pdf", "within the applet 593 ................................................................................................... Section 105.4 Loading images, audio and other resources 594 ................................................................................. Chapter 106 Expressions 596 ...................................................................................................................................... Section 106.1 Operator Precedence 596 ........................................................................................................................ Section 106.2 Expression Basics 597 .............................................................................................................................. Section 106.3 Expression evaluation order 598 ............................................................................................................ Section 106.4 Constant Expressions 599 ....................................................................................................................... Chapter 107 JSON in Java 601 .................................................................................................................................. Section 107.1 Using Jackson Object Mapper 601 ......................................................................................................... Section 107.2 JSON To Object Gson Library 602 ....................................................................................................... Section 107.3 JSONObject.NULL 602 ............................................................................................................................. Section 107.4 JSON Builder - chaining methods 603 ................................................................................................... Section 107.5 Object To JSON Gson Library 603 ....................................................................................................... Section 107.6 JSON Iteration 603 ................................................................................................................................... Section 107.7 optXXX vs getXXX methods 604 ............................................................................................................. Section 107.8 Extract single element from JSON 604 .................................................................................................. Section 107.9 JsonArray to Java List Gson Library 604 ........................................................................................... Section 107.10 Encoding data as JSON 605 .................................................................................................................. Section 107.11 Decoding JSON data 605 ....................................................................................................................... Chapter 108 XML Parsing using the JAXP APIs 607 ......................................................................................... Section 108.1 Parsing a document using the StAX API 607 .......................................................................................... Section 108.2 Parsing and navigating a document using the DOM API 608 ............................................................. Chapter 109 XML XPath Evaluation 610 ................................................................................................................ Section 109.1 Parsing multiple XPath Expressions in a single XML 610 ...................................................................... Section 109.2 Parsing single XPath Expression": "input.pdf", "multiple times in an XML 610 .......................................................... Section 109.3 Evaluating a NodeList in an XML document 611 .................................................................................. Chapter 110 XOM - XML Object Model 612 ........................................................................................................... Section 110.1 Reading a XML \ufb01le 612 .............................................................................................................................. Section 110.2 Writing to a XML File 614 ......................................................................................................................... Chapter 111 Polymorphism 617 .................................................................................................................................. Section 111.1 Method Overriding 617 ............................................................................................................................... Section 111.2 Method Overloading 618 ........................................................................................................................... Section 111.3 Polymorphism and dierent types of overriding 619 ............................................................................ Section 111.4 Virtual functions 622 .................................................................................................................................. Section 111.5 Adding behaviour by adding classes without touching existing code 623 .......................................... Chapter 112 Encapsulation 625 .................................................................................................................................. Section 112.1 Encapsulation to maintain invariants 625 ............................................................................................... Section 112.2 Encapsulation to reduce coupling 626 .................................................................................................... Chapter 113 Java Agents 627 ...................................................................................................................................... Section 113.1 Modifying classes with agents 627 ........................................................................................................... Section 113.2 Adding an agent at runtime 627 ............................................................................................................. Section 113.3 Setting up a basic agent 628 .................................................................................................................... Chapter 114 Varargs Variable Argument 629 ................................................................................................ Section 114.1 Working with Varargs parameters 629 ................................................................................................... Section 114.2 Specifying a varargs parameter 629 ...................................................................................................... Chapter 115 Logging java.util.logging 630 ....................................................................................................... Section 115.1 Logging complex messages eciently 630 ......................................................................................... Section 115.2 Using the default logger 631 ................................................................................................................... Section 115.3 Logging levels 632 .................................................................................................................................... Chapter 116 log4j log4j2 634": "input.pdf", ".................................................................................................................................. Section 116.1 Properties-File to log to DB 634 ............................................................................................................... Section 116.2 How to get Log4j 634 ................................................................................................................................ Section 116.3 Setting up property \ufb01le 635 ...................................................................................................................... Section 116.4 Basic log4j2.xml con\ufb01guration \ufb01le 636 ................................................................................................... Section 116.5 How to use Log4j in Java code 636 ........................................................................................................ Section 116.6 Migrating from log4j 1.x to 2.x 637 ........................................................................................................... Section 116.7 Filter Logoutput by level log4j 1.x 638 ................................................................................................... Chapter 117 Oracle Ocial Code Standard 639 ............................................................................................... Section 117.1 Naming Conventions 639 .......................................................................................................................... Section 117.2 Class Structure 640 ................................................................................................................................... Section 117.3 Annotations 641 ......................................................................................................................................... Section 117.4 Import statements 641 ............................................................................................................................. Section 117.5 Braces 642 ................................................................................................................................................. Section 117.6 Redundant Parentheses 643 .................................................................................................................... Section 117.7 Modi\ufb01ers 643 .............................................................................................................................................. Section 117.8 Indentation 644 .......................................................................................................................................... Section 117.9 Literals 644 ................................................................................................................................................. Section 117.10 Package declaration 644 ........................................................................................................................ Section 117.11 Lambda Expressions 644 ......................................................................................................................... Section 117.12 Java Source Files 645 .............................................................................................................................. Section 117.13 Wrapping statements 645 ....................................................................................................................... Section 117.14 Wrapping Method Declarations 646 ...................................................................................................... Section 117.15 Wrapping Expressions 646 ...................................................................................................................... Section 117.16 Whitespace 647 ........................................................................................................................................ Section 117.17 Special Characters 647 ............................................................................................................................ Section 117.18 Variable Declarations 648 ....................................................................................................................... Chapter 118 Character encoding 649 ..................................................................................................................... Section 118.1 Reading text from a \ufb01le encoded in UTF-8 649 ..................................................................................... Section 118.2 Writing text": "input.pdf", "to a \ufb01le in UTF-8 649 ............................................................................................................ Section 118.3 Getting byte representation of a string in UTF-8 650 ........................................................................... Chapter 119 Apache Commons Lang 651 ............................................................................................................. Section 119.1 Implement equals method 651 .............................................................................................................. Section 119.2 Implement hashCode method 651 ....................................................................................................... Section 119.3 Implement toString method 652 ........................................................................................................... Chapter 120 Localization and Internationalization 654 ................................................................................ Section 120.1 Locale 654 .................................................................................................................................................. Section 120.2 Automatically formatted Dates using locale 655 .............................................................................. Section 120.3 String Comparison 655 ............................................................................................................................ Chapter 121 Parallel programming with ForkJoin framework 656 ...................................................... Section 121.1 ForkJoin Tasks in Java 656 .................................................................................................................... Chapter 122 Non-Access Modi\ufb01ers 658 ................................................................................................................. Section 122.1 \ufb01nal 658 ...................................................................................................................................................... Section 122.2 static 659 ................................................................................................................................................... Section 122.3 abstract 660 .............................................................................................................................................. Section 122.4 strictfp 661 ................................................................................................................................................ Section 122.5 volatile 661 ................................................................................................................................................ Section 122.6 synchronized 662 ..................................................................................................................................... Section 122.7 transient 663 ............................................................................................................................................. Chapter 123 Process 664 ............................................................................................................................................... Section 123.1 Pitfall Runtime.exec, Process and ProcessBuilder dont understand shell syntax 664 ...................... Section 123.2 Simple example Java version 1.5 666 ............................................................................................... Chapter 124 Java Native Access 667 ..................................................................................................................... Section 124.1 Introduction to JNA 667 ........................................................................................................................... Chapter 125 Modules 668 .............................................................................................................................................. Section 125.1 De\ufb01ning a basic module 668 ................................................................................................................... Chapter 126 Concurrent Programming Threads 669 .................................................................................. Section 126.1 Callable and Future 669": "input.pdf", "........................................................................................................................... Section 126.2 CountDownLatch 670 ............................................................................................................................... Section 126.3 Basic Multithreading 672 ......................................................................................................................... Section 126.4 Locks as Synchronisation aids 673 ......................................................................................................... Section 126.5 Semaphore 674 ........................................................................................................................................ Section 126.6 Synchronization 675 ................................................................................................................................. Section 126.7 Runnable Object 676 ................................................................................................................................ Section 126.8 Creating basic deadlocked system 677 ................................................................................................. Section 126.9 Creating a java.lang.Thread instance 679 ............................................................................................. Section 126.10 Atomic operations 680 ........................................................................................................................... Section 126.11 Exclusive write Concurrent read access 681 ...................................................................................... Section 126.12 Producer-Consumer 682 ........................................................................................................................ Section 126.13 Visualizing readwrite barriers while using synchronized volatile 684 ........................................... Section 126.14 Get status of all threads started by your program excluding system threads 685 ........................ Section 126.15 Using ThreadLocal 686 ........................................................................................................................... Section 126.16 Multiple producerconsumer example with shared global queue 687 ............................................. Section 126.17 Add two int arrays using a Threadpool 688 ....................................................................................... Section 126.18 Pausing Execution 689 ............................................................................................................................ Section 126.19 Thread Interruption Stopping Threads 690 ....................................................................................... Chapter 127 Executor, ExecutorService and Thread pools 693 ................................................................ Section 127.1 ThreadPoolExecutor 693 .......................................................................................................................... Section 127.2 Retrieving value from computation - Callable 694 ............................................................................... Section 127.3 submit vs execute exception handling dierences 695 .................................................................. Section 127.4 Handle Rejected Execution 697 .............................................................................................................. Section 127.5 Fire and Forget - Runnable Tasks 697 ................................................................................................... Section 127.6 Use cases for dierent types": "input.pdf", "of concurrency constructs 698 ............................................................. Section 127.7 Wait for completion of all tasks in ExecutorService 699 ...................................................................... Section 127.8 Use cases for dierent types of ExecutorService 701 .......................................................................... Section 127.9 Scheduling tasks to run at a \ufb01xed time, after a delay or repeatedly 703 .......................................... Section 127.10 Using Thread Pools 704 ......................................................................................................................... Chapter 128 ThreadLocal 705 .................................................................................................................................... Section 128.1 Basic ThreadLocal usage 705 .................................................................................................................. Section 128.2 ThreadLocal Java 8 functional initialization 706 .................................................................................. Section 128.3 Multiple threads with one shared object 707 ........................................................................................ Chapter 129 Using ThreadPoolExecutor in MultiThreaded applications. 709 .................................... Section 129.1 Performing Asynchronous Tasks Where No Return Value Is Needed Using a Runnable Class Instance 709 .............................................................................................................................................................. Section 129.2 Performing Asynchronous Tasks Where a Return Value Is Needed Using a Callable Class Instance 710 .............................................................................................................................................................. Section 129.3 De\ufb01ning Asynchronous Tasks Inline using Lambdas 713 .................................................................... Chapter 130 Common Java Pitfalls 715 ................................................................................................................ Section 130.1 Pitfall using to compare primitive wrappers objects such as Integer 715 ..................................... Section 130.2 Pitfall using to compare strings 715 ................................................................................................. Section 130.3 Pitfall forgetting to free resources 717 ................................................................................................. Section 130.4 Pitfall testing a \ufb01le before attempting to open it 718 .......................................................................... Section 130.5 Pitfall thinking of variables as objects 719": "input.pdf", "........................................................................................... Section 130.6 Pitfall memory leaks 722 ........................................................................................................................ Section 130.7 Pitfall Not understanding that String is an immutable class 723 ....................................................... Section 130.8 Pitfall combining assignment and side-eects 724 ............................................................................. Chapter 131 Java Pitfalls - Exception usage 725 .............................................................................................. Section 131.1 Pitfall - Catching Throwable, Exception, Error or RuntimeException 725 ............................................ Section 131.2 Pitfall - Ignoring or squashing exceptions 726 ....................................................................................... Section 131.3 Pitfall - Throwing Throwable, Exception, Error or RuntimeException 727 ........................................... Section 131.4 Pitfall - Using exceptions for normal \ufb02owcontrol 728 ........................................................................... Section 131.5 Pitfall - Directly subclassing Throwable 729 ......................................................................................... Section 131.6 Pitfall - Catching InterruptedException 729 ............................................................................................ Section 131.7 Pitfall - Excessive or inappropriate stacktraces 731 .............................................................................. Chapter 132 Java Pitfalls - Language syntax 732 ........................................................................................... Section 132.1 Pitfall - Missing a break in a switch case 732 ...................................................................................... Section 132.2 Pitfall - Declaring classes with the same names as standard classes 732 ........................................ Section 132.3 Pitfall - Leaving out braces the dangling if and dangling else problems 733 ............................. Section 132.4 Pitfall - Octal literals 735 .......................................................................................................................... Section 132.5 Pitfall - Using to test a boolean 735 ................................................................................................. Section 132.6 Pitfall - Ignoring method visibility 736 .................................................................................................... Section 132.7 Pitfall Using assert for argument": "input.pdf", "or user input validation 736 ......................................................... Section 132.8 Pitfall - Wildcard imports can make your code fragile 737 ................................................................. Section 132.9 Pitfall - Misplaced semicolons and missing braces 738 ....................................................................... Section 132.10 Pitfall - Overloading instead of overriding 739 .................................................................................... Section 132.11 Pitfall of Auto-Unboxing Null Objects into Primitives 740 .................................................................... Chapter 133 Java Pitfalls - Threads and Concurrency 741 ......................................................................... Section 133.1 Pitfall - Extending java.lang.Thread 741 ................................................................................................ Section 133.2 Pitfall - Too many threads makes an application slower 742 ............................................................. Section 133.3 Pitfall incorrect use of wait notify 743 ........................................................................................... Section 133.4 Pitfall Shared variables require proper synchronization 743 .............................................................. Section 133.5 Pitfall - Thread creation is relatively expensive 746 ............................................................................. Chapter 134 Java Pitfalls - Nulls and NullPointerException 749 ............................................................. Section 134.1 Pitfall - Making good unexpected nulls 749 ......................................................................................... Section 134.2 Pitfall - Using null to represent an empty array or collection 750 ...................................................... Section 134.3 Pitfall - Not checking if an IO stream isnt even initialized when closing it 751 ............................... Section 134.4 Pitfall - Returning null instead of throwing an exception 751 .............................................................. Section 134.5 Pitfall - Unnecessary use of Primitive Wrappers can lead to NullPointerExceptions 752 ................ Section 134.6 Pitfall - Using": "input.pdf", "Yoda notation to avoid NullPointerException 753 ...................................................... Chapter 135 Java Pitfalls - Performance Issues 754 ...................................................................................... Section 135.1 Pitfall - String concatenation in a loop does not scale 754 .................................................................. Section 135.2 Pitfall - Using size to test if a collection is empty is inecient 755 .................................................. Section 135.3 Pitfall - Interning strings so that you can use is a bad idea 755 ..................................................... Section 135.4 Pitfall - Using new to create primitive wrapper instances is inecient 757 ..................................... Section 135.5 Pitfall - Eciency concerns with regular expressions 757 ................................................................... Section 135.6 Pitfall - Small reads writes on unbuered streams are inecient 760 ........................................... Section 135.7 Pitfall - Over-use of primitive wrapper types is inecient 762 ............................................................ Section 135.8 Pitfall - The overheads of creating log messages 763 ......................................................................... Section 135.9 Pitfall - Iterating a Maps keys can be inecient 764 ........................................................................... Section 135.10 Pitfall - Calling System.gc is inecient 764 ....................................................................................... Section 135.11 Pitfall - Calling new StringString is inecient 765 ............................................................................ Chapter 136 ServiceLoader 766 ................................................................................................................................ Section 136.1 Simple ServiceLoader Example 766 ........................................................................................................ Section 136.2 Logger Service 767 ................................................................................................................................... Chapter 137 Classloaders 769 .................................................................................................................................... Section 137.1 Implementing a custom classLoader 769 ............................................................................................... Section 137.2 Loading an external": "input.pdf", ".class \ufb01le 769 .......................................................................................................... Section 137.3 Instantiating and using a classloader 770 ............................................................................................. Chapter 138 Creating Images Programmatically 772 ................................................................................... Section 138.1 Creating a simple image programmatically and displaying it 772 ..................................................... Section 138.2 Save an Image to disk 773 ...................................................................................................................... Section 138.3 Setting individual pixels color in BueredImage 773 ........................................................................... Section 138.4 Specifying image rendering quality 774 ................................................................................................ Section 138.5 Creating an image with BueredImage class 776 ............................................................................... Section 138.6 Editing and re-using image with BueredImage 777 ........................................................................... Section 138.7 How to scale a BueredImage 778 ........................................................................................................ Chapter 139 Atomic Types 779 .................................................................................................................................. Section 139.1 Creating Atomic Types 779 ...................................................................................................................... Section 139.2 Motivation for Atomic Types 779 ............................................................................................................ Chapter 140 RSA Encryption 783 ............................................................................................................................. Section 140.1 An example using a hybrid cryptosystem consisting of OAEP and GCM 783 .................................... Chapter 141 Secure objects 788 ................................................................................................................................ Section 141.1 SealedObject javax.crypto.SealedObject 788 ...................................................................................... Section 141.2 SignedObject java.security.SignedObject 788 ..................................................................................... Chapter 142 Security Cryptography 790 ......................................................................................................... Section 142.1 Compute Cryptographic Hashes 790 ...................................................................................................... Section 142.2 Encrypt and Decrypt Data with Public Private Keys 790 .................................................................. Section 142.3 Generate Cryptographically Random Data 791 ................................................................................... Section 142.4 Generate Public Private Key Pairs 791 ................................................................................................ Section 142.5 Compute and Verify Digital Signatures 792 ..........................................................................................": "input.pdf", "Chapter 143 Security Cryptography 793 ......................................................................................................... Section 143.1 The JCE 793 ............................................................................................................................................... Section 143.2 Keys and Key Management 793 ............................................................................................................ Section 143.3 Common Java vulnerabilities 793 .......................................................................................................... Section 143.4 Networking Concerns 793 ....................................................................................................................... Section 143.5 Randomness and You 793 ....................................................................................................................... Section 143.6 Hashing and Validation 793 .................................................................................................................... Chapter 144 SecurityManager 795 ......................................................................................................................... Section 144.1 Sandboxing classes loaded by a ClassLoader 795 ............................................................................... Section 144.2 Enabling the SecurityManager 796 ........................................................................................................ Section 144.3 Implementing policy deny rules 796 ...................................................................................................... Chapter 145 JNDI 804 .................................................................................................................................................... Section 145.1 RMI through JNDI 804 .............................................................................................................................. Chapter 146 sun.misc.Unsafe 808 ............................................................................................................................ Section 146.1 Instantiating sun.misc.Unsafe via re\ufb02ection 808 .................................................................................... Section 146.2 Instantiating sun.misc.Unsafe via bootclasspath 808 ........................................................................... Section 146.3 Getting Instance of Unsafe 808 .............................................................................................................. Section 146.4 Uses of Unsafe 809 .................................................................................................................................. Chapter 147 Java Memory Model 810 ................................................................................................................... Section 147.1 Motivation for the Memory Model 810 .................................................................................................... Section 147.2 Happens-before relationships 812 ......................................................................................................... Section 147.3 How to avoid needing to understand the Memory Model 813 ............................................................ Section 147.4 Happens-before reasoning applied to some examples 814 ............................................................... Chapter 148 Java deployment 817 ......................................................................................................................... Section 148.1 Making an executable JAR from the command line 817 ..................................................................... Section 148.2 Creating an UberJAR for an application and its dependencies": "input.pdf", "818 .................................................. Section 148.3 Creating JAR, WAR and EAR \ufb01les 819 ................................................................................................... Section 148.4 Introduction to Java Web Start 820 ....................................................................................................... Chapter 149 Java plugin system implementations 823 ............................................................................... Section 149.1 Using URLClassLoader 823 ...................................................................................................................... Chapter 150 JavaBean 827 ......................................................................................................................................... Section 150.1 Basic Java Bean 827 ................................................................................................................................ Chapter 151 Java SE 7 Features 828 ....................................................................................................................... Section 151.1 New Java SE 7 programming language features 828 .......................................................................... Section 151.2 Binary Literals 828 .................................................................................................................................... Section 151.3 The try-with-resources statement 828 ................................................................................................... Section 151.4 Underscores in Numeric Literals 829 ...................................................................................................... Section 151.5 Type Inference for Generic Instance Creation 829 ................................................................................ Section 151.6 Strings in switch Statements 829 ............................................................................................................. Chapter 152 Java SE 8 Features 831 ...................................................................................................................... Section 152.1 New Java SE 8 programming language features 831 ......................................................................... Chapter 153 Dynamic Method Dispatch 832 ....................................................................................................... Section 153.1 Dynamic Method Dispatch - Example Code 832 ................................................................................... Chapter 154 Generating Java Code 835 .............................................................................................................. Section 154.1 Generate POJO From JSON 835 ............................................................................................................. Chapter 155 JShell 836 .................................................................................................................................................. Section 155.1 Editting Snippets 836 ................................................................................................................................ Section 155.2 Entering and Exiting JShell 837 ............................................................................................................... Section 155.3 Expressions 837 ........................................................................................................................................ Section 155.4 Methods and Classes 838 ........................................................................................................................ Section 155.5 Variables 838 ............................................................................................................................................ Chapter 156 Stack-Walking API 839 ........................................................................................................................ Section": "input.pdf", "156.1 Print all stack frames of the current thread 839 .................................................................................... Section 156.2 Print current caller class 840 ................................................................................................................... Section 156.3 Showing re\ufb02ection and other hidden frames 840 ................................................................................. Chapter 157 Sockets 842 .............................................................................................................................................. Section 157.1 Read from socket 842 .............................................................................................................................. Chapter 158 Java Sockets 843 .................................................................................................................................. Section 158.1 A simple TCP echo back server 843 ........................................................................................................ Chapter 159 FTP File Transfer Protocol 846 .................................................................................................... Section 159.1 Connecting and Logging Into a FTP Server 846 .................................................................................... Chapter 160 Using Other Scripting Languages in Java 851 ....................................................................... Section 160.1 Evaluating A JavaScript \ufb01le in -scripting mode of nashorn 851 .......................................................... Chapter 161 C Comparison 854 ............................................................................................................................. Section 161.1 Static Class Members 854 ......................................................................................................................... Section 161.2 Classes De\ufb01ned within Other Constructs 854 ........................................................................................ Section 161.3 Pass-by-value Pass-by-reference 856 ................................................................................................ Section 161.4 Inheritance vs Composition 857 .............................................................................................................. Section 161.5 Outcast Downcasting 857 ........................................................................................................................ Section 161.6 Abstract Methods Classes 857 ............................................................................................................. Chapter 162 Audio 859 .................................................................................................................................................... Section 162.1 Play a MIDI \ufb01le 859 .................................................................................................................................... Section 162.2 Play an Audio \ufb01le Looped 860 ................................................................................................................ Section 162.3 Basic audio output 860 ............................................................................................................................ Section 162.4 Bare metal sound 861 .............................................................................................................................. Chapter 163 Java Print Service 863 ........................................................................................................................ Section 163.1 Building the Doc that will be printed": "input.pdf", "863 ................................................................................................ Section 163.2 Discovering the available print services 863 ......................................................................................... Section 163.3 De\ufb01ning print request attributes 864 ...................................................................................................... Section 163.4 Listening print job request status change 864 ...................................................................................... Section 163.5 Discovering the default print service 866 .............................................................................................. Section 163.6 Creating a print job from a print service 866 ........................................................................................ Chapter 164 CompletableFuture 868 ..................................................................................................................... Section 164.1 Simple Example of CompletableFuture 868 ........................................................................................... Chapter 165 Runtime Commands 869 .................................................................................................................... Section 165.1 Adding shutdown hooks 869 .................................................................................................................... Chapter 166 Unit Testing 870 ...................................................................................................................................... Section 166.1 What is Unit Testing? 870 ......................................................................................................................... Chapter 167 Asserting 873 ........................................................................................................................................... Section 167.1 Checking arithmetic with assert 873 ....................................................................................................... Chapter 168 Multi-Release JAR Files 874 ............................................................................................................. Section 168.1 Example of a multi-release Jar \ufb01les contents 874 ............................................................................... Section 168.2 Creating a multi-release Jar using the jar tool 874 .............................................................................. Section 168.3 URL of a loaded class inside a multi-release Jar 875 .......................................................................... Chapter 169 Just in Time JIT compiler 877 ...................................................................................................... Section 169.1 Overview 877 ............................................................................................................................................. Chapter 170 Bytecode Modi\ufb01cation 879 ............................................................................................................... Section 170.1 What is Bytecode? 879 ............................................................................................................................. Section 170.2 How to edit jar \ufb01les with ASM 880 .......................................................................................................... Section 170.3 How to load a ClassNode as a Class 882 .............................................................................................. Section 170.4 How": "input.pdf", "to rename classes in a jar \ufb01le 883 ................................................................................................. Section 170.5 Javassist Basic 883 .................................................................................................................................. Chapter 171 Disassembling and Decompiling 885 ............................................................................................ Section 171.1 Viewing bytecode with javap 885 ............................................................................................................. Chapter 172 JMX 892 ...................................................................................................................................................... Section 172.1 Simple example with Platform MBean Server 892 ................................................................................ Chapter 173 Java Virtual Machine JVM 896 .................................................................................................... Section 173.1 These are the basics 896 .......................................................................................................................... Chapter 174 XJC 897 ....................................................................................................................................................... Section 174.1 Generating Java code from simple XSD \ufb01le 897 ................................................................................... Chapter 175 JVM Flags 900 ......................................................................................................................................... Section 175.1 -XXaggressive 900 .................................................................................................................................... Section 175.2 -XXallocClearChunks 900 ......................................................................................................................... Section 175.3 -XXallocClearChunkSize 900 .................................................................................................................... Section 175.4 -XXcallPro\ufb01ling 900 .................................................................................................................................. Section 175.5 -XXdisableFatSpin 901 ............................................................................................................................. Section 175.6 -XXdisableGCHeuristics 901 .................................................................................................................... Section 175.7 -XXdumpSize 901 ...................................................................................................................................... Section 175.8 -XXexitOnOutOfMemory 902 ................................................................................................................... Chapter 176 JVM Tool Interface 903 ...................................................................................................................... Section 176.1 Iterate over objects reachable from object Heap 1.0 903 .................................................................. Section 176.2 Get JVMTI environment 905 .................................................................................................................... Section 176.3 Example of initialization inside of AgentOnLoad method 905 .......................................................... Chapter 177 Java Memory Management 907 .................................................................................................... Section 177.1 Setting the Heap, PermGen and Stack sizes 907 ................................................................................... Section 177.2 Garbage collection 908 ............................................................................................................................ Section 177.3 Memory leaks in Java 910 ....................................................................................................................... Section 177.4 Finalization 911 ......................................................................................................................................... Section 177.5": "input.pdf", "Manually triggering GC 912 ..................................................................................................................... Chapter 178 Java Performance Tuning 913 ....................................................................................................... Section 178.1 An evidence-based approach to Java performance tuning 913 ........................................................ Section 178.2 Reducing amount of Strings 914 ............................................................................................................ Section 178.3 General approach 914 ............................................................................................................................. Chapter 179 Benchmarks 916 ..................................................................................................................................... Section 179.1 Simple JMH example 916 ......................................................................................................................... Chapter 180 FileUpload to AWS 919 ....................................................................................................................... Section 180.1 Upload \ufb01le to s3 bucket 919 .................................................................................................................... Chapter 181 AppDynamics and TIBCO BusinessWorks Instrumentation for Easy Integration 921 ................................................................................................................................................................... Section 181.1 Example of Instrumentation of all BW Applications in a Single Step for Appdynamics 921 ............. Appendix A Installing Java Standard Edition 922 ........................................................................................ Section A.1 Setting PATH and JAVAHOME after installing on Windows 922 .............................................. Section A.2 Installing a Java JDK on Linux 923 ........................................................................................................... Section A.3 Installing a Java JDK on macOS 925 ........................................................................................................ Section A.4 Installing a Java JDK or JRE on Windows 926 ........................................................................................ Section A.5 Con\ufb01guring and switching Java versions on Linux using alternatives 927 .......................................... Section A.6 What do I need for Java Development 928 ............................................................................................. Section A.7 Selecting an appropriate Java SE release 928 ........................................................................................ Section A.8 Java release and version naming 929 ...................................................................................................... Section A.9 Installing Oracle Java on Linux with latest tar": "input.pdf", "\ufb01le 929 ............................................................................ Section A.10 Post-installation checking and con\ufb01guration on Linux 930 ................................................................... Appendix B Java Editions, Versions, Releases and Distributions 933 ................................................... Section B.1 Dierences between Java SE JRE or Java SE JDK distributions 933 .................................................... Section B.2 Java SE Versions 934 .................................................................................................................................. Section B.3 Dierences between Java EE, Java SE, Java ME and JavaFX 935 ....................................................... Appendix C The Classpath 937 .................................................................................................................................. Section C.1 Dierent ways to specify the classpath 937 ............................................................................................. Section C.2 Adding all JARs in a directory to the classpath 937 ................................................................................ Section C.3 Load a resource from the classpath 938 .................................................................................................. Section C.4 Classpath path syntax 938 ......................................................................................................................... Section C.5 Dynamic Classpath 939 .............................................................................................................................. Section C.6 Mapping classnames to pathnames 939 .................................................................................................. Section C.7 The bootstrap classpath 939 ..................................................................................................................... Section C.8 What the classpath means how searches work 940 .............................................................................. Appendix D Resources on classpath 941 .......................................................................................................... Section D.1 Loading default con\ufb01guration 941 ............................................................................................................ Section D.2 Loading an image from a resource 941 ................................................................................................... Section D.3 Finding and reading resources using a classloader 941 ........................................................................ Section D.4 Loading same-name resource from multiple JARs 943 ......................................................................... Credits 944 ............................................................................................................................................................................ You may also like 958 ...................................................................................................................................................... GoalKicker.com Java Notes for Professionals 1About Please feel free": "input.pdf", "to share this PDF with anyone for free, latest version of this book can be downloaded from httpsgoalkicker.comJavaBook This Java Notes for Professionals book is compiled from Stack Over\ufb02ow Documentation , the content is written by the beautiful people at Stack Over\ufb02ow. Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise speci\ufb01ed This is an uno\ufb03cial free book created for educational purposes and is not a\ufb03liated with o\ufb03cial Java groups or companys nor Stack Over\ufb02ow. All trademarks and registered trademarks are the property of their respective company owners The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk Please send feedback and corrections to webpetercv.com GoalKicker.com Java Notes for Professionals 2Chapter 1 Getting started with Java Language Java SE Version Code Name End-of-life free1 Release Date Java SE 10 Early Access None future 2018-03-20 Java SE 9 None future 2017-07-27 Java SE 8 Spider future 2014-03-18 Java SE 7 Dolphin 2015-04-14 2011-07-28 Java SE 6 Mustang 2013-04-16 2006-12-23 Java SE 5 Tiger 2009-11-04 2004-10-04 Java SE 1.4": "input.pdf", "Merlin prior to 2009-11-04 2002-02-06 Java SE 1.3 Kestrel prior to 2009-11-04 2000-05-08 Java SE 1.2 Playground prior to 2009-11-04 1998-12-08 Java SE 1.1 None prior to 2009-11-04 1997-02-19 Java SE 1.0 Oak prior to 2009-11-04 1996-01-21 Section 1.1 Creating Your First Java Program Create a new \ufb01le in your text editor or IDE named HelloWorld. java . Then paste this code block into the \ufb01le and save public class HelloWorld public static void mainString args System.out.printlnHello, World! Run live on Ideone Note For Java to recognize this as a public class and not throw a compile time error , the \ufb01lename must be the same as the class name HelloWorld in this example with a .java extension. There should also be a public access modi\ufb01er before it. Naming conventions recommend that Java classes begin with an uppercase character, and be in camel case format in which the \ufb01rst letter of each word is capitalized. The conventions recommend against underscores and dollar signs . To compile, open a terminal window and navigate to the directory of HelloWorld. java cd pathtocontaining folder Note cd is the terminal command to change directory. Enter javac followed by the \ufb01le name and extension": "input.pdf", "as follows javac HelloWorld. java Its fairly common to get the error javac is not recognized as an internal or external command, operable program or batch file. even when you have installed the JDK and are able to run the program from IDE ex. eclipse etc. Since the path is not added to the environment by default. GoalKicker.com Java Notes for Professionals 3In case you get this on windows, to resolve, \ufb01rst try browsing to your javac.exe path, its most probably in your CProgram FilesJavajdk version number bin . Then try running it with below. CProgram FilesJavajdk version number binjavac HelloWorld. java Previously when we were calling javac it was same as above command. Only in that case your OS knew where javac resided. So lets tell it now, this way you dont have to type the whole path every-time. We would need to add this to our PATH To edit the PATH environment variable in Windows XPVista7810 Control Panel System Advanced system settings Switch to Advanced tab Environment Variables In System Variables, scroll down to select PATH Edit You cannot undo this so be careful. First copy your existing path to notepad. Then to get the exact PATH": "input.pdf", "to your javac browse manually to the folder where javac resides and click on the address bar and then copy it. It should look something like cProgram FilesJavajdk1.8.0xxbin In Variable value \ufb01eld, paste this IN FRONT of all the existing directories, followed by a semi-colon . DO NOT DELETE any existing entries. Variable name PATH Variable value cProgram FilesJavajdk1.8.0xxbin Existing Entries... Now this should resolve. For Linux Based systems try here . Note The javac command invokes the Java compiler. The compiler will then generate a bytecode \ufb01le called HelloWorld. class which can be executed in the Java Virtual Machine JVM . The Java programming language compiler, javac , reads source \ufb01les written in the Java programming language and compiles them into bytecode class \ufb01les. Optionally, the compiler can also process annotations found in source and class \ufb01les using the Pluggable Annotation Processing API. The compiler is a command line tool but can also be invoked using the Java Compiler API. To run your program, enter java followed by the name of the class which contains the main method HelloWorld in our example. Note how the .class is omitted java HelloWorld Note The java command runs a Java application.": "input.pdf", "This will output to your console Hello, World! You have successfully coded and built your very \ufb01rst Java program! Note In order for Java commands java , javac , etc to be recognized, you will need to make sure A JDK is installed e.g. Oracle , OpenJDK and other sources GoalKicker.com Java Notes for Professionals 4Your environment variables are properly set up You will need to use a compiler javac and an executor java provided by your JVM. To \ufb01nd out which versions you have installed, enter java -version and javac -version on the command line. The version number of your program will be printed in the terminal e.g. 1.8.073 . A closer look at the Hello World program The Hello World program contains a single \ufb01le, which consists of a HelloWorld class de\ufb01nition, a main method, and a statement inside the main method. public class HelloWorld The class keyword begins the class de\ufb01nition for a class named HelloWorld . Every Java application contains at least one class de\ufb01nition Further information about classes. public static void mainString args This is an entry point method de\ufb01ned by its name and signature of public static void mainString from which the JVM": "input.pdf", "can run your program. Every Java program should have one. It is public meaning that the method can be called from anywhere mean from outside the program as well. See Visibility for more information on this. static meaning it exists and can be run by itself at the class level without creating an object. void meaning it returns no value. Note This is unlike C and C where a return code such as int is expected Javas way is System.exit. This main method accepts An array typically called args of String s passed as arguments to main function e.g. from command line arguments. Almost all of this is required for a Java entry point method. Non-required parts The name args is a variable name, so it can be called anything you want, although it is typically called args . Whether its parameter type is an array String args or Varargs String... args does not matter because arrays can be passed into varargs. Note A single application may have multiple classes containing an entry point main method. The entry point of the application is determined by the class name passed as an argument to the java command. Inside the main": "input.pdf", "method, we see the following statement System.out.printlnHello, World! Lets break down this statement element-by-element Element Purpose Systemthis denotes that the subsequent expression will call upon the System class, from the java.lang package. GoalKicker.com Java Notes for Professionals 5.this is a dot operator. Dot operators provide you access to a classes members1 i.e. its \ufb01elds variables and its methods. In this case, this dot operator allows you to reference the out static \ufb01eld within the System class. outthis is the name of the static \ufb01eld of PrintStream type within the System class containing the standard output functionality. .this is another dot operator. This dot operator provides access to the println method within the out variable. printlnthis is the name of a method within the PrintStream class. This method in particular prints the contents of the parameters into the console and inserts a newline after. this parenthesis indicates that a method is being accessed and not a \ufb01eld and begins the parameters being passed into the println method. Hello, World!this is the String literal that is passed as a parameter, into the println method. The double quotation marks on each end delimit the text as a String. this parenthesis signi\ufb01es the": "input.pdf", "closure of the parameters being passed into the println method. this semicolon marks the end of the statement. Note Each statement in Java must end with a semicolon . The method body and class body are then closed. end of main function scope end of class HelloWorld scope Heres another example demonstrating the OO paradigm. Lets model a football team with one yes, one! member. There can be more, but well discuss that when we get to arrays. First, lets de\ufb01ne our Team class public class Team Member member public TeamMember member who is in this Team? this.member member one member is in this Team! Now, lets de\ufb01ne our Member class class Member private String name private String type private int level note the data type here private int rank note the data type here as well public MemberString name, String type, int level, int rank this.name name this.type type this.level level this.rank rank Why do we use private here? Well, if someone wanted to know your name, they should ask you directly, instead of reaching into your pocket and pulling out your Social Security card. This private does something like that it prevents outside entities from accessing your": "input.pdf", "variables. You can only return private members through getter functions shown below. GoalKicker.com Java Notes for Professionals 6After putting it all together, and adding the getters and main method as discussed before, we have public class Team Member member public TeamMember member this.member member heres our main method public static void mainString args Member myMember new MemberAurieel , light, 10, 1 Team myTeam new TeammyMember System.out.printlnmyTeam.member.getName System.out.printlnmyTeam.member.getType System.out.printlnmyTeam.member.getLevel System.out.printlnmyTeam.member.getRank class Member private String name private String type private int level private int rank public MemberString name, String type, int level, int rank this.name name this.type type this.level level this.rank rank lets define our getter functions here public String getName what is your name? return this.name my name is ... public String getType what is your type? return this.type my type is ... public int getLevel what is your level? return this.level my level is ... public int getRank what is your rank? return this.rank my rank is Output Aurieel light 10 1 Run on ideone GoalKicker.com Java Notes for Professionals 7Once again, the main method inside the Test class is the entry point to our program. Without the main method, we cannot tell the Java Virtual Machine JVM from": "input.pdf", "where to begin execution of the program. 1 - Because the HelloWorld class has little relation to the System class, it can only access public data. GoalKicker.com Java Notes for Professionals 8Chapter 2 Type Conversion Section 2.1 Numeric primitive casting Numeric primitives can be cast in two ways. Implicit casting happens when the source type has smaller range than the target type. Implicit casting byte byteVar 42 short shortVar byteVar int intVar shortVar long longVar intvar float floatVar longVar double doubleVar floatVar Explicit casting has to be done when the source type has larger range than the target type. Explicit casting double doubleVar 42.0d float floatVar float doubleVar long longVar long floatVar int intVar int longVar short shortVar short intVar byte byteVar byte shortVar When casting \ufb02oating point primitives float , double to whole number primitives, the number is rounded down . Section 2.2 Basic Numeric Promotion static void testNumericPromotion char char1 1, char2 2 short short1 1, short2 2 int int1 1, int2 2 float float1 1.0f, float2 2.0f char1 char1 char2 Error Cannot convert from int to char short1 short1 short2 Error Cannot convert from int to short int1 char1 char2 char is promoted to int. int1": "input.pdf", "short1 short2 short is promoted to int. int1 char1 short2 both char and short promoted to int. float1 short1 float2 short is promoted to float. int1 int1 int2 int is unchanged. Section 2.3 Non-numeric primitive casting The boolean type cannot be cast tofrom any other primitive type. A char can be cast tofrom any numeric type by using the code-point mappings speci\ufb01ed by Unicode. A char is represented in memory as an unsigned 16-bit integer value 2 bytes, so casting to byte 1 byte will drop 8 of those bits this is safe for ASCII characters. The utility methods of the Character class use int 4 bytes to transfer tofrom code-point values, but a short 2 bytes would also su\ufb03ce for storing a Unicode code-point. int badInt int true Compiler error incompatible types GoalKicker.com Java Notes for Professionals 9char char1 char 65 A byte byte1 byte A 65 short short1 short A 65 int int1 int A 65 char char2 char 8253 byte byte2 byte 61 truncated code-point into the ASCII range short short2 short 8253 int int2 int 8253 Section 2.4 Object casting As with primitives, objects can be cast both explicitly and implicitly. Implicit casting happens when": "input.pdf", "the source type extends or implements the target type casting to a superclass or interface. Explicit casting has to be done when the source type is extended or implemented by the target type casting to a subtype. This can produce a runtime exception ClassCastException when the object being cast is not of the target type or the targets subtype. Float floatVar new Float42.0f Number n floatVar Implicit Float implements Number Float floatVar2 Float n Explicit Double doubleVar Double n Throws exception the object is not Double Section 2.5 Testing if an object can be cast using instanceof Java provides the instanceof operator to test if an object is of a certain type, or a subclass of that type. The program can then choose to cast or not cast that object accordingly. Object obj Calendar .getInstance long time 0 ifobj instanceof Calendar time Calendar obj.getTime ifobj instanceof Date time Dateobj.getTime This line will never be reached, obj is not a Date type. GoalKicker.com Java Notes for Professionals 10Chapter 3 Getters and Setters This article discusses getters and setters the standard way to provide access to data in Java classes. Section 3.1 Using a setter or getter to implement a constraint": "input.pdf", "Setters and Getters allow for an object to contain private variables which can be accessed and changed with restrictions. For example, public class Person private String name public String getName return name public void setName String name ifname!null name.length2 this.name name In this Person class, there is a single variable name . This variable can be accessed using the getName method and changed using the setNameString method, however, setting a name requires the new name to have a length greater than 2 characters and to not be null. Using a setter method rather than making the variable name public allows others to set the value of name with certain restrictions. The same can be applied to the getter method public String getName ifname.length16 return Name is too large! else return name In the modi\ufb01ed getName method above, the name is returned only if its length is less than or equal to 16. Otherwise, Name is too large is returned. This allows the programmer to create variables that are reachable and modi\ufb01able however they wish, preventing client classes from editing the variables unwantedly. Section 3.2 Why Use Getters and Setters? Consider a basic class containing an object with getters and": "input.pdf", "setters in Java public class CountHolder private int count 0 public int getCount return count public void setCount int c count c We cant access the count variable because its private. But we can access the getCount and the setCount int methods because they are public. To some, this might raise the question why introduce the middleman? Why not just simply make they count public? public class CountHolder GoalKicker.com Java Notes for Professionals 11 public int count 0 For all intents and purposes, these two are exactly the same, functionality-wise. The di\ufb00erence between them is the extensibility. Consider what each class says First I have a method that will give you an int value, and a method that will set that value to another int. Second I have an int that you can set and get as you please. These might sound similar, but the \ufb01rst is actually much more guarded in its nature it only lets you interact with its internal nature as it dictates. This leaves the ball in its court it gets to choose how the internal interactions occur. The second has exposed its internal implementation externally, and is now not only prone to external users,": "input.pdf", "but, in the case of an API, committed to maintaining that implementation or otherwise releasing a non-backward- compatible API. Lets consider if we want to synchronize access to modifying and accessing the count. In the \ufb01rst, this is simple public class CountHolder private int count 0 public synchronized int getCount return count public synchronized void setCount int c count c but in the second example, this is now nearly impossible without going through and modifying each place where the count variable is referenced. Worse still, if this is an item that youre providing in a library to be consumed by others, you do not have a way of performing that modi\ufb01cation, and are forced to make the hard choice mentioned above. So it begs the question are public variables ever a good thing or, at least, not evil? Im unsure. On one hand, you can see examples of public variables that have stood the test of time IE the out variable referenced in System.out. On the other, providing a public variable gives no bene\ufb01t outside of extremely minimal overhead and potential reduction in wordiness. My guideline here would be that, if youre planning on making a variable public, you": "input.pdf", "should judge it against these criteria with extreme prejudice The variable should have no conceivable reason to ever change in its implementation. This is something 1. thats extremely easy to screw up and, even if you do get it right, requirements can change, which is why getterssetters are the common approach. If youre going to have a public variable, this really needs to be thought through, especially if released in a libraryframeworkAPI. The variable needs to be referenced frequently enough that the minimal gains from reducing verbosity2. warrants it. I dont even think the overhead for using a method versus directly referencing should be considered here. Its far too negligible for what Id conservatively estimate to be 99.9 of applications. Theres probably more than I havent considered o\ufb00 the top of my head. If youre ever in doubt, always use getterssetters. Section 3.3 Adding Getters and Setters Encapsulation is a basic concept in OOP. It is about wrapping data and code as a single unit. In this case, it is a good practice to declare the variables as private and then access them through Getters and Setters to view andor modify them. public class Sample GoalKicker.com Java Notes for": "input.pdf", "Professionals 12 private String name private int age public int getAge return age public void setAgeint age this.age age public String getName return name public void setName String name this.name name These private variables cannot be accessed directly from outside the class. Hence they are protected from unauthorized access. But if you want to view or modify them, you can use Getters and Setters. getXxx method will return the current value of the variable xxx, while you can set the value of the variable xxx using setXxx. The naming convention of the methods are in example variable is called variableName All non boolean variables getVariableName Getter, The variable name should start with uppercase setVariableName .. Setter, The variable name should start with uppercase boolean variables isVariableName Getter, The variable name should start with uppercase setVariableName ... Setter, The variable name should start with uppercase Public Getters and Setters are part of the Property de\ufb01nition of a Java Bean. GoalKicker.com Java Notes for Professionals 13Chapter 4 Reference Data Types Section 4.1 Dereferencing Dereferencing happens with the . operator Object obj new Object String text obj.toString obj is dereferenced. Dereferencing follows the memory address stored in a reference, to the place": "input.pdf", "in memory where the actual object resides. When an object has been found, the requested method is called toString in this case. When a reference has the value null , dereferencing results in a NullPointerException Object obj null obj.toString Throws a NullpointerException when this statement is executed. null indicates the absence of a value, i.e. following the memory address leads nowhere. So there is no object on which the requested method can be called. Section 4.2 Instantiating a reference type Object obj new Object Note the new keyword Where Object is a reference type. obj is the variable in which to store the new reference. Object is the call to a constructor of Object . What happens Space in memory is allocated for the object. The constructor Object is called to initialize that memory space. The memory address is stored in obj, so that it references the newly created object. This is di\ufb00erent from primitives int i 10 Where the actual value 10 is stored in i. GoalKicker.com Java Notes for Professionals 14Chapter 5 Java Compiler - javac Section 5.1 The javac command - getting started Simple example Assuming that the HelloWorld.java contains the following Java source public class": "input.pdf", "HelloWorld public static void mainString args System.out.printlnHello world! For an explanation of the above code, please refer to Getting started with Java Language . We can compile the above \ufb01le using this command javac HelloWorld. java This produces a \ufb01le called HelloWorld.class, which we can then run as follows java HelloWorld Hello world ! The key points to note from this example are The source \ufb01lename HelloWorld.java must match the class name in the source \ufb01le ... which is HelloWorld . If 1. they dont match, you will get a compilation error. The bytecode \ufb01lename HelloWorld.class corresponds to the classname. If you were to rename the2. HelloWorld.class, you would get an error when your tried to run it. When running a Java application using java , you supply the classname NOT the bytecode \ufb01lename. 3. Example with packages Most practical Java code uses packages to organize the namespace for classes and reduce the risk of accidental class name collision. If we wanted to declare the HelloWorld class in a package call com.example , the HelloWorld.java would contain the following Java source package com.example public class HelloWorld public static void mainString args System.out.printlnHello world! This source code \ufb01le needs to": "input.pdf", "stored in a directory tree whose structure corresponds to the package naming. . the current directory for this example ----com GoalKicker.com Java Notes for Professionals 15 ----example ----HelloWorld. java We can compile the above \ufb01le using this command javac com exampleHelloWorld. java This produces a \ufb01le called comexampleHelloWorld.class i.e. after compilation, the \ufb01le structure should look like this . the current directory for this example ----com ----example ----HelloWorld. java ----HelloWorld. class We can then run the application as follows java com. example.HelloWorld Hello world ! Additional points to note from this example are The directory structure must match the package name structure.1. When you run the class, the full class name must be supplied i.e. com.example.HelloWorld not2. HelloWorld. You dont have to compile and run Java code out of the current directory. We are just doing it here for3. illustration. Compiling multiple \ufb01les at once with javac. If your application consists of multiple source code \ufb01les and most do! you can compile them one at a time. Alternatively, you can compile multiple \ufb01les at the same time by listing the pathnames javac Foo. java Bar.java or using your command shells \ufb01lename wildcard functionality .... javac .java javac com example.java": "input.pdf", "javac .java Only works on Zsh or with globstar enabled on your shell This will compile all Java source \ufb01les in the current directory, in the comexample directory, and recursively in child directories respectively. A third alternative is to supply a list of source \ufb01lenames and compiler options as a \ufb01le. For example javac sourcefiles where the sourcefiles \ufb01le contains Foo.java Bar.java GoalKicker.com Java Notes for Professionals 16comexampleHelloWorld. java Note compiling code like this is appropriate for small one-person projects, and for once-o\ufb00 programs. Beyond that, it is advisable to select and use a Java build tool. Alternatively, most programmers use a Java IDE e.g. NetBeans , eclipse , IntelliJ IDEA which o\ufb00ers an embedded compiler and incremental building of projects. Commonly used javac options Here are a few options for the javac command that are likely to be useful to you The -d option sets a destination directory for writing the .class \ufb01les. The -sourcepath option sets a source code search path. The -cp or -classpath option sets the search path for \ufb01nding external and previously compiled classes. For more information on the classpath and how to specify it, refer to the The Classpath Topic. The -version option": "input.pdf", "prints the compilers version information. A more complete list of compiler options will be described in a separate example. References The de\ufb01nitive reference for the javac command is the Oracle manual page for javac . Section 5.2 Compiling for a dierent version of Java The Java programming language and its runtime has undergone numerous changes since its release since its initial public release. These changes include Changes in the Java programming language syntax and semantics Changes in the APIs provided by the Java standard class libraries. Changes in the Java bytecode instruction set and class\ufb01le format. With very few exceptions for example the enum keyword, changes to some internal classes, etc, these changes are backwards compatible. A Java program that was compiled using an older version of the Java toolchain will run on a newer version Java platform without recompilation. A Java program that was written in an older version of Java will compile successfully with a new Java compiler. Compiling old Java with a newer compiler If you need to re-compile older Java code on a newer Java platform to run on the newer platform, you generally dont need to give any special compilation \ufb02ags. In a few": "input.pdf", "cases e.g. if you had used enum as an identi\ufb01er you could use the -source option to disable the new syntax. For example, given the following class public class OldSyntax private static int enum invalid in Java 5 or later the following is required to compile the class using a Java 5 compiler or later javac -source 1.4 OldSyntax. java Compiling for an older execution platform If you need to compile Java to run on an older Java platforms, the simplest approach is to install a JDK for the oldest GoalKicker.com Java Notes for Professionals 17version you need to support, and use that JDKs compiler in your builds. You can also compile with a newer Java compiler, but there are complicated. First of all, there some important preconditions that must be satis\ufb01ed The code you are compiling must not use Java language constructs that were not available in the version of Java that you are targeting. The code must not depend on standard Java classes, \ufb01elds, methods and so on that were not available in the older platforms. Third party libraries that the code depends must also be built for the older platform and available at compile- time and": "input.pdf", "run-time. Given the preconditions are met, you can recompile code for an older platform using the -target option. For example, javac -target 1.4 SomeClass. java will compile the above class to produce bytecodes that are compatible with Java 1.4 or later JVM. In fact, the - source option implies a compatible -target , so javac -source 1.4 ... would have the same e\ufb00ect. The relationship between -source and -target is described in the Oracle documentation. Having said that, if you simply use -target or -source , you will still be compiling against the standard class libraries provided by the compilers JDK. If you are not careful, you can end up with classes with the correct bytecode version, but with dependencies on APIs that are not available. The solution is to use the -bootclasspath option. For example javac -target 1.4 --bootclasspath path tojava1.4rt.jar SomeClass. java will compile against an alternative set of runtime libraries. If the class being compiled has accidental dependencies on newer libraries, this will give you compilation errors. GoalKicker.com Java Notes for Professionals 18Chapter 6 Documenting Java Code Documentation for java code is often generated using javadoc . Javadoc was created by Sun Microsystems for the purpose": "input.pdf", "of generating API documentation in HTML format from java source code. Using the HTML format gives the convenience of being able to hyperlink related documents together. Section 6.1 Building Javadocs From the Command Line Many IDEs provide support for generating HTML from Javadocs automatically some build tools Maven and Gradle , for example also have plugins that can handle the HTML creation. However, these tools are not required to generate the Javadoc HTML this can be done using the command line javadoc tool. The most basic usage of the tool is javadoc JavaFile. java Which will generate HTML from the Javadoc comments in JavaFile. java . A more practical use of the command line tool, which will recursively read all java \ufb01les in source-directory , create documentation for package.name and all sub-packages, and place the generated HTML in the docs- directory is javadoc -d docs-directory -subpackages -sourcepath source-directory package.name Section 6.2 Class Documentation All Javadoc comments begin with a block comment followed by an asterisk and end when the block comment does . Optionally, each line can begin with arbitrary whitespace and a single asterisk these are ignored when the documentation \ufb01les are generated. Brief summary of this class,": "input.pdf", "ending with a period. It is common to leave a blank line between the summary and further details. The summary everything before the first period is used in the class or package overview section. The following inline tags can be used not an exhaustive list link some.other.class.Documentation for linking to other docs or symbols link some.other.class.Documentation Some Display Name the links appearance can be customized by adding a display name after the doc or symbol locator code code goes here for formatting as code literal foo for interpreting literal text without converting to HTML markup or other tags. Optionally, the following tags may be used at the end of class documentation not an exhaustive list author John Doe version 1.0 since 51015 see some.other.class.Documentation deprecated This class has been replaced by some.other.package.BetterFileReader GoalKicker.com Java Notes for Professionals 19 You can also have custom tags for displaying additional information. Using the custom.NAME tag and the -tag custom.NAMEhtmltagcontext command line option, you can create a custom tag. Example custom tag and generation custom.updated 2.0 Javadoc flag -tag custom.updatedaUpdated in version The above flag will display the value of custom.updated under Updated in version public class FileReader The same tags and format": "input.pdf", "used for Classes can be used for Enums and Interfaces as well. Section 6.3 Method Documentation All Javadoc comments begin with a block comment followed by an asterisk and end when the block comment does . Optionally, each line can begin with arbitrary whitespace and a single asterisk these are ignored when the documentation \ufb01les are generated. Brief summary of method, ending with a period. Further description of method and what it does, including as much detail as is appropriate. Inline tags such as code code here, link some.other.Docs, and literal text here can be used. If a method overrides a superclass method, inheritDoc can be used to copy the documentation from the superclass method param stream Describe this parameter. Include as much detail as is appropriate Parameter docs are commonly aligned as here, but this is optional. As with other docs, the documentation before the first period is used as a summary. return Describe the return values. Include as much detail as is appropriate Return type docs are commonly aligned as here, but this is optional. As with other docs, the documentation before the first period is used as a summary. throws IOException Describe when and why this": "input.pdf", "exception can be thrown. Exception docs are commonly aligned as here, but this is optional. As with other docs, the documentation before the first period is used as a summary. Instead of throws, exception can also be used. since 2.1.0 see some.other.class.Documentation deprecated Describe why this method is outdated. A replacement can also be specified. public String readInputStream stream throws IOException return null GoalKicker.com Java Notes for Professionals 20Section 6.4 Package Documentation Version Java SE 5 It is possible to create package-level documentation in Javadocs using a \ufb01le called package-info.java . This \ufb01le must be formatted as below. Leading whitespace and asterisks optional, typically present in each line for formatting reason Package documentation goes here any documentation before the first period will be used as a summary. It is common practice to leave a blank line between the summary and the rest of the documentation use this space to describe the package in as much detail as is appropriate. Inline tags such as code code here, link reference.to.other.Documentation, and literal text here can be used in this documentation. package com.example.foo The rest of the file must be empty. In the above case, you must put this \ufb01le package-info.java inside": "input.pdf", "the folder of the Java package com.example.foo. Section 6.5 Links Linking to other Javadocs is done with the link tag You can link to the javadoc of an already imported class using link ClassName. You can also use the fully-qualified name, if the class is not already imported link some.other.ClassName You can link to members fields or methods of a class like so link ClassNamesomeMethod link ClassNamesomeMethodWithParametersint, String link ClassNamesomeField link someMethodInThisClass - used to link to members in the current class You can add a label to a linked javadoc like so link ClassNamesomeMethod link text GoalKicker.com Java Notes for Professionals 21With the see tag you can add elements to the See also section. Like param or return the place where they appear is not relevant. The spec says you should write it after return . This method has a nice explanation but you might found further information at the bottom. see ClassNamesomeMethod If you want to add links to external resources you can just use the HTML a tag. You can use it inline anywhere or inside both link and see tags. Wondering how this works? You might want to check this a hrefhttpstackoverflow.comgreat servicea. see a": "input.pdf", "hrefhttpstackoverflow.comStack Overflowa Section 6.6 Code snippets inside documentation The canonical way of writing code inside documentation is with the code construct. If you have multiline code wrap inside prepre. The Class TestUtils. p This is an code inlinecode example. p You should wrap it in pre tags when writing multiline code. precode Example example1 new FirstLineExample example1.butYouCanHaveMoreThanOneLine pre p Thanks for reading. class TestUtils Sometimes you may need to put some complex code inside the javadoc comment. The sign is specially problematic. The use of the old code tag alongside the literal construct solves the problem. Usage precode class SomethingTest literal Rule GoalKicker.com Java Notes for Professionals 22 public SingleTestRule singleTestRule new SingleTestRuletest1 literal Test public void test1 only this test will be executed ... codepre class SingleTestRule implements TestRule Section 6.7 Field Documentation All Javadoc comments begin with a block comment followed by an asterisk and end when the block comment does . Optionally, each line can begin with arbitrary whitespace and a single asterisk these are ignored when the documentation \ufb01les are generated. Fields can be documented as well. As with other javadocs, the documentation before the first period is used as a summary, and is usually": "input.pdf", "separated from the rest of the documentation by a blank line. Documentation for fields can use inline tags, such as code code here literal text here link other.docs.Here Field documentation can also make use of the following tags since 2.1.0 see some.other.class.Documentation deprecated Describe why this field is outdated public static final String CONSTANTSTRING foo Section 6.8 Inline Code Documentation Apart from the Javadoc documentation code can be documented inline. Single Line comments are started by and may be positioned after a statement on the same line, but not before. public void method single line comment someMethodCall single line comment after statement Multi-Line comments are de\ufb01ned between and . They can span multiple lines and may even been positioned between statements. public void methodObject object GoalKicker.com Java Notes for Professionals 23 multi line comment object inner-line-comment .method JavaDocs are a special form of multi-line comments, starting with . As too many inline comments may decrease readability of code, they should be used sparsely in case the code isnt self-explanatory enough or the design decision isnt obvious. An additional use case for single-line comments is the use of TAGs, which are short, convention driven keywords. Some development environments recognize certain": "input.pdf", "conventions for such single-comments. Common examples are TODO FIXME Or issue references, i.e. for Jira PRJ-1234 GoalKicker.com Java Notes for Professionals 24Chapter 7 Command line Argument Processing Parameter Details argsThe command line arguments. Assuming that the main method is invoked by the Java launcher, args will be non-null, and will have no null elements. Section 7.1 Argument processing using GWT ToolBase If you want to parse more complex command-line arguments, e.g. with optional parameters, than the best is to use googles GWT approach. All classes are public available at httpsgwt.googlesource.comgwt2.8.0-beta1devcoresrccomgooglegwtutiltoolsToolBase.java An example for handling the command-line myprogram -dir Documents -port 8888 is public class MyProgramHandler extends ToolBase protected File dir protected int port getters for dir and port ... public MyProgramHandler this.registerHandler new ArgHandlerDir Override public void setDirFile dir this.dir dir this.registerHandler new ArgHandlerInt Override public String getTagArgs return new Stringport Override public void setIntint value this.port value public static void mainString args MyProgramHandler myShell new MyProgramHandler if myShell. processArgs args main program operation System.out.printlnString.formatport d dir s , myShell. getPort, myShell. getDir System.exit1 ArgHandler also has a method isRequired which can be overwritten to say that the command-line argument is required default return is false so that the": "input.pdf", "argument is optional. Section 7.2 Processing arguments by hand When the command-line syntax for an application is simple, it is reasonable to do the command argument GoalKicker.com Java Notes for Professionals 25processing entirely in custom code. In this example, we will present a series of simple case studies. In each case, the code will produce error messages if the arguments are unacceptable, and then call System.exit1 to tell the shell that the command has failed. We will assume in each case that the Java code is invoked using a wrapper whose name is myapp. A command with no arguments In this case-study, the command requires no arguments. The code illustrates that args.length gives us the number of command line arguments. public class Main public static void mainString args if args.length 0 System.err.printlnusage myapp System.exit1 Run the application System.out.printlnIt worked A command with two arguments In this case-study, the command requires at precisely two arguments. public class Main public static void mainString args if args.length ! 2 System.err.printlnusage myapp arg1 arg2 System.exit1 Run the application System.out.printlnIt worked args0 , args1 Note that if we neglected to check args.length , the command would crash if the user ran it with too": "input.pdf", "few command-line arguments. A command with \ufb02ag options and at least one argument In this case-study, the command has a couple of optional \ufb02ag options, and requires at least one argument after the options. package tommy public class Main public static void mainString args boolean feelMe false boolean seeMe false int index loop for index 0 index args.length index String opt argsindex switch opt case -c seeMe true break case -f GoalKicker.com Java Notes for Professionals 26 feelMe true break default if !opts.isEmpty opts.charAt0 - error Unknown option opt break loop if index args.length error Missing arguments Run the application ... private static void errorString message if message ! null System.err.printlnmessage System.err.printlnusage myapp -f -c arg ... System.exit1 As you can see, processing the arguments and options gets rather cumbersome if the command syntax is complicated. It is advisable to use a command line parsing library see the other examples. GoalKicker.com Java Notes for Professionals 27Chapter 8 The Java Command - java and javaw Section 8.1 Entry point classes A Java entry-point class has a main method with the following signature and modi\ufb01ers public static void mainString args Sidenote because of how arrays work, it can also be String": "input.pdf", "args When the java command starts the virtual machine, it loads the speci\ufb01ed entry-point classes and tries to \ufb01nd main . If successful, the arguments from command line are converted to Java String objects and assembled into an array. If main is invoked like this, the array will not be null and wont contain any null entries. A valid entry-point class method must do the following Be named main case-sensitive Be public and static Have a void return type Have a single argument with an array String. The argument must be present and no more than one argument is allowed. Be generic type parameters are not allowed. Have a non-generic, top-level not nested or inner enclosing class It is conventional to declare the class as public but this not strictly necessary. From Java 5 onward, the main methods argument type may be a String varargs instead of a string array. main can optionally throw exceptions, and its parameter can be named anything, but conventionally it is args . JavaFX entry-points From Java 8 onwards the java command can also directly launch a JavaFX application. JavaFX is documented in the JavaFX tag, but a JavaFX entry-point must do the following": "input.pdf", "Extend javafx.application .Application Be public and not abstract Not be generic or nested Have an explicit or implicit public no-args constructor Section 8.2 Troubleshooting the java command This example covers common errors with using the java command. Command not found If you get an error message like java command not found when trying to run the java command, this means that there is no java command on your shells command search path. The cause could be GoalKicker.com Java Notes for Professionals 28you dont have a Java JRE or JDK installed at all, you have not updated the PATH environment variable correctly in your shell initialization \ufb01le, or you have not sourced the relevant initialization \ufb01le in the current shell. Refer to Installing Java for the steps that you need to take. Could not \ufb01nd or load main class This error message is output by the java command if it has been unable to \ufb01nd load the entry-point class that you have speci\ufb01ed. In general terms, there are three broad reasons that this can happen You have speci\ufb01ed an entry point class that does not exist. The class exists, but you have speci\ufb01ed it incorrectly. The class exists and you": "input.pdf", "have speci\ufb01ed it correctly, but Java cannot it \ufb01nd it because the classpath is incorrect. Here is a procedure to diagnose and solve the problem Find out the full name of the entry-point class.1. If you have source code for a class, then the full name consists of the package name and the simple class name. The instance the Main class is declared in the package com.example.myapp then its full name is com.example.myapp.Main. If you have a compiled class \ufb01le, you can \ufb01nd the class name by running javap on it. If the class \ufb01le is in a directory, you can infer the full class name from the directory names. If the class \ufb01le is in a JAR or ZIP \ufb01le, you can infer the full class name from the \ufb01le path in the JAR or ZIP \ufb01le. Look at the error message from the java command. The message should end with the full class name that 2. java is trying to use. Check that it exactly matches the full classname for the entry-point class. It should not end with .java or .class. It should not contain slashes or any other character that is not legal in a Java": "input.pdf", "identi\ufb01er1. The casing of the name should exactly match the full class name. If you are using the correct classname, make sure that the class is actually on the classpath3. Work out the pathname that the classname maps to see Mapping classnames to pathnames Work out what the classpath is see this example Di\ufb00erent ways to specify the classpath Look at each of the JAR and ZIP \ufb01les on the classpath to see if they contain a class with the required pathname. Look at each directory to see if the pathname resolves to a \ufb01le within the directory. If checking the classpath by hand did not \ufb01nd the issue, you could add the -Xdiag and -XshowSettings options. The former lists all classes that are loaded, and the latter prints out settings that include the e\ufb00ective classpath for the JVM. Finally, there are some obscure causes for this problem An executable JAR \ufb01le with a Main-Class attribute that speci\ufb01es a class that does not exist. An executable JAR \ufb01le with an incorrect Class-Path attribute. If you mess up2 the options before the classname, the java command may attempt to interpret one of them GoalKicker.com Java Notes for Professionals 29as the": "input.pdf", "classname. If someone has ignored Java style rules and used package or class identi\ufb01ers that di\ufb00er only in letter case, and you are running on a platform that treats letter case in \ufb01lenames as non-signi\ufb01cant. Problems with homoglyphs in class names in the code or on the command line. Main method not found in class name This problem happens when the java command is able to \ufb01nd and load the class that you nominated, but is then unable to \ufb01nd an entry-point method. There are three possible explanations If you are trying to run an executable JAR \ufb01le, then the JARs manifest has an incorrect Main-Class attribute that speci\ufb01es a class that is not a valid entry point class. You have told the java command a class that is not an entry point class. The entry point class is incorrect see Entry point classes for more information. Other Resources What does Could not \ufb01nd or load main class mean? httpdocs.oracle.comjavasetutorialgetStartedproblemsindex.html 1 - From Java 8 and later, the java command will helpfully map a \ufb01lename separator or to a period .. However, this behavior is not documented in the manual pages. 2 - A really obscure case is if": "input.pdf", "you copy-and-paste a command from a formatted document where the text editor has used a long hyphen instead of a regular hyphen. Section 8.3 Running a Java application with library dependencies This is a continuation of the main class and executable JAR examples. Typical Java applications consist of an application-speci\ufb01c code, and various reusable library code that you have implemented or that has been implemented by third parties. The latter are commonly referred to as library dependencies, and are typically packaged as JAR \ufb01les. Java is a dynamically bound language. When you run a Java application with library dependencies, the JVM needs to know where the dependencies are so that it can load classes as required. Broadly speaking, there are two ways to deal with this The application and its dependencies can be repackaged into a single JAR \ufb01le that contains all of the required classes and resources. The JVM can be told where to \ufb01nd the dependent JAR \ufb01les via the runtime classpath. For an executable JAR \ufb01le, the runtime classpath is speci\ufb01ed by the Class-Path manifest attribute. Editorial Note This should be described in a separate Topic on the jar command. Otherwise, the runtime classpath needs to": "input.pdf", "be supplied using the -cp option or using the CLASSPATH environment variable. For example, suppose that we have a Java application in the myApp.jar \ufb01le whose entry point class is com.example.MyApp . Suppose also that the application depends on library JAR \ufb01les liblibrary1.jar and liblibrary2.jar. We could launch the application using the java command as follows in a command line Alternative 1 preferred GoalKicker.com Java Notes for Professionals 30 java -cp myApp. jarliblibrary1. jarliblibrary2. jar com.example.MyApp Alternative 2 export CLASSPATH myApp.jarliblibrary1. jarliblibrary2. jar java com. example.MyApp On Windows, you would use instead of as the classpath separator, and you would set the local CLASSPATH variable using set rather than export . While a Java developer would be comfortable with that, it is not user friendly. So it is common practice to write a simple shell script or Windows batch \ufb01le to hide the details that the user doesnt need to know about. For example, if you put the following shell script into a \ufb01le called myApp, made it executable, and put it into a directory on the command search path !binbash The myApp wrapper script export DIRusrlibexecmyApp export CLASSPATH DIRmyApp.jar DIRliblibrary1.jar DIRliblibrary2.jar java com.example.MyApp then you could run it": "input.pdf", "as follows myApp arg1 arg2 ... Any arguments on the command line will be passed to the Java application via the expansion. You can do something similar with a Windows batch \ufb01le, though the syntax is di\ufb00erent. Section 8.4 Java Options The java command supports a wide range of options All options start with a single hyphen or minus-sign - the GNULinux convention of using -- for long options is not supported. Options must appear before the classname or the -jar jarfile argument to be recognized. Any arguments after them will be treated as arguments to be passed to Java app that is being run. Options that do not start with -X or -XX are standard options. You can rely on all Java implementations1 to support any standard option. Options that start with -X are non-standard options, and may be withdrawn from one Java version to the next. Options that start with -XX are advanced options, and may also be withdrawn. Setting system properties with -D The -Dproperty value option is used to set a property in the system Properties object. This parameter can be repeated to set di\ufb00erent properties. Memory, Stack and Garbage Collector options The main options": "input.pdf", "for controlling the heap and stack sizes are documented in Setting the Heap, PermGen and Stack sizes. Editorial note Garbage Collector options should be described in the same topic. GoalKicker.com Java Notes for Professionals 31Enabling and disabling assertions The -ea and -da options respectively enable and disable Java assert checking All assertion checking is disabled by default. The -ea option enables checking of all assertions The -eapackagename ... enables checking of assertions in a package and all subpackages . The -eaclassname ... enables checking of assertions in a class. The -da option disables checking of all assertions The -dapackagename ... disables checking of assertions in a package and all subpackages . The -daclassname ... disables checking of assertions in a class. The -esa option enables checking for all system classes. The -dsa option disables checking for all system classes. The options can be combined. For example. Enable all assertion checking in non -system classes java -ea -dsa MyApp Enable assertions for all classes in a package except for one. java -eacom.wombat.fruitbat ... -dacom.wombat.fruitbat .Brickbat MyApp Note that enabling to assertion checking is liable to alter the behavior of a Java programming. It is liable make the application slower in": "input.pdf", "general. It can cause speci\ufb01c methods to take longer to run, which could change timing of threads in a multi-threaded application. It can introduce serendipitous happens-before relations which can cause memory anomalies to disappear. An incorrectly implemented assert statement could have unwanted side-e\ufb00ects. Selecting the VM type The -client and -server options allow you to select between two di\ufb00erent forms of the HotSpot VM The client form is tuned for user applications and o\ufb00ers faster startup. The server form is tuned for long running applications. It takes longer capturing statistic during JVM warm up which allows the JIT compiler to do a better of job of optimizing the native code. By default, the JVM will run in 64bit mode if possible, depending on the capabilities of the platform. The -d32 and - d64 options allow you to select the mode explicitly. 1 - Check the o\ufb03cial manual for the java command. Sometimes a standard option is described as subject to change. Section 8.5 Spaces and other special characters in arguments First of all, the problem of handling spaces in arguments is NOT actually a Java problem. Rather it is a problem that needs to be handled by the command": "input.pdf", "shell that you are using when you run a Java program. As an example, let us suppose that we have the following simple program that prints the size of a \ufb01le import java.io.File public class PrintFileSizes GoalKicker.com Java Notes for Professionals 32 public static void mainString args for String name args File file new Filename System.out.printlnSize of file is file.size Now suppose that we want print the size of a \ufb01le whose pathname has spaces in it e.g. homesteveTest File.txt. If we run the command like this java PrintFileSizes homesteveTest File.txt the shell wont know that homesteveTest File.txt is actually one pathname. Instead, it will pass 2 distinct arguments to the Java application, which will attempt to \ufb01nd their respective \ufb01le sizes, and fail because \ufb01les with those paths probably do not exist. Solutions using a POSIX shell POSIX shells include sh as well derivatives such as bash and ksh. If you are using one of these shells, then you can solve the problem by quoting the argument. java PrintFileSizes homesteveTest File.txt The double-quotes around the pathname tell the shell that it should be passed as a single argument. The quotes will be removed when this happens. There are": "input.pdf", "a couple of other ways to do this java PrintFileSizes homesteveTest File.txt Single straight quotes are treated like double-quotes except that they also suppress various expansions within the argument. java PrintFileSizes homesteveTest File.txt A backslash escapes the following space, and causes it not to be interpreted as an argument separator. For more comprehensive documentation, including descriptions of how to deal with other special characters in arguments, please refer to the quoting topic in the Bash documentation. Solution for Windows The fundamental problem for Windows is that at the OS level, the arguments are passed to a child process as a single string source . This means that the ultimate responsibility of parsing or re-parsing the command line falls on either program or its runtime libraries. There is lots of inconsistency. In the Java case, to cut a long story short You can put double-quotes around an argument in a java command, and that will allow you to pass arguments with spaces in them. Apparently, the java command itself is parsing the command string, and it gets it more or less right However, when you try to combine this with the use of SET and variable substitution in a batch": "input.pdf", "\ufb01le, it gets really complicated as to whether double-quotes get removed. GoalKicker.com Java Notes for Professionals 33The cmd.exe shell apparently has other escaping mechanisms e.g. doubling double-quotes, and using escapes. For more detail, please refer to the Batch-File documentation. Section 8.6 Running an executable JAR \ufb01le Executable JAR \ufb01les are the simplest way to assemble Java code into a single \ufb01le that can be executed. Editorial Note Creation of JAR \ufb01les should be covered by a separate Topic. Assuming that you have an executable JAR \ufb01le with pathname jar-path , you should be able to run it as follows java -jar jar-path If the command requires command-line arguments, add them after the jar-path . For example java -jar jar-path arg1 arg2 arg3 If you need to provide additional JVM options on the java command line, they need to go before the -jar option. Note that a -cp -classpath option will be ignored if you use -jar. The applications classpath is determined by the JAR \ufb01le manifest. Section 8.7 Running a Java applications via a main class When an application has not been packaged as an executable JAR, you need to provide the name of an entry-point class on the": "input.pdf", "java command line. Running the HelloWorld class The HelloWorld example is described in Creating a new Java program . It consists of a single class called HelloWorld which satis\ufb01es the requirements for an entry-point. Assuming that the compiled HelloWorld.class \ufb01le is in the current directory, it can be launched as follows java HelloWorld Some important things to note are We must provide the name of the class not the pathname for the .class \ufb01le or the .java \ufb01le. If the class is declared in a package as most Java classes are, then the class name we supply to the java command must be the full classname. For instance if SomeClass is declared in the com.example package, then the full classname will be com.example.SomeClass . Specifying a classpath Unless we are using in the java -jar command syntax, the java command looks for the class to be loaded by searching the classpath see The Classpath. The above command is relying on the default classpath being or including the current directory. We can be more explicit about this by specifying the classpath to be used using the -cp option. java -cp . HelloWorld This says to make the current directory which": "input.pdf", "is what . refers to the sole entry on the classpath. GoalKicker.com Java Notes for Professionals 34The -cp is an option that is processed by the java command. All options that are intended for the java command should be before the classname. Anything after the class will be treated as an command line argument for the Java application, and will be passed to application in the String that is passed to the main method. If no -cp option is provided, the java will use the classpath that is given by the CLASSPATH environment variable. If that variable is unset or empty, java uses . as the default classpath. GoalKicker.com Java Notes for Professionals 35Chapter 9 Literals A Java literal is a syntactic element i.e. something you \ufb01nd in the source code of a Java program that represents a value. Examples are 1, 0.333F , false , 39X39 and Hello world n. Section 9.1 Using underscore to improve readability Since Java 7 it has been possible to use one or more underscores for separating groups of digits in a primitive number literal to improve their readability. For instance, these two declarations are equivalent Version Java SE 7 int i1 123456": "input.pdf", "int i2 123456 System.out.printlni1 i2 true This can be applied to all primitive number literals as shown below Version Java SE 7 byte color 123 short yearsAnnoDomini 2016 int socialSecurtyNumber 999999999 long creditCardNumber 1234567890123456L float piFourDecimals 3.1415F double piTenDecimals 3.1415926535 This also works using pre\ufb01xes for binary, octal and hexadecimal bases Version Java SE 7 short binary 0b0101 int octal 0777777770 long hexBytes 0xFFECDE5E There are a few rules about underscores which forbid their placement in the following places At the beginning or end of a number e.g. 123 or 123 are not valid Adjacent to a decimal point in a \ufb02oating point literal e.g. 1.23 or 1.23 are not valid Prior to an F or L su\ufb03x e.g. 1.23F or 9999999L are not valid In positions where a string of digits is expected e.g. 0xFFFF is not valid Section 9.2 Hexadecimal, Octal and Binary literals A hexadecimal number is a value in base-16. There are 16 digits, 0-9 and the letters A-F case does not matter. A-F represent 10-15. An octal number is a value in base-8, and uses the digits 0-7. A binary number is a value in base-2, and uses the digits 0 and 1. All": "input.pdf", "of these numbers result in the same value, 110 int dec 110 no prefix -- decimal literal int bin 0b1101110 0b prefix -- binary literal int oct 0156 0 prefix -- octal literal GoalKicker.com Java Notes for Professionals 36int hex 0x6E 0x prefix -- hexadecimal literal Note that binary literal syntax was introduced in Java 7. The octal literal can easily be a trap for semantic errors. If you de\ufb01ne a leading 0 to your decimal literals you will get the wrong value int a 0100 Instead of 100, a 64 Section 9.3 Boolean literals Boolean literals are the simplest of the literals in the Java programming language. The two possible boolean values are represented by the literals true and false . These are case-sensitive. For example boolean flag true using the true literal flag false using the false literal Section 9.4 String literals String literals provide the most convenient way to represent string values in Java source code. A String literal consists of An opening double-quote character. Zero or more other characters that are neither a double-quote or a line-break character. A backslash character alters the meaning of subsequent characters see Escape sequences in literals. A closing double-quote": "input.pdf", "character. For example Hello world A literal denoting an 11 character String A literal denoting an empty zero length String A literal denoting a String consisting of one double quote character 1t2t3n Another literal with escape sequences Note that a single string literal may not span multiple source code lines. It is a compilation error for a line-break or the end of the source \ufb01le to occur before a literals closing double-quote. For example Jello world Compilation error at the end of the line! Long strings If you need a string that is too long to \ufb01t on a line, the conventional way to express it is to split it into multiple literals and use the concatenation operator to join the pieces. For example String typingPractice The quick brown fox jumped over the lazy dog An expression like the above consisting of string literals and satis\ufb01es the requirements to be a Constant Expression. That means that the expression will be evaluated by the compiler and represented at runtime by a single String object. Interning of string literals GoalKicker.com Java Notes for Professionals 37When class \ufb01le containing string literals is loaded by the JVM, the corresponding String objects are interned": "input.pdf", "by the runtime system. This means that a string literal used in multiple classes occupies no more space than if it was used in one class. For more information on interning and the string pool, refer to the String pool and heap storage example in the Strings topic. Section 9.5 The Null literal The Null literal written as null represents the one and only value of the null type. Here are some examples MyClass object null MyClass objects new MyClass new MyClass , null, new MyClass myMethod null if objects ! null Do something The null type is rather unusual. It has no name, so you cannot express it in Java source code. And it has no runtime representation either. The sole purpose of the null type is to be the type of null . It is assignment compatible with all reference types, and can be type cast to any reference type. In the latter case, the cast does not entail a runtime type check. Finally, null has the property that null instanceof SomeReferenceType will evaluate to false , no matter what the type is. Section 9.6 Escape sequences in literals String and character literals provide an escape mechanism": "input.pdf", "that allows express character codes that would otherwise not be allowed in the literal. An escape sequence consists of a backslash character followed by one ore more other characters. The same sequences are valid in both character an string literals. The complete set of escape sequences is as follows Escape sequence Meaning Denotes an backslash character Denotes a single-quote character Denotes a double-quote character n Denotes a line feed LF character r Denotes a carriage return CR character t Denotes a horizontal tab HT character f Denotes a form feed FF character b Denotes a backspace BS character octal Denotes a character code in the range 0 to 255. The octal in the above consists of one, two or three octal digits 0 through 7 which represent a number between 0 and 255 decimal. Note that a backslash followed by any other character is an invalid escape sequence. Invalid escape sequences are treated as compilation errors by the JLS. GoalKicker.com Java Notes for Professionals 38Reference JLS 3.10.6. Escape Sequences for Character and String Literals Unicode escapes In addition to the string and character escape sequences described above, Java has a more general Unicode escaping mechanism, as de\ufb01ned in JLS": "input.pdf", "3.3. Unicode Escapes . A Unicode escape has the following syntax u hex-digit hex-digit hex-digit hex-digit where hex-digit is one of 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, A, B, C, D, E, F. A Unicode escape is mapped by the Java compiler to a character strictly speaking a 16-bit Unicode code unit , and can be used anywhere in the source code where the mapped character is valid. It is commonly used in character and string literals when you need to represent a non-ASCII character in a literal. Escaping in regexes TBD Section 9.7 Character literals Character literals provide the most convenient way to express char values in Java source code. A character literal consists of An opening single-quote character. A representation of a character. This representation cannot be a single-quote or a line-break character, but it can be an escape sequence introduced by a backslash character see Escape sequences in literals. A closing single-quote character. For example char a a char doubleQuote char singleQuote A line-break in a character literal is a compilation error char newline Compilation error in previous line char newLine n Correct Section 9.8 Decimal": "input.pdf", "Integer literals Integer literals provide values that can be used where you need a byte , short , int, long or char instance. This example focuses on the simple decimal forms. Other examples explain how to literals in octal, hexadecimal and binary, and the use of underscores to improve readability. Ordinary integer literals The simplest and most common form of integer literal is a decimal integer literal. For example 0 The decimal number zero type int GoalKicker.com Java Notes for Professionals 39 1 The decimal number one type int 42 The decimal number forty two type int You need to be careful with leading zeros. A leading zero causes an integer literal to be interpreted as octal not decimal. 077 This literal actually means 7 x 8 7 ... or 63 decimal! Integer literals are unsigned. If you see something like -10 or 10, these are actually expressions using the unary - and unary operators. The range of integer literals of this form have an intrinsic type of int, and must fall in the range zero to 231 or 2,147,483,648. Note that 231 is 1 greater than Integer.MAXVALUE . Literals from 0 through to 2147483647 can be used anywhere,": "input.pdf", "but it is a compilation error to use 2147483648 without a preceding unary - operator. In other words, it is reserved for expressing the value of Integer.MINVALUE . int max 2147483647 OK int min -2147483648 OK int tooBig 2147483648 ERROR Long integer literals Literals of type long are expressed by adding an L su\ufb03x. For example 0L The decimal number zero type long 1L The decimal number one type long 2147483648L The value of Integer.MAXVALUE 1 long big 2147483648 ERROR long big2 2147483648L OK Note that the distinction between int and long literals is signi\ufb01cant in other places. For example int i 2147483647 long l i 1 Produces a negative value because the operation is performed using 32 bit arithmetic, and the addition overflows long l2 i 1L Produces the intuitively correct value. Reference JLS 3.10.1 - Integer Literals Section 9.9 Floating-point literals Floating point literals provide values that can be used where you need a float or double instance. There are three kinds of \ufb02oating point literal. Simple decimal forms Scaled decimal forms Hexadecimal forms The JLS syntax rules combine the two decimal forms into a single form. We treat them separately for ease of explanation. GoalKicker.com Java": "input.pdf", "Notes for Professionals 40There are distinct literal types for float and double literals, expressed using su\ufb03xes. The various forms use letters to express di\ufb00erent things. These letters are case insensitive. Simple decimal forms The simplest form of \ufb02oating point literal consists of one or more decimal digits and a decimal point . and an optional su\ufb03x f, F, d or D. The optional su\ufb03x allows you to specify that the literal is a float f or F or double d or D value. The default when no su\ufb03x is speci\ufb01ed is double . For example 0.0 this denotes zero .0 this also denotes zero 0. this also denotes zero 3.14159 this denotes Pi, accurate to approximately! 5 decimal places. 1.0F a float literal 1.0D a double literal. double is the default if no suffix is given In fact, decimal digits followed by a su\ufb03x is also a \ufb02oating point literal. 1F means the same thing as 1.0F The meaning of a decimal literal is the IEEE \ufb02oating point number that is closest to the in\ufb01nite precision mathematical Real number denoted by the decimal \ufb02oating point form. This conceptual value is converted to IEEE binary \ufb02oating point representation using round": "input.pdf", "to nearest . The precise semantics of decimal conversion are speci\ufb01ed in the javadocs for Double.valueOfString and Float.valueOfString, bearing in mind that there are di\ufb00erences in the number syntaxes. Scaled decimal forms Scaled decimal forms consist of simple decimal with an exponent part introduced by an E or e, and followed by a signed integer. The exponent part is a short hand for multiplying the decimal form by a power of ten, as shown in the examples below. There is also an optional su\ufb03x to distinguish float and double literals. Here are some examples 1.0E1 this means 1.0 x 101 ... or 10.0 double 1E-1D this means 1.0 x 10-1 ... or 0.1 double 1.0e10f this means 1.0 x 1010 ... or 10000000000.0 float The size of a literal is limited by the representation float or double . It is a compilation error if the scale factor results in a value that is too large or too small. Hexadecimal forms Starting with Java 6, it is possible to express \ufb02oating point literals in hexadecimal. The hexadecimal form have an analogous syntax to the simple and scaled decimal forms with the following di\ufb00erences Every hexadecimal \ufb02oating point literal starts with": "input.pdf", "a zero 0 and then an x or X. 1. The digits of the number but not the exponent part! also include the hexadecimal digits a through f and 2. their uppercase equivalents. The exponent is mandatory , and is introduced by the letter p or P instead of an e or E. The exponent 3. represents a scaling factor that is a power of 2 instead of a power of 10. Here are some examples GoalKicker.com Java Notes for Professionals 410x0.0p0f this is zero expressed in hexadecimal form float 0xff.0p19 this is 255.0 x 219 double Advice since hexadecimal \ufb02oating-point forms are unfamiliar to most Java programmers, it is advisable to use them sparingly. Underscores Starting with Java 7, underscores are permitted within the digit strings in all three forms of \ufb02oating point literal. This applies to the exponent parts as well. See Using underscores to improve readability. Special cases It is a compilation error if a \ufb02oating point literal denotes a number that is too large or too small to represent in the selected representation i.e. if the number would over\ufb02ow to INF or -INF, or under\ufb02ow to 0.0. However, it is legal for a literal to": "input.pdf", "represent a non-zero denormalized number. The \ufb02oating point literal syntax does not provide literal representations for IEEE 754 special values such as the INF and NaN values. If you need to express them in source code, the recommended way is to use the constants de\ufb01ned by the java.lang.Float and java.lang.Double e.g. Float.NaN, Float.NEGATIVEINFINITY and Float.POSITIVEINFINITY . GoalKicker.com Java Notes for Professionals 42Chapter 10 Primitive Data Types The 8 primitive data types byte , short , int, long , char , boolean , float , and double are the types that store most raw numerical data in Java programs. Section 10.1 The char primitive A char can store a single 16-bit Unicode character. A character literal is enclosed in single quotes char myChar u char myChar2 5 char myChar3 65 myChar3 A It has a minimum value of u0000 0 in the decimal representation, also called the null character and a maximum value of uffff 65,535. The default value of a char is u0000 . char defaultChar defaultChar u0000 In order to de\ufb01ne a char of value an escape sequence character preceded by a backslash has to be used char singleQuote There are also other escape sequences char tab t": "input.pdf", "char backspace b char newline n char carriageReturn r char formfeed f char singleQuote char doubleQuote escaping redundant here would be the same however still allowed char backslash char unicodeChar uXXXX XXXX represents the Unicode-value of the character you want to display You can declare a char of any Unicode character. char heart u2764 System.out.printlnCharacter .toString heart Prints a line containing . It is also possible to add to a char . e.g. to iterate through every lower-case letter, you could do to the following for int i 0 i 26 i char letter char a i System.out.printlnletter Section 10.2 Primitive Types Cheatsheet Table showing size and values range of all primitive types data type numeric representation range of valuesdefault value GoalKicker.com Java Notes for Professionals 43boolean na false and true false byte 8-bit signed -27 to 27 - 1 0 -128 to 127 short 16-bit signed -215 to 215 - 1 0 -32,768 to 32,767 int 32-bit signed -231 to 231 - 1 0 -2,147,483,648 to 2,147,483,647 long 64-bit signed -263 to 263 - 1 0L -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 \ufb02oat 32-bit \ufb02oating point 1.401298464e-45 to 3.402823466e38 positive or negative 0.0F double 64-bit \ufb02oating point4.94065645841246544e-324d to 1.79769313486231570e308d positive or": "input.pdf", "negative0.0D char 16-bit unsigned 0 to 216 - 1 0 0 to 65,535 Notes The Java Language Speci\ufb01cation mandates that signed integral types byte through long use binary twos- 1. complement representation, and the \ufb02oating point types use standard IEE 754 binary \ufb02oating point representations. Java 8 and later provide methods to perform unsigned arithmetic operations on int and long . While these 2. methods allow a program to treat values of the respective types as unsigned, the types remain signed types. The smallest \ufb02oating point shown above are subnormal i.e. they have less precision than a normal value. The 3. smallest normal numbers are 1.175494351e 38 and 2.2250738585072014e 308 A char conventionally represents a Unicode UTF-16 code unit . 4. Although a boolean contains just one bit of information, its size in memory varies depending on the Java 5. Virtual Machine implementation see boolean type . Section 10.3 The \ufb02oat primitive A float is a single-precision 32-bit IEEE 754 \ufb02oating point number. By default, decimals are interpreted as doubles. To create a float , simply append an f to the decimal literal. double doubleExample 0.5 without f after digits double float floatExample 0.5f with f after digits float": "input.pdf", "float myFloat 92.7f this is a float... float positiveFloat 89.3f it can be positive, float negativeFloat -89.3f or negative float integerFloat 43.0f it can be a whole number not an int float underZeroFloat 0.0549f it can be a fractional value less than 0 Floats handle the \ufb01ve common arithmetical operations addition, subtraction, multiplication, division, and modulus. Note The following may vary slightly as a result of \ufb02oating point errors. Some results have been rounded for clarity and readability purposes i.e. the printed result of the addition example was actually 34.600002. addition float result 37.2f -2.6f result 34.6 subtraction float result 45.1f - 10.3f result 34.8 GoalKicker.com Java Notes for Professionals 44 multiplication float result 26.3f 1.7f result 44.71 division float result 37.1f 4.8f result 7.729166 modulus float result 37.1f 4.8f result 3.4999971 Because of the way \ufb02oating point numbers are stored i.e. in binary form, many numbers dont have an exact representation. float notExact 3.1415926f System.out.printlnnotExact 3.1415925 While using float is \ufb01ne for most applications, neither float nor double should be used to store exact representations of decimal numbers like monetary amounts, or numbers where higher precision is required. Instead, the BigDecimal class should be used. The default value": "input.pdf", "of a float is 0.0f. float defaultFloat defaultFloat 0.0f A float is precise to roughly an error of 1 in 10 million. Note Float.POSITIVEINFINITY , Float.NEGATIVEINFINITY , Float.NaN are float values. NaN stands for results of operations that cannot be determined, such as dividing 2 in\ufb01nite values. Furthermore 0f and -0f are di\ufb00erent, but yields true float f1 0f float f2 -0f System.out.printlnf1 f2 true System.out.println1f f1 Infinity System.out.println1f f2 -Infinity System.out.printlnFloat.POSITIVEINFINITY Float.POSITIVEINFINITY NaN Section 10.4 The int primitive A primitive data type such as int holds values directly into the variable that is using it, meanwhile a variable that was declared using Integer holds a reference to the value. According to java API The Integer class wraps a value of the primitive type int in an object. An object of type Integer contains a single \ufb01eld whose type is int. By default, int is a 32-bit signed integer. It can store a minimum value of -231, and a maximum value of 231 - 1. int example -42 int myInt 284 int anotherInt 73 int addedInts myInt anotherInt 284 73 357 int subtractedInts myInt - anotherInt 284 - 73 211 If you need to store a number outside of": "input.pdf", "this range, long should be used instead. Exceeding the value range of int leads to an integer over\ufb02ow, causing the value exceeding the range to be added to the opposite site of the range positive becomes negative and vise versa. The value is value - MINVALUE RANGE MINVALUE , or value GoalKicker.com Java Notes for Professionals 45 2147483648 4294967296 - 2147483648 int demo 2147483647 maximum positive integer System.out.printlndemo prints 2147483647 demo demo 1 leads to an integer overflow System.out.printlndemo prints -2147483648 The maximum and minimum values of int can be found at int high Integer.MAXVALUE high 2147483647 int low Integer.MINVALUE low -2147483648 The default value of an int is 0 int defaultInt defaultInt 0 Section 10.5 Converting Primitives In Java, we can convert between integer values and \ufb02oating-point values. Also, since every character corresponds to a number in the Unicode encoding, char types can be converted to and from the integer and \ufb02oating-point types. boolean is the only primitive datatype that cannot be converted to or from any other primitive datatype. There are two types of conversions widening conversion and narrowing conversion . A widening conversion is when a value of one datatype is converted to a value of": "input.pdf", "another datatype that occupies more bits than the former. There is no issue of data loss in this case. Correspondingly, A narrowing conversion is when a value of one datatype is converted to a value of another datatype that occupies fewer bits than the former. Data loss can occur in this case. Java performs widening conversions automatically. But if you want to perform a narrowing conversion if you are sure that no data loss will occur, then you can force Java to perform the conversion using a language construct known as a cast . Widening Conversion int a 1 double d a valid conversion to double, no cast needed widening Narrowing Conversion double d 18.96 int b d invalid conversion to int, will throw a compile-time error int b int d valid conversion to int, but result is truncated gets rounded down This is type-casting Now, b 18 Section 10.6 Memory consumption of primitives vs. boxed primitives Primitive Boxed Type Memory Size of primitive boxed boolean Boolean 1 byte 16 bytes byte Byte 1 byte 16 bytes short Short 2 bytes 16 bytes GoalKicker.com Java Notes for Professionals 46char Char 2 bytes 16 bytes int Integer 4 bytes 16": "input.pdf", "bytes long Long 8 bytes 16 bytes \ufb02oat Float 4 bytes 16 bytes double Double 8 bytes 16 bytes Boxed objects always require 8 bytes for type and memory management, and because the size of objects is always a multiple of 8, boxed types all require 16 bytes total . In addition , each usage of a boxed object entails storing a reference which accounts for another 4 or 8 bytes, depending on the JVM and JVM options. In data-intensive operations, memory consumption can have a major impact on performance. Memory consumption grows even more when using arrays a float5 array will require only 32 bytes whereas a Float5 storing 5 distinct non-null values will require 112 bytes total on 64 bit without compressed pointers, this increases to 152 bytes. Boxed value caches The space overheads of the boxed types can be mitigated to a degree by the boxed value caches. Some of the boxed types implement a cache of instances. For example, by default, the Integer class will cache instances to represent numbers in the range -128 to 127. This does not, however, reduce the additional cost arising from the additional memory indirection. If you create an instance": "input.pdf", "of a boxed type either by autoboxing or by calling the static valueOfprimitive method, the runtime system will attempt to use a cached value. If your application uses a lot of values in the range that is cached, then this can substantially reduce the memory penalty of using boxed types. Certainly, if you are creating boxed value instances by hand, it is better to use valueOf rather than new. The new operation always creates a new instance. If, however, the majority of your values are not in the cached range, it can be faster to call new and save the cache lookup. Section 10.7 The double primitive A double is a double-precision 64-bit IEEE 754 \ufb02oating point number. double example -7162.37 double myDouble 974.21 double anotherDouble 658.7 double addedDoubles myDouble anotherDouble 315.51 double subtractedDoubles myDouble - anotherDouble 1632.91 double scientificNotationDouble 1.2e-3 0.0012 Because of the way \ufb02oating point numbers are stored, many numbers dont have an exact representation. double notExact 1.32 - 0.42 result should be 0.9 System.out.printlnnotExact 0.9000000000000001 While using double is \ufb01ne for most applications, neither float nor double should be used to store precise numbers such as currency. Instead, the BigDecimal class should be used The": "input.pdf", "default value of a double is 0.0d public double defaultDouble defaultDouble 0.0 GoalKicker.com Java Notes for Professionals 47Note Double.POSITIVEINFINITY , Double.NEGATIVEINFINITY , Double.NaN are double values. NaN stands for results of operations that cannot be determined, such as dividing 2 in\ufb01nite values. Furthermore 0d and -0d are di\ufb00erent, but yields true double d1 0d double d2 -0d System.out.printlnd1 d2 true System.out.println1d d1 Infinity System.out.println1d d2 -Infinity System.out.printlnDouble.POSITIVEINFINITY Double.POSITIVEINFINITY NaN Section 10.8 The long primitive By default, long is a 64-bit signed integer in Java 8, it can be either signed or unsigned. Signed, it can store a minimum value of -263, and a maximum value of 263 - 1, and unsigned it can store a minimum value of 0 and a maximum value of 264 - 1 long example -42 long myLong 284 long anotherLong 73 an L must be appended to the end of the number, because by default, numbers are assumed to be the int type. Appending an L makes it a long as 549755813888 2 39 is larger than the maximum value of an int 231 - 1, L must be appended long bigNumber 549755813888L long addedLongs myLong anotherLong 284 73 357 long subtractedLongs myLong -": "input.pdf", "anotherLong 284 - 73 211 The maximum and minimum values of long can be found at long high Long.MAXVALUE high 9223372036854775807L long low Long.MINVALUE low -9223372036854775808L The default value of a long is 0L long defaultLong defaultLong 0L Note letter L appended at the end of long literal is case insensitive, however it is good practice to use capital as it is easier to distinct from digit one 2L 2l true Warning Java caches Integer objects instances from the range -128 to 127. The reasoning is explained here httpsblogs.oracle.comdarcyentryboxingandcachesintegervalueof The following results can be found Long val1 127L Long val2 127L System.out.printlnval1 val2 true Long val3 128L Long val4 128L GoalKicker.com Java Notes for Professionals 48System.out.printlnval3 val4 false To properly compare 2 Object Long values, use the following codeFrom Java 1.7 onward Long val3 128L Long val4 128L System.out.printlnObjects. equalval3, val4 true Comparing a primitive long to an Object long will not result in a false negative like comparing 2 objects with does. Section 10.9 The boolean primitive A boolean can store one of two values, either true or false boolean foo true System.out.printlnfoo foo foo true boolean bar false System.out.printlnbar bar bar false boolean notFoo !foo System.out.printlnnotFoo notFoo": "input.pdf", "notFoo false boolean fooAndBar foo bar System.out.printlnfooAndBar fooAndBar fooAndBar false boolean fooOrBar foo bar System.out.printlnfooOrBar fooOrBar fooOrBar true boolean fooXorBar foo bar System.out.printlnfooXorBar fooXorBar fooXorBar true The default value of a boolean is false boolean defaultBoolean defaultBoolean false Section 10.10 The byte primitive A byte is a 8-bit signed integer. It can store a minimum value of -27 -128, and a maximum value of 27 - 1 127 byte example -36 byte myByte 96 byte anotherByte 7 byte addedBytes byte myByte anotherByte 103 byte subtractedBytes byte myBytes - anotherByte 89 The maximum and minimum values of byte can be found at byte high Byte.MAXVALUE high 127 byte low Byte.MINVALUE low -128 The default value of a byte is 0 GoalKicker.com Java Notes for Professionals 49byte defaultByte defaultByte 0 Section 10.11 Negative value representation Java and most other languages store negative integral numbers in a representation called 2s complement notation. For a unique binary representation of a data type using n bits, values are encoded like this The least signi\ufb01cant n-1 bits store a positive integral number x in integral representation. Most signi\ufb01cant value stores a bit vith value s. The value repesented by those bits is x - s": "input.pdf", "2n-1 i.e. if the most signi\ufb01cant bit is 1, then a value that is just by 1 larger than the number you could represent with the other bits 2n-2 2n-3 ... 21 20 2n-1 - 1 is subtracted allowing a unique binary representation for each value from - 2n-1 s 1 x 0 to 2n-1 - 1 s 0 x 2n-1 - 1. This also has the nice side e\ufb00ect, that you can add the binary representations as if they were positive binary numbers v1 x1 - s1 2n-1 v2 x2 - s2 2n-1 s1s2x1 x2 over\ufb02ow addition result 00No x1 x2 v1 v2 00Yes too large to be represented with data type over\ufb02ow 01Nox1 x2 - 2n-1 x1 x2 - s2 2n-1 v1 v2 01Yesx1 x2 mod 2n-1 x1 x2 - 2n-1 v1 v2 10 see above swap summands 11No too small to be represented with data type x1 x2 - 2n -2n-1 under\ufb02ow 11Yesx1 x2 mod 2n-1 - 2n-1 x1 x2 - 2n-1 - 2n-1 x1 - s1 2n-1 x2 - s2 2n-1 v1 v2 Note that this fact makes \ufb01nding binary representation of the additive inverse i.e. the negative value easy Observe that adding the bitwise": "input.pdf", "complement to the number results in all bits being 1. Now add 1 to make value over\ufb02ow and you get the neutral element 0 all bits 0. So the negative value of a number i can be calculated using ignoring possible promotion to int here i 1 Example taking the negative value of 0 byte The result of negating 0, is 11111111 . Adding 1 gives a value of 100000000 9 bits. Because a byte can only store 8 bits, the leftmost value is truncated, and the result is 00000000 Original Process Result 0 00000000 Negate -0 11111111 11111111 Add 1 to binary 100000000 100000000 Truncate to 8 bits 00000000 -0 equals 0 GoalKicker.com Java Notes for Professionals 50Section 10.12 The short primitive A short is a 16-bit signed integer. It has a minimum value of -215 -32,768, and a maximum value of 215 1 32,767 short example -48 short myShort 987 short anotherShort 17 short addedShorts short myShort anotherShort 1,004 short subtractedShorts short myShort - anotherShort 970 The maximum and minimum values of short can be found at short high Short.MAXVALUE high 32767 short low Short.MINVALUE low -32768 The default value of a short is 0 short defaultShort": "input.pdf", "defaultShort 0 GoalKicker.com Java Notes for Professionals 51Chapter 11 Strings Strings java.lang.String are pieces of text stored in your program. Strings are not a primitive data type in Java , however, they are very common in Java programs. In Java, Strings are immutable, meaning that they cannot be changed. Click here for a more thorough explanation of immutability. Section 11.1 Comparing Strings In order to compare Strings for equality, you should use the String objects equals or equalsIgnoreCase methods. For example, the following snippet will determine if the two instances of String are equal on all characters String firstString Test123 String secondString Test 123 if firstString. equalssecondString Both Strings have the same content. Live demo This example will compare them, independent of their case String firstString Test123 String secondString TEST123 if firstString. equalsIgnoreCase secondString Both Strings are equal, ignoring the case of the individual characters. Live demo Note that equalsIgnoreCase does not let you specify a Locale . For instance, if you compare the two words Taki and TAKI in English they are equal however, in Turkish they are di\ufb00erent in Turkish, the lowercase I is \u0131. For cases like this, converting both strings to lowercase or uppercase with": "input.pdf", "Locale and then comparing with equals is the solution. String firstString Taki String secondString TAKI System.out.printlnfirstString. equalsIgnoreCase secondString prints true Locale locale Locale.forLanguageTag tr-TR System.out.printlnfirstString. toLowerCase locale.equals secondString. toLowerCase locale prints false Live demo Do not use the operator to compare Strings Unless you can guarantee that all strings have been interned see below, you should not use the or ! GoalKicker.com Java Notes for Professionals 52operators to compare Strings. These operators actually test references, and since multiple String objects can represent the same String, this is liable to give the wrong answer. Instead, use the String.equalsObject method, which will compare the String objects based on their values. For a detailed explanation, please refer to Pitfall using to compare strings. Comparing Strings in a switch statement Version Java SE 7 As of Java 1.7, it is possible to compare a String variable to literals in a switch statement. Make sure that the String is not null, otherwise it will always throw a NullPointerException . Values are compared using String.equals , i.e. case sensitive. String stringToSwitch A switch stringToSwitch case a System.out.printlna break case A System.out.printlnA the code goes here break case B System.out.printlnB break default break Live demo Comparing": "input.pdf", "Strings with constant values When comparing a String to a constant value, you can put the constant value on the left side of equals to ensure that you wont get a NullPointerException if the other String is null . baz.equalsfoo While foo.equalsbaz will throw a NullPointerException if foo is null , baz.equalsfoo will evaluate to false . Version Java SE 7 A more readable alternative is to use Objects. equals, which does a null check on both parameters Objects. equalsfoo, baz. Note It is debatable as to whether it is better to avoid NullPointerExceptions in general, or let them happen and then \ufb01x the root cause see here and here. Certainly, calling the avoidance strategy best practice is not justi\ufb01able. String orderings The String class implements Comparable String with the String.compareTo method as described at the start of this example. This makes the natural ordering of String objects case-sensitive order. The String class provide a Comparator String constant called CASEINSENSITIVEORDER suitable for case-insensitive sorting. GoalKicker.com Java Notes for Professionals 53Comparing with interned Strings The Java Language Speci\ufb01cation JLS 3.10.6 states the following Moreover, a string literal always refers to the same instance of class String . This is because": "input.pdf", "string literals - or, more generally, strings that are the values of constant expressions - are interned so as to share unique instances, using the method String.intern . This means it is safe to compare references to two string literals using . Moreover, the same is true for references to String objects that have been produced using the String.intern method. For example String strObj new StringHello! String str Hello! The two string references point two strings that are equal if strObj.equalsstr System.out.printlnThe strings are equal The two string references do not point to the same object if strObj ! str System.out.printlnThe strings are not the same object If we intern a string that is equal to a given literal, the result is a string that has the same reference as the literal. String internedStr strObj. intern if internedStr str System.out.printlnThe interned string and the literal are the same object Behind the scenes, the interning mechanism maintains a hash table that contains all interned strings that are still reachable . When you call intern on a String , the method looks up the object in the hash table If the string is found, then that value is returned as the": "input.pdf", "interned string. Otherwise, a copy of the string is added to the hash table and that string is returned as the interned string. It is possible to use interning to allow strings to be compared using . However, there are signi\ufb01cant problems with doing this see Pitfall - Interning strings so that you can use is a bad idea for details. It is not recommended in most cases. Section 11.2 Changing the case of characters within a String The String type provides two methods for converting strings between upper case and lower case toUpperCase to convert all characters to upper case toLowerCase to convert all characters to lower case These methods both return the converted strings as new String instances the original String objects are not modi\ufb01ed because String is immutable in Java. See this for more on immutability Immutability of Strings in Java String string This is a Random String GoalKicker.com Java Notes for Professionals 54String upper string. toUpperCase String lower string. toLowerCase System.out.printlnstring prints This is a Random String System.out.printlnlower prints this is a random string System.out.printlnupper prints THIS IS A RANDOM STRING Non-alphabetic characters, such as digits and punctuation marks, are una\ufb00ected by these methods. Note": "input.pdf", "that these methods may also incorrectly deal with certain Unicode characters under certain conditions. Note These methods are locale-sensitive , and may produce unexpected results if used on strings that are intended to be interpreted independent of the locale. Examples are programming language identi\ufb01ers, protocol keys, and HTML tags. For instance, TITLE.toLowerCase in a Turkish locale returns t\u0131tle, where \u0131 u0131 is the LATIN SMALL LETTER DOTLESS I character. To obtain correct results for locale insensitive strings, pass Locale.ROOT as a parameter to the corresponding case converting method e.g. toLowerCase Locale.ROOT or toUpperCase Locale.ROOT. Although using Locale.ENGLISH is also correct for most cases, the language invariant way is Locale.ROOT . A detailed list of Unicode characters that require special casing can be found on the Unicode Consortium website . Changing case of a speci\ufb01c character within an ASCII string To change the case of a speci\ufb01c character of an ASCII string following algorithm can be used Steps Declare a string.1. Input the string.2. Convert the string into a character array.3. Input the character that is to be searched.4. Search for the character into the character array.5. If found,check if the character is lowercase or uppercase.6. If Uppercase, add 32": "input.pdf", "to the ASCII code of the character. If Lowercase, subtract 32 from the ASCII code of the character. Change the original character from the Character array.7. Convert the character array back into the string.8. Voila, the Case of the character is changed. An example of the code for the algorithm is Scanner scanner new Scanner System.in System.out.printlnEnter the String String s scanner. next char a s.toCharArray System.out.printlnEnter the character you are looking for System.out.printlns String c scanner. next char d c.charAt0 for int i 0 i s.length i if ai d if d a d z d - 32 GoalKicker.com Java Notes for Professionals 55 else if d A d Z d 32 a i d break s String.valueOfa System.out.printlns Section 11.3 Finding a String Within Another String To check whether a particular String a is being contained in a String b or not, we can use the method String.contains with the following syntax b.contains a Return true if a is contained in b, false otherwise The String.contains method can be used to verify if a CharSequence can be found in the String. The method looks for the String a in the String b in a case-sensitive way. String": "input.pdf", "str1 Hello World String str2 Hello String str3 helLO System.out.printlnstr1.contains str2 prints true System.out.printlnstr1.contains str3 prints false Live Demo on Ideone To \ufb01nd the exact position where a String starts within another String, use String.indexOf String s this is a long sentence int i s.indexOfi the first i in String is at index 2 int j s.indexOflong the index of the first occurrence of long in s is 10 int k s.indexOfz k is -1 because z was not found in String s int h s.indexOfLoNg h is -1 because LoNg was not found in String s Live Demo on Ideone The String.indexOf method returns the \ufb01rst index of a char or String in another String . The method returns -1 if it is not found. Note The String.indexOf method is case sensitive. Example of search ignoring the case String str1 Hello World String str2 wOr str1.indexOfstr2 -1 str1.toLowerCase .contains str2.toLowerCase true str1.toLowerCase .indexOfstr2.toLowerCase 6 Live Demo on Ideone GoalKicker.com Java Notes for Professionals 56Section 11.4 String pool and heap storage Like many Java objects, all String instances are created on the heap, even literals. When the JVM \ufb01nds a String literal that has no equivalent reference in the": "input.pdf", "heap, the JVM creates a corresponding String instance on the heap and it also stores a reference to the newly created String instance in the String pool. Any other references to the same String literal are replaced with the previously created String instance in the heap. Lets look at the following example class Strings public static void main String args String a alpha String b alpha String c new Stringalpha All three strings are equivalent System.out.printlna.equalsb b.equalsc Although only a and b reference the same heap object System.out.printlna b System.out.printlna ! c System.out.printlnb ! c The output of the above is true true true true GoalKicker.com Java Notes for Professionals 57When we use double quotes to create a String, it \ufb01rst looks for String with same value in the String pool, if found it just returns the reference else it creates a new String in the pool and then returns the reference. However using new operator, we force String class to create a new String object in heap space. We can use intern method to put it into the pool or refer to other String object from string pool having same value. The String pool itself is also created": "input.pdf", "on the heap. Version Java SE 7 Before Java 7, String literals were stored in the runtime constant pool in the method area of PermGen , that had a \ufb01xed size. The String pool also resided in PermGen . Version Java SE 7 RFC 6962931 In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap known as the young and old generations, along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small di\ufb00erences in heap usage due to this change, but larger applications that load many classes or make heavy use of the String.intern method will see more signi\ufb01cant di\ufb00erences. Section 11.5 Splitting Strings You can split a String on a particular delimiting character or a Regular Expression, you can use the String.split method that has the following signature public String splitString regex Note that delimiting character or regular expression gets removed from the resulting": "input.pdf", "String Array. Example using delimiting character String lineFromCsvFile MickeyBolton12345121216 String dataCells lineFromCsvFile. split Result is dataCells Mickey, Bolton, 12345, 121216 Example using regular expression String lineFromInput What do you need from me? String words lineFromInput. splits one or more space chars Result is words What, do, you, need, from, me? You can even directly split a String literal String firstNames Mickey, Frank, Alicia, Tom .split, Result is firstNames Mickey, Frank, Alicia, Tom GoalKicker.com Java Notes for Professionals 58Warning Do not forget that the parameter is always treated as a regular expression. aaa.bbb .split. This returns an empty array In the previous example . is treated as the regular expression wildcard that matches any character, and since every character is a delimiter, the result is an empty array. Splitting based on a delimiter which is a regex meta-character The following characters are considered special aka meta-characters in regex - ! ? . To split a string based on one of the above delimiters, you need to either escape them using or use Pattern. quote Using Pattern. quote String s abc String regex Pattern. quote String arr s.splitregex Escaping the special characters String s abc String arr s.split Split removes empty": "input.pdf", "values splitdelimiter by default removes trailing empty strings from result array. To turn this mechanism o\ufb00 we need to use overloaded version of splitdelimiter, limit with limit set to negative value like String split data.split, -1 splitregex internally returns result of splitregex, 0. The limit parameter controls the number of times the pattern is applied and therefore a\ufb00ects the length of the resulting array. If the limit n is greater than zero then the pattern will be applied at most n - 1 times, the arrays length will be no greater than n, and the arrays last entry will contain all input beyond the last matched delimiter. If n is negative, then the pattern will be applied as many times as possible and the array can have any length. If n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded. Splitting with a StringTokenizer Besides the split method Strings can also be split using a StringTokenizer . StringTokenizer is even more restrictive than String.split, and also a bit harder to use. It is essentially designed for pulling out tokens delimited by a": "input.pdf", "\ufb01xed set of characters given as a String . Each character will act as a separator. Because of this restriction, its about twice as fast as String.split. Default set of characters are empty spaces tnrf . The following example will print out each word separately. GoalKicker.com Java Notes for Professionals 59String str the lazy fox jumped over the brown fence StringTokenizer tokenizer new StringTokenizer str while tokenizer. hasMoreTokens System.out.printlntokenizer. nextToken This will print out the lazy fox jumped over the brown fence You can use di\ufb00erent character sets for separation. String str jumped over In this case character u and e will be used as delimiters StringTokenizer tokenizer new StringTokenizer str, ue while tokenizer. hasMoreTokens System.out.printlntokenizer. nextToken This will print out j mp d ov r Section 11.6 Joining Strings with a delimiter Version Java SE 8 An array of strings can be joined using the static method String.join String elements foo, bar, foobar String singleString String.join , elements System.out.printlnsingleString Prints foo bar foobar Similarly, theres an overloaded String.join method for Iterable s. To have a \ufb01ne-grained control over joining, you may use StringJoiner class StringJoiner sj new StringJoiner , , , The last two arguments are optional, they": "input.pdf", "define prefix and suffix for the result string sj.addfoo sj.addbar sj.addfoobar System.out.printlnsj Prints foo, bar, foobar GoalKicker.com Java Notes for Professionals 60To join a stream of strings, you may use the joining collector StreamString stringStream Stream. offoo, bar, foobar String joined stringStream. collectCollectors. joining, System.out.printlnjoined Prints foo, bar, foobar Theres an option to de\ufb01ne pre\ufb01x and su\ufb03x here as well StreamString stringStream Stream. offoo, bar, foobar String joined stringStream. collectCollectors. joining, , , System.out.printlnjoined Prints foo, bar, foobar Section 11.7 String concatenation and StringBuilders String concatenation can be performed using the operator. For example String s1 a String s2 b String s3 c String s s1 s2 s3 abc Normally a compiler implementation will perform the above concatenation using methods involving a StringBuilder under the hood. When compiled, the code would look similar to the below StringBuilder sb new StringBuilder a String s sb.appendb.appendc.toString StringBuilder has several overloaded methods for appending di\ufb00erent types, for example, to append an int instead of a String . For example, an implementation can convert String s1 a String s2 b String s s1 s2 2 ab2 to the following StringBuilder sb new StringBuilder a String s sb.appendb.append2.toString The above examples illustrate a simple": "input.pdf", "concatenation operation that is e\ufb00ectively done in a single place in the code. The concatenation involves a single instance of the StringBuilder . In some cases, a concatenation is carried out in a cumulative way such as in a loop String result forint i 0 i array.length i result extractElement arrayi return result In such cases, the compiler optimization is usually not applied, and each iteration will create a new StringBuilder object. This can be optimized by explicitly transforming the code to use a single StringBuilder StringBuilder result new StringBuilder forint i 0 i array.length i result. appendextractElement arrayi GoalKicker.com Java Notes for Professionals 61 return result. toString A StringBuilder will be initialized with an empty space of only 16 characters. If you know in advance that you will be building larger strings, it can be bene\ufb01cial to initialize it with su\ufb03cient size in advance, so that the internal bu\ufb00er does not need to be resized StringBuilder buf new StringBuilder 30 Default is 16 characters buf.append0123456789 buf.append0123456789 Would cause a reallocation of the internal buffer otherwise String result buf.toString Produces a 20-chars copy of the string If you are producing many strings, it is advisable to reuse StringBuilder s": "input.pdf", "StringBuilder buf new StringBuilder 100 for int i 0 i 100 i buf. setLength 0 Empty buffer buf. appendThis is line .appendi.appendn outputfile. writebuf.toString If and only if multiple threads are writing to the same bu\ufb00er, use StringBu\ufb00er , which is a synchronized version of StringBuilder . But because usually only a single thread writes to a bu\ufb00er, it is usually faster to use StringBuilder without synchronization. Using concat method String string1 Hello String string2 world String string3 string1. concatstring2 Hello world This returns a new string that is string1 with string2 added to it at the end. You can also use the concat method with string literals, as in My name is .concatBuyya Section 11.8 Substrings String s this is an example String a s.substring 11 a will hold the string starting at character 11 until the end example String b s.substring 5, 10 b will hold the string starting at character 5 and ending right before character 10 is an String b s.substring 5, b.length-3 b will hold the string starting at character 5 ending right before b s lenght is out of 3 is an exam Substrings may also be applied to slice and addreplace character": "input.pdf", "into its original String. For instance, you faced a Chinese date containing Chinese characters but you want to store it as a well format Date String. String datestring 2015 \u5e7411\u670817\u65e5 datestring datestring. substring 0, 4 - datestring. substring 5,7 - datestring. substring 8,10 Result will be 2015-11-17 The substring method extracts a piece of a String . When provided one parameter, the parameter is the start and GoalKicker.com Java Notes for Professionals 62the piece extends until the end of the String . When given two parameters, the \ufb01rst parameter is the starting character and the second parameter is the index of the character right after the end the character at the index is not included. An easy way to check is the subtraction of the \ufb01rst parameter from the second should yield the expected length of the string. Version Java SE 7 In JDK 7u6 versions the substring method instantiates a String that shares the same backing char as the original String and has the internal offset and count \ufb01elds set to the result start and length. Such sharing may cause memory leaks, that can be prevented by calling new Strings.substring ... to force creation of a copy, after": "input.pdf", "which the char can be garbage collected. Version Java SE 7 From JDK 7u6 the substring method always copies the entire underlying char array, making the complexity linear compared to the previous constant one but guaranteeing the absence of memory leaks at the same time. Section 11.9 Platform independent new line separator Since the new line separator varies from platform to platform e.g. n on Unix-like systems or rn on Windows it is often necessary to have a platform-independent way of accessing it. In Java it can be retrieved from a system property System.getProperty line.separator Version Java SE 7 Because the new line separator is so commonly needed, from Java 7 on a shortcut method returning exactly the same result as the code above is available System.lineSeparator Note Since it is very unlikely that the new line separator changes during the programs execution, it is a good idea to store it in in a static \ufb01nal variable instead of retrieving it from the system property every time it is needed. When using String.format , use n rather than n or rn to output a platform independent new line separator. System.out.printlnString.formatline 1 s.nline 2 sn , lines0,lines1 Section 11.10 Reversing": "input.pdf", "Strings There are a couple ways you can reverse a string to make it backwards. StringBuilderStringBu\ufb00er1. String code code System.out.printlncode StringBuilder sb new StringBuilder code code sb.reverse.toString System.out.printlncode Char array2. GoalKicker.com Java Notes for Professionals 63String code code System.out.printlncode char array code.toCharArray for int index 0, mirroredIndex array.length - 1 index mirroredIndex index, mirroredIndex -- char temp arrayindex array index arraymirroredIndex array mirroredIndex temp print reversed System.out.printlnnew Stringarray Section 11.11 Adding toString method for custom objects Suppose you have de\ufb01ned the following Person class public class Person String name int age public Person int age, String name this.age age this.name name If you instantiate a new Person object Person person new Person25, John and later in your code you use the following statement in order to print the object System.out.printlnperson.toString Live Demo on Ideone youll get an output similar to the following Person7ab89d This is the result of the implementation of the toString method de\ufb01ned in the Object class, a superclass of Person . The documentation of Object.toString states The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character , and the unsigned": "input.pdf", "hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of getClass .getName Integer.toHexString hashCode So, for meaningful output, youll have to override the toString method Override GoalKicker.com Java Notes for Professionals 64public String toString return My name is this.name and my age is this.age Now the output will be My name is John and my age is 25 You can also write System.out.printlnperson Live Demo on Ideone In fact, println implicitly invokes the toString method on the object. Section 11.12 Remove Whitespace from the Beginning and End of a String The trim method returns a new String with the leading and trailing whitespace removed. String s new String Hello World!! String t s.trim t Hello World!! If you trim a String that doesnt have any whitespace to remove, you will be returned the same String instance. Note that the trim method has its own notion of whitespace , which di\ufb00ers from the notion used by the Character .isWhitespace method All ASCII control characters with codes U0000 to U0020 are considered whitespace and are removed by trim. This includes U0020 SPACE , U0009 CHARACTER TABULATION , U000A LINE": "input.pdf", "FEED and U000D CARRIAGE RETURN characters, but also the characters like U0007 BELL . Unicode whitespace like U00A0 NO-BREAK SPACE or U2003 EM SPACE are not recognized by trim. Section 11.13 Case insensitive switch Version Java SE 7 switch itself can not be parameterised to be case insensitive, but if absolutely required, can behave insensitive to the input string by using toLowerCase or toUpperCase switch myString. toLowerCase case case1 ... break case case2 ... break Beware Locale might a\ufb00ect how changing cases happen! GoalKicker.com Java Notes for Professionals 65Care must be taken not to have any uppercase characters in the labels - those will never get executed! Section 11.14 Replacing parts of Strings Two ways to replace by regex or by exact match. Note the original String object will be unchanged, the return value holds the changed String. Exact match Replace single character with another single character String replace char oldChar, char newChar Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar. String s popcorn System.out.printlns.replacep,W Result WoWcorn Replace sequence of characters with another sequence of characters String replace CharSequence target, CharSequence replacement Replaces each substring of this string that matches the": "input.pdf", "literal target sequence with the speci\ufb01ed literal replacement sequence. String s metal petal et al. System.out.printlns.replaceetal,etallica Result metallica petallica et al. Regex Note the grouping uses the character to reference the groups, like 1. Replace all matches String replaceAll String regex, String replacement Replaces each substring of this string that matches the given regular expression with the given replacement. String s spiral metal petal et al. System.out.printlns.replaceAll wetal ,1lica Result GoalKicker.com Java Notes for Professionals 66spiral metallica petallica et al. Replace \ufb01rst match only String replaceFirst String regex, String replacement Replaces the \ufb01rst substring of this string that matches the given regular expression with the given replacement String s spiral metal petal et al. System.out.printlns.replaceAll wetal ,1lica Result spiral metallica petal et al. Section 11.15 Getting the length of a String In order to get the length of a String object, call the length method on it. The length is equal to the number of UTF-16 code units chars in the string. String str Hello, World! System.out.printlnstr.length Prints out 13 Live Demo on Ideone A char in a String is UTF-16 value. Unicode codepoints whose values are 0x1000 for example, most emojis use two char positions. To count the": "input.pdf", "number of Unicode codepoints in a String, regardless of whether each codepoint \ufb01ts in a UTF-16 char value, you can use the codePointCount method int length str.codePointCount 0, str.length You can also use a Stream of codepoints, as of Java 8 int length str.codePoints .count Section 11.16 Getting the nth character in a String String str My String System.out.printlnstr.charAt0 M System.out.printlnstr.charAt1 y System.out.printlnstr.charAt2 System.out.printlnstr.charAtstr.length-1 Last character g To get the nth character in a string, simply call charAtn on a String , where n is the index of the character you would like to retrieve NOTE index n is starting at 0, so the \ufb01rst element is at n0. Section 11.17 Counting occurrences of a substring or GoalKicker.com Java Notes for Professionals 67character in a string countMatches method from org.apache.commons.lang3.StringUtils is typically used to count occurrences of a substring or character in a String import org.apache.commons.lang3.StringUtils String text One fish, two fish, red fish, blue fish count occurrences of a substring String stringTarget fish int stringOccurrences StringUtils. countMatches text, stringTarget 4 count occurrences of a char char charTarget , int charOccurrences StringUtils. countMatches text, charTarget 3 Otherwise for does the same with standard Java APIs you could use Regular": "input.pdf", "Expressions import java.util.regex.Matcher import java.util.regex.Pattern String text One fish, two fish, red fish, blue fish System.out.printlncountStringInString fish, text prints 4 System.out.printlncountStringInString ,, text prints 3 public static int countStringInString String search, String text Pattern pattern Pattern. compilesearch Matcher matcher pattern. matchertext int stringOccurrences 0 while matcher. find stringOccurrences return stringOccurrences GoalKicker.com Java Notes for Professionals 68Chapter 12 StringBuer Introduction to Java StringBu\ufb00er class. Section 12.1 String Buer class Key Points used to created mutable modi\ufb01able string. Mutable Which can be changed. is thread-safe i.e. multiple threads cannot access it simultaneously. Methods public synchronized StringBu\ufb00er appendString s public synchronized StringBu\ufb00er insertint o\ufb00set, String s public synchronized StringBu\ufb00er replaceint startIndex, int endIndex, String str public synchronized StringBu\ufb00er deleteint startIndex, int endIndex public synchronized StringBu\ufb00er reverse public int capacity public void ensureCapacityint minimumCapacity public char charAtint index public int length public String substringint beginIndex public String substringint beginIndex, int endIndex Example Showing di\ufb00erence between String and String Bu\ufb00er implementation class Test public static void mainString args String str study str.concattonight System.out.printlnstr Output study StringBuffer strB new StringBuffer study strB.appendtonight System.out.printlnstrB Output studytonight GoalKicker.com Java Notes for Professionals 69Chapter 13 StringBuilder Java StringBuilder class is used to create mutable modi\ufb01able string. The Java": "input.pdf", "StringBuilder class is same as StringBu\ufb00er class except that it is non-synchronized. It is available since JDK 1.5. Section 13.1 Comparing StringBuer, StringBuilder, Formatter and StringJoiner The StringBuffer , StringBuilder , Formatter and StringJoiner classes are Java SE utility classes that are primarily used for assembling strings from other information The StringBuffer class has been present since Java 1.0, and provides a variety of methods for building and modifying a bu\ufb00er containing a sequence of characters. The StringBuilder class was added in Java 5 to address performance issues with the original StringBuffer class. The APIs for the two clases are essentially the same. The main di\ufb00erence between StringBuffer and StringBuilder is that the former is thread-safe and synchronized and the latter is not. This example shows how StringBuilder is can be used int one 1 String color red StringBuilder sb new StringBuilder sb.appendOne.appendone.append, Color .appendcolor.appendn System.out.printsb Prints One1, Colourred followed by an ASCII newline. The StringBuffer class is used the same way just change StringBuilder to StringBuffer in the above The StringBuffer and StringBuilder classes are suitable for both assembling and modifying strings i.e they provide methods for replacing and removing characters as well as adding them in various.": "input.pdf", "The remining two classes are speci\ufb01c to the task of assembling strings. The Formatter class was added in Java 5, and is loosely modeled on the sprintf function in the C standard library. It takes a format string with embedded format speci\ufb01ers and a sequences of other arguments, and generates a string by converting the arguments into text and substituting them in place of the format speci\ufb01ers. The details of the format speci\ufb01ers say how the arguments are converted into text. The StringJoiner class was added in Java 8. It is a special purpose formatter that succinctly formats a sequence of strings with separators between them. It is designed with a \ufb02uent API, and can be used with Java 8 streams. Here are some typical examples of Formatter usage This does the same thing as the StringBuilder example above int one 1 String color red Formatter f new Formatter System.out.printf.formatOned, coloursn , one, color Prints One1, Colourred followed by the platforms line separator The same thing using the String.format convenience method System.out.printString.formatOned, colorsn , one, color GoalKicker.com Java Notes for Professionals 70The StringJoiner class is not ideal for the above task, so here is an example of a formatting": "input.pdf", "an array of strings. StringJoiner sj new StringJoiner , , , for String s new StringA, B, C sj.adds System.out.printlnsj Prints A, B, C The use-cases for the 4 classes can be summarized StringBuilder suitable for any string assembly OR string modi\ufb01cation task. StringBuffer use only when you require a thread-safe version of StringBuilder . Formatter provides much richer string formatting functionality, but is not as e\ufb03cient as StringBuilder . This is because each call to Formatter. format... entails parsing the format string, creating and populate a varargs array, and autoboxing any primitive type arguments. StringJoiner provides succinct and e\ufb03cient formatting of a sequence of strings with separators, but is not suitable for other formatting tasks. Section 13.2 Repeat a String n times Problem Create a String containing n repetitions of a String s. The trivial approach would be repeatedly concatenating the String final int n ... final String s ... String result for int i 0 i n i result s This creates n new string instances containing 1 to n repetitions of s resulting in a runtime of Os.length n\u00b2 Os.length 12...n-1n. To avoid this StringBuilder should be used, which allows creating the String in Os.length n": "input.pdf", "instead final int n ... final String s ... StringBuilder builder new StringBuilder for int i 0 i n i builder. appends String result builder. toString GoalKicker.com Java Notes for Professionals 71Chapter 14 String Tokenizer The java.util.StringTokenizer class allows you to break a string into tokens. It is simple way to break string. The set of delimiters the characters that separate tokens may be speci\ufb01ed either at creation time or on a per- token basis. Section 14.1 StringTokenizer Split by space import java.util.StringTokenizer public class Simple public static void mainString args StringTokenizer st new StringTokenizer apple ball cat dog , while st.hasMoreTokens System.out.printlnst.nextToken Output apple ball cat dog Section 14.2 StringTokenizer Split by comma , public static void mainString args StringTokenizer st new StringTokenizer apple,ball cat,dog , , while st.hasMoreTokens System.out.printlnst.nextToken Output apple ball cat dog GoalKicker.com Java Notes for Professionals 72Chapter 15 Splitting a string into \ufb01xed length parts Section 15.1 Break a string up into substrings all of a known length The trick is to use a look-behind with the regex G, which means end of previous match String parts str.split?G.8 The regex matches 8 characters after the end of the last match. Since in this case": "input.pdf", "the match is zero-width, we could more simply say 8 characters after the last match. Conveniently, G is initialized to start of input, so it works for the \ufb01rst part of the input too. Section 15.2 Break a string up into substrings all of variable length Same as the known length example, but insert the length into regex int length 5 String parts str.split?G. length GoalKicker.com Java Notes for Professionals 73Chapter 16 Date Class Parameter Explanation No parameter Creates a new Date object using the allocation time to the nearest millisecond long dateCreates a new Date object with the time set to the number of milliseconds since the epoch January 1, 1970, 000000 GMT Section 16.1 Convert java.util.Date to java.sql.Date java.util.Date to java.sql.Date conversion is usually necessary when a Date object needs to be written in a database. java.sql.Date is a wrapper around millisecond value and is used by JDBC to identify an SQL DATE type In the below example, we use the java.util.Date constructor, that creates a Date object and initializes it to represent time to the nearest millisecond. This date is used in the convertjava.util.Date utilDate method to return a java.sql.Date object Example public class UtilToSqlConversion public": "input.pdf", "static void mainString args java. util.Date utilDate new java.util.Date System.out.printlnjava.util.Date is utilDate java. sql.Date sqlDate convert utilDate System.out.printlnjava.sql.Date is sqlDate DateFormat df new SimpleDateFormat ddMMYYYY - hhmmss System.out.printlndateFormated date is df.formatutilDate private static java.sql.Date convert java.util.Date uDate java. sql.Date sDate new java.sql.DateuDate.getTime return sDate Output java.util.Date is Fri Jul 22 144035 IST 2016 java.sql.Date is 2016-07-22 dateFormated date is 22072016 - 024035 java.util.Date has both date and time information, whereas java.sql.Date only has date information Section 16.2 A basic date output Using the following code with the format string yyyyMMdd hhmm.ss, we will receive the following output 20160419 1145.36 GoalKicker.com Java Notes for Professionals 74 define the format to use String formatString yyyyMMdd hhmm.ss get a current date object Date date Calendar .getInstance .getTime create the formatter SimpleDateFormat simpleDateFormat new SimpleDateFormat formatString format the date String formattedDate simpleDateFormat. formatdate print it System.out.printlnformattedDate single-line version of all above code System.out.printlnnew SimpleDateFormat yyyyMMdd hhmm.ss .formatCalendar .getInstance .getTime Section 16.3 Java 8 LocalDate and LocalDateTime objects Date and LocalDate objects cannot be exactly converted between each other since a Date object represents both a speci\ufb01c day and time, while a LocalDate object does not contain time or timezone information. However, it can": "input.pdf", "be useful to convert between the two if you only care about the actual date information and not the time information. Creates a LocalDate Create a default date LocalDate lDate LocalDate. now Creates a date from values lDate LocalDate. of2017, 12, 15 create a date from string lDate LocalDate. parse2017-12-15 creates a date from zone LocalDate. nowZoneId.systemDefault Creates a LocalDateTime Create a default date time LocalDateTime lDateTime LocalDateTime. now Creates a date time from values lDateTime LocalDateTime. of2017, 12, 15, 11, 30 create a date time from string lDateTime LocalDateTime. parse2017-12-05T113030 create a date time from zone LocalDateTime. nowZoneId.systemDefault LocalDate to Date and vice-versa Date date Date.fromInstant. now ZoneId defaultZoneId ZoneId. systemDefault GoalKicker.com Java Notes for Professionals 75 Date to LocalDate LocalDate localDate date.toInstant .atZonedefaultZoneId .toLocalDate LocalDate to Date Date.fromlocalDate. atStartOfDay defaultZoneId .toInstant LocalDateTime to Date and vice-versa Date date Date.fromInstant. now ZoneId defaultZoneId ZoneId. systemDefault Date to LocalDateTime LocalDateTime localDateTime date.toInstant .atZonedefaultZoneId .toLocalDateTime LocalDateTime to Date Date out Date.fromlocalDateTime. atZonedefaultZoneId .toInstant Section 16.4 Creating a Speci\ufb01c Date While the Java Date class has several constructors, youll notice that most are deprecated. The only acceptable way of creating a Date instance directly is either by using the empty constructor": "input.pdf", "or passing in a long number of milliseconds since standard base time. Neither are handy unless youre looking for the current date or have another Date instance already in hand. To create a new date, you will need a Calendar instance. From there you can set the Calendar instance to the date that you need. Calendar c Calendar .getInstance This returns a new Calendar instance set to the current time. Calendar has many methods for mutating its date and time or setting it outright. In this case, well set it to a speci\ufb01c date. c.set1974, 6, 2, 8, 0, 0 Date d c.getTime The getTime method returns the Date instance that we need. Keep in mind that the Calendar set methods only set one or more \ufb01elds, they do not set them all. That is, if you set the year, the other \ufb01elds remain unchanged. PITFALL In many cases, this code snippet ful\ufb01lls its purpose, but keep in mind that two important parts of the datetime are not de\ufb01ned. the 1974, 6, 2, 8, 0, 0 parameters are interpreted within the default timezone, de\ufb01ned somewhere else, the milliseconds are not set to zero, but \ufb01lled from the system clock": "input.pdf", "at the time the Calendar instance is created. Section 16.5 Converting Date to a certain String format format from SimpleDateFormat class helps to convert a Date object into certain format String object by using the supplied pattern string . Date today new Date GoalKicker.com Java Notes for Professionals 76SimpleDateFormat dateFormat new SimpleDateFormat dd-MMM-yy pattern is specified here System.out.printlndateFormat. formattoday 25-Feb-16 Patterns can be applied again by using applyPattern dateFormat. applyPattern dd-MM-yyyy System.out.printlndateFormat. formattoday 25-02-2016 dateFormat. applyPattern dd-MM-yyyy HHmmss E System.out.printlndateFormat. formattoday 25-02-2016 061433 Thu Note Here mm small letter m denotes minutes and MM capital M denotes month. Pay careful attention when formatting years capital Y Y indicates the week in the year while lower-case y y indicates the year. Section 16.6 LocalTime To use just the time part of a Date use LocalTime. You can instantiate a LocalTime object in a couple ways LocalTime time LocalTime. now 1. time LocalTime. MIDNIGHT 2. time LocalTime. NOON 3. time LocalTime. of12, 12, 45 4. LocalTime also has a built in toString method that displays the format very nicely. System.out.printlntime you can also get, add and subtract hours, minutes, seconds, and nanoseconds from the LocalTime object i.e. time.plusMinutes 1 time.getMinutes time.minusMinutes": "input.pdf", "1 You can turn it into a Date object with the following code LocalTime lTime LocalTime. now Instant instant lTime.atDateLocalDate. ofAYEAR, AMONTH, ADAY . atZoneZoneId.systemDefault .toInstant Date time Date.frominstant this class works very nicely within a timer class to simulate an alarm clock. Section 16.7 Convert formatted string representation of date to Date object This method can be used to convert a formatted string representation of a date into a Date object. Parses the date using the given format. param formattedDate the formatted date string param dateFormat the date format which was used to create the string. return the date public static Date parseDate String formattedDate, String dateFormat Date date null GoalKicker.com Java Notes for Professionals 77 SimpleDateFormat objDf new SimpleDateFormat dateFormat try date objDf.parseformattedDate catch ParseException e Do what ever needs to be done with exception. return date Section 16.8 Creating Date objects Date date new Date System.out.printlndate Thu Feb 25 050359 IST 2016 Here this Date object contains the current date and time when this object was created. Calendar calendar Calendar .getInstance calendar. set90, Calendar .DECEMBER , 11 Date myBirthDate calendar. getTime System.out.printlnmyBirthDate Mon Dec 31 000000 IST 1990 Date objects are best created through a Calendar": "input.pdf", "instance since the use of the data constructors is deprecated and discouraged. To do se we need to get an instance of the Calendar class from the factory method. Then we can set year, month and day of month by using numbers or in case of months constants provided py the Calendar class to improve readability and reduce errors. calendar. set90, Calendar .DECEMBER , 11, 8, 32, 35 Date myBirthDatenTime calendar. getTime System.out.printlnmyBirthDatenTime Mon Dec 31 083235 IST 1990 Along with date, we can also pass time in the order of hour, minutes and seconds. Section 16.9 Comparing Date objects Calendar, Date, and LocalDate Version Java SE 8 before, after, compareTo and equals methods Use of Calendar and Date objects final Date today new Date final Calendar calendar Calendar .getInstance calendar. set1990, Calendar .NOVEMBER , 1, 0, 0, 0 Date birthdate calendar. getTime final Calendar calendar2 Calendar .getInstance calendar2. set1990, Calendar .NOVEMBER , 1, 0, 0, 0 Date samebirthdate calendar2. getTime Before example System.out.printfIs 1tF before 2tF? 3bn , today, birthdate, Boolean.valueOftoday.beforebirthdate System.out.printfIs 1tF before 1tF? 3bn , today, today, Boolean.valueOftoday.beforetoday System.out.printfIs 2tF before 1tF? 3bn , today, birthdate, Boolean.valueOfbirthdate. beforetoday After example System.out.printfIs 1tF after 2tF? 3bn ,": "input.pdf", "today, birthdate, GoalKicker.com Java Notes for Professionals 78Boolean.valueOftoday.afterbirthdate System.out.printfIs 1tF after 1tF? 3bn , today, birthdate, Boolean.valueOftoday.aftertoday System.out.printfIs 2tF after 1tF? 3bn , today, birthdate, Boolean.valueOfbirthdate. aftertoday Compare example System.out.printfCompare 1tF to 2tF 3dn , today, birthdate, Integer.valueOftoday.compareTo birthdate System.out.printfCompare 1tF to 1tF 3dn , today, birthdate, Integer.valueOftoday.compareTo today System.out.printfCompare 2tF to 1tF 3dn , today, birthdate, Integer.valueOfbirthdate. compareTo today Equal example System.out.printfIs 1tF equal to 2tF? 3bn , today, birthdate, Boolean.valueOftoday.equalsbirthdate System.out.printfIs 1tF equal to 2tF? 3bn , birthdate, samebirthdate, Boolean.valueOfbirthdate. equalssamebirthdate System.out.printf Because birthdate.getTime - 1d is different from samebirthdate.getTime - 2d, there are millisecondes!n , Long.valueOfbirthdate. getTime, Long.valueOfsamebirthdate. getTime Clear ms from calendars calendar. clearCalendar .MILLISECOND calendar2. clearCalendar .MILLISECOND birthdate calendar. getTime samebirthdate calendar2. getTime System.out.printfIs 1tF equal to 2tF after clearing ms? 3bn , birthdate, samebirthdate, Boolean.valueOfbirthdate. equalssamebirthdate Version Java SE 8 isBefore, isAfter, compareTo and equals methods Use of LocalDate final LocalDate now LocalDate. now final LocalDate birthdate2 LocalDate. of2012, 6, 30 final LocalDate birthdate3 LocalDate. of2012, 6, 30 Hours, minutes, second and nanoOfsecond can also be configured with an other class LocalDateTime LocalDateTime.ofyear, month, dayOfMonth, hour, minute, second, nanoOfSecond isBefore example System.out.printfIs 1tF before 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.isBefore birthdate2 System.out.printfIs 1tF": "input.pdf", "before 1tF? 3bn , now, birthdate2, Boolean.valueOfnow.isBefore now System.out.printfIs 2tF before 1tF? 3bn , now, birthdate2, Boolean.valueOfbirthdate2. isBefore now isAfter example System.out.printfIs 1tF after 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.isAfterbirthdate2 System.out.printfIs 1tF after 1tF? 3bn , now, birthdate2, Boolean.valueOfnow.isAfternow System.out.printfIs 2tF after 1tF? 3bn , now, birthdate2, Boolean.valueOfbirthdate2. isAfternow compareTo example System.out.printfCompare 1tF to 2tF 3dn , now, birthdate2, Integer.valueOfnow.compareTo birthdate2 GoalKicker.com Java Notes for Professionals 79System.out.printfCompare 1tF to 1tF 3dn , now, birthdate2, Integer.valueOfnow.compareTo now System.out.printfCompare 2tF to 1tF 3dn , now, birthdate2, Integer.valueOfbirthdate2. compareTo now equals example System.out.printfIs 1tF equal to 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.equalsbirthdate2 System.out.printfIs 1tF to 2tF? 3bn , birthdate2, birthdate3, Boolean.valueOfbirthdate2. equalsbirthdate3 isEqual example System.out.printfIs 1tF equal to 2tF? 3bn , now, birthdate2, Boolean.valueOfnow.isEqualbirthdate2 System.out.printfIs 1tF to 2tF? 3bn , birthdate2, birthdate3, Boolean.valueOfbirthdate2. isEqualbirthdate3 Date comparison before Java 8 Before Java 8, dates could be compared using java.util.Calendar and java.util.Date classes. Date class o\ufb00ers 4 methods to compare dates afterDate when beforeDate when compareToDate anotherDate equalsObject obj after , before , compareTo and equals methods compare the values returned by getTime method for each date. compareTo method returns positive integer. Value greater than 0 when the Date is after the Date argument": "input.pdf", "Value greater than 0 when the Date is before the Date argument Value equals to 0 when the Date is equal to the Date argument equals results can be surprising as shown in the example because values, like milliseconds, are not initialize with the same value if not explicitly given. Since Java 8 With Java 8 a new Object to work with Date is available java.time.LocalDate . LocalDate implements ChronoLocalDate , the abstract representation of a date where the Chronology, or calendar system, is pluggable. To have the date time precision the Object java.time.LocalDateTime has to be used. LocalDate and LocalDateTime use the same methods name for comparing. Comparing dates using a LocalDate is di\ufb00erent from using ChronoLocalDate because the chronology, or calendar system are not taken in account the \ufb01rst one. Because most application should use LocalDate , ChronoLocalDate is not included in examples. Further reading here . Most applications should declare method signatures, \ufb01elds and variables as LocalDate, not thisChronoLocalDate interface. LocalDate has 5 methods to compare dates GoalKicker.com Java Notes for Professionals 80isAfterChronoLocalDate other isBeforeChronoLocalDate other isEqualChronoLocalDate other compareToChronoLocalDate other equalsObject obj In case of LocalDate parameter, isAfter , isBefore , isEqual , equals and compareTo": "input.pdf", "now use this method int compareTo0 LocalDate otherDate int cmp year - otherDate. year if cmp 0 cmp month - otherDate. month if cmp 0 cmp day - otherDate. day return cmp equals method check if the parameter reference equals the date \ufb01rst whereas isEqual directly calls compareTo0 . In case of an other class instance of ChronoLocalDate the dates are compared using the Epoch Day . The Epoch Day count is a simple incrementing count of days where day 0 is 1970-01-01 ISO. Section 16.10 Converting String into Date parse from SimpleDateFormat class helps to convert a String pattern into a Date object. DateFormat dateFormat DateFormat .getDateInstance DateFormat .SHORT, Locale.US String dateStr 02252016 input String Date date dateFormat. parsedateStr System.out.printlndate.getYear 116 There are 4 di\ufb00erent styles for the text format, SHORT , MEDIUM this is the default, LONG and FULL , all of which depend on the locale. If no locale is speci\ufb01ed, the system default locale is used. Style Locale.US Locale.France SHORT 63009 300609 MEDIUM Jun 30, 2009 30 juin 2009 LONG June 30, 2009 30 juin 2009 FULL Tuesday, June 30, 2009 mardi 30 juin 2009 Section 16.11 Time Zones and java.util.Date A java.util.Date object does": "input.pdf", "not have a concept of time zone. There is no way to set a timezone for a Date There is no way to change the timezone of a Date object A Date object created with the new Date default constructor will be initialised with the current time in the system default timezone However, it is possible to display the date represented by the point in time described by the Date object in a di\ufb00erent time zone using e.g. java.text.SimpleDateFormat Date date new Date GoalKicker.com Java Notes for Professionals 81print default time zone System.out.printlnTimeZone .getDefault .getDisplayName SimpleDateFormat sdf new SimpleDateFormat yyyy-MM-dd HHmmss note time zone not in format! print date in the original time zone System.out.printlnsdf.formatdate current time in London sdf.setTimeZone TimeZone .getTimeZone EuropeLondon System.out.printlnsdf.formatdate Output Central European Time 2016-07-21 225056 2016-07-21 215056 GoalKicker.com Java Notes for Professionals 82Chapter 17 Dates and Time java.time. Section 17.1 Calculate Dierence between 2 LocalDates Use LocalDate and ChronoUnit LocalDate d1 LocalDate. of2017, 5, 1 LocalDate d2 LocalDate. of2017, 5, 18 now, since the method between of the ChronoUnit enumerator takes 2 Temporal s as parameters so you can pass without a problem the LocalDate instances long days ChronoUnit. DAYS.betweend1, d2 System.out.println days Section": "input.pdf", "17.2 Date and time Date and time without time zone information LocalDateTime dateTime LocalDateTime. of2016, Month. JULY, 27, 8, 0 LocalDateTime now LocalDateTime. now LocalDateTime parsed LocalDateTime. parse2016-07-27T070000 Date and time with time zone information ZoneId zoneId ZoneId. ofUTC2 ZonedDateTime dateTime ZonedDateTime. of2016, Month. JULY, 27, 7, 0, 0, 235, zoneId ZonedDateTime composition ZonedDateTime. oflocalDate, localTime, zoneId ZonedDateTime now ZonedDateTime. now Default time zone ZonedDateTime parsed ZonedDateTime. parse2016-07-27T0700000100EuropeStockholm Date and time with o\ufb00set information i.e. no DST changes taken into account ZoneOffset zoneOffset ZoneOffset. ofHours2 OffsetDateTime dateTime OffsetDateTime. of2016, 7, 27, 7, 0, 0, 235, zoneOffset OffsetDateTime composition OffsetDateTime. oflocalDate, localTime, zoneOffset OffsetDateTime now OffsetDateTime. now Offset taken from the default ZoneId OffsetDateTime parsed OffsetDateTime. parse2016-07-27T0700000200 Section 17.3 Operations on dates and times LocalDate tomorrow LocalDate. now.plusDays 1 LocalDateTime anHourFromNow LocalDateTime. now.plusHours 1 Long daysBetween java.time.temporal .ChronoUnit .DAYS.betweenLocalDate. now, LocalDate. now.plusDays 3 3 Duration duration Duration. betweenInstant. now, ZonedDateTime. parse2016-07-27T0700000100EuropeStockholm Section 17.4 Instant Represents an instant in time. Can be thought of as a wrapper around a Unix timestamp. Instant now Instant. now Instant epoch1 Instant. ofEpochMilli 0 GoalKicker.com Java Notes for Professionals 83Instant epoch2 Instant. parse1970-01-01T000000Z java.time.temporal .ChronoUnit .MICROS.betweenepoch1, epoch2 0 Section 17.5 Usage of various classes of": "input.pdf", "Date Time API Following example also have explanation required for understanding example within it. import java.time.Clock import java.time.Duration import java.time.Instant import java.time.LocalDate import java.time.LocalDateTime import java.time.LocalTime import java.time.ZoneId import java.time.ZonedDateTime import java.util.TimeZone public class SomeMethodsExamples Has the methods of the class link LocalDateTime public static void checkLocalDateTime LocalDateTime localDateTime LocalDateTime. now System.out.printlnLocal Date time using static now method localDateTime LocalDateTime ldt1 LocalDateTime. nowZoneId.ofZoneId.SHORTIDS . getAET System.out . printlnLOCAL TIME USING nowZoneId zoneId method ldt1 LocalDateTime ldt2 LocalDateTime. nowClock.systemZoneId . ofZoneId.SHORTIDS .getPST System.out . printlnLocal TIME USING nowClock.systemZoneId.of ldt2 System.out . printlnFollowing is a static map in ZoneId class which has mapping of short timezone names to their Actual timezone names System.out.printlnZoneId.SHORTIDS This has the methods of the class link LocalDate public static void checkLocalDate LocalDate localDate LocalDate. now System.out.printlnGives date without Time using now method. localDate LocalDate localDate2 LocalDate. nowZoneId.ofZoneId.SHORTIDS . getECT System.out . printlnnow is overridden to take ZoneID as parametere using this we can get the same date under different timezones. localDate2 GoalKicker.com Java Notes for Professionals 84 This has the methods of abstract class link Clock. Clock can be used for time which has time with link TimeZone. public static void checkClock Clock clock Clock.systemUTC Represents": "input.pdf", "time according to ISO 8601 System.out.printlnTime using Clock class clock.instant This has the link Instant class methods. public static void checkInstant Instant instant Instant. now System.out.printlnInstant using now method instant Instant ins1 Instant. nowClock.systemUTC System.out.printlnInstants using nowClock clock ins1 This class checks the methods of the link Duration class. public static void checkDuration toString converts the duration to PTnHnMnS format according to ISO 8601 standard. If a field is zero its ignored. P is the duration designator historically called period placed at the start of the duration representation. Y is the year designator that follows the value for the number of years. M is the month designator that follows the value for the number of months. W is the week designator that follows the value for the number of weeks. D is the day designator that follows the value for the number of days. T is the time designator that precedes the time components of the representation. H is the hour designator that follows the value for the number of hours. M is the minute designator that follows the value for the number of minutes. S is the second designator that follows the value for the number of seconds.": "input.pdf", "System.out.printlnDuration. ofDays2 Shows Local time without date. It doesnt store or represenet a date and time. Instead its a representation of Time like clock on the wall. public static void checkLocalTime LocalTime localTime LocalTime. now System.out.printlnLocalTime localTime GoalKicker.com Java Notes for Professionals 85 A date time with Time zone details in ISO-8601 standards. public static void checkZonedDateTime ZonedDateTime zonedDateTime ZonedDateTime. nowZoneId . ofZoneId.SHORTIDS .getCST System.out.printlnzonedDateTime Section 17.6 Date Time Formatting Before Java 8, there was DateFormat and SimpleDateFormat classes in the package java.text and this legacy code will be continued to be used for sometime. But, Java 8 o\ufb00ers a modern approach to handling Formatting and Parsing. In formatting and parsing \ufb01rst you pass a String object to DateTimeFormatter , and in turn use it for formatting or parsing. import java.time. import java.time.format. class DateTimeFormat public static void mainString args Parsing String pattern d-MM-yyyy HHmm DateTimeFormatter dtF1 DateTimeFormatter. ofPattern pattern LocalDateTime ldp1 LocalDateTime. parse2014-03-25T0130 , Default format ldp2 LocalDateTime. parse15-05-2016 1355 ,dtF1 Custom format System.out.printlnldp1 n ldp2 Will be printed in Default format Formatting DateTimeFormatter dtF2 DateTimeFormatter. ofPattern EEE d, MMMM, yyyy HHmm DateTimeFormatter dtF3 DateTimeFormatter. ISOLOCALDATETIME LocalDateTime ldtf1 LocalDateTime. now System.out.printlnldtf1.formatdtF2 nldtf1.formatdtF3 An important notice, instead of using": "input.pdf", "Custom patterns, it is good practice to use prede\ufb01ned formatters. Your code look more clear and usage of ISO8061 will de\ufb01nitely help you in the long run. Section 17.7 Simple Date Manipulations Get the current date. LocalDate. now Get yesterdays date. GoalKicker.com Java Notes for Professionals 86LocalDate y LocalDate. now.minusDays 1 Get tomorrows date LocalDate t LocalDate. now.plusDays 1 Get a speci\ufb01c date. LocalDate t LocalDate. of1974, 6, 2, 8, 30, 0, 0 In addition to the plus and minus methods, there are a set of with methods that can be used to set a particular \ufb01eld on a LocalDate instance. LocalDate. now.withMonth 6 The example above returns a new instance with the month set to June this di\ufb00ers from java.util.Date where setMonth was indexed a 0 making June 5. Because LocalDate manipulations return immutable LocalDate instances, these methods may also be chained together. LocalDate ld LocalDate. now.plusDays 1.plusYears 1 This would give us tomorrows date one year from now. GoalKicker.com Java Notes for Professionals 87Chapter 18 LocalTime Method Output LocalTime. of13, 12, 11 131211 LocalTime. MIDNIGHT 0000 LocalTime. NOON 1200 LocalTime. now Current time from system clock LocalTime. MAX The maximum supported local time 235959.999999999 LocalTime. MIN The": "input.pdf", "minimum supported local time 0000 LocalTime. ofSecondOfDay 84399 235959 , Obtains Time from second-of-day value LocalTime. ofNanoOfDay 2000000000 000002 , Obtains Time from nanos-of-day value Section 18.1 Amount of time between two LocalTime There are two equivalent ways to calculate the amount of time unit between two LocalTime 1 through untilTemporal, TemporalUnit method and through 2 TemporalUnit. betweenTemporal, Temporal . import java.time.LocalTime import java.time.temporal.ChronoUnit public class AmountOfTime public static void mainString args LocalTime start LocalTime. of1, 0, 0 hour, minute, second LocalTime end LocalTime. of2, 10, 20 hour, minute, second long halfDays1 start.untilend, ChronoUnit. HALFDAYS 0 long halfDays2 ChronoUnit. HALFDAYS .betweenstart, end 0 long hours1 start.untilend, ChronoUnit. HOURS 1 long hours2 ChronoUnit. HOURS.betweenstart, end 1 long minutes1 start.untilend, ChronoUnit. MINUTES 70 long minutes2 ChronoUnit. MINUTES.betweenstart, end 70 long seconds1 start.untilend, ChronoUnit. SECONDS 4220 long seconds2 ChronoUnit. SECONDS.betweenstart, end 4220 long millisecs1 start.untilend, ChronoUnit. MILLIS 4220000 long millisecs2 ChronoUnit. MILLIS.betweenstart, end 4220000 long microsecs1 start.untilend, ChronoUnit. MICROS 4220000000 long microsecs2 ChronoUnit. MICROS.betweenstart, end 4220000000 long nanosecs1 start.untilend, ChronoUnit. NANOS 4220000000000 long nanosecs2 ChronoUnit. NANOS.betweenstart, end 4220000000000 Using others ChronoUnit will be thrown UnsupportedTemporalTypeException. The following methods are examples thereof. long days1 start.untilend, ChronoUnit. DAYS long days2 ChronoUnit. DAYS.betweenstart, end GoalKicker.com": "input.pdf", "Java Notes for Professionals 88Section 18.2 Intro LocalTime is an immutable class and thread-safe, used to represent time, often viewed as hour-min-sec. Time is represented to nanosecond precision. For example, the value 1345.30.123456789 can be stored in a LocalTime. This class does not store or represent a date or time-zone. Instead, it is a description of the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an o\ufb00set or time- zone. This is a value based class, equals method should be used for comparisons. Fields MAX - The maximum supported LocalTime, 235959.999999999. MIDNIGHT, MIN, NOON Important Static Methods now, nowClock clock, nowZoneId zone, parseCharSequence text Important Instance Methods isAfterLocalTime other, isBeforeLocalTime other, minusTemporalAmount amountToSubtract, minuslong amountToSubtract, TemporalUnit unit, plusTemporalAmount amountToAdd, pluslong amountToAdd, TemporalUnit unit ZoneId zone ZoneId. ofAsiaKolkata LocalTime now LocalTime. now LocalTime now1 LocalTime. nowzone LocalTime then LocalTime. parse041640 Di\ufb00erence in time can be calculated in any of following ways long timeDiff Duration. betweennow, now1 .toMinutes long timeDiff1 java.time.temporal .ChronoUnit .MINUTES.betweennow2, now1 You can also addsubtract hours, minutes or seconds from any object of LocalTime. minusHourslong hoursToSubtract, minusMinuteslong hoursToMinutes, minusNanoslong nanosToSubtract, minusSecondslong secondsToSubtract, plusHourslong hoursToSubtract, plusMinuteslong": "input.pdf", "hoursToMinutes, plusNanoslong nanosToSubtract, plusSecondslong secondsToSubtract now.plusHours 1L now1.minusMinutes 20L Section 18.3 Time Modi\ufb01cation You can add hours, minutes, seconds and nanoseconds LocalTime time LocalTime. now LocalTime addHours time.plusHours 5 Add 5 hours LocaLTime addMinutes time.plusMinutes 15 Add 15 minutes LocalTime addSeconds time.plusSeconds 30 Add 30 seconds LocalTime addNanoseconds time.plusNanos 150000000 Add 150.000.000ns 150ms Section 18.4 Time Zones and their time dierence import java.time.LocalTime GoalKicker.com Java Notes for Professionals 89import java.time.ZoneId import java.time.temporal.ChronoUnit public class Test public static void mainString args ZoneId zone1 ZoneId. ofEuropeBerlin ZoneId zone2 ZoneId. ofBrazilEast LocalTime now LocalTime. now LocalTime now1 LocalTime. nowzone1 LocalTime now2 LocalTime. nowzone2 System.out.printlnCurrent Time now System.out.printlnBerlin Time now1 System.out.printlnBrazil Time now2 long minutesBetween ChronoUnit. MINUTES.betweennow2, now1 System.out.printlnMinutes Between Berlin and Brazil minutesBetween mins GoalKicker.com Java Notes for Professionals 90Chapter 19 BigDecimal The BigDecimal class provides operations for arithmetic add, subtract, multiply, divide, scale manipulation, rounding, comparison, hashing, and format conversion. The BigDecimal represents immutable, arbitrary-precision signed decimal numbers. This class shall be used in a necessity of high-precision calculation. Section 19.1 Comparing BigDecimals The method compareTo should be used to compare BigDecimals BigDecimal a new BigDecimal 5 a.compareTo new BigDecimal 0 a is greater, returns 1 a.compareTo new BigDecimal 5 a": "input.pdf", "is equal, returns 0 a.compareTo new BigDecimal 10 a is less, returns -1 Commonly you should not use the equals method since it considers two BigDecimals equal only if they are equal in value and also scale BigDecimal a new BigDecimal 5 a.equalsnew BigDecimal 5 value and scale are equal, returns true a.equalsnew BigDecimal 5.00 value is equal but scale is not, returns false Section 19.2 Using BigDecimal instead of \ufb02oat Due to way that the \ufb02oat type is represented in computer memory, results of operations using this type can be inaccurate - some values are stored as approximations. Good examples of this are monetary calculations. If high precision is necessary, other types should be used. e.g. Java 7 provides BigDecimal. import java.math.BigDecimal public class FloatTest public static void mainString args float accountBalance 10000.00f System.out.printlnOperations using float System.out.println1000 operations for 1.99 forint i 0 i1000 i accountBalance - 1.99f System.out.printlnString.formatAccount balance after float operations f , accountBalance BigDecimal accountBalanceTwo new BigDecimal 10000.00 System.out.printlnOperations using BigDecimal System.out.println1000 operations for 1.99 BigDecimal operation new BigDecimal 1.99 forint i 0 i1000 i accountBalanceTwo accountBalanceTwo. subtract operation System.out.printlnString.formatAccount balance after BigDecimal operations f , accountBalanceTwo Output of this program is GoalKicker.com Java Notes": "input.pdf", "for Professionals 91Operations using float 1000 operations for 1.99 Account balance after float operations 8009,765625 Operations using BigDecimal 1000 operations for 1.99 Account balance after BigDecimal operations 8010,000000 For a starting balance of 10000.00, after 1000 operations for 1.99, we expect the balance to be 8010.00. Using the \ufb02oat type gives us an answer around 8009.77, which is unacceptably imprecise in the case of monetary calculations. Using BigDecimal gives us the proper result. Section 19.3 BigDecimal.valueOf The BigDecimal class contains an internal cache of frequently used numbers e.g. 0 to 10. The BigDecimal.valueOf methods are provided in preference to constructors with similar type parameters i.e. in the below example a is preferred to b. BigDecimal a BigDecimal .valueOf10L Returns cached Object reference BigDecimal b new BigDecimal 10L Does not return cached Object reference BigDecimal a BigDecimal .valueOf20L Does not return cached Object reference BigDecimal b new BigDecimal 20L Does not return cached Object reference BigDecimal a BigDecimal .valueOf15.15 Preferred way to convert a double or float into a BigDecimal, as the value returned is equal to that resulting from constructing a BigDecimal from the result of using Double.toStringdouble BigDecimal b new BigDecimal 15.15 Return unpredictable result Section 19.4 Mathematical": "input.pdf", "operations with BigDecimal This example shows how to perform basic mathematical operations using BigDecimals. 1.Addition BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result a b BigDecimal result a.addb System.out.printlnresult Result 12 2.Subtraction BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result a - b BigDecimal result a.subtract b System.out.printlnresult Result -2 GoalKicker.com Java Notes for Professionals 923.Multiplication When multiplying two BigDecimal s the result is going to have scale equal to the sum of the scales of operands. BigDecimal a new BigDecimal 5.11 BigDecimal b new BigDecimal 7.221 Equivalent to result a b BigDecimal result a.multiply b System.out.printlnresult Result 36.89931 To change the scale of the result use the overloaded multiply method which allows passing MathContext - an object describing the rules for operators, in particular the precision and rounding mode of the result. For more information about available rounding modes please refer to the Oracle Documentation. BigDecimal a new BigDecimal 5.11 BigDecimal b new BigDecimal 7.221 MathContext returnRules new MathContext 4, RoundingMode. HALFDOWN Equivalent to result a b BigDecimal result a.multiply b, returnRules System.out.printlnresult Result 36.90 4.Division Division is a bit more complicated than the other arithmetic operations, for": "input.pdf", "instance consider the below example BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 BigDecimal result a.divideb System.out.printlnresult We would expect this to give something similar to 0.7142857142857143, but we would get Result java.lang.ArithmeticException Non-terminating decimal expansion no exact representable decimal result. This would work perfectly well when the result would be a terminating decimal say if I wanted to divide 5 by 2, but for those numbers which upon dividing would give a non terminating result we would get an ArithmeticException . In the real world scenario, one cannot predict the values that would be encountered during the division, so we need to specify the Scale and the Rounding Mode for BigDecimal division. For more information on the Scale and Rounding Mode, refer the Oracle Documentation . For example, I could do BigDecimal a new BigDecimal 5 GoalKicker.com Java Notes for Professionals 93BigDecimal b new BigDecimal 7 Equivalent to result a b Upto 10 Decimal places and Round HALFUP BigDecimal result a.divideb,10,RoundingMode. HALFUP System.out.printlnresult Result 0.7142857143 5.Remainder or Modulus BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result a b BigDecimal result a.remainder b System.out.printlnresult Result 5 6.Power BigDecimal a new BigDecimal 5": "input.pdf", "Equivalent to result a10 BigDecimal result a.pow10 System.out.printlnresult Result 9765625 7.Max BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result MAXa,b BigDecimal result a.maxb System.out.printlnresult Result 7 8.Min BigDecimal a new BigDecimal 5 BigDecimal b new BigDecimal 7 Equivalent to result MINa,b BigDecimal result a.minb System.out.printlnresult Result 5 9.Move Point To Left GoalKicker.com Java Notes for Professionals 94BigDecimal a new BigDecimal 5234.49843776 Moves the decimal point to 2 places left of current position BigDecimal result a.movePointLeft 2 System.out.printlnresult Result 52.3449843776 10.Move Point To Right BigDecimal a new BigDecimal 5234.49843776 Moves the decimal point to 3 places right of current position BigDecimal result a.movePointRight 3 System.out.printlnresult Result 5234498.43776 There are many more options and combination of parameters for the above mentioned examples For instance, there are 6 variations of the divide method, this set is a non-exhaustive list and covers a few basic examples. Section 19.5 Initialization of BigDecimals with value zero, one or ten BigDecimal provides static properties for the numbers zero, one and ten. Its good practise to use these instead of using the actual numbers BigDecimal .ZERO BigDecimal .ONE BigDecimal .TEN By using the static properties, you avoid an unnecessary instantiation, also youve": "input.pdf", "got a literal in your code instead of a magic number. Bad example BigDecimal bad0 new BigDecimal 0 BigDecimal bad1 new BigDecimal 1 BigDecimal bad10 new BigDecimal 10 Good Example BigDecimal good0 BigDecimal .ZERO BigDecimal good1 BigDecimal .ONE BigDecimal good10 BigDecimal .TEN Section 19.6 BigDecimal objects are immutable If you want to calculate with BigDecimal you have to use the returned value because BigDecimal objects are immutable BigDecimal a new BigDecimal 42.23 BigDecimal b new BigDecimal 10.001 a.addb a will still be 42.23 GoalKicker.com Java Notes for Professionals 95BigDecimal c a.addb c will be 52.231 GoalKicker.com Java Notes for Professionals 96Chapter 20 BigInteger The BigInteger class is used for mathematical operations involving large integers with magnitudes too large for primitive data types. For example 100-factorial is 158 digits - much larger than a long can represent. BigInteger provides analogues to all of Javas primitive integer operators, and all relevant methods from java.lang.Math as well as few other operations. Section 20.1 Initialization The java.math.BigInteger class provides operations analogues to all of Javas primitive integer operators and for all relevant methods from java.lang.Math . As the java.math package is not automatically made available you may have to import java.math.BigInteger before you": "input.pdf", "can use the simple class name. To convert long or int values to BigInteger use long longValue Long.MAXVALUE BigInteger valueFromLong BigInteger .valueOflongValue or, for integers int intValue Integer.MINVALUE negative BigInteger valueFromInt BigInteger .valueOfintValue which will widen the intValue integer to long, using sign bit extension for negative values, so that negative values will stay negative. To convert a numeric String to BigInteger use String decimalString -1 BigInteger valueFromDecimalString new BigInteger decimalString Following constructor is used to translate the String representation of a BigInteger in the speci\ufb01ed radix into a BigInteger . String binaryString 10 int binaryRadix 2 BigInteger valueFromBinaryString new BigInteger binaryString , binaryRadix Java also supports direct conversion of bytes to an instance of BigInteger . Currently only signed and unsigned big endian encoding may be used byte bytes new byte byte 0x80 BigInteger valueFromBytes new BigInteger bytes This will generate a BigInteger instance with value -128 as the \ufb01rst bit is interpreted as the sign bit. byte unsignedBytes new byte byte 0x80 int sign 1 positive BigInteger valueFromUnsignedBytes new BigInteger sign, unsignedBytes This will generate a BigInteger instance with value 128 as the bytes are interpreted as unsigned number, and the sign is explicitly set to 1,": "input.pdf", "a positive number. There are prede\ufb01ned constants for common values GoalKicker.com Java Notes for Professionals 97BigInteger .ZERO value of 0. BigInteger .ONE value of 1. BigInteger .TEN value of 10. Theres also BigInteger .TWO value of 2, but you cant use it in your code because its private . Section 20.2 BigInteger Mathematical Operations Examples BigInteger is in an immutable object, so you need to assign the results of any mathematical operation, to a new BigInteger instance. Addition 10 10 20 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 10 BigInteger sum value1. addvalue2 System.out.printlnsum output 20 Subtraction 10 - 9 1 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 9 BigInteger sub value1. subtract value2 System.out.printlnsub output 1 Division 10 5 2 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 5 BigInteger div value1. dividevalue2 System.out.printlndiv output 2 Division 174 4 BigInteger value1 new BigInteger 17 BigInteger value2 new BigInteger 4 BigInteger div value1. dividevalue2 System.out.printlndiv output 4 GoalKicker.com Java Notes for Professionals 98Multiplication 10 5 50 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 5 BigInteger mul value1. multiply value2 System.out.printlnmul output 50 Power 10 3 1000 BigInteger value1 new BigInteger 10 BigInteger": "input.pdf", "power value1. pow3 System.out.printlnpower output 1000 Remainder 10 6 4 BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 6 BigInteger power value1. remainder value2 System.out.printlnpower output 4 GCD Greatest Common Divisor GCD for 12and 18 is 6. BigInteger value1 new BigInteger 12 BigInteger value2 new BigInteger 18 System.out.printlnvalue1.gcdvalue2 Output 6 Maximum of two BigIntegers BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 11 System.out.printlnvalue1.maxvalue2 Output 11 Minimum of two BigIntegers GoalKicker.com Java Notes for Professionals 99BigInteger value1 new BigInteger 10 BigInteger value2 new BigInteger 11 System.out.printlnvalue1.minvalue2 Output 10 Section 20.3 Comparing BigIntegers You can compare BigIntegers same as you compare String or other objects in Java. For example BigInteger one BigInteger .valueOf1 BigInteger two BigInteger .valueOf2 ifone.equalstwo System.out.printlnEqual else System.out.printlnNot Equal Output Not Equal Note In general, do not use use the operator to compare BigIntegers operator compares references i.e. whether two values refer to the same object equals method compares the content of two BigIntegers. For example, BigIntegers should not be compared in the following way if firstBigInteger secondBigInteger Only checks for reference equality, not content equality! Doing so may lead to unexpected behavior, as the operator only checks for reference equality. If both BigIntegers contain": "input.pdf", "the same content, but do not refer to the same object, this will fail. Instead, compare BigIntegers using the equals methods, as explained above. You can also compare your BigInteger to constant values like 0,1,10. for example BigInteger reallyBig BigInteger .valueOf1 ifBigInteger .ONE.equalsreallyBig code when they are equal. You can also compare two BigIntegers by using compareTo method, as following compareTo returns 3 values. GoalKicker.com Java Notes for Professionals 1000 When both are equal . 1 When \ufb01rst is greater than second the one in brackets. -1 When \ufb01rst is less than second. BigInteger reallyBig BigInteger .valueOf10 BigInteger reallyBig1 BigInteger .valueOf100 ifreallyBig. compareTo reallyBig1 0 code when both are equal. else ifreallyBig. compareTo reallyBig1 1 code when reallyBig is greater than reallyBig1. else ifreallyBig. compareTo reallyBig1 -1 code when reallyBig is less than reallyBig1. Section 20.4 Binary Logic Operations on BigInteger BigInteger supports the binary logic operations that are available to Number types as well. As with all operations they are implemented by calling a method. Binary Or BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9 val1.orval2 Output 11 which is equivalent to 10 9 Binary And BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9": "input.pdf", "val1.andval2 Output 8 which is equivalent to 10 9 Binary Xor BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9 val1.xorval2 Output 3 which is equivalent to 10 9 RightShift BigInteger val1 new BigInteger 10 GoalKicker.com Java Notes for Professionals 101val1.shiftRight 1 the argument be an Integer Output 5 equivalent to 10 1 LeftShift BigInteger val1 new BigInteger 10 val1.shiftLeft 1 here parameter should be Integer Output 20 equivalent to 10 1 Binary Inversion Not BigInteger val1 new BigInteger 10 val1.not Output 5 NAND And-Not BigInteger val1 new BigInteger 10 BigInteger val2 new BigInteger 9 val1.andNotval2 Output 7 Section 20.5 Generating random BigIntegers The BigInteger class has a constructor dedicated to generate random BigIntegers , given an instance of java.util.Random and an int that speci\ufb01es how many bits will the BigInteger have. Its usage is quite simple - when you call the constructor BigInteger int, Random like this BigInteger randomBigInt new BigInteger bitCount, sourceOfRandomness then youll end up with a BigInteger whose value is between 0 inclusive and 2 bitCount exclusive. This also means that new BigInteger 2147483647 , sourceOfRandomness may return all positive BigInteger s given enough time. What will the sourceOfRandomness be is up to you.": "input.pdf", "For example, a new Random is good enough in most cases new BigInteger 32, new Random If youre willing to give up speed for higher-quality random numbers, you can use a new httpsdocs.oracle.comjavase8docsapijavasecuritySecureRandom.html relnofollow noreferrerSecureRandom instead GoalKicker.com Java Notes for Professionals 102import java.security.SecureRandom somewhere in the code... new BigInteger 32, new SecureRandom You can even implement an algorithm on-the-\ufb02y with an anonymous class! Note that rolling out your own RNG algorithm will end you up with low quality randomness , so always be sure to use an algorithm that is proven to be decent unless you want the resulting BigInteger s to be predictable. new BigInteger 32, new Random int seed 0 Override protected int nextint bits seed 22695477 seed 1 2147483647 Values shamelessly stolen from httpsen.wikipedia.orgwikiLinearcongruentialgeneratorParametersincommonuse relnofollow noreferrerWikipedia return seed GoalKicker.com Java Notes for Professionals 103Chapter 21 NumberFormat Section 21.1 NumberFormat Di\ufb00erent countries have di\ufb00erent number formats and considering this we can have di\ufb00erent formats using Locale of java. Using locale can help in formatting Locale locale new Localeen, IN NumberFormat numberFormat NumberFormat .getInstance locale using above format you can perform various tasks Format Number1. numberFormat. format10000000.99 Format Currency2. NumberFormat currencyFormat NumberFormat .getCurrencyInstance locale currencyFormat. format10340.999 Format Percentage3.": "input.pdf", "NumberFormat percentageFormat NumberFormat .getPercentInstance locale percentageFormat. format10929.999 Control Number of Digits4. numberFormat. setMinimumIntegerDigits int digits numberFormat. setMaximumIntegerDigits int digits numberFormat. setMinimumFractionDigits int digits numberFormat. setMaximumFractionDigits int digits GoalKicker.com Java Notes for Professionals 104Chapter 22 Bit Manipulation Section 22.1 Checking, setting, clearing, and toggling individual bits. Using long as bit mask Assuming we want to modify bit n of an integer primitive, i byte, short, char, int, or long i 1 n ! 0 checks bit n i 1 n sets bit n to 1 i 1 n sets bit n to 0 i 1 n toggles the value of bit n Using longintshortbyte as a bit mask public class BitMaskExample private static final long FIRSTBIT 1L 0 private static final long SECONDBIT 1L 1 private static final long THIRDBIT 1L 2 private static final long FOURTHBIT 1L 3 private static final long FIFTHBIT 1L 4 private static final long BIT55 1L 54 public static void mainString args checkBitMask FIRSTBIT THIRDBIT FIFTHBIT BIT55 private static void checkBitMask long bitmask System.out.printlnFIRSTBIT bitmask FIRSTBIT ! 0 System.out.printlnSECONDBIT bitmask SECONDBIT ! 0 System.out.printlnTHIRDBIT bitmask THIRDBIT ! 0 System.out.printlnFOURThBIT bitmask FOURTHBIT ! 0 System.out.printlnFIFTHBIT bitmask FIFTHBIT ! 0 System.out.printlnBIT55 bitmask BIT55 ! 0 Prints": "input.pdf", "FIRSTBIT true SECONDBIT false THIRDBIT true FOURThBIT false FIFTHBIT true BIT55 true which matches that mask we passed as checkBitMask parameter FIRSTBIT THIRDBIT FIFTHBIT BIT55 . Section 22.2 java.util.BitSet class Since 1.7 theres a java.util.BitSet class that provides simple and user-friendly bit storage and manipulation interface final BitSet bitSet new BitSet8 by default all bits are unset IntStream. range0, 8.filteri - i 2 0.forEachbitSetset 0, 2, 4, 6 bitSet.set3 0, 2, 3, 4, 6 GoalKicker.com Java Notes for Professionals 105bitSet.set3, false 0, 2, 4, 6 final boolean b bitSet. get3 b false bitSet.flip6 0, 2, 4 bitSet.set100 0, 2, 4, 100 - expands automatically BitSet implements Clonable and Serializable , and under the hood all bit values are stored in long words \ufb01eld, that expands automatically. It also supports whole-set logical operations and, or, xor, andNot bitSet.andnew BitSet8 bitSet.ornew BitSet8 bitSet.xornew BitSet8 bitSet.andNotnew BitSet8 Section 22.3 Checking if a number is a power of 2 If an integer x is a power of 2, only one bit is set, whereas x-1 has all bits set after that. For example 4 is 100 and 3 is 011 as binary number, which satis\ufb01es the aforementioned condition. Zero is not a power": "input.pdf", "of 2 and has to be checked explicitly. boolean isPowerOfTwo int x return x ! 0 x x - 1 0 Usage for Left and Right Shift Lets suppose, we have three kind of permissions, READ , WRITE and EXECUTE . Each permission can range from 0 to 7. Let s assume 4 bit number system RESOURCE READ WRITE EXECUTE 12 bit number RESOURCE 0100 0110 0101 4 6 5 12 bit number How can we get the 12 bit number permissions, set on above 12 bit number? 0100 0110 0101 0000 0000 0111 0000 0000 0101 5 So, this is how we can get the EXECUTE permissions of the RESOURCE . Now, what if we want to get READ permissions of the RESOURCE ? 0100 0110 0101 0111 0000 0000 GoalKicker.com Java Notes for Professionals 1060100 0000 0000 1024 Right? You are probably assuming this? But, permissions are resulted in 1024. We want to get only READ permissions for the resource. Don t worry, that s why we had the shift operators. If we see, READ permissions are 8 bits behind the actual result, so if apply some shift operator, which will bring READ permissions to the very": "input.pdf", "right of the result? What if we do 0100 0000 0000 8 0000 0000 0100 Because it s a positive number so replaced with 0 s, if you don t care about sign, just use unsigned right shift operator We now actually have the READ permissions which is 4. Now, for example, we are given READ , WRITE , EXECUTE permissions for a RESOURCE , what can we do to make permissions for this RESOURCE ? Lets \ufb01rst take the example of binary permissions. Still assuming 4 bit number system READ 0001 WRITE 0100 EXECUTE 0110 If you are thinking that we will simply do READ WRITE EXECUTE , you are somewhat right but not exactly. See, what will happen if we will perform READ WRITE EXECUTE 0001 0100 0110 0111 But permissions are actually being represented in our example as 0001 0100 0110 So, in order to do this, we know that READ is placed 8 bits behind, WRITE is placed 4 bits behind and PERMISSIONS is placed at the last. The number system being used for RESOURCE permissions is actually 12 bit in our example. It canwill be di\ufb00erent in di\ufb00erent systems. READ 8 WRITE 4 EXECUTE": "input.pdf", "0000 0000 0001 8 READ 0001 0000 0000 Left shift by 8 bits 0000 0000 0100 4 WRITE 0000 0100 0000 Left shift by 4 bits 0000 0000 0001 EXECUTE Now if we add the results of above shifting, it will be something like GoalKicker.com Java Notes for Professionals 1070001 0000 0000 READ 0000 0100 0000 WRITE 0000 0000 0001 EXECUTE 0001 0100 0001 PERMISSIONS Section 22.4 Signed vs unsigned shift In Java, all number primitives are signed. For example, an int always represent values from -231 - 1, 231, keeping the \ufb01rst bit to sign the value - 1 for negative value, 0 for positive. Basic shift operators and are signed operators. They will conserve the sign of the value. But it is common for programmers to use numbers to store unsigned values . For an int, it means shifting the range to 0, 232 - 1, to have twice as much value as with a signed int. For those power users, the bit for sign as no meaning. Thats why Java added , a left-shift operator, disregarding that sign bit. initial value 4 100 signed left -shift 4 1 8 1000 signed right -shift 4 1 2": "input.pdf", "10 unsigned right -shift 4 1 2 10 initial value -4 11111111111111111111111111111100 signed left -shift -4 1 -8 11111111111111111111111111111000 signed right -shift -4 1 -2 11111111111111111111111111111110 unsigned right -shift -4 1 2147483646 1111111111111111111111111111110 Why is there no ? This comes from the intended de\ufb01nition of right-shift. As it \ufb01lls the emptied places on the left, there are no decision to take regarding the bit of sign. As a consequence, there is no need for 2 di\ufb00erent operators. See this question for a more detailled answer. Section 22.5 Expressing the power of 2 For expressing the power of 2 2n of integers, one may use a bitshift operation that allows to explicitly specify the n. The syntax is basically int pow2 1n Examples int twoExp4 14 24 int twoExp5 15 25 int twoExp6 16 26 ... int twoExp31 131 231 This is especially useful when de\ufb01ning constant values that should make it apparent, that a power of 2 is used, GoalKicker.com Java Notes for Professionals 108instead of using hexadecimal or decimal values. int twoExp4 0x10 hexadecimal int twoExp5 0x20 hexadecimal int twoExp6 64 decimal ... int twoExp31 -2147483648 is that a power of 2? A simple method to calculate the": "input.pdf", "int power of 2 would be int pow2int exp return 1exp Section 22.6 Packing unpacking values as bit fragments It is common for memory performance to compress multiple values into a single primitive value. This may be useful to pass various information into a single variable. For example, one can pack 3 bytes - such as color code in RGB - into an single int. Packing the values Raw bytes as input byte b byte0x65, byte0xFF, byte0x31 Packed in big endian x 0x65FF31 int x b0 0xFF 16 Red b1 0xFF 8 Green b2 0xFF 0 Blue Packed in little endian y 0x31FF65 int y b0 0xFF 0 b1 0xFF 8 b2 0xFF 16 Unpacking the values Raw int32 as input int x 0x31FF65 Unpacked in big endian 0x65, 0xFF, 0x31 byte c bytex 16, bytex 8, bytex 0xFF Unpacked in little endian 0x31, 0xFF, 0x65 byte d bytex 0xFF, bytex 8, bytex 16 GoalKicker.com Java Notes for Professionals 109Chapter 23 Arrays Parameter Details ArrayType Type of the array. This can be primitive int, long , byte or Objects String , MyObject , etc. index Index refers to the position of a certain Object in an array. lengthEvery array,": "input.pdf", "when being created, needs a set length speci\ufb01ed. This is either done when creating an empty array new int3 or implied when specifying values 1, 2, 3. Arrays allow for the storage and retrieval of an arbitrary quantity of values. They are analogous to vectors in mathematics. Arrays of arrays are analogous to matrices, and act as multidimensional arrays. Arrays can store any data of any type primitives such as int or reference types such as Object . Section 23.1 Creating and Initializing Arrays Basic cases int numbers1 new int3 Array for 3 int values, default value is 0 int numbers2 1, 2, 3 Array literal of 3 int values int numbers3 new int 1, 2, 3 Array of 3 int values initialized int numbers4 1, 2 , 3, 4, 5 Jagged array literal int numbers5 new int5 Jagged array, one dimension 5 long int numbers6 new int54 Multidimensional array 5x4 Arrays may be created using any primitive or reference type. float boats new float5 Array of five 32-bit floating point numbers. double header new double 4.56, 332.267, 7.0, 0.3367, 10.0 Array of five 64-bit floating point numbers. String theory new String a, b, c Array of three strings": "input.pdf", "reference type. Object dArt new Object new Object, We love Stack Overflow. , new Integer3 Array of three Objects reference type. For the last example, note that subtypes of the declared array type are allowed in the array. Arrays for user de\ufb01ned types can also be built similar to primitive types UserDefinedClass udType new UserDefinedClass 5 Arrays, Collections, and Streams Version Java SE 1.2 Parameters require objects, not primitives Auto-boxing happening for int 127 here Integer initial 127, Integer.valueOf 42 ListInteger toList Arrays.asList initial Fixed size! Note Works with all collections Integer fromCollection toList. toArray new IntegertoList.size Java doesnt allow you to create an array of a parameterized type ListString list new ArrayList String2 Compilation error! Version Java SE 8 Streams - JDK 8 StreamInteger toStream Arrays.stream initial Integer fromStream toStream. toArray Integernew Intro GoalKicker.com Java Notes for Professionals 110An array is a data structure that holds a \ufb01xed number of primitive values or references to object instances. Each item in an array is called an element, and each element is accessed by its numerical index. The length of an array is established when the array is created int size 42 int array new intsize The size of an": "input.pdf", "array is \ufb01xed at runtime when initialized. It cannot be changed after initialization. If the size must be mutable at runtime, a Collection class such as ArrayList should be used instead. ArrayList stores elements in an array and supports resizing by allocating a new array and copying elements from the old array. If the array is of a primitive type, i.e. int array1 1,2,3 int array2 new int10 the values are stored in the array itself. In the absence of an initializer as in array2 above, the default value assigned to each element is 0 zero. If the array type is an object reference, as in SomeClassOrInterface array new SomeClassOrInterface 10 then the array contains references to objects of type SomeClassOrInterface . Those references can refer to an instance of SomeClassOrInterface or any subclass for classes or implementing class for interfaces of SomeClassOrInterface . If the array declaration has no initializer then the default value of null is assigned to each element. Because all arrays are int-indexed, the size of an array must be speci\ufb01ed by an int. The size of the array cannot be speci\ufb01ed as a long long size 23L int array new intsize Compile-time error incompatible": "input.pdf", "types possible lossy conversion from long to int Arrays use a zero-based index system, which means indexing starts at 0 and ends at length - 1. For example, the following image represents an array with size 10. Here, the \ufb01rst element is at index 0 and the last element is at index 9, instead of the \ufb01rst element being at index 1 and the last element at index 10 see \ufb01gure below. Accesses to elements of arrays are done in constant time . That means accessing to the \ufb01rst element of the array has the same cost in time of accessing the second element, the third element and so on. Java o\ufb00ers several ways of de\ufb01ning and initializing arrays, including literal and constructor notations. When GoalKicker.com Java Notes for Professionals 111declaring arrays using the new Typelength constructor, each element will be initialized with the following default values 0 for primitive numerical types byte , short , int, long , float , and double . u0000 null character for the char type. false for the boolean type. null for reference types . Creating and initializing primitive type arrays int array1 new int 1, 2, 3 Create an array with new": "input.pdf", "operator and array initializer. int array2 1, 2, 3 Shortcut syntax with array initializer. int array3 new int3 Equivalent to 0, 0, 0 int array4 null The array itself is an object, so it can be set as null. When declaring an array, will appear as part of the type at the beginning of the declaration after the type name, or as part of the declarator for a particular variable after variable name, or both int array5 equivalent to int array5 int a, b, c equivalent to int a int b int c int a, b equivalent to int a int b int a, b, c Compilation Error, because is not part of the type at beginning of the declaration, rather it is before b. The same rules apply when declaring a method that returns an array int foo ... equivalent to int foo ... In the following example, both declarations are correct and can compile and run without any problems. However, both the Java Coding Convention and the Google Java Style Guide discourage the form with brackets after the variable name the brackets identify the array type and should appear with the type designation . The same should": "input.pdf", "be used for method return signatures. float array and int foo ... are discouraged float array and int foo ... are encouraged The discouraged type is meant to accommodate transitioning C users , who are familiar with the syntax for C which has the brackets after the variable name. In Java, it is possible to have arrays of size 0 int array new int0 Compiles and runs fine. int array2 Equivalent syntax. However, since its an empty array, no elements can be read from it or assigned to it array0 1 Throws java.lang.ArrayIndexOutOfBoundsException. int i array20 Also throws ArrayIndexOutOfBoundsException. Such empty arrays are typically useful as return values, so that the calling code only has to worry about dealing with an array, rather than a potential null value that may lead to a NullPointerException . The length of an array must be a non-negative integer int array new int-1 Throws java.lang.NegativeArraySizeException GoalKicker.com Java Notes for Professionals 112The array size can be determined using a public \ufb01nal \ufb01eld called length System.out.printlnarray.length Prints 0 in this case. Note array.length returns the actual size of the array and not the number of array elements which were assigned a value, unlike ArrayList .size": "input.pdf", "which returns the number of array elements which were assigned a value. Creating and initializing multi-dimensional arrays The simplest way to create a multi-dimensional array is as follows int a new int23 It will create two three-length int arrays a0 and a1. This is very similar to the classical, C-style initialization of rectangular multi-dimensional arrays. You can create and initialize at the same time int a 1, 2, 3, 4, 5, 6 Unlike C , where only rectangular multi-dimensional arrays are supported, inner arrays do not need to be of the same length, or even de\ufb01ned int a 1, 2, 3, null Here, a0 is a one-length int array, whereas a1 is a two-length int array and a2 is null . Arrays like this are called jagged arrays or ragged arrays, that is, they are arrays of arrays. Multi-dimensional arrays in Java are implemented as arrays of arrays, i.e. arrayijk is equivalent to arrayijk. Unlike C , the syntax arrayi,j is not supported in Java. Multidimensional array representation in Java Source - Live on Ideone Creating and initializing reference type arrays String array6 new String Laurel , Hardy Create an array with new operator and array initializer. String array7": "input.pdf", "Laurel , Hardy Shortcut syntax with array GoalKicker.com Java Notes for Professionals 113 initializer. String array8 new String3 null, null, null String array9 null null Live on Ideone In addition to the String literals and primitives shown above, the shortcut syntax for array initialization also works with canonical Object types Object array10 new Object, new Object Because arrays are covariant, a reference type array can be initialized as an array of a subclass, although an ArrayStoreException will be thrown if you try to set an element to something other than a String Object array11 new String foo, bar, baz array111 qux fine array111 new StringBuilder throws ArrayStoreException The shortcut syntax cannot be used for this because the shortcut syntax would have an implicit type of Object. An array can be initialized with zero elements by using String emptyArray new String0. For example, an array with zero length like this is used for Creating an Array from a Collection when the method needs the runtime type of an object. In both primitive and reference types, an empty array initialization for example String array8 new String3 will initialize the array with the default value for each data type . Creating and": "input.pdf", "initializing generic type arrays In generic classes, arrays of generic types cannot be initialized like this due to type erasure public class MyGenericClass T private T a public MyGenericClass a new T5 Compile time error generic array creation Instead, they can be created using one of the following methods note that these will generate unchecked warnings By creating an Object array, and casting it to the generic type 1. a T new Object5 This is the simplest method, but since the underlying array is still of type Object, this method does not provide type safety. Therefore, this method of creating an array is best used only within the generic class - not exposed publicly. By using Array.newInstance with a class parameter 2. public MyGenericClass ClassT clazz a T Array.newInstance clazz, 5 GoalKicker.com Java Notes for Professionals 114 Here the class of T has to be explicitly passed to the constructor. The return type of Array.newInstance is always Object . However, this method is safer because the newly created array is always of type T, and therefore can be safely externalized. Filling an array after initialization Version Java SE 1.2 Arrays.fill can be used to \ufb01ll an array with the": "input.pdf", "same value after initialization Arrays.fillarray8, abc abc, abc, abc Live on Ideone fill can also assign a value to each element of the speci\ufb01ed range of the array Arrays.fillarray8, 1, 2, aaa Placing aaa from index 1 to 2. Live on Ideone Version Java SE 8 Since Java version 8, the method setAll , and its Concurrent equivalent parallelSetAll , can be used to set every element of an array to generated values. These methods are passed a generator function which accepts an index and returns the desired value for that position. The following example creates an integer array and sets all of its elements to their respective index value int array new int5 Arrays.setAllarray, i - i The array becomes 0, 1, 2, 3, 4 . Live on Ideone Separate declaration and initialization of arrays The value of an index for an array element must be a whole number 0, 1, 2, 3, 4, ... and less than the length of the array indexes are zero-based. Otherwise, an ArrayIndexOutOfBoundsException will be thrown int array9 Array declaration - uninitialized array9 new int3 Initialize array - 0, 0, 0 array90 10 Set index 0 value - 10, 0, 0 array91": "input.pdf", "20 Set index 1 value - 10, 20, 0 array92 30 Set index 2 value - 10, 20, 30 Arrays may not be re-initialized with array initializer shortcut syntax It is not possible to re-initialize an array via a shortcut syntax with an array initializer since an array initializer can only be speci\ufb01ed in a \ufb01eld declaration or local variable declaration, or as a part of an array creation expression. However, it is possible to create a new array and assign it to the variable being used to reference the old array. While this results in the array referenced by that variable being re-initialized, the variable contents are a completely new array. To do this, the new operator can be used with an array initializer and assigned to the array variable First initialization of array int array new int 1, 2, 3 GoalKicker.com Java Notes for Professionals 115 Prints 1 2 3 . for int i array System.out.printi Re-initializes array to a new int array. array new int 4, 5, 6 Prints 4 5 6 . for int i array System.out.printi array 1, 2, 3, 4 Compile-time error! Cant re-initialize an array via shortcut syntax with array initializer. Live": "input.pdf", "on Ideone Section 23.2 Creating a List from an Array The Arrays.asList method can be used to return a \ufb01xed-size List containing the elements of the given array. The resulting List will be of the same parameter type as the base type of the array. String stringArray foo, bar, baz ListString stringList Arrays.asListstringArray Note This list is backed by a view of the original array, meaning that any changes to the list will change the array and vice versa. However, changes to the list that would change its size and hence the array length will throw an exception. To create a copy of the list, use the constructor of java.util.ArrayList taking a Collection as an argument Version Java SE 5 String stringArray foo, bar, baz ListString stringList new ArrayList StringArrays.asListstringArray Version Java SE 7 In Java SE 7 and later, a pair of angle brackets empty set of type arguments can be used, which is called the Diamond. The compiler can determine the type arguments from the context. This means the type information can be left out when calling the constructor of ArrayList and it will be inferred automatically during compilation. This is called Type Inference which is a": "input.pdf", "part of Java Generics. Using Arrays.asList String stringArray foo, bar, baz ListString stringList new ArrayList Arrays.asListstringArray Using ArrayList.addAll String stringArray foo, bar, baz ArrayList String list new ArrayList list.addAllArrays.asListstringArray Using Collections.addAll String stringArray foo, bar, baz ArrayList String list new ArrayList Collections .addAlllist, stringArray GoalKicker.com Java Notes for Professionals 116A point worth noting about the Diamond is that it cannot be used with Anonymous Classes. Version Java SE 8 Using Streams int ints 1, 2, 3 ListInteger list Arrays.streamints.boxed.collectCollectors. toList String stringArray foo, bar, baz ListObject list Arrays.streamstringArray .collectCollectors. toList Important notes related to using Arrays.asList method This method returns List , which is an instance of ArraysArrayList static inner class of Arrays and not java.util.ArrayList . The resulting List is of \ufb01xed-size. That means, adding or removing elements is not supported and will throw an UnsupportedOperationException stringList. addsomething throws java.lang.UnsupportedOperationException A new List can be created by passing an array-backed List to the constructor of a new List . This creates a new copy of the data, which has changeable size and that is not backed by the original array ListString modifiableList new ArrayList Arrays.asListfoo, bar Calling T ListT asListT... a on a primitive array, such as an": "input.pdf", "int, will produce a Listint whose only element is the source primitive array instead of the actual elements of the source array. The reason for this behavior is that primitive types cannot be used in place of generic type parameters, so the entire primitive array replaces the generic type parameter in this case. In order to convert a primitive array to a List , \ufb01rst of all, convert the primitive array to an array of the corresponding wrapper type i.e. call Arrays.asList on an Integer instead of an int. Therefore, this will print false int arr 1, 2, 3 primitive array of int System.out.printlnArrays.asListarr.contains 1 View Demo On the other hand, this will print true Integer arr 1, 2, 3 object array of Integer wrapper for int System.out.printlnArrays.asListarr.contains 1 View Demo This will also print true , because the array will be interpreted as an Integer System.out.printlnArrays.asList1,2,3.contains 1 View Demo GoalKicker.com Java Notes for Professionals 117Section 23.3 Creating an Array from a Collection Two methods in java.util.Collection create an array from a collection Object toArray T T toArrayT a Object toArray can be used as follows Version Java SE 5 SetString set new HashSet String set.addred set.addblue although set": "input.pdf", "is a SetString, toArray returns an Object not a String Object objectArray set.toArray T T toArrayT a can be used as follows Version Java SE 5 SetString set new HashSet String set.addred set.addblue The array does not need to be created up front with the correct size. Only the array type matters. If the size is wrong, a new array will be created with the same type. String stringArray set.toArraynew String0 If you supply an array of the same size as collection or bigger, it will be populated with collection values and returned new array wont be allocated String stringArray2 set.toArraynew Stringset.size The di\ufb00erence between them is more than just having untyped vs typed results. Their performance can di\ufb00er as well for details please read this performance analysis section Object toArray uses vectorized arraycopy , which is much faster than the type-checked arraycopy used in T toArray T a. T toArray new Tnon-zero-size needs to zero-out the array at runtime, while T toArray new T0 does not. Such avoidance makes the latter call faster than the former. Detailed analysis here Arrays of Wisdom of the Ancients . Version Java SE 8 Starting from Java SE 8, where the concept": "input.pdf", "of Stream has been introduced, it is possible to use the Stream produced by the collection in order to create a new Array using the Stream.toArray method. String strings list.stream.toArrayStringnew Examples taken from two answers 1, 2 to Converting ArrayList to String in Java on Stack Over\ufb02ow. Section 23.4 Multidimensional and Jagged Arrays It is possible to de\ufb01ne an array with more than one dimension. Instead of being accessed by providing a single index, a multidimensional array is accessed by specifying an index for each dimension. GoalKicker.com Java Notes for Professionals 118The declaration of multidimensional array can be done by adding for each dimension to a regular array declaration. For instance, to make a 2-dimensional int array, add another set of brackets to the declaration, such as int. This continues for 3-dimensional arrays int and so forth. To de\ufb01ne a 2-dimensional array with three rows and three columns int rows 3 int columns 3 int table new introwscolumns The array can be indexed and assign values to it with this construct. Note that the unassigned values are the default values for the type of an array, in this case 0 for int. table00 0 table01 1 table02 2 It": "input.pdf", "is also possible to instantiate a dimension at a time, and even make non-rectangular arrays. These are more commonly referred to as jagged arrays . int nonRect new int4 It is important to note that although it is possible to de\ufb01ne any dimension of jagged array, its preceding level must be de\ufb01ned. valid String employeeGraph new String30 invalid int unshapenMatrix new int10 also invalid int misshapenGrid new int10010 How Multidimensional Arrays are represented in Java Image source httpmath.hws.edueckcs124javanotes3c8s5.html GoalKicker.com Java Notes for Professionals 119Jagged array literal intialization Multidimensional arrays and jagged arrays can also be initialized with a literal expression. The following declares and populates a 2x3 int array int table 1, 2, 3, 4, 5, 6 Note Jagged subarrays may also be null . For instance, the following code declares and populates a two dimensional int array whose \ufb01rst subarray is null , second subarray is of zero length, third subarray is of one length and the last subarray is a two length array int table null, , 1, 1,2 For multidimensional array it is possible to extract arrays of lower-level dimension by their indices int arr new int333 int arr1 arr0 get first 3x3-dimensional array from arr": "input.pdf", "int arr2 arr10 get first 3-dimensional array from arr1 int arr3 arr0 error cannot convert from int to int Section 23.5 ArrayIndexOutOfBoundsException The ArrayIndexOutOfBoundsException is thrown when a non-existing index of an array is being accessed. Arrays are zero-based indexed, so the index of the \ufb01rst element is 0 and the index of the last element is the array capacity minus 1 i.e. array.length - 1. Therefore, any request for an array element by the index i has to satisfy the condition 0 i array.length , otherwise the ArrayIndexOutOfBoundsException will be thrown. The following code is a simple example where an ArrayIndexOutOfBoundsException is thrown. String people new String Carol, Andy An array will be created people0 Carol people1 Andy Notice no item on index 2. Trying to access it triggers the exception System.out.printlnpeople2 throws an ArrayIndexOutOfBoundsException. Output Exception in thread main java.lang.ArrayIndexOutOfBoundsException 2 at your.package.path.methodYourClass.java15 Note that the illegal index that is being accessed is also included in the exception 2 in the example this information could GoalKicker.com Java Notes for Professionals 120be useful to \ufb01nd the cause of the exception. To avoid this, simply check that the index is within the limits of the array int index 2": "input.pdf", "if index 0 index people. length System.out.printlnpeopleindex Section 23.6 Array Covariance Object arrays are covariant, which means that just as Integer is a subclass of Number , Integer is a subclass of Number. This may seem intuitive, but can result in surprising behavior Integer integerArray 1, 2, 3 Number numberArray integerArray valid Number firstElement numberArray 0 valid numberArray 0 4L throws ArrayStoreException at runtime Although Integer is a subclass of Number, it can only hold Integer s, and trying to assign a Long element throws a runtime exception. Note that this behavior is unique to arrays, and can be avoided by using a generic List instead ListInteger integerList Arrays.asList1, 2, 3 ListNumber numberList integerList compile error List? extends Number numberList integerList Number firstElement numberList. get0 numberList.set0, 4L compile error Its not necessary for all of the array elements to share the same type, as long as they are a subclass of the arrays type interface I class A implements I class B implements I class C implements I I array10 new I new A, new B, new C Create an array with new operator and array initializer. I array11 new A, new B, new C Shortcut syntax with array": "input.pdf", "initializer. I array12 new I3 null, null, null I array13 new A new A, new A Works because A implements I. Object array14 new Object Hello, World! , 3.14159, 42 Create an array with new operator and array initializer. Object array15 new A, 64, My String Shortcut syntax with array initializer. GoalKicker.com Java Notes for Professionals 121Section 23.7 Arrays to Stream Version Java SE 8 Converting an array of objects to Stream String arr new String str1, str2, str3 StreamString stream Arrays.streamarr Converting an array of primitives to Stream using Arrays.stream will transform the array to a primitive specialization of Stream int intArr 1, 2, 3 IntStream intStream Arrays.streamintArr You can also limit the Stream to a range of elements in the array. The start index is inclusive and the end index is exclusive int values 1, 2, 3, 4 IntStream intStream Arrays.streamvalues, 2, 4 A method similar to Arrays.stream appears in the Stream class Stream.of. The di\ufb00erence is that Stream.of uses a varargs parameter, so you can write something like StreamInteger intStream Stream. of1, 2, 3 StreamString stringStream Stream. of1, 2, 3 StreamDouble doubleStream Stream. ofnew Double1.0, 2.0 Section 23.8 Iterating over arrays You can iterate over arrays": "input.pdf", "either by using enhanced for loop aka foreach or by using array indices int array new int10 using indices read and write for int i 0 i array.length i array i i Version Java SE 5 extended for read only for int e array System.out.printlne It is worth noting here that there is no direct way to use an Iterator on an Array, but through the Arrays library it can be easily converted to a list to obtain an Iterable object. For boxed arrays use Arrays.asList Integer boxed 1, 2, 3 Iterable Integer boxedIt Arrays.asListboxed list-backed iterable Iterator Integer fromBoxed1 boxedIt. iterator For primitive arrays using java 8 use streams speci\ufb01cally in this example - Arrays.stream - IntStream int primitives 1, 2, 3 GoalKicker.com Java Notes for Professionals 122IntStream primitiveStream Arrays.streamprimitives list-backed iterable PrimitiveIterator. OfInt fromPrimitive1 primitiveStream. iterator If you cant use streams no java 8, you can choose to use googles guava library Iterable Integer fromPrimitive2 Ints.asListprimitives In two-dimensional arrays or more, both techniques can be used in a slightly more complex fashion. Example int array new int1010 for int indexOuter 0 indexOuter array.length indexOuter for int indexInner 0 indexInner arrayindexOuter .length indexInner array indexOuter indexInner indexOuter indexInner": "input.pdf", "Version Java SE 5 for int numbers array for int value numbers System.out.printlnvalue It is impossible to set an Array to any non-uniform value without using an index based loop. Of course you can also use while or do-while loops when iterating using indices. One note of caution when using array indices, make sure the index is between 0 and array.length - 1 both inclusive. Dont make hard coded assumptions on the array length otherwise you might break your code if the array length changes but your hard coded values dont. Example int numbers 1, 2, 3, 4 public void incrementNumbers DO THIS for int i 0 i numbers. length i numbers i 1 or this numbersi numbersi 1 or numbersi DONT DO THIS for int i 0 i 4 i numbers i 1 Its also best if you dont use fancy calculations to get the index but use the index to iterate and if you need di\ufb00erent values calculate those. Example public void fillArrayWithDoubleIndex int array DO THIS for int i 0 i array.length i array i i 2 GoalKicker.com Java Notes for Professionals 123 DONT DO THIS int doubleLength array.length 2 for int i 0 i doubleLength": "input.pdf", "i 2 array i 2 i Accessing Arrays in reverse order int array 0, 1, 1, 2, 3, 5, 8, 13 for int i array.length - 1 i 0 i-- System.out.printlnarrayi Using temporary Arrays to reduce code repetition Iterating over a temporary array instead of repeating code can make your code cleaner. It can be used where the same operation is performed on multiple variables. we want to print out all of these String name Margaret int eyeCount 16 double height 50.2 int legs 9 int arms 5 copy-paste approach System.out.printlnname System.out.printlneyeCount System.out.printlnheight System.out.printlnlegs System.out.printlnarms temporary array approach forObject attribute new Objectname, eyeCount, height, legs, arms System.out.printlnattribute using only numbers fordouble number new doubleeyeCount, legs, arms, height System.out.printlnMath.sqrtnumber Keep in mind that this code should not be used in performance-critical sections, as an array is created every time the loop is entered, and that primitive variables will be copied into the array and thus cannot be modi\ufb01ed. Section 23.9 Arrays to a String Version Java SE 5 Since Java 1.5 you can get a String representation of the contents of the speci\ufb01ed array without iterating over its every element. Just use Arrays.toString Object or Arrays.deepToString Object for multidimentional arrays": "input.pdf", "int arr 1, 2, 3, 4, 5 System.out.printlnArrays.toString arr 1, 2, 3, 4, 5 GoalKicker.com Java Notes for Professionals 124int arr 1, 2, 3, 4, 5, 6, 7, 8, 9 System.out.printlnArrays.deepToString arr 1, 2, 3, 4, 5, 6, 7, 8, 9 Arrays.toString method uses Object.toString method to produce String values of every item in the array, beside primitive type array, it can be used for all type of arrays. For instance public class Cat implicitly extends Object Override public String toString return CAT! Cat arr new Cat, new Cat System.out.printlnArrays.toString arr CAT!, CAT! If no overridden toString exists for the class, then the inherited toString from Object will be used. Usually the output is then not very useful, for example public class Dog implicitly extends Object Dog arr new Dog System.out.printlnArrays.toString arr Dog17ed40e0 Section 23.10 Sorting arrays Sorting arrays can be easily done with the Arrays api. import java.util.Arrays creating an array with integers int array 7, 4, 2, 1, 19 this is the sorting part just one function ready to be used Arrays.sortarray prints 1, 2, 4, 7, 19 System.out.printlnArrays.toString array Sorting String arrays String is not a numeric data, it de\ufb01nes its own order which is called": "input.pdf", "lexicographic order, also known as alphabetic order. When you sort an array of String using sort method, it sorts array into natural order de\ufb01ned by Comparable interface, as shown below Increasing Order String names John, Steve, Shane, Adam, Ben System.out.printlnString array before sorting Arrays.toString names Arrays.sortnames System.out.printlnString array after sorting in ascending order Arrays.toString names Output GoalKicker.com Java Notes for Professionals 125String array before sorting John, Steve, Shane, Adam, Ben String array after sorting in ascending order Adam, Ben, John, Shane, Steve Decreasing Order Arrays.sortnames, 0, names. length, Collections .reverseOrder System.out.printlnString array after sorting in descending order Arrays.toString names Output String array after sorting in descending order Steve, Shane, John, Ben, Adam Sorting an Object array In order to sort an object array, all elements must implement either Comparable or Comparator interface to de\ufb01ne the order of the sorting. We can use either sortObject method to sort an object array on its natural order, but you must ensure that all elements in the array must implement Comparable . Furthermore, they must be mutually comparable as well, for example e1.compareTo e2 must not throw a ClassCastException for any elements e1 and e2 in the array. Alternatively you can sort an": "input.pdf", "Object array on custom order using sortT, Comparator method as shown in following example. How to Sort Object Array in Java using Comparator and Comparable Course courses new Course4 courses0 new Course101, Java, 200 courses1 new Course201, Ruby, 300 courses2 new Course301, Python , 400 courses3 new Course401, Scala, 500 System.out.printlnObject array before sorting Arrays.toString courses Arrays.sortcourses System.out.printlnObject array after sorting in natural order Arrays.toString courses Arrays.sortcourses, new Course. PriceComparator System.out.printlnObject array after sorting by price Arrays.toString courses Arrays.sortcourses, new Course. NameComparator System.out.printlnObject array after sorting by name Arrays.toString courses Output Object array before sorting 101 Java200 , 201 Ruby300 , 301 Python400 , 401 Scala500 Object array after sorting in natural order 101 Java200 , 201 Ruby300 , 301 Python400 , 401 Scala500 Object array after sorting by price 101 Java200 , 201 Ruby300 , 301 Python400 , 401 Scala500 Object array after sorting by name 101 Java200 , 301 Python400 , 201 Ruby300 , 401 Scala500 GoalKicker.com Java Notes for Professionals 126Section 23.11 Getting the Length of an Array Arrays are objects which provide space to store up to its size of elements of speci\ufb01ed type. An arrays size can not be modi\ufb01ed after the array is": "input.pdf", "created. int arr1 new int0 int arr2 new int2 int arr3 new int1, 2, 3, 4 int arr4 1, 2, 3, 4, 5, 6, 7 int len1 arr1.length 0 int len2 arr2.length 2 int len3 arr3.length 4 int len4 arr4.length 7 The length \ufb01eld in an array stores the size of an array. It is a final \ufb01eld and cannot be modi\ufb01ed. This code shows the di\ufb00erence between the length of an array and amount of objects an array stores. public static void mainString args Integer arr new Integer 1,2,3,null,5,null,7,null,null,null,11,null,13 int arrayLength arr.length int nonEmptyElementsCount 0 for int i0 iarrayLength i Integer arrElt arri if arrElt ! null nonEmptyElementsCount System.out.printlnArray arr has a length of arrayLength n and it contains nonEmptyElementsCount non-empty values Result Array arr has a length of 13 and it contains 7 non-empty values Section 23.12 Finding an element in an array There are many ways \ufb01nd the location of a value in an array. The following example snippets all assume that the array is one of the following String strings new String A, B, C int ints new int 1, 2, 3, 4 In addition, each one sets index or index2 to either the index": "input.pdf", "of required element, or -1 if the element is not present. Using Arrays.binarySearch for sorted arrays only int index Arrays.binarySearch strings, A int index2 Arrays.binarySearch ints, 1 GoalKicker.com Java Notes for Professionals 127Using a Arrays.asList for non-primitive arrays only int index Arrays.asListstrings.indexOfA int index2 Arrays.asListints.indexOf1 compilation error Using a Stream Version Java SE 8 int index IntStream. range0, strings. length . filteri - A.equalsstringsi . findFirst . orElse-1 If not present, gives us -1. Similar for an array of primitives Linear search using a loop int index -1 for int i 0 i array.length i if A.equalsarrayi index i break Similar for an array of primitives Linear search using 3rd-party libraries such as org.apache.commons int index org.apache.commons.lang3.ArrayUtils .contains strings, A int index2 org.apache.commons.lang3.ArrayUtils .contains ints, 1 Note Using a direct linear search is more e\ufb03cient than wrapping in a list. Testing if an array contains an element The examples above can be adapted to test if the array contains an element by simply testing to see if the index computed is greater or equal to zero. Alternatively, there are also some more concise variations boolean isPresent Arrays.asListstrings.contains A Version Java SE 8 boolean isPresent StreamString.ofstrings.anyMatch x - A.equalsx boolean": "input.pdf", "isPresent false for String s strings if A.equalss isPresent true break boolean isPresent org.apache.commons.lang3.ArrayUtils .contains ints, 4 Section 23.13 How do you change the size of an array? The simple answer is that you cannot do this. Once an array has been created, its size cannot be changed. Instead, an array can only be resized by creating a new array with the appropriate size and copying the elements from the existing array to the new one. String listOfCities new String3 array created with size 3. listOfCities 0 New York GoalKicker.com Java Notes for Professionals 128listOfCities 1 London listOfCities 2 Berlin Suppose for example that a new element needs to be added to the listOfCities array de\ufb01ned as above. To do this, you will need to create a new array with size 4,1. copy the existing 3 elements of the old array to the new array at o\ufb00sets 0, 1 and 2, and2. add the new element to the new array at o\ufb00set 3.3. There are various ways to do the above. Prior to Java 6, the most concise way was String newArray new StringlistOfCities. length 1 System.arraycopy listOfCities, 0, newArray, 0, listOfCities. length newArray listOfCities. length Sydney From Java": "input.pdf", "6 onwards, the Arrays.copyOf and Arrays.copyOfRange methods can do this more simply String newArray Arrays.copyOflistOfCities, listOfCities. length 1 newArray listOfCities. length Sydney For other ways to copy an array, refer to the following example. Bear in mind that you need an array copy with a di\ufb00erent length to the original when resizing. Copying arrays A better alternatives to array resizing There two major drawbacks with resizing an array as described above It is ine\ufb03cient. Making an array bigger or smaller involves copying many or all of the existing array elements, and allocating a new array object. The larger the array, the more expensive it gets. You need to be able to update any live variables that contain references to the old array. One alternative is to create the array with a large enough size to start with. This is only viable if you can determine that size accurately before allocating the array . If you cannot do that, then the problem of resizing the array arises again. The other alternative is to use a data structure class provided by the Java SE class library or a third-party library. For example, the Java SE collections framework provides a number of": "input.pdf", "implementations of the List , Set and Map APIs with di\ufb00erent runtime properties. The ArrayList class is closest to performance characteristics of a plain array e.g. ON lookup, O1 get and set, ON random insertion and deletion while providing more e\ufb03cient resizing without the reference update problem. The resize e\ufb03ciency for ArrayList comes from its strategy of doubling the size of the backing array on each resize. For a typical use-case, this means that you only resize occasionally. When you amortize over the lifetime of the list, the resize cost per insert is O1. It may be possible to use the same strategy when resizing a plain array. Section 23.14 Converting arrays between primitives and boxed types Sometimes conversion of primitive types to boxed types is necessary. To convert the array, its possible to use streams in Java 8 and above GoalKicker.com Java Notes for Professionals 129Version Java SE 8 int primitiveArray 1, 2, 3, 4 Integer boxedArray Arrays.streamprimitiveArray .boxed.toArrayIntegernew With lower versions it can be by iterating the primitive array and explicitly copying it to the boxed array Version Java SE 8 int primitiveArray 1, 2, 3, 4 Integer boxedArray new IntegerprimitiveArray. length for int i 0 i": "input.pdf", "primitiveArray. length i boxedArray i primitiveArray i Each element is autoboxed here Similarly, a boxed array can be converted to an array of its primitive counterpart Version Java SE 8 Integer boxedArray 1, 2, 3, 4 int primitiveArray Arrays.streamboxedArray .mapToInt IntegerintValue .toArray Version Java SE 8 Integer boxedArray 1, 2, 3, 4 int primitiveArray new intboxedArray. length for int i 0 i boxedArray. length i primitiveArray i boxedArray i Each element is outboxed here Section 23.15 Remove an element from an array Java doesnt provide a direct method in java.util.Arrays to remove an element from an array. To perform it, you can either copy the original array to a new one without the element to remove or convert your array to another structure allowing the removal. Using ArrayList You can convert the array to a java.util.List , remove the element and convert the list back to an array as follows String array new Stringfoo, bar, baz ListString list new ArrayList Arrays.asListarray list.removefoo Creates a new array with the same size as the list and copies the list elements to it. array list.toArraynew Stringlist.size System.out.printlnArrays.toString array bar, baz Using System.arraycopy System.arraycopy can be used to make a copy of the": "input.pdf", "original array and remove the element you want. Below an example int array new int 1, 2, 3, 4 Original array. int result new intarray.length - 1 Array which will contain the result. int index 1 Remove the value 2. GoalKicker.com Java Notes for Professionals 130 Copy the elements at the left of the index. System.arraycopy array, 0, result, 0, index Copy the elements at the right of the index. System.arraycopy array, index 1, result, index, array. length - index - 1 System.out.printlnArrays.toString result 1, 3, 4 Using Apache Commons Lang To easily remove an element, you can use the Apache Commons Lang library and especially the static method removeElement of the class ArrayUtils . Below an example int array new int1,2,3,4 array ArrayUtils. removeElement array, 2 remove first occurrence of 2 System.out.printlnArrays.toString array 1, 3, 4 Section 23.16 Comparing arrays for equality Array types inherit their equals and hashCode implementations from java.lang.Object, so equals will only return true when comparing against the exact same array object. To compare arrays for equality based on their values, use java.util.Arrays.equals , which is overloaded for all array types. int a new int1, 2, 3 int b new int1, 2, 3 System.out.printlna.equalsb": "input.pdf", "prints false because a and b refer to different objects System.out.printlnArrays.equalsa, b prints true because the elements of a and b have the same values When the element type is a reference type, Arrays.equals calls equals on the array elements to determine equality. In particular, if the element type is itself an array type, identity comparison will be used. To compare multidimensional arrays for equality, use Arrays.deepEquals instead as below int a 1, 2, 3 int b 1, 2, 3 Object aObject a aObject contains one element Object bObject b bObject contains one element System.out.printlnArrays.equalsaObject, bObject false System.out.printlnArrays.deepEquals aObject, bObject true Because sets and maps use equals and hashCode , arrays are generally not useful as set elements or map keys. Either wrap them in a helper class that implements equals and hashCode in terms of the array elements, or convert them to List instances and store the lists. Section 23.17 Copying arrays Java provides several ways to copy an array. for loop int a 4, 1, 3, 2 int b new inta.length for int i 0 i a.length i bi ai GoalKicker.com Java Notes for Professionals 131Note that using this option with an Object array instead of primitive": "input.pdf", "array will \ufb01ll the copy with reference to the original content instead of copy of it. Object.clone Since arrays are Object s in Java, you can use Object.clone. int a 4, 1, 3, 2 int b a.clone 4, 1, 3, 2 Note that the Object.clone method for an array performs a shallow copy , i.e. it returns a reference to a new array which references the same elements as the source array. Arrays.copyOf java.util.Arrays provides an easy way to perform the copy of an array to another. Here is the basic usage int a 4, 1, 3, 2 int b Arrays.copyOfa, a.length 4, 1, 3, 2 Note that Arrays.copyOf also provides an overload which allows you to change the type of the array Double doubles 1.0, 2.0, 3.0 Number numbers Arrays.copyOfdoubles, doubles. length, Number.class System.arraycopy public static void arraycopy Object src, int srcPos, Object dest, int destPos, int length Copies an array from the speci\ufb01ed source array, beginning at the speci\ufb01ed position, to the speci\ufb01ed position of the destination array. Below an example of use int a 4, 1, 3, 2 int b new inta.length System.arraycopy a, 0, b, 0, a.length 4, 1, 3, 2 Arrays.copyOfRange Mainly used to": "input.pdf", "copy a part of an Array, you can also use it to copy whole array to another as below int a 4, 1, 3, 2 int b Arrays.copyOfRange a, 0, a.length 4, 1, 3, 2 Section 23.18 Casting Arrays Arrays are objects, but their type is de\ufb01ned by the type of the contained objects. Therefore, one cannot just cast A to T, but each A member of the speci\ufb01c A must be cast to a T object. Generic example public static T, A T castArray T target, A array for int i 0 i array.length i target i T arrayi GoalKicker.com Java Notes for Professionals 132 return target Thus, given an A array T target new Tarray.Length target castArray target, array Java SE provides the method Arrays.copyOforiginal, newLength, newType for this purpose Double doubles 1.0, 2.0, 3.0 Number numbers Arrays.copyOfdoubles, doubles. length, Number.class GoalKicker.com Java Notes for Professionals 133Chapter 24 Collections The collections framework in java.util provides a number of generic classes for sets of data with functionality that cant be provided by regular arrays. Collections framework contains interfaces for Collection O, with main sub-interfaces ListO and SetO, and mapping collection MapK,V. Collections are the root interface and are": "input.pdf", "being implemented by many other collection frameworks. Section 24.1 Removing items from a List within a loop It is tricky to remove items from a list while within a loop, this is due to the fact that the index and length of the list gets changed. Given the following list, here are some examples that will give an unexpected result and some that will give the correct result. ListString fruits new ArrayList String fruits.addApple fruits.addBanana fruits.addStrawberry INCORRECT Removing in iteration of for statement Skips Banana The code sample will only print Apple and Strawberry . Banana is skipped because it moves to index 0 once Apple is deleted, but at the same time i gets incremented to 1. for int i 0 i fruits. size i System.out.println fruits.geti if Apple.equalsfruits.geti fruits. removei Removing in the enhanced for statement Throws Exception Because of iterating over collection and modifying it at the same time. Throws java.util.ConcurrentModi\ufb01cationException for String fruit fruits System.out.printlnfruit if Apple.equalsfruit fruits. removefruit CORRECT Removing in while loop using an Iterator Iterator String fruitIterator fruits. iterator whilefruitIterator. hasNext String fruit fruitIterator. next System.out.printlnfruit if Apple.equalsfruit GoalKicker.com Java Notes for Professionals 134 fruitIterator. remove The Iterator interface has a remove": "input.pdf", "method built in just for this case. However, this method is marked as optional in the documentation, and it might throw an UnsupportedOperationException . Throws UnsupportedOperationException - if the remove operation is not supported by this iterator Therefore, it is advisable to check the documentation to make sure this operation is supported in practice, unless the collection is an immutable one obtained through a 3rd party library or the use of one of the Collections .unmodifiable ... method, the operation is almost always supported. While using an Iterator a ConcurrentModificationException is thrown when the modCount of the List is changed from when the Iterator was created. This could have happened in the same thread or in a multi-threaded application sharing the same list. A modCount is an int variable which counts the number of times this list has been structurally modi\ufb01ed. A structural change essentially means an add or remove operation being invoked on Collection object changes made by Iterator are not counted. When the Iterator is created, it stores this modCount and on every iteration of the List checks if the current modCount is same as and when the Iterator was created. If there is a change in": "input.pdf", "the modCount value it throws a ConcurrentModificationException . Hence for the above-declared list, an operation like below will not throw any exception Iterator String fruitIterator fruits. iterator fruits.set0, Watermelon whilefruitIterator. hasNext System.out.printlnfruitIterator. next But adding a new element to the List after initializing an Iterator will throw a ConcurrentModificationException Iterator String fruitIterator fruits. iterator fruits.addWatermelon whilefruitIterator. hasNext System.out.printlnfruitIterator. next ConcurrentModificationException here Iterating backwards for int i fruits.size - 1 i 0 i-- System.out.println fruits.geti if Apple.equalsfruits.geti fruits. removei This does not skip anything. The downside of this approach is that the output is reverse. However, in most cases where you remove items that will not matter. You should never do this with LinkedList . Iterating forward, adjusting the loop index for int i 0 i fruits. size i System.out.println fruits.geti GoalKicker.com Java Notes for Professionals 135 if Apple.equalsfruits.geti fruits. removei i -- This does not skip anything. When the ith element is removed from the List , the element originally positioned at index i1 becomes the new ith element. Therefore, the loop can decrement i in order for the next iteration to process the next element, without skipping. Using a should-be-removed list ArrayList shouldBeRemoved new ArrayList for String str": "input.pdf", "currentArrayList if condition shouldBeRemoved. addstr currentArrayList. removeAll shouldBeRemoved This solution enables the developer to check if the correct elements are removed in a cleaner way. Version Java SE 8 In Java 8 the following alternatives are possible. These are cleaner and more straight forward if the removing does not have to happen in a loop. Filtering a Stream A List can be streamed and \ufb01ltered. A proper \ufb01lter can be used to remove all undesired elements. ListString filteredList fruits. stream.filterp - !Apple.equalsp.collectCollectors. toList Note that unlike all the other examples here, this example produces a new List instance and keeps the original List unchanged. Using removeIf Saves the overhead of constructing a stream if all that is needed is to remove a set of items. fruits.removeIf p - Apple.equalsp Section 24.2 Constructing collections from existing data Standard Collections Java Collections framework A simple way to construct a List from individual data values is to use java.utils.Arrays method Arrays.asList ListString data Arrays.asListab, bc, cd, ab, bc, cd All standard collection implementations provide constructors that take another collection as an argument adding all elements to the new collection at the time of construction ListString list new ArrayList data will add data": "input.pdf", "as is SetString set1 new HashSet data will add data keeping only unique values GoalKicker.com Java Notes for Professionals 136SortedSet String set2 new TreeSet data will add data keeping unique values and sorting SetString set3 new LinkedHashSet data will add data keeping only unique values and preserving the original order Google Guava Collections framework Another great framework is Google Guava that is amazing utility class providing convenience static methods for construction of di\ufb00erent types of standard collections Lists and Sets import com.google.common.collect.Lists import com.google.common.collect.Sets ... ListString list1 Lists.newArrayList ab, bc, cd ListString list2 Lists.newArrayList data SetString set4 Sets.newHashSet data SortedSet String set5 Sets.newTreeSet bc, cd, ab, bc, cd Mapping Collections Java Collections framework Similarly for maps, given a MapString, Object map a new map can be constructed with all elements as follows MapString, Object map1 new HashMap map SortedMap String, Object map2 new TreeMap map Apache Commons Collections framework Using Apache Commons you can create Map using array in ArrayUtils. toMap as well as MapUtils. toMap import org.apache.commons.lang3.ArrayUtils ... Taken from org.apache.commons.lang.ArrayUtilstoMap JavaDoc Create a Map mapping colors. Map colorMap MapUtils. toMapnew String RED, FF0000 , GREEN, 00FF00 , BLUE, 0000FF Each element of the array must be either": "input.pdf", "a Map.Entry or an Array, containing at least two elements, where the \ufb01rst element is used as key and the second as value. Google Guava Collections framework Utility class from Google Guava framework is named Maps import com.google.common.collect.Maps ... void howToCreateMapsMethod Function ? super K,V valueFunction, Iterable K keys1, Set K keys2, SortedSet K keys3 ImmutableMap K, V map1 toMapkeys1, valueFunction Immutable copy Map K, V map2 asMapkeys2, valueFunction Live Map view SortedMap K, V map3 toMapkeys3, valueFunction Live Map view Version Java SE 8 GoalKicker.com Java Notes for Professionals 137Using Stream , Stream.ofxyz, abc.collectCollectors. toList or Arrays.streamxyz, abc.collectCollectors. toList Section 24.3 Declaring an ArrayList and adding objects We can create an ArrayList following the List interface List aListOfFruits new ArrayList Version Java SE 5 ListString aListOfFruits new ArrayList String Version Java SE 7 ListString aListOfFruits new ArrayList Now, use the method add to add a String aListOfFruits. addMelon aListOfFruits. addStrawberry In the above example, the ArrayList will contain the String Melon at index 0 and the String Strawberry at index 1. Also we can add multiple elements with addAllCollection ? extends E c method ListString aListOfFruitsAndVeggies new ArrayList String aListOfFruitsAndVeggies. addOnion aListOfFruitsAndVeggies. addAllaListOfFruits Now Onion is placed at": "input.pdf", "0 index in aListOfFruitsAndVeggies , Melon is at index 1 and Strawberry is at index 2. Section 24.4 Iterating over Collections Iterating over List ListString names new ArrayList Arrays.asListClementine , Duran, Mike Version Java SE 8 names.forEachSystem.outprintln If we need parallelism use names.parallelStream .forEachSystem.outprintln Version Java SE 5 for String name names System.out.printlnname Version Java SE 5 for int i 0 i names.size i System.out.printlnnames.geti Version Java SE 1.2 GoalKicker.com Java Notes for Professionals 138Creates ListIterator which supports both forward as well as backward traversel ListIterator String listIterator names.listIterator Iterates list in forward direction whilelistIterator. hasNext System.out.printlnlistIterator. next Iterates list in backward direction once reaches the last element from above iterator in forward direction whilelistIterator. hasPrevious System.out.printlnlistIterator. previous Iterating over Set SetString names new HashSet Arrays.asListClementine , Duran, Mike Version Java SE 8 names.forEachSystem.outprintln Version Java SE 5 for Iterator String iterator names.iterator iterator. hasNext System.out.printlniterator. next for String name names System.out.printlnname Version Java SE 5 Iterator iterator names.iterator while iterator. hasNext System.out.printlniterator. next Iterating over Map MapInteger, String names new HashMap names.put1, Clementine names.put2, Duran names.put3, Mike Version Java SE 8 names.forEachkey, value - System.out.printlnKey key Value value Version Java SE 5 for Map.EntryInteger, String entry names.entrySet System.out.printlnentry.getKey": "input.pdf", "System.out.printlnentry.getValue Iterating over only keys for Integer key names.keySet System.out.printlnkey Iterating over only values for String value names.values System.out.printlnvalue Version Java SE 5 Iterator entries names.entrySet .iterator while entries. hasNext Map.Entry entry Map.Entry entries. next System.out.printlnentry.getKey System.out.printlnentry.getValue GoalKicker.com Java Notes for Professionals 139 Section 24.5 Immutable Empty Collections Sometimes it is appropriate to use an immutable empty collection. The Collections class provides methods to get such collections in an e\ufb03cient way ListString anEmptyList Collections .emptyList MapInteger, Date anEmptyMap Collections .emptyMap SetNumber anEmptySet Collections .emptySet These methods are generic and will automatically convert the returned collection to the type it is assigned to. That is, an invocation of e.g. emptyList can be assigned to any type of List and likewise for emptySet and emptyMap . The collections returned by these methods are immutable in that they will throw UnsupportedOperationException if you attempt to call methods which would change their contents add, put, etc.. These collections are primarily useful as substitutes for empty method results or other default values, instead of using null or creating objects with new. Section 24.6 Sub Collections List subListint fromIndex, int toIndex Here fromIndex is inclusive and toIndex is exclusive. List list new ArrayList List list1": "input.pdf", "list.subListfromIndex,toIndex If the list doesnt exist in the give range, it throws IndexOutofBoundException.1. What ever changes made on the list1 will impact the same changes in the list.This is called backed collections.2. If the fromnIndex is greater than the toIndex fromIndex toIndex it throws IllegalArgumentException.3. Example ListString list new ArrayList String ListString list new ArrayList String list.addHello1 list.addHello2 System.out.printlnBefore Sublist list ListString list2 list.subList0, 1 list2.addHello3 System.out.printlnAfter sublist changes list Output Before Sublist Hello1, Hello2 After sublist changes Hello1, Hello3, Hello2 Set subSetfromIndex,toIndex Here fromIndex is inclusive and toIndex is exclusive. Set set new TreeSet GoalKicker.com Java Notes for Professionals 140Set set1 set.subSetfromIndex,toIndex The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Map subMapfromKey,toKey fromKey is inclusive and toKey is exclusive Map map new TreeMap Map map1 map.getfromKey,toKey If fromKey is greater than toKey or if this map itself has a restricted range, and fromKey or toKey lies outside the bounds of the range then it throws IllegalArgumentException. All the collections support backed collections means changes made on the sub collection will have same change on the main collection. Section 24.7 Unmodi\ufb01able Collection Sometimes its not a good practice expose an": "input.pdf", "internal collection since it can lead to a malicious code vulnerability due to its mutable characteristic. In order to provide read-only collections java provides its unmodi\ufb01able versions. An unmodi\ufb01able collection is often a copy of a modi\ufb01able collection which guarantees that the collection itself cannot be altered. Attempts to modify it will result in an UnsupportedOperationException exception. It is important to notice that objects which are present inside the collection can still be altered. import java.util.ArrayList import java.util.Collections import java.util.List public class MyPojoClass private ListInteger intList new ArrayList public void addValueToIntList Integer value intList. addvalue public ListInteger getIntList return Collections .unmodifiableList intList The following attempt to modify an unmodi\ufb01able collection will throw an exception import java.util.List public class App public static void mainString args MyPojoClass pojo new MyPojoClass pojo. addValueToIntList 42 List Integer list pojo.getIntList list. add69 GoalKicker.com Java Notes for Professionals 141output Exception in thread main java.lang.UnsupportedOperationException at java.util.CollectionsUnmodifiableCollection.addCollections.java1055 at App.mainApp.java12 Section 24.8 Pitfall concurrent modi\ufb01cation exceptions This exception occurs when a collection is modi\ufb01ed while iterating over it using methods other than those provided by the iterator object. For example, we have a list of hats and we want to remove all those that have ear \ufb02aps": "input.pdf", "ListIHat hats new ArrayList hats.addnew Ushanka that one has ear flaps hats.addnew Fedora hats.addnew Sombrero for IHat hat hats if hat.hasEarFlaps hats. removehat If we run this code, ConcurrentModi\ufb01cationException will be raised since the code modi\ufb01es the collection while iterating it. The same exception may occur if one of the multiple threads working with the same list is trying to modify the collection while others iterate over it. Concurrent modi\ufb01cation of collections in multiple threads is a natural thing, but should be treated with usual tools from the concurrent programming toolbox such as synchronization locks, special collections adopted for concurrent modi\ufb01cation, modifying the cloned collection from initial etc. Section 24.9 Removing matching items from Lists using Iterator Above I noticed an example to remove items from a List within a Loop and I thought of another example that may come in handy this time using the Iterator interface. This is a demonstration of a trick that might come in handy when dealing with duplicate items in lists that you want to get rid of. Note This is only adding on to the Removing items from a List within a loop example So lets de\ufb01ne our lists as usual String": "input.pdf", "names James,Smith,Sonny,Huckle ,Berry,Finn,Allan List String nameList new ArrayList Create a List from an Array nameList. addAllArrays.asListnames String removeNames Sonny,Huckle ,Berry List String removeNameList new ArrayList Create a List from an Array removeNameList. addAllArrays.asListremoveNames The following method takes in two Collection objects and performs the magic of removing the elements in our removeNameList that match with elements in nameList . GoalKicker.com Java Notes for Professionals 142private static void removeNames Collection String collection1, Collection String collection2 get Iterator. Iterator String iterator collection1. iterator Loop while collection has items whileiterator. hasNext if collection2. contains iterator. next iterator. remove remove the current Name or Item Calling the method and passing in the nameList and the removeNameList as follows removeNames nameList,removeNameList Will produce the following output Array List before removing names James Smith Sonny Huckle Berry Finn Allan Array List after removing names James Smith Finn Allan A simple neat use for Collections that may come in handy to remove repeating elements within lists. Section 24.10 Join lists Following ways can be used for joining lists without modifying source lists. First approach. Has more lines but easy to understand ListString newList new ArrayList String newList. addAlllistOne newList. addAlllistTwo Second approach. Has one less line": "input.pdf", "but less readable. ListString newList new ArrayList StringlistOne newList. addAlllistTwo Third approach. Requires third party Apache commons-collections library. ListUtils. unionlistOne,listTwo Version Java SE 8 Using Streams the same can be achieved by ListString newList Stream. concatlistOne. stream, listTwo. stream.collectCollectors. toList References. Interface List Section 24.11 Creating your own Iterable structure for use with Iterator or for-each loop To ensure that our collection can be iterated using iterator or for-each loop, we have to take care of following steps The stu\ufb00 we want to iterate upon has to be Iterable and expose iterator . 1. Design a java.util.Iterator by overriding hasNext, next and remove. 2. GoalKicker.com Java Notes for Professionals 143I have added a simple generic linked list implementation below that uses above entities to make the linked list iterable. package org.algorithms.linkedlist import java.util.Iterator import java.util.NoSuchElementException public class LinkedList T implements Iterable T NodeT head, current private static class NodeT T data NodeT next NodeT data this.data data public LinkedList T data head new Nodedata public Iterator T iterator return new LinkedListIterator private class LinkedListIterator implements Iterator T NodeT node head Override public boolean hasNext return node ! null Override public T next if !hasNext throw new NoSuchElementException NodeT prevNode": "input.pdf", "node node node.next return prevNode. data Override public void remove throw new UnsupportedOperationException Removal logic not implemented. public void addT data Node current head GoalKicker.com Java Notes for Professionals 144 while current. next ! null current current. next current. next new Nodedata class App public static void mainString args LinkedList Integer list new LinkedList 1 list.add2 list.add4 list.add3 Test 1 System.out.printlnusing Iterator Iterator Integer itr list.iterator while itr.hasNext Integer i itr.next System.out.printi Test 2 System.out.printlnnnusing for-each for Integer data list System.out.printdata Output using Iterator 1 2 4 3 using for-each 1 2 4 3 This will run in Java 7. You can make it run on Java 5 and Java 6 also by substituting LinkedList Integer list new LinkedList 1 with LinkedList Integer list new LinkedList Integer1 or just any other version by incorporating the compatible changes. Section 24.12 Collections and Primitive Values Collections in Java only work for objects. I.e. there is no Mapint, int in Java. Instead, primitive values need to be boxed into objects, as in MapInteger, Integer . Java auto-boxing will enable transparent use of these collections MapInteger, Integer map new HashMap GoalKicker.com Java Notes for Professionals 145map.put1, 17 Automatic boxing of int to Integer": "input.pdf", "objects int a map.get1 Automatic unboxing. Unfortunately, the overhead of this is substantial . A HashMapInteger, Integer will require about 72 bytes per entry e.g. on 64-bit JVM with compressed pointers, and assuming integers larger than 256, and assuming 50 load of the map. Because the actual data is only 8 bytes, this yields a massive overhead. Furthermore, it requires two level of indirection Map - Entry - Value it is unnecessarily slow. There exist several libraries with optimized collections for primitive data types that require only 16 bytes per entry at 50 load, i.e. 4x less memory, and one level of indirection less, that can yield substantial performance bene\ufb01ts when using large collections of primitive values in Java. GoalKicker.com Java Notes for Professionals 146Chapter 25 Lists A list is an ordered collection of values. In Java, lists are part of the Java Collections Framework . Lists implement the java.util.List interface, which extends java.util.Collection . Section 25.1 Sorting a generic list The Collections class o\ufb00ers two standard static methods to sort a list sortListT list applicable to lists where T extends Comparable ? super T, and sortListT list, Comparator ? super T c applicable to lists of any type.": "input.pdf", "Applying the former requires amending the class of list elements being sorted, which is not always possible. It might also be undesirable as although it provides the default sorting, other sorting orders may be required in di\ufb00erent circumstances, or sorting is just a one o\ufb00 task. Consider we have a task of sorting objects that are instances of the following class public class User public final Long id public final String username public UserLong id, String username this.id id this.username username Override public String toString return String.formatsd, username, id In order to use Collections .sortListUser list we need to modify the User class to implement the Comparable interface. For example public class User implements Comparable User public final Long id public final String username public UserLong id, String username this.id id this.username username Override public String toString return String.formatsd, username, id Override The natural ordering for User objects is by the id field. public int compareTo User o return id.compareTo o.id GoalKicker.com Java Notes for Professionals 147Aside many standard Java classes such as String , Long , Integer implement the Comparable interface. This makes lists of those elements sortable by default, and simpli\ufb01es implementation of compare or compareTo in": "input.pdf", "other classes. With the modi\ufb01cation above, the we can easily sort a list of User objects based on the classes natural ordering . In this case, we have de\ufb01ned that to be ordering based on id values. For example ListUser users Lists.newArrayList new User33L, A, new User25L, B, new User28L, Collections .sortusers System.out.printusers B25, C28, A33 However, suppose that we wanted to sort User objects by name rather than by id. Alternatively, suppose that we had not been able to change the class to make it implement Comparable . This is where the sort method with the Comparator argument is useful Collections .sortusers, new Comparator User Override Order two User objects based on their names. public int compare User left, User right return left.username .compareTo right.username System.out.printusers A33, B25, C28 Version Java SE 8 In Java 8 you can use a lambda instead of an anonymous class. The latter reduces to a one-liner Collections .sortusers, l, r - l.username .compareTo r.username Further, there Java 8 adds a default sort method on the List interface, which simpli\ufb01es sorting even more. users.sortl, r - l.username .compareTo r.username Section 25.2 Convert a list of integers to a list of strings ListInteger nums": "input.pdf", "Arrays.asList1, 2, 3 ListString strings nums.stream .mapObjecttoString .collectCollectors. toList That is Create a stream from the list1. Map each element using ObjecttoString 2. Collect the String values into a List using Collectors. toList 3. Section 25.3 Classes implementing List - Pros and Cons The List interface is implemented by di\ufb00erent classes. Each of them has its own way for implementing it with di\ufb00erent strategies and providing di\ufb00erent pros and cons. GoalKicker.com Java Notes for Professionals 148Classes implementing List These are all of the public classes in Java SE 8 that implement the java.util.List interface Abstract Classes1. AbstractList AbstractSequentialList Concrete Classes2. ArrayList AttributeList CopyOnWriteArrayList LinkedList RoleList RoleUnresolvedList Stack Vector Pros and Cons of each implementation in term of time complexity ArrayList public class ArrayList E extends AbstractList E implements ListE, RandomAccess, Cloneable , Serializable ArrayList is a resizable-array implementation of the List interface. Storing the list into an array, ArrayList provides methods in addition to the methods implementing the List interface for manipulating the size of the array. Initialize ArrayList of Integer with size 100 ListInteger myList new ArrayList Integer100 Constructs an empty list with the specified initial capacity. - PROS The size, isEmpty, get, set, iterator, and listIterator operations": "input.pdf", "run in constant time. So getting and setting each element of the List has the same time cost int e1 myList. get0 int e2 myList. get10 All the same constant cost O1 myList.set2,10 - CONS Being implemented with an array static structure adding elements over the size of the array has a big cost due to the fact that a new allocation need to be done for all the array. However, from documentation The add operation runs in amortized constant time, that is, adding n elements requires On time Removing an element requires On time. AttributeList GoalKicker.com Java Notes for Professionals 149On coming CopyOnWriteArrayList On coming LinkedList public class LinkedList E extends AbstractSequentialList E implements ListE, DequeE, Cloneable , Serializable LinkedList is implemented by a doubly-linked list a linked data structure that consists of a set of sequentially linked records called nodes. Iitialize LinkedList of Integer ListInteger myList new LinkedList Integer Constructs an empty list. - PROS Adding or removing an element to the front of the list or to the end has constant time. myList.add10 myList.add0,2 constant time O1 myList.remove - CONS From documentation Operations that index into the list will traverse the list from the beginning or": "input.pdf", "the end, whichever is closer to the speci\ufb01ed index. Operations such as myList.get10 myList.add11,25 worst case done in On2 myList.set15,35 RoleList On coming RoleUnresolvedList On coming Stack On coming GoalKicker.com Java Notes for Professionals 150Vector On coming Section 25.4 Finding common elements between 2 lists Suppose you have two lists A and B, and you need to \ufb01nd the elements that exist in both lists. You can do it by just invoking the method List.retainAll . Example public static void mainString args List Integer numbersA new ArrayList List Integer numbersB new ArrayList numbersA. addAllArrays.asListnew Integer 1, 3, 4, 7, 5, 2 numbersB. addAllArrays.asListnew Integer 13, 32, 533, 3, 4, 2 System.out.printlnA numbersA System.out.printlnB numbersB List Integer numbersC new ArrayList numbersC. addAllnumbersA numbersC. retainAll numbersB System.out.printlnList A numbersA System.out.printlnList B numbersB System.out.printlnCommon elements between A and B numbersC Section 25.5 In-place replacement of a List element This example is about replacing a List element while ensuring that the replacement element is at the same position as the element that is replaced. This can be done using these methods setint index, T type int indexOfT type Consider an ArrayList containing the elements Program starting!, Hello world! and Goodbye world! ListString strings": "input.pdf", "new ArrayList String strings. addProgram starting! strings. addHello world! strings. addGoodbye world! If we know the index of the element we want to replace, we can simply use set as follows strings. set1, Hi world If we dont know the index, we can search for it \ufb01rst. For example int pos strings. indexOfGoodbye world! if pos 0 GoalKicker.com Java Notes for Professionals 151 strings. setpos, Goodbye cruel world! Notes The set operation will not cause a ConcurrentModificationException . 1. The set operation is fast O1 for ArrayList but slow ON for a LinkedList . 2. An indexOf search on an ArrayList or LinkedList is slow ON . 3. Section 25.6 Making a list unmodi\ufb01able The Collections class provides a way to make a list unmodi\ufb01able ListString ls new ArrayList String ListString unmodifiableList Collections .unmodifiableList ls If you want an unmodi\ufb01able list with one item you can use ListString unmodifiableList Collections .singletonList Only string in the list Section 25.7 Moving objects around in the list The Collections class allows for you to move objects around in the list using various methods ls is the List Reversing a list Collections .reversels Rotating positions of elements in a list The rotate method": "input.pdf", "requires an integer argument. This is how many spots to move it along the line by. An example of this is below ListString ls new ArrayList String ls.add how ls.add are ls.add you? ls.addhello, Collections .rotatels, 1 forString line ls System.out.printline System.out.println This will print hello, how are you? Shu\ufb04ing elements around in a list Using the same list above, we can shu\ufb04e the elements in a list Collections .shufflels We can also give it a java.util.Random object that it uses to randomly place objects in spots Random random new Random12 Collections .shufflels, random GoalKicker.com Java Notes for Professionals 152Section 25.8 Creating, Adding and Removing element from an ArrayList ArrayList is one of the inbuilt data structures in Java. It is a dynamic array where the size of the data structure not needed to be declared \ufb01rst for storing elements Objects. It extends AbstractList class and implements List interface. An ArrayList can contain duplicate elements where it maintains insertion order. It should be noted that the class ArrayList is non-synchronized, so care should be taken when handling concurrency with ArrayList . ArrayList allows random access because array works at the index basis. Manipulation is slow in ArrayList because of": "input.pdf", "shifting that often occurs when an element is removed from the array list. An ArrayList can be created as follows ListT myArrayList new ArrayList Where T Generics is the type that will be stored inside ArrayList . The type of the ArrayList can be any Object. The type cant be a primitive type use their wrapper classes instead. To add an element to the ArrayList , use add method myArrayList. addelement Or to add item to a certain index myArrayList. addindex, element index of the element should be an int starting from 0 To remove an item from the ArrayList , use the remove method myArrayList. removeelement Or to remove an item from a certain index myArrayList. removeindex index of the element should be an int starting from 0 Section 25.9 Creating a List Giving your list a type To create a list you need a type any class, e.g. String . This is the type of your List . The List will only store objects of the speci\ufb01ed type. For example ListString strings Can store string1 , hello world! , goodbye , etc, but it cant store 9.2, however ListDouble doubles Can store 9.2, but not hello world!": "input.pdf", ". Initialising your list If you try to add something to the lists above you will get a NullPointerException, because strings and doubles GoalKicker.com Java Notes for Professionals 153both equal null! There are two ways to initialise a list Option 1 Use a class that implements List List is an interface, which means that does not have a constructor, rather methods that a class must override. ArrayList is the most commonly used List , though LinkedList is also common. So we initialise our list like this ListString strings new ArrayList String or ListString strings new LinkedList String Version Java SE 7 Starting from Java SE 7, you can use a diamond operator ListString strings new ArrayList or ListString strings new LinkedList Option 2 Use the Collections class The Collections class provides two useful methods for creating Lists without a List variable emptyList returns an empty list. singletonList T creates a list of type T and adds the element speci\ufb01ed. And a method which uses an existing List to \ufb01ll data in addAllL, T... adds all the speci\ufb01ed elements to the list passed as the \ufb01rst parameter. Examples import java.util.List import java.util.Collections ListInteger l Collections.emptyList ListInteger l1 Collections.singletonList42 Collections.addAlll1, 1,": "input.pdf", "2, 3 Section 25.10 Positional Access Operations The List API has eight methods for positional access operations addT type addint index, T type removeObject o removeint index getint index setint index, E element int indexOf Object o int lastIndexOf Object o So, if we have a List GoalKicker.com Java Notes for Professionals 154ListString strings new ArrayList String And we wanted to add the strings Hello world! and Goodbye world! to it, we would do it as such strings. addHello world! strings. addGoodbye world! And our list would contain the two elements. Now lets say we wanted to add Program starting! at the front of the list. We would do this like this strings. add0, Program starting! NOTE The \ufb01rst element is 0. Now, if we wanted to remove the Goodbye world! line, we could do it like this strings. removeGoodbye world! And if we wanted to remove the \ufb01rst line which in this case would be Program starting!, we could do it like this strings. remove0 Note Adding and removing list elements modify the list, and this can lead to a ConcurrentModificationException 1. if the list is being iterated concurrently. Adding and removing elements can be O1 or ON": "input.pdf", "depending on the list class, the method used, and 2. whether you are adding removing an element at the start, the end, or in the middle of the list. In order to retrieve an element of the list at a speci\ufb01ed position you can use the E getint index method of the List API. For example strings. get0 will return the \ufb01rst element of the list. You can replace any element at a speci\ufb01ed position by using the setint index, E element . For example strings. set0,This is a replacement This will set the String This is a replacement as the \ufb01rst element of the list. Note The set method will overwrite the element at the position 0. It will not add the new String at the position 0 and push the old one to the position 1. The int indexOf Object o returns the position of the \ufb01rst occurrence of the object passed as argument. If there are no occurrences of the object in the list then the -1 value is returned. In continuation of the previous example if you call strings. indexOfThis is a replacement the 0 is expected to be returned as we set the String": "input.pdf", "This is a replacement in the position 0 of our list. In case where there are more than one occurrence in the list when int indexOf Object o is called then as mentioned GoalKicker.com Java Notes for Professionals 155the index of the \ufb01rst occurrence will be returned. By calling the int lastIndexOf Object o you can retrieve the index of the last occurrence in the list. So if we add another This is a replacement strings. addThis is a replacement strings. lastIndexOf This is a replacement This time the 1 will be returned and not the 0 Section 25.11 Iterating over elements in a list For the example, lets say that we have a List of type String that contains four elements hello, , how , are , you? The best way to iterate over each element is by using a for-each loop public void printEachElement ListString list forString s list System.out.printlns Which would print hello, how are you? To print them all in the same line, you can use a StringBuilder public void printAsLine ListString list StringBuilder builder new StringBuilder forString s list builder. appends System.out.printlnbuilder. toString Will print hello, how are you ? Alternatively, you can use": "input.pdf", "element indexing as described in Accessing element at ith Index from ArrayList to iterate a list. Warning this approach is ine\ufb03cient for linked lists. Section 25.12 Removing elements from list B that are present in the list A Lets suppose you have 2 Lists A and B, and you want to remove from B all the elements that you have in A the method in this case is List.removeAll Collection c Example GoalKicker.com Java Notes for Professionals 156public static void mainString args List Integer numbersA new ArrayList List Integer numbersB new ArrayList numbersA. addAllArrays.asListnew Integer 1, 3, 4, 7, 5, 2 numbersB. addAllArrays.asListnew Integer 13, 32, 533, 3, 4, 2 System.out.printlnA numbersA System.out.printlnB numbersB numbersB. removeAll numbersA System.out.printlnB cleared numbersB this will print A 1, 3, 4, 7, 5, 2 B 13, 32, 533, 3, 4, 2 B cleared 13, 32, 533 GoalKicker.com Java Notes for Professionals 157Chapter 26 Sets Section 26.1 Initialization A Set is a Collection that cannot contain duplicate elements. It models the mathematical set abstraction. Set have its implementation in various classes like HashSet , TreeSet , LinkedHashSet . For example HashSet SetT set new HashSet T Here T can be String , Integer or": "input.pdf", "any other object . HashSet allows for quick lookup of O1 but does not sort the data added to it and loses the insertion order of items. TreeSet It stores data in a sorted manner sacri\ufb01cing some speed for basic operations which take Olgn. It does not maintain the insertion order of items. TreeSetT sortedSet new TreeSet T LinkedHashSet It is a linked list implementation of HashSet Once can iterate over the items in the order they were added. Sorting is not provided for its contents. O1 basic operations are provided, however there is higher cost than HashSet in maintaining the backing linked list. LinkedHashSet T linkedhashset new LinkedHashSet T Section 26.2 Basics of Set What is a Set? A set is a data structure which contains a set of elements with an important property that no two elements in the set are equal. Types of Set HashSet A set backed by a hash table actually a HashMap instance 1. Linked HashSet A Set backed by Hash table and linked list, with predictable iteration order 2. TreeSet A NavigableSet implementation based on a TreeMap. 3. Creating a set SetInteger set new HashSet Integer Creates an empty Set of Integers": "input.pdf", "SetInteger linkedHashSet new LinkedHashSet Integer Creates a empty Set of Integers, with predictable iteration order Adding elements to a Set GoalKicker.com Java Notes for Professionals 158Elements can be added to a set using the add method set.add12 - Adds element 12 to the set set.add13 - Adds element 13 to the set Our set after executing this method set 12,13 Delete all the elements of a Set set.clear Removes all objects from the collection. After this set will be set Check whether an element is part of the Set Existence of an element in the set can be checked using the contains method set.contains 0 Returns true if a specified object is an element within the set. Output False Check whether a Set is empty isEmpty method can be used to check whether a Set is empty. set.isEmpty Returns true if the set has no elements Output True Remove an element from the Set set.remove0 Removes first occurrence of a specified object from the collection Check the Size of the Set set.size Returns the number of elements in the collection Output 0 Section 26.3 Types and Usage of Sets Generally, sets are a type of collection which stores unique": "input.pdf", "values. Uniqueness is determined by the equals and hashCode methods. Sorting is determined by the type of set. HashSet - Random Sorting Version Java SE 7 SetString set new HashSet set.addBanana GoalKicker.com Java Notes for Professionals 159set.addBanana set.addApple set.addStrawberry Set Elements Strawberry, Banana, Apple LinkedHashSet - Insertion Order Version Java SE 7 SetString set new LinkedHashSet set.addBanana set.addBanana set.addApple set.addStrawberry Set Elements Banana, Apple, Strawberry TreeSet - By compareTo or Comparator Version Java SE 7 SetString set new TreeSet set.addBanana set.addBanana set.addApple set.addStrawberry Set Elements Apple, Banana, Strawberry Version Java SE 7 SetString set new TreeSet string1, string2 - string2. compareTo string1 set.addBanana set.addBanana set.addApple set.addStrawberry Set Elements Strawberry, Banana, Apple Section 26.4 Create a list from an existing Set Using a new List ListString list new ArrayList StringlistOfElements Using List.addAll method SetString set new HashSet String set. addfoo set. addboo List String list new ArrayList String list. addAllset Using Java 8 Steam API ListString list set.stream.collectCollectors. toList Section 26.5 Eliminating duplicates using Set Suppose you have a collection elements , and you want to create another collection containing the same elements but with all duplicates eliminated GoalKicker.com Java Notes for Professionals 160Collection Type noDuplicates new HashSet Typeelements Example": "input.pdf", "ListString names new ArrayList Arrays.asListJohn, Marco, Jenny, Emily, Jenny, Emily, John SetString noDuplicates new HashSet names System.out.printlnnoDuplicates noDuplicates Output noDuplicates Marco, Emily, John, Jenny Section 26.6 Declaring a HashSet with values You can create a new class that inherits from HashSet SetString h new HashSet String adda addb One line solution SetString h new HashSet StringArrays.asLista, b Using guava Sets.newHashSet a, b, c Using Streams SetString set3 Stream. ofa, b, c.collecttoSet GoalKicker.com Java Notes for Professionals 161Chapter 27 List vs Set What are di\ufb00erences between List and Set collection at the top level and How to choose when to use List in java and when to use Set in Java Section 27.1 List vs Set import java.util.ArrayList import java.util.HashSet import java.util.List import java.util.Set public class SetAndListExample public static void main String args System.out.printlnList example ..... List list new ArrayList list. add1 list. add2 list. add3 list. add4 list. add1 for String temp list System.out.printlntemp System.out.printlnSet example ..... Set String set new HashSet String set. add1 set. add2 set. add3 set. add4 set. add1 set. add2 set. add5 for String temp set System.out.printlntemp Output List example ..... 1 2 3 4 1 Set example ..... 3 2 10 5 4": "input.pdf", "GoalKicker.com Java Notes for Professionals 162Chapter 28 Maps The java.util.Map interface represents a mapping between keys and their values. A map cannot contain duplicate keys and each key can map to at most one value. Since Map is an interface, then you need to instantiate a concrete implementation of that interface in order to use it there are several Map implementations, and mostly used are the java.util.HashMap and java.util.TreeMap Section 28.1 Iterating Map Entries Eciently This section provides code and benchmarks for ten unique example implementations which iterate over the entries of a MapInteger, Integer and generate the sum of the Integer values. All of the examples have an algorithmic complexity of \u0398n, however, the benchmarks are still useful for providing insight on which implementations are more e\ufb03cient in a real world environment. Implementation using Iterator with Map.Entry 1. Iterator Map.EntryInteger, Integer it map.entrySet .iterator while it.hasNext Map.EntryInteger, Integer pair it.next sum pair.getKey pair.getValue Implementation using for with Map.Entry 2. for Map.EntryInteger, Integer pair map.entrySet sum pair.getKey pair.getValue Implementation using Map.forEach Java 8 3. map. forEachk, v - sum0 k v Implementation using Map.keySet with for 4. for Integer key map.keySet sum key map.getkey Implementation using Map.keySet with Iterator": "input.pdf", "5. Iterator Integer it map.keySet.iterator while it.hasNext Integer key it.next sum key map.getkey Implementation using for with Iterator and Map.Entry 6. for Iterator Map.EntryInteger, Integer entries map. entrySet .iterator entries. hasNext Map.EntryInteger, Integer entry entries. next sum entry.getKey entry.getValue Implementation using Stream.forEach Java 8 7. GoalKicker.com Java Notes for Professionals 163 map. entrySet .stream.forEache - sum e.getKey e.getValue Implementation using Stream.forEach with Stream.parallel Java 8 8. map. entrySet . stream . parallel . forEache - sum e.getKey e.getValue Implementation using IterableMap from Apache Collections 9. MapIterator Integer, Integer mit iterableMap. mapIterator while mit.hasNext sum mit.next it.getValue Implementation using MutableMap from Eclipse Collections 10. mutableMap. forEachKeyValue key, value - sum key value Performance Tests Code available on Github Test Environment Windows 8.1 64-bit, Intel i7-4790 3.60GHz, 16 GB Average Performance of 10 Trials 100 elements Best 308 21 nsop 1. Benchmark Score Error Units test3UsingForEachAndJava8 308 21 nsop test10UsingEclipseMutableMap 309 9 nsop test1UsingWhileAndMapEntry 380 14 nsop test6UsingForAndIterator 387 16 nsop test2UsingForEachAndMapEntry 391 23 nsop test7UsingJava8StreamAPI 510 14 nsop test9UsingApacheIterableMap 524 8 nsop test4UsingKeySetAndForEach 816 26 nsop test5UsingKeySetAndIterator 863 25 nsop test8UsingJava8StreamAPIParallel 5552 185 nsop Average Performance of 10 Trials 10000 elements Best 37.606 0.790 \u03bcsop 2. Benchmark Score Error Units": "input.pdf", "test10UsingEclipseMutableMap 37606 790 nsop test3UsingForEachAndJava8 50368 887 nsop test6UsingForAndIterator 50332 507 nsop test2UsingForEachAndMapEntry 51406 1032 nsop test1UsingWhileAndMapEntry 52538 2431 nsop test7UsingJava8StreamAPI 54464 712 nsop test4UsingKeySetAndForEach 79016 25345 nsop test5UsingKeySetAndIterator 91105 10220 nsop test8UsingJava8StreamAPIParallel 112511 365 nsop test9UsingApacheIterableMap 125714 1935 nsop Average Performance of 10 Trials 100000 elements Best 1184.767 332.968 \u03bcsop 3. Benchmark Score Error Units GoalKicker.com Java Notes for Professionals 164test1UsingWhileAndMapEntry 1184.767 332.968 \u03bcsop test10UsingEclipseMutableMap 1191.735 304.273 \u03bcsop test2UsingForEachAndMapEntry 1205.815 366.043 \u03bcsop test6UsingForAndIterator 1206.873 367.272 \u03bcsop test8UsingJava8StreamAPIParallel 1485.895 233.143 \u03bcsop test5UsingKeySetAndIterator 1540.281 357.497 \u03bcsop test4UsingKeySetAndForEach 1593.342 294.417 \u03bcsop test3UsingForEachAndJava8 1666.296 126.443 \u03bcsop test7UsingJava8StreamAPI 1706.676 436.867 \u03bcsop test9UsingApacheIterableMap 3289.866 1445.564 \u03bcsop A Comparison of Performance Variations Respective to Map Size4. x Size of Map fx Benchmark Score \u03bcsop 100 600 1100 1600 2100 --------------------------------------------------- 10 0.333 1.631 2.752 5.937 8.024 3 0.309 1.971 4.147 8.147 10.473 6 0.372 2.190 4.470 8.322 10.531 1 0.405 2.237 4.616 8.645 10.707 Tests 2 0.376 2.267 4.809 8.403 10.910 fx 7 0.473 2.448 5.668 9.790 12.125 9 0.565 2.830 5.952 13.22 16.965 4 0.808 5.012 8.813 13.939 17.407 5 0.81 5.104 8.533 14.064 17.422 8 5.173 12.499 17.351 24.671 30.403 Section 28.2 Usage of HashMap HashMap is an implementation of the Map interface": "input.pdf", "that provides a Data Structure to store data in Key-Value pairs. 1. Declaring HashMap MapKeyType, ValueType myMap new HashMap KeyType, ValueType GoalKicker.com Java Notes for Professionals 165KeyType and ValueType must be valid types in Java, such as - String, Integer, Float or any custom class like Employee, Student etc.. For Example MapString,Integer myMap new HashMap String,Integer 2. Putting values in HashMap. To put a value in the HashMap, we have to call put method on the HashMap object by passing the Key and the Value as parameters. myMap.putkey1, 1 myMap.putkey2, 2 If you call the put method with the Key that already exists in the Map, the method will override its value and return the old value. 3. Getting values from HashMap. For getting the value from a HashMap you have to call the get method, by passing the Key as a parameter. myMap.getkey1 return 1 class Integer If you pass a key that does not exists in the HashMap, this method will return null 4. Check whether the Key is in the Map or not. myMap.containsKey varKey 5. Check whether the Value is in the Map or not. myMap.containsValue varValue The above methods will return a boolean value": "input.pdf", "true or false if key, value exists in the Map or not. Section 28.3 Using Default Methods of Map from Java 8 Examples of using Default Methods introduced in Java 8 in Map interface Using getOrDefault 1. Returns the value mapped to the key, or if the key is not present, returns the default value MapInteger, String map new HashMap map.put1, First element map.get1 First element map.get2 null map.getOrDefault 2, Default element Default element Using forEach 2. Allows to perform the operation speci\ufb01ed in the action on each Map Entry MapInteger, String map new HashMap Integer, String map.put1, one map.put2, two map.put3, three GoalKicker.com Java Notes for Professionals 166 map.forEachkey, value - System.out.printlnKey key Value value Key 1 Value one Key 2 Value two Key 3 Value three Using replaceAll 3. Will replace with new-value only if key is present MapString, Integer map new HashMap String, Integer map.putjohn, 20 map.putpaul, 30 map.putpeter, 40 map.replaceAll key,value -value10 john30, paul40, peter50 Using putIfAbsent 4. Key-Value pair is added to the map, if the key is not present or mapped to null MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 map. putIfAbsent kelly, 50": "input.pdf", "john20, paul30, peter40, kelly50 Using remove 5. Removes the key only if its associated with the given value MapString, Integer map new HashMap String, Integer map.putjohn, 20 map.putpaul, 30 map.putpeter, 40 map.removepeter,40 john30, paul40 Using replace 6. If the key is present then the value is replaced by new-value. If the key is not present, does nothing. MapString, Integer map new HashMap String, Integer map.putjohn, 20 map.putpaul, 30 map.putpeter, 40 map.replacepeter,50 john20, paul30, peter50 map.replacejack,60 john20, paul30, peter50 Using computeIfAbsent 7. This method adds an entry in the Map. the key is speci\ufb01ed in the function and the value is the result of the application of the mapping function MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 GoalKicker.com Java Notes for Professionals 167 map. computeIfAbsent kelly, k-map.getjohn10 john20, paul30, peter40, kelly30 map. computeIfAbsent peter, k-map.getjohn10 john20, paul30, peter40, kelly30 peter already present Using computeIfPresent 8. This method adds an entry or modi\ufb01es an existing entry in the Map. Does nothing if an entry with that key is not present MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 map. computeIfPresent kelly, k,v-v10 john20, paul30,": "input.pdf", "peter40 kelly not present map. computeIfPresent peter, k,v-v10 john20, paul30, peter50 peter present, so increase the value Using compute 9. This method replaces the value of a key by the newly computed value MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 map. computepeter, k,v-v50 john20, paul30, peter90 Increase the value Using merge 10. Adds the key-value pair to the map, if key is not present or value for the key is null Replaces the value with the newly computed value, if the key is present Key is removed from the map , if new value computed is null MapString, Integer map new HashMap String, Integer map. putjohn, 20 map. putpaul, 30 map. putpeter, 40 Adds the key-value pair to the map, if key is not present or value for the key is null map. mergekelly, 50 , k,v-map.getjohn10 john20, paul30, peter40, kelly50 Replaces the value with the newly computed value, if the key is present map. mergepeter, 50 , k,v-map.getjohn10 john20, paul30, peter30, kelly50 Key is removed from the map , if new value computed is null map. mergepeter, 30 , k,v-map.getnancy john20, paul30, kelly50 Section 28.4 Iterating through the contents": "input.pdf", "of a Map Maps provide methods which let you access the keys, values, or key-value pairs of the map as collections. You can iterate through these collections. Given the following map for example MapString, Integer repMap new HashMap repMap.putJon Skeet , 927654 repMap.putBalusC , 708826 repMap.putDarin Dimitrov , 715567 Iterating through map keys GoalKicker.com Java Notes for Professionals 168for String key repMap. keySet System.out.printlnkey Prints Darin Dimitrov Jon Skeet BalusC keySet provides the keys of the map as a Set. Set is used as the keys cannot contain duplicate values. Iterating through the set yields each key in turn. HashMaps are not ordered, so in this example the keys may be returned in any order. Iterating through map values for Integer value repMap. values System.out.printlnvalue Prints 715567 927654 708826 values returns the values of the map as a Collection . Iterating through the collection yields each value in turn. Again, the values may be returned in any order. Iterating through keys and values together for Map.EntryString, Integer entry repMap. entrySet System.out.printfs d n, entry. getKey, entry. getValue Prints Darin Dimitrov 715567 Jon Skeet 927654 BalusC 708826 entrySet returns a collection of Map.Entry objects. Map.Entry gives access to the key": "input.pdf", "and value for each entry. Section 28.5 Merging, combine and composing Maps Use putAll to put every member of one map into another. Keys already present in the map will have their corresponding values overwritten. MapString, Integer numbers new HashMap numbers. putOne, 1 GoalKicker.com Java Notes for Professionals 169numbers. putThree, 3 MapString, Integer othernumbers new HashMap othernumbers. putTwo, 2 othernumbers. putThree, 4 numbers. putAllothernumbers This yields the following mapping in numbers One - 1 Two - 2 Three - 4 old value 3 was overwritten by new value 4 If you want to combine values instead of overwriting them, you can use Map.merge , added in Java 8, which uses a user-provided BiFunction to merge values for duplicate keys. merge operates on individual keys and values, so youll need to use a loop or Map.forEach . Here we concatenate strings for duplicate keys for Map.EntryString, Integer e othernumbers. entrySet numbers. mergee.getKey, e.getValue , Integersum or instead of the above loop othernumbers. forEachk, v - numbers. mergek, v, Integersum If you want to enforce the constraint there are no duplicate keys, you can use a merge function that throws an AssertionError mapA.forEachk, v - mapB. mergek, v, v1, v2 -": "input.pdf", "throw new AssertionError duplicate values for key k Composing MapX,Y and MapY,Z to get MapX,Z If you want to compose two mappings, you can do it as follows MapString, Integer map1 new HashMap String, Integer map1. putkey1, 1 map1. putkey2, 2 map1. putkey3, 3 MapInteger, Double map2 new HashMap Integer, Double map2. put1, 1.0 map2. put2, 2.0 map2. put3, 3.0 MapString, Double map3 new new HashMap String, Double map1. forEachkey,value -map3.putkey,map2. getvalue This yields the following mapping key1 - 1.0 key2 - 2.0 key3 - 3.0 Section 28.6 Add multiple items We can use V putK key,V value GoalKicker.com Java Notes for Professionals 170Associates the speci\ufb01ed value with the speci\ufb01ed key in this map optional operation. If the map previously contained a mapping for the key, the old value is replaced by the speci\ufb01ed value. String currentVal MapInteger, String map new TreeMap currentVal map.put1, First element. System.out.printlncurrentVal Will print null currentVal map.put2, Second element. System.out.printlncurrentVal Will print null yet again currentVal map.put2, This will replace Second element System.out.printlncurrentVal will print Second element. System.out.printlnmap.size Will print 2 as key having value 2 was replaced. MapInteger, String map2 new HashMap map2.put2, Element 2 map2.put3, Element 3 map.putAllmap2 System.out.printlnmap.size Output 3 To": "input.pdf", "add many items you can use an inner classes like this MapInteger, String map new HashMap This is now an anonymous inner class with an unnamed instance constructor put5, high put4, low put1, too slow Keep in mind that creating an anonymous inner class is not always e\ufb03cient and can lead to memory leaks so when possible, use an initializer block instead static MapInteger, String map new HashMap static Now no inner classes are created so we can avoid memory leaks put5, high put4, low put1, too slow The example above makes the map static. It can also be used in a non-static context by removing all occurrences of static . In addition to that most implementations support putAll , which can add all entries in one map to another like this another. putAllone GoalKicker.com Java Notes for Professionals 171Section 28.7 Creating and Initializing Maps Introduction Maps stores keyvalue pairs, where each key has an associated value. Given a particular key, the map can look up the associated value very quickly. Maps , also known as associate array, is an object that stores the data in form of keys and values. In Java, maps are represented using Map interface": "input.pdf", "which is not an extension of the collection interface. Way 1 J2SE 5.0 Map map new HashMap map.putname, A map.putaddress , Malviya-Nagar map.putcity, Jaipur System.out.printlnmap Way 2 J2SE 5.0 style use of generics MapString, Object map new HashMap map.putname, A map.putaddress , Malviya-Nagar map.putcity, Jaipur System.out.printlnmap Way 3 MapString, Object map new HashMap String, Object put name, A put address , Malviya-Nagar put city, Jaipur System.out.printlnmap Way 4 MapString, Object map new TreeMap String, Object map. putname, A map. putaddress , Malviya-Nagar map. putcity, Jaipur System.out.printlnmap Way 5 Java 8 final MapString, String map Arrays.streamnew String name, A , address , Malviya-Nagar , city, jaipur , .collectCollectors. toMapm - m0, m - m1 System.out.printlnmap GoalKicker.com Java Notes for Professionals 172Way 6 This way for initial a map in outside the function final static MapString, String map static map new HashMap String, String map. puta, b map. putc, d Way 7 Creating an immutable single key-value map. Immutable single key-value map MapString, String singletonMap Collections .singletonMap key, value Please note, that it is impossible to modify such map . Any attemts to modify the map will result in throwing the UnsupportedOperationException. Immutable single key-value pair MapString, String singletonMap Collections .singletonMap": "input.pdf", "key, value singletonMap. putnewKey , newValue will throw UnsupportedOperationException singletonMap. putAllnew HashMap will throw UnsupportedOperationException singletonMap. removekey will throw UnsupportedOperationException singletonMap. replacekey, value, newValue will throw UnsupportedOperationException and etc Section 28.8 Check if key exists MapString, String num new HashMap num.putone, first if num.containsKey one System.out.printlnnum.getone first Maps can contain null values For maps, one has to be carrefull not to confuse containing a key with having a value. For example, HashMap s can contain null which means the following is perfectly normal behavior MapString, String map new HashMap map.putone, null if map.containsKey one System.out.printlnThis prints ! This line is reached if map.getone ! null System.out.printlnThis is never reached ! This line is never reached More formally, there is no guarantee that map.contains key map.getkey!null Section 28.9 Add an element Addition1. GoalKicker.com Java Notes for Professionals 173MapInteger, String map new HashMap map.put1, First element. System.out.printlnmap.get1 Output First element. Override2. MapInteger, String map new HashMap map.put1, First element. map.put1, New element. System.out.printlnmap.get1 Output New element. HashMap is used as an example. Other implementations that implement the Map interface may be used as well. Section 28.10 Clear the map MapInteger, String map new HashMap map.put1, First element. map.put2, Second element. map.put3,": "input.pdf", "Third element. map.clear System.out.printlnmap.size 0 Section 28.11 Use custom object as key Before using your own object as key you must override hashCode and equals method of your object. In simple case you would have something like class MyKey private String name MyKey String name this.name name Override public boolean equalsObject obj ifobj instanceof MyKey return this.name.equalsMyKeyobj.name return false Override public int hashCode return this.name.hashCode hashCode will decide which hash bucket the key belongs to and equals will decide which object inside that hash bucket. GoalKicker.com Java Notes for Professionals 174Without these method, the reference of your object will be used for above comparison which will not work unless you use the same object reference every time. GoalKicker.com Java Notes for Professionals 175Chapter 29 LinkedHashMap LinkedHashMap class is Hash table and Linked list implementation of the Map interface, with predictable iteration order. It inherits HashMap class and implements the Map interface. The important points about Java LinkedHashMap class are A LinkedHashMap contains values based on the key. It contains only unique elements. It may have one null key and multiple null values. It is same as HashMap instead maintains insertion order. Section 29.1 Java LinkedHashMap class Key Points Is": "input.pdf", "Hash table and Linked list implementation of the Map interface, with predictable iteration order. inherits HashMap class and implements the Map interface. contains values based on the key. only unique elements. may have one null key and multiple null values. same as HashMap instead maintains insertion order. Methods void clear. boolean containsKeyObject key. Object getObject key. protected boolean removeEldestEntryMap.Entry eldest Example public static void mainString arg LinkedHashMap String, String lhm new LinkedHashMap String, String lhm. putRamesh , Intermediate lhm. putShiva, B-Tech lhm. putSantosh , B-Com lhm. putAsha, Msc lhm. putRaghu, M-Tech Set set lhm.entrySet Iterator i set.iterator while i.hasNext Map.Entry me Map.Entry i.next System.out.printlnme.getKey me.getValue System.out.printlnThe Key Contains lhm.containsKey Shiva System.out.printlnThe value to the corresponding to key lhm.getAsha GoalKicker.com Java Notes for Professionals 176Chapter 30 WeakHashMap Concepts of weak Hashmap Section 30.1 Concepts of WeakHashmap Key Points Implementation of Map. stores only weak references to its keys. Weak References The objects that are referenced only by weak references are garbage collected eagerly the GC wont wait until it needs memory in that case. Di\ufb00erence between Hashmap and WeakHashMap If the Java memory manager no longer has a strong reference to the object speci\ufb01ed as a key, then the entry": "input.pdf", "in the map will be removed in WeakHashMap. Example public class WeakHashMapTest public static void mainString args Map hashMap new HashMap Map weakHashMap new WeakHashMap String keyHashMap new StringkeyHashMap String keyWeakHashMap new StringkeyWeakHashMap hashMap. putkeyHashMap, Ankita weakHashMap. putkeyWeakHashMap, Atul System.gc System.out.printlnBefore hash map value hashMap. getkeyHashMap and weak hash map valueweakHashMap. getkeyWeakHashMap keyHashMap null keyWeakHashMap null System.gc System.out.printlnAfter hash map value hashMap. getkeyHashMap and weak hash map valueweakHashMap. getkeyWeakHashMap Size di\ufb00erences HashMap vs WeakHashMap Calling size method on HashMap object will return the same number of key-value pairs. size will decrease only if remove method is called explicitly on the HashMap object. Because the garbage collector may discard keys at anytime, a WeakHashMap may behave as though an unknown thread is silently removing entries. So it is possible for the size method to return smaller values over time.So, in WeakHashMap size decrease happens automatically . GoalKicker.com Java Notes for Professionals 177Chapter 31 SortedMap Introduction to sorted Map. Section 31.1 Introduction to sorted Map Keypoint SortedMap interface extends Map. entries are maintained in an ascending key order. Methods of sorted Map Comparator comparator . Object \ufb01rstKey . SortedMap headMapObject end. Object lastKey . SortedMap subMapObject start, Object end. SortedMap tailMapObject": "input.pdf", "start. Example public static void mainString args Create a hash map TreeMap tm new TreeMap Put elements to the map tm. putZara, new Double3434.34 tm. putMahnaz , new Double123.22 tm. putAyan, new Double1378.00 tm. putDaisy, new Double99.22 tm. putQadir, new Double-19.08 Get a set of the entries Set set tm.entrySet Get an iterator Iterator i set.iterator Display elements whilei.hasNext Map.Entry me Map.Entryi.next System.out.printme.getKey System.out.printlnme.getValue System.out.println Deposit 1000 into Zaras account double balance Doubletm.getZara.doubleValue tm. putZara, new Doublebalance 1000 System.out.printlnZaras new balance tm.getZara GoalKicker.com Java Notes for Professionals 178Chapter 32 TreeMap and TreeSet TreeMap and TreeSet are basic Java collections added in Java 1.2. TreeMap is a mutable , ordered , Map implementation. Similarly, TreeSet is a mutable , ordered Set implementation. TreeMap is implemented as a Red-Black tree, which provides Olog n access times. TreeSet is implemented using a TreeMap with dummy values. Both collections are not thread-safe. Section 32.1 TreeMap of a simple Java type First, we create an empty map, and insert some elements into it Version Java SE 7 TreeMapInteger, String treeMap new TreeMap Version Java SE 7 TreeMapInteger, String treeMap new TreeMap Integer, String treeMap. put10, ten treeMap. put4, four treeMap. put1, one treeSet. put12,": "input.pdf", "twelve Once we have a few elements in the map, we can perform some operations System.out.printlntreeMap. firstEntry Prints 1one System.out.printlntreeMap. lastEntry Prints 12twelve System.out.printlntreeMap. size Prints 4, since there are 4 elemens in the map System.out.printlntreeMap. get12 Prints twelve System.out.printlntreeMap. get15 Prints null, since the key is not found in the map We can also iterate over the map elements using either an Iterator, or a foreach loop. Note that the entries are printed according to their natural ordering , not the insertion order Version Java SE 7 for EntryInteger, String entry treeMap. entrySet System.out.printentry prints 1one 4four 10ten 12twelve Iterator EntryInteger, String iter treeMap. entrySet .iterator while iter.hasNext System.out.printiter.next prints 1one 4four 10ten 12twelve Section 32.2 TreeSet of a simple Java Type First, we create an empty set, and insert some elements into it Version Java SE 7 TreeSetInteger treeSet new TreeSet Version Java SE 7 TreeSetInteger treeSet new TreeSet Integer treeSet. add10 treeSet. add4 treeSet. add1 GoalKicker.com Java Notes for Professionals 179treeSet. add12 Once we have a few elements in the set, we can perform some operations System.out.printlntreeSet. first Prints 1 System.out.printlntreeSet. last Prints 12 System.out.printlntreeSet. size Prints 4, since there are 4 elemens in the set": "input.pdf", "System.out.printlntreeSet. contains 12 Prints true System.out.printlntreeSet. contains 15 Prints false We can also iterate over the map elements using either an Iterator, or a foreach loop. Note that the entries are printed according to their natural ordering , not the insertion order Version Java SE 7 for Integer i treeSet System.out.printi prints 1 4 10 12 Iterator Integer iter treeSet. iterator while iter.hasNext System.out.printiter.next prints 1 4 10 12 Section 32.3 TreeMapTreeSet of a custom Java type Since TreeMap s and TreeSet s maintain keyselements according to their natural ordering . Therefor TreeMap keys and TreeSet elements have to comparable to one another. Say we have a custom Person class public class Person private int id private String firstName, lastName private Date birthday ... Constuctors, getters, setters and various methods If we store it as-is in a TreeSet or a Key in a TreeMap TreeSetPerson2 set ... set.addnew Person1,first,last,Date.fromInstant. now Then wed run into an Exception such as this one Exception in thread main java.lang.ClassCastException Person cannot be cast to java.lang.Comparable at java. util.TreeMap.compareTreeMap.java1294 at java. util.TreeMap.putTreeMap.java538 at java. util.TreeSet.addTreeSet.java255 To \ufb01x that, lets assume that we want to order Person instances based on the order of their ids": "input.pdf", "private int id. We could do it in one of two ways One solution is to modify Person so it would implement the Comparable interface 1. GoalKicker.com Java Notes for Professionals 180public class Person implements Comparable Person private int id private String firstName, lastName private Date birthday ... Constuctors, getters, setters and various methods Override public int compareTo Person o return Integer.comparethis.id, o.id Compare by id Another solution is to provide the TreeSet with a Comparator 2. Version Java SE 8 TreeSetPerson treeSet new TreeSet personA, personB - Integer.comparepersonA. getId, personB. getId TreeSetPerson treeSet new TreeSet new Comparator Person Override public int compare Person personA, Person personB return Integer.comparepersonA. getId, personB. getId However, there are two caveats to both approaches Its very important not to modify any \ufb01elds used for ordering once an instance has been inserted into a 1. TreeSet TreeMap . In the above example, if we change the id of a person thats already inserted into the collection, we might run into unexpected behavior. Its important to implement the comparison properly and consistently. As per the Javadoc 2. The implementor must ensure sgnx.compareTo y -sgny.compareTo x for all x and y. This implies that x.compareTo y": "input.pdf", "must throw an exception i\ufb00 y.compareTo x throws an exception. The implementor must also ensure that the relation is transitive x.compareTo y0 y.compareTo z0 implies x.compareTo z0. Finally, the implementor must ensure that x.compareTo y0 implies that sgnx.compareTo z sgny.compareTo z, for all z. Section 32.4 TreeMap and TreeSet Thread Safety TreeMap and TreeSet are not thread-safe collections, so care must be taken to ensure when used in multi-threaded programs. Both TreeMap and TreeSet are safe when read, even concurrently, by multiple threads. So if they have been created and populated by a single thread say, at the start of the program, and only then read, but not modi\ufb01ed by multiple threads, theres no reason for synchronization or locking. However, if read and modi\ufb01ed concurrently, or modi\ufb01ed concurrently by more than one thread, the collection might throw a ConcurrentModi\ufb01cationException or behave unexpectedly. In these cases, its imperative to synchronizelock access to the collection using one of the following approaches GoalKicker.com Java Notes for Professionals 181Using Collections .synchronizedSorted .. 1. SortedSet Integer set Collections .synchronizedSortedSet new TreeSet Integer SortedMap Integer,String map Collections .synchronizedSortedMap new TreeMapInteger,String This will provide a SortedSet SortedMap implementation backed by the actual collection, and synchronized on": "input.pdf", "some mutex object. Note that this will synchronize all read and write access to the collection on a single lock, so even concurrent reads would not be possible. By manually synchronizing on some object, like the collection itself2. TreeSet Integer set new TreeSet ... Thread 1 synchronized set set. add4 ... Thread 2 synchronized set set. remove5 By using a lock, such as a ReentrantReadWriteLock 3. TreeSet Integer set new TreeSet ReentrantReadWriteLock lock new ReentrantReadWriteLock ... Thread 1 lock.writeLock .lock set.add4 lock.writeLock .unlock ... Thread 2 lock.readLock .lock set.contains 5 lock.readLock .unlock As opposed to the previous synchronization methods, using a ReadWriteLock allows multiple threads to read from the map concurrently. GoalKicker.com Java Notes for Professionals 182Chapter 33 Queues and Deques Section 33.1 The usage of the PriorityQueue PriorityQueue is a data structure. Like SortedSet , PriorityQueue sorts also its elements based on their priorities. The elements, which have a higher priority, comes \ufb01rst. The type of the PriorityQueue should implement comparable or comparator interface, whose methods decides the priorities of the elements of the data structure. The type of the PriorityQueue is Integer. PriorityQueue Integer queue new PriorityQueue Integer The elements are added to the PriorityQueue queue.addAll Arrays.asList": "input.pdf", "9, 2, 3, 1, 3, 8 The PriorityQueue sorts the elements by using compareTo method of the Integer Class The head of this queue is the least element with respect to the specified ordering System.out.println queue The Output 1, 2, 3, 9, 3, 8 queue.remove System.out.println queue The Output 2, 3, 3, 9, 8 queue.remove System.out.println queue The Output 3, 8, 3, 9 queue.remove System.out.println queue The Output 3, 8, 9 queue.remove System.out.println queue The Output 8, 9 queue.remove System.out.println queue The Output 9 queue.remove System.out.println queue The Output Section 33.2 Deque A Deque is a double ended queue which means that a elements can be added at the front or the tail of the queue. The queue only can add elements to the tail of a queue. The Deque inherits the Queue interface which means the regular methods remain, however the Deque interface o\ufb00ers additional methods to be more \ufb02exible with a queue. The additional methods really speak for them self if you know how a queue works, since those methods are intended to add more \ufb02exibility Method Brief description getFirst Gets the \ufb01rst item of the head of the queue without removing it. getLast Gets the \ufb01rst": "input.pdf", "item of the tail of the queue without removing it. addFirst E eAdds an item to the head of the queue addLastE eAdds an item to the tail of the queue removeFirst Removes the \ufb01rst item at the head of the queue removeLast Removes the \ufb01rst item at the tail of the queue Of course the same options for offer , poll and peek are available, however they do not work with exceptions but rather with special values. There is no point in showing what they do here. Adding and Accessing Elements To add elements to the tail of a Deque you call its add method. You can also use the addFirst and addLast methods, which add elements to the head and tail of the deque. GoalKicker.com Java Notes for Professionals 183DequeString dequeA new LinkedList dequeA.addelement 1 add element at tail dequeA.addFirst element 2 add element at head dequeA.addLastelement 3 add element at tail You can peek at the element at the head of the queue without taking the element out of the queue. This is done via the element method. You can also use the getFirst and getLast methods, which return the \ufb01rst and last element in the": "input.pdf", "Deque . Here is how that looks String firstElement0 dequeA. element String firstElement1 dequeA. getFirst String lastElement dequeA. getLast Removing Elements To remove elements from a deque, you call the remove, removeFirst and removeLast methods. Here are a few examples String firstElement dequeA. remove String firstElement dequeA. removeFirst String lastElement dequeA. removeLast Section 33.3 Stacks What is a Stack? In Java, Stacks are a LIFO Last In, First Out Data structure for objects. Stack API Java contains a Stack API with the following methods Stack Creates an empty Stack isEmpty Is the Stack Empty? Return Type Boolean pushItem item push an item onto the stack pop removes item from top of stack Return Type Item size returns of items in stack Return Type Int Example import java.util. public class StackExample public static void mainString args Stack st new Stack System.out.printlnstack st st. push10 System.out.println10 was pushed to the stack System.out.printlnstack st st. push15 System.out.println15 was pushed to the stack System.out.printlnstack st st. push80 System.out.println80 was pushed to the stack System.out.printlnstack st GoalKicker.com Java Notes for Professionals 184 st. pop System.out.println80 was popped from the stack System.out.printlnstack st st. pop System.out.println15 was popped from the stack System.out.printlnstack st st. pop": "input.pdf", "System.out.println10 was popped from the stack System.out.printlnstack st ifst.isEmpty System.out.printlnempty stack This returns stack 10 was pushed to the stack stack 10 15 was pushed to the stack stack 10, 15 80 was pushed to the stack stack 10, 15, 80 80 was popped from the stack stack 10, 15 15 was popped from the stack stack 10 10 was popped from the stack stack empty stack Section 33.4 BlockingQueue A BlockingQueue is an interface, which is a queue that blocks when you try to dequeue from it and the queue is empty, or if you try to enqueue items to it and the queue is already full. A thread trying to dequeue from an empty queue is blocked until some other thread inserts an item into the queue. A thread trying to enqueue an item in a full queue is blocked until some other thread makes space in the queue, either by dequeuing one or more items or clearing the queue completely. BlockingQueue methods come in four forms, with di\ufb00erent ways of handling operations that cannot be satis\ufb01ed immediately, but may be satis\ufb01ed at some point in the future one throws an exception, the second returns a special": "input.pdf", "value either null or false, depending on the operation, the third blocks the current thread inde\ufb01nitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. Operation Throws Exception Special Value Blocks Times out Insert add o\ufb00ere pute o\ufb00ere, time, unit Remove remove poll take polltime, unit Examine element peek NA NA A BlockingQueue can be bounded or unbounded . A bounded BlockingQueue is one which is initialized with initial GoalKicker.com Java Notes for Professionals 185capacity. BlockingQueue String bQueue new ArrayBlockingQueue String2 Any calls to a put method will be blocked if the size of the queue is equal to the initial capacity de\ufb01ned. An unbounded Queue is one which is initialized without capacity, actually by default it initialized with Integer.MAXVALUE. Some common implementations of BlockingQueue are ArrayBlockingQueue1. LinkedBlockingQueue2. PriorityBlockingQueue3. Now lets look at an example of ArrayBlockingQueue BlockingQueue String bQueue new ArrayBlockingQueue 2 bQueue.putThis is entry 1 System.out.printlnEntry one done bQueue.putThis is entry 2 System.out.printlnEntry two done bQueue.putThis is entry 3 System.out.printlnEntry three done This will print Entry one done Entry two done And the thread will be blocked after the second output. Section 33.5 LinkedList as a FIFO": "input.pdf", "Queue The java.util.LinkedList class, while implementing java.util.List is a general-purpose implementation of java.util.Queue interface too operating on a FIFO First In, First Out principle. In the example below, with offer method, the elements are inserted into the LinkedList . This insertion operation is called enqueue . In the while loop below, the elements are removed from the Queue based on FIFO. This operation is called dequeue . QueueString queue new LinkedList String queue.offer first element queue.offer second element queue.offer third element queue.offer fourth. element queue.offer fifth. element while !queue.isEmpty System.out.println queue.poll The output of this code is first element GoalKicker.com Java Notes for Professionals 186second element third element fourth element fifth element As seen in the output, the \ufb01rst inserted element \ufb01rst element is removed \ufb01rstly, second element is removed in the second place etc. Section 33.6 Queue Interface Basics A Queue is a collection for holding elements prior to processing. Queues typically, but not necessarily, order elements in a FIFO \ufb01rst-in-\ufb01rst-out manner. Head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. The Queue Interface": "input.pdf", "public interface QueueE extends Collection E boolean addE e boolean offerE e E remove E poll E element E peek Each Queue method exists in two forms one throws an exception if the operation fails other returns a special value if the operation fails either null or false depending on the operation. Type of operation Throws exception Returns special value Insert adde offere Remove remove poll Examine element peek GoalKicker.com Java Notes for Professionals 187Chapter 34 Dequeue Interface A Deque is linear collection that supports element insertion and removal at both ends. The name deque is short for double ended queue and is usually pronounced deck. Most Deque implementations place no \ufb01xed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no \ufb01xed size limit. The Deque interface is a richer abstract data type than both Stack and Queue because it implements both stacks and queues at same time Section 34.1 Adding Elements to Deque Deque deque new LinkedList Adding element at tail deque.addItem1 Adding element at head deque.addFirst Item2 Adding element at tail deque.addLastItem3 Section 34.2 Removing Elements from Deque Retrieves and removes the head of the": "input.pdf", "queue represented by this deque Object headItem deque.remove Retrieves and removes the first element of this deque. Object firstItem deque.removeFirst Retrieves and removes the last element of this deque. Object lastItem deque.removeLast Section 34.3 Retrieving Element without Removing Retrieves, but does not remove, the head of the queue represented by this deque Object headItem deque.element Retrieves, but does not remove, the first element of this deque. Object firstItem deque.getFirst Retrieves, but does not remove, the last element of this deque. Object lastItem deque.getLast Section 34.4 Iterating through Deque Using Iterator Iterator iterator deque.iterator whileiterator. hasNext String Item String iterator. next Using For Loop GoalKicker.com Java Notes for Professionals 188forObject object deque String Item String object GoalKicker.com Java Notes for Professionals 189Chapter 35 Enums Java enums declared using the enum keyword are shorthand syntax for sizable quantities of constants of a single class. Section 35.1 Declaring and using a basic enum Enum can be considered to be syntax sugar for a sealed class that is instantiated only a number of times known at compile-time to de\ufb01ne a set of constants. A simple enum to list the di\ufb00erent seasons would be declared as follows public enum Season WINTER, SPRING, SUMMER, FALL": "input.pdf", "While the enum constants dont necessarily need to be in all-caps, it is Java convention that names of constants are entirely uppercase, with words separated by underscores. You can declare an Enum in its own \ufb01le This enum is declared in the Season.java file. public enum Season WINTER, SPRING, SUMMER, FALL But you can also declare it inside another class public class Day private Season season public String getSeason return season. name public void setSeason String season this.season Season. valueOfseason This enum is declared inside the Day.java file and cannot be accessed outside because its declared as private. private enum Season WINTER, SPRING, SUMMER, FALL GoalKicker.com Java Notes for Professionals 190 Finally, you cannot declare an Enum inside a method body or constructor public class Day Constructor public Day Illegal. Compilation error enum Season WINTER, SPRING, SUMMER, FALL public void aSimpleMethod Legal. You can declare a primitive or an Object inside a method. Compile! int primitiveInt 42 Illegal. Compilation error. enum Season WINTER, SPRING, SUMMER, FALL Season season Season. SPRING Duplicate enum constants are not allowed public enum Season WINTER, WINTER, Compile Time Error Duplicate Constants SPRING, SUMMER, FALL Every constant of enum is public , static and final": "input.pdf", "by default. As every constant is static , they can be accessed directly using the enum name. Enum constants can be passed around as method parameters public static void display Season s System.out.printlns.name name is a built-in method that gets the exact name of the enum constant displaySeason.WINTER Prints out WINTER GoalKicker.com Java Notes for Professionals 191You can get an array of the enum constants using the values method. The values are guaranteed to be in declaration order in the returned array Season seasons Season. values Note this method allocates a new array of values each time it is called. To iterate over the enum constants public static void enumIterate for Season s Season. values System.out.printlns.name You can use enums in a switch statement public static void enumSwitchExample Season s switchs case WINTER System.out.printlnIts pretty cold break case SPRING System.out.printlnIts warming up break case SUMMER System.out.printlnIts pretty hot break case FALL System.out.printlnIts cooling down break You can also compare enum constants using Season.FALL Season. WINTER false Season.SPRING Season. SPRING true Another way to compare enum constants is by using equals as below, which is considered bad practice as you can easily fall into pitfalls as follows Season.FALL.equalsSeason.FALL true Season.FALL.equalsSeason.WINTER": "input.pdf", "false Season.FALL.equalsFALL false and no compiler error Furthermore, although the set of instances in the enum cannot be changed at run-time, the instances themselves are not inherently immutable because like any other class, an enum can contain mutable \ufb01elds as is demonstrated below. public enum MutableExample A, B private int count 0 public void increment GoalKicker.com Java Notes for Professionals 192 count public void print System.out.printlnThe count of name is count Usage MutableExample. A.print Outputs 0 MutableExample. A.increment MutableExample. A.print Outputs 1 -- weve changed a field MutableExample. B.print Outputs 0 -- another instance remains unchanged However, a good practice is to make enum instances immutable, i.e. when they either dont have any additional \ufb01elds or all such \ufb01elds are marked as final and are immutable themselves. This will ensure that for a lifetime of the application an enum wont leak any memory and that it is safe to use its instances across all threads. Enums implicitly implement Serializable and Comparable because the Enum class does public abstract class EnumE extends EnumE extends Object implements Comparable E, Serializable Section 35.2 Enums with constructors An enum cannot have a public constructor however, private constructors are acceptable constructors for enums are": "input.pdf", "package-private by default public enum Coin PENNY 1, NICKEL 5, DIME10, QUARTER 25 usual names for US coins note that the above parentheses and the constructor arguments match private int value Coin int value this.value value public int getValue return value int p Coin.NICKEL.getValue the int value will be 5 It is recommended that you keep all \ufb01elds private and provide getter methods, as there are a \ufb01nite number of instances for an enum. If you were to implement an Enum as a class instead, it would look like this public class CoinT extends CoinT implements Comparable T, Serializable public static final Coin PENNY new Coin1 public static final Coin NICKEL new Coin5 public static final Coin DIME new Coin10 public static final Coin QUARTER new Coin25 private int value GoalKicker.com Java Notes for Professionals 193 private Coinint value this.value value public int getValue return value int p Coin.NICKEL.getValue the int value will be 5 Enum constants are technically mutable, so a setter could be added to change the internal structure of an enum constant. However, this is considered very bad practice and should be avoided. Best practice is to make Enum \ufb01elds immutable, with final public enum Coin": "input.pdf", "PENNY 1, NICKEL 5, DIME10, QUARTER 25 private final int value Coin int value this.value value ... You may de\ufb01ne multiple constructors in the same enum. When you do, the arguments you pass in your enum declaration decide which constructor is called public enum Coin PENNY 1, true, NICKEL 5, false, DIME10, QUARTER 25 private final int value private final boolean isCopperColored Coin int value thisvalue, false Coin int value, boolean isCopperColored this.value value this.isCopperColored isCopperColored ... Note All non-primitive enum \ufb01elds should implement Serializable because the Enum class does. Section 35.3 Enums with Abstract Methods Enums can de\ufb01ne abstract methods, which each enum member is required to implement. enum Action DODGE GoalKicker.com Java Notes for Professionals 194 public boolean execute Player player return player. isAttacking , ATTACK public boolean execute Player player return player. hasWeapon , JUMP public boolean execute Player player return player. getCoordinates .equalsnew Coordinates 0, 0 public abstract boolean execute Player player This allows for each enum member to de\ufb01ne its own behaviour for a given operation, without having to switch on types in a method in the top-level de\ufb01nition. Note that this pattern is a short form of what is typically achieved using polymorphism": "input.pdf", "andor implementing interfaces. Section 35.4 Implements Interface This is an enum that is also a callable function that tests String inputs against precompiled regular expression patterns. import java.util.function.Predicate import java.util.regex.Pattern enum RegEx implements Predicate String UPPER A-Z , LOWERa-z , NUMERIC -?0-9 private final Pattern pattern private RegExfinal String pattern this.pattern Pattern. compilepattern Override public boolean testfinal String input return this.pattern.matcherinput.matches public class Main public static void mainString args System.out.printlnRegEx.UPPER.testABC System.out.printlnRegEx.LOWER.testabc System.out.printlnRegEx.NUMERIC.test111 Each member of the enum can also implement the method import java.util.function.Predicate GoalKicker.com Java Notes for Professionals 195enum Acceptor implements Predicate String NULL Override public boolean testString s return s null , EMPTY Override public boolean testString s return s.equals , NULLOREMPTY Override public boolean testString s return NULL.tests EMPTY.tests public class Main public static void mainString args System.out.printlnAcceptor. NULL.testnull true System.out.printlnAcceptor. EMPTY.test true System.out.printlnAcceptor. NULLOREMPTY .test false Section 35.5 Implement Singleton pattern with a single- element enum Enum constants are instantiated when an enum is referenced for the \ufb01rst time. Therefore, that allows to implement Singleton software design pattern with a single-element enum. public enum Attendant INSTANCE private Attendant perform some initialization routine public void sayHello System.out.printlnHello! public class Main public static void mainString... args Attendant.": "input.pdf", "INSTANCE .sayHello instantiated at this point According to E\ufb00ective Java book by Joshua Bloch, a single-element enum is the best way to implement a singleton. This approach has following advantages thread safety guarantee of single instantiation out-of-the-box serialization And as shown in the section implements interface this singleton might also implement one or more interfaces. GoalKicker.com Java Notes for Professionals 196Section 35.6 Using methods and static blocks An enum can contain a method, just like any class. To see how this works, well declare an enum like this public enum Direction NORTH, SOUTH, EAST, WEST Lets have a method that returns the enum in the opposite direction public enum Direction NORTH, SOUTH, EAST, WEST public Direction getOpposite switch this case NORTH return SOUTH case SOUTH return NORTH case WEST return EAST case EAST return WEST default This will never happen return null This can be improved further through the use of \ufb01elds and static initializer blocks public enum Direction NORTH, SOUTH, EAST, WEST private Direction opposite public Direction getOpposite return opposite static NORTH. opposite SOUTH SOUTH. opposite NORTH WEST. opposite EAST EAST. opposite WEST In this example, the opposite direction is stored in a private instance \ufb01eld opposite ,": "input.pdf", "which is statically initialized the \ufb01rst time a Direction is used. In this particular case because NORTH references SOUTH and conversely, we cannot use Enums with constructors here Constructors NORTHSOUTH, SOUTHNORTH, EASTWEST, WESTEAST would be more elegant and would allow opposite to be declared final , but would be self-referential and therefore are not allowed. Section 35.7 Zero instance enum enum Util No instances GoalKicker.com Java Notes for Professionals 197 public static int clampint min, int max, int i return Math.minMath.maxi, min, max other utility methods... Just as enum can be used for singletons 1 instance classes, it can be used for utility classes 0 instance classes. Just make sure to terminate the empty list of enum constants with a . See the question Zero instance enum vs private constructors for preventing instantiation for a discussion on pros and cons compared to private constructors. Section 35.8 Enum as a bounded type parameter When writing a class with generics in java, it is possible to ensure that the type parameter is an enum. Since all enums extend the Enum class, the following syntax may be used. public class HolderT extends EnumT public final T value public HolderT init this.value init": "input.pdf", "In this example, the type T must be an enum. Section 35.9 Documenting enums Not always the enum name is clear enough to be understood. To document an enum , use standard javadoc United States coins public enum Coins One-cent coin, commonly known as a penny, is a unit of currency equaling one-hundredth of a United States dollar PENNY 1, A nickel is a five-cent coin equaling five-hundredth of a United States dollar NICKEL 5, The dime is a ten-cent coin refers to one tenth of a United States dollar DIME 10, The quarter is a US coin worth 25 cents, one-fourth of a United States dollar GoalKicker.com Java Notes for Professionals 198 QUARTER 25 private int value Coins int value this.value value public int getValue return value Section 35.10 Enum constant speci\ufb01c body In an enum it is possible to de\ufb01ne a speci\ufb01c behavior for a particular constant of the enum which overrides the default behavior of the enum , this technique is known as constant speci\ufb01c body . Suppose three piano students - John, Ben and Luke - are de\ufb01ned in an enum named PianoClass , as follows enum PianoClass JOHN, BEN, LUKE public String getSex return": "input.pdf", "Male public String getLevel return Beginner And one day two other students arrive - Rita and Tom - with a sex Female and level Intermediate that do not match the previous ones enum PianoClass2 JOHN, BEN, LUKE, RITA, TOM public String getSex return Male issue, Rita is a female public String getLevel return Beginner issue, Tom is an intermediate student so that simply adding the new students to the constant declaration, as follows, is not correct PianoClass2 tom PianoClass2. TOM PianoClass2 rita PianoClass2. RITA System.out.printlntom.getLevel prints Beginner - wrong Toms not a beginner System.out.printlnrita.getSex prints Male - wrong Ritas not a male Its possible to de\ufb01ne a speci\ufb01c behavior for each of the constant, Rita and Tom, which overrides the PianoClass2 default behavior as follows enum PianoClass3 JOHN, BEN, LUKE, RITA Override GoalKicker.com Java Notes for Professionals 199 public String getSex return Female , TOM Override public String getLevel return Intermediate public String getSex return Male public String getLevel return Beginner and now Toms level and Ritas sex are as they should be PianoClass3 tom PianoClass3. TOM PianoClass3 rita PianoClass3. RITA System.out.printlntom.getLevel prints Intermediate System.out.printlnrita.getSex prints Female Another way to de\ufb01ne content speci\ufb01c body is by using constructor, for": "input.pdf", "instance enum Friend MATMale, JOHN Male, JANE Female private String gender Friend String gender this.gender gender public String getGender return this.gender and usage Friend mat Friend. MAT Friend john Friend. JOHN Friend jane Friend. JANE System.out.printlnmat.getGender Male System.out.printlnjohn.getGender Male System.out.printlnjane.getGender Female Section 35.11 Getting the values of an enum Each enum class contains an implicit static method named values. This method returns an array containing all values of that enum. You can use this method to iterate over the values. It is important to note however that this method returns a new array every time it is called. GoalKicker.com Java Notes for Professionals 200public enum Day MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY Print out all the values in this enum. public static void printAllDays forDay day Day.values System.out.printlnday.name If you need a Set you can use EnumSet. allOfDay.class as well. Section 35.12 Enum Polymorphism Pattern When a method need to accept an extensible set of enum values, the programmer can apply polymorphism like on a normal class by creating an interface which will be used anywere where the enum s shall be used public interface ExtensibleEnum String name This way, any enum tagged by implementing the interface can": "input.pdf", "be used as a parameter, allowing the programmer to create a variable amount of enum s that will be accepted by the method. This can be useful, for example, in APIs where there is a default unmodi\ufb01able enum and the user of these APIs want to extend the enum with more values. A set of default enum values can be de\ufb01ned as follows public enum DefaultValues implements ExtensibleEnum VALUEONE, VALUETWO Additional values can then be de\ufb01ned like this public enum ExtendedValues implements ExtensibleEnum VALUETHREE, VALUEFOUR Sample which shows how to use the enums - note how printEnum accepts values from both enum types private void printEnum ExtensibleEnum val System.out.printlnval.name printEnum DefaultValues. VALUEONE VALUEONE printEnum DefaultValues. VALUETWO VALUETWO printEnum ExtendedValues. VALUETHREE VALUETHREE printEnum ExtendedValues. VALUEFOUR VALUEFOUR Note This pattern does not prevent you from rede\ufb01ning enum values, which are already de\ufb01ned in one enum, in another enum. These enum values would be di\ufb00erent instances then. Also, it is not possible to use switch-on-enum since all we have is the interface, not the real enum . GoalKicker.com Java Notes for Professionals 201Section 35.13 Compare and Contains for Enum values Enums contains only constants and can be compared directly with . So,": "input.pdf", "only reference check is needed, no need to use .equals method. Moreover, if .equals used incorrectly, may raise the NullPointerException while thats not the case with check. enum Day GOOD, AVERAGE, WORST public class Test public static void mainString args Day day null if day.equalsDay.GOOD NullPointerException! System.out.printlnGood Day! if day Day.GOOD Always use to compare enum System.out.printlnGood Day! To group, complement, range the enum values we have EnumSet class which contains di\ufb00erent methods. EnumSetrange To get subset of enum by range de\ufb01ned by two endpoints EnumSetof Set of speci\ufb01c enums without any range. Multiple overloaded of methods are there. EnumSetcomplementOf Set of enum which is complement of enum values provided in method parameter enum Page A1, A2, A3, A4, A5, A6, A7, A8, A9, A10 public class Test public static void mainString args EnumSet Page range EnumSet. rangePage.A1, Page.A5 if range.contains Page.A4 System.out.printlnRange contains A4 EnumSet Page of EnumSet. ofPage.A1, Page.A5, Page.A3 if of.contains Page.A1 System.out.printlnOf contains A1 Section 35.14 Get enum constant by name Say we have an enum DayOfWeek GoalKicker.com Java Notes for Professionals 202enum DayOfWeek SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY An enum is compiled with a built-in static valueOf method which can be used": "input.pdf", "to lookup a constant by its name String dayName DayOfWeek. SUNDAY.name assert dayName. equalsSUNDAY DayOfWeek day DayOfWeek. valueOfdayName assert day DayOfWeek. SUNDAY This is also possible using a dynamic enum type ClassDayOfWeek enumType DayOfWeek. class DayOfWeek day Enum.valueOfenumType, SUNDAY assert day DayOfWeek. SUNDAY Both of these valueOf methods will throw an IllegalArgumentException if the speci\ufb01ed enum does not have a constant with a matching name. The Guava library provides a helper method Enums.getIfPresent that returns a Guava Optional to eliminate explicit exception handling DayOfWeek defaultDay DayOfWeek. SUNDAY DayOfWeek day Enums.valueOfDayOfWeek. class, INVALID .ordefaultDay assert day DayOfWeek. SUNDAY Section 35.15 Enum with properties \ufb01elds In case we want to use enum with more information and not just as constant values, and we want to be able to compare two enums. Consider the following example public enum Coin PENNY 1, NICKEL 5, DIME10, QUARTER 25 private final int value Coin int value this.value value public boolean isGreaterThan Coin other return this.value other.value Here we de\ufb01ned an Enum called Coin which represent its value. With the method isGreaterThan we can compare two enum s Coin penny Coin.PENNY Coin dime Coin.DIME System.out.printlnpenny.isGreaterThan dime prints false GoalKicker.com Java Notes for Professionals 203System.out.printlndime.isGreaterThan penny prints": "input.pdf", "true Section 35.16 Convert enum to String Sometimes you want to convert your enum to a String, there are two ways to do that. Assume we have public enum Fruit APPLE, ORANGE, STRAWBERRY, BANANA, LEMON, GRAPEFRUIT So how do we convert something like Fruit.APPLE to APPLE ? Convert using name name is an internal method in enum that returns the String representation of the enum, the return String represents exactly how the enum value was de\ufb01ned. For example System.out.printlnFruit.BANANA.name BANANA System.out.printlnFruit.GRAPEFRUIT .name GRAPEFRUIT Convert using toString toString is, by default , overridden to have the same behavior as name However, toString is likely overridden by developers to make it print a more user friendly String Dont use toString if you want to do checking in your code, name is much more stable for that. Only use toString when you are going to output the value to logs or stdout or something By default System.out.printlnFruit.BANANA.toString BANANA System.out.printlnFruit.GRAPEFRUIT .toString GRAPEFRUIT Example of being overridden System.out.printlnFruit.BANANA.toString Banana System.out.printlnFruit.GRAPEFRUIT .toString Grape Fruit Section 35.17 Enums with static \ufb01elds If your enum class is required to have static \ufb01elds, keep in mind they are created after the enum values themselves. That means, the following": "input.pdf", "code will result in a NullPointerException enum Example ONE1, TWO2 static MapString, Integer integers new HashMap private Example int value GoalKicker.com Java Notes for Professionals 204 integers. putthis.name, value A possible way to \ufb01x this enum Example ONE1, TWO2 static MapString, Integer integers private Example int value putValue this.name, value private static void putValue String name, int value if integers null integers new HashMap integers. putname, value Do not initialize the static \ufb01eld enum Example ONE1, TWO2 after initialisisation integers is null!! static MapString, Integer integers null private Example int value putValue this.name, value private static void putValue String name, int value if integers null integers new HashMap integers. putname, value !!this may lead to null poiner exception!! public int getValue return Example. integers .getthis.name initialisisation create the enum values as side e\ufb00ect putValue called that initializes integers the static values are set integers null is executed after the enums so the content of integers is lost GoalKicker.com Java Notes for Professionals 205Chapter 36 Enum Map Java EnumMap class is the specialized Map implementation for enum keys. It inherits Enum and AbstractMap classes. the Parameters for java.util.EnumMap class. K It is the type of keys maintained by this map.": "input.pdf", "V It is the type of mapped values. Section 36.1 Enum Map Book Example import java.util. class Book int id String name,author,publisher int quantity public Bookint id, String name, String author, String publisher, int quantity this.id id this.name name this.author author this.publisher publisher this.quantity quantity public class EnumMapExample Creating enum public enum Key One, Two, Three public static void mainString args EnumMap Key, Book map new EnumMap Key, BookKey.class Creating Books Book b1new Book101,Let us C ,Yashwant Kanetkar ,BPB,8 Book b2new Book102,Data Communications Networking ,Forouzan ,Mc Graw Hill ,4 Book b3new Book103,Operating System ,Galvin ,Wiley,6 Adding Books to Map map. putKey.One, b1 map. putKey.Two, b2 map. putKey.Three, b3 Traversing EnumMap forMap.EntryKey, Book entrymap.entrySet Book bentry.getValue System.out.printlnb.id b.name b.author b.publisher b.quantity GoalKicker.com Java Notes for Professionals 206Chapter 37 EnumSet class Java EnumSet class is the specialized Set implementation for use with enum types. It inherits AbstractSet class and implements the Set interface. Section 37.1 Enum Set Example import java.util. enum days SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY public class EnumSetExample public static void mainString args Setdays set EnumSet. ofdays.TUESDAY, days.WEDNESDAY Traversing elements Iterator days iter set.iterator while iter.hasNext System.out.printlniter.next GoalKicker.com Java Notes for Professionals 207Chapter 38 Enum starting with": "input.pdf", "number Java does not allow the name of enum to start with number like 100A, 25K. In that case, we can append the code with underscore or any allowed pattern and make check of it. Section 38.1 Enum with name at beginning public enum BookCode 10A Simon Haykin , Communication System , 42B Stefan Hakins , A Brief History of Time , E1Sedra Smith , Electronics Circuits private String author private String title BookCode String author, String title this.author author this.title title public String getName String name name if name.charAt0 name name.substring 1, name.length return name public static BookCode of String code if Character .isDigitcode.charAt0 code code return BookCode. valueOfcode GoalKicker.com Java Notes for Professionals 208Chapter 39 Hashtable Hashtable is a class in Java collections which implements Map interface and extends the Dictionary Class Contains only unique elements and its synchronized Section 39.1 Hashtable import java.util. public class HashtableDemo public static void mainString args create and populate hash table Hashtable Integer, String map new Hashtable Integer, String map.put101,C Language map.put102, Domain map.put104, Databases System.out.printlnValues before remove map Remove value for key 102 map.remove102 System.out.printlnValues after remove map GoalKicker.com Java Notes for Professionals 209Chapter 40 Operators Operators in Java programming": "input.pdf", "language are special symbols that perform speci\ufb01c operations on one, two, or three operands, and then return a result. Section 40.1 The IncrementDecrement Operators -- Variables can be incremented or decremented by 1 using the and -- operators, respectively. When the and -- operators follow variables, they are called post-increment and post-decrement respectively. int a 10 a a now equals 11 a-- a now equals 10 again When the and -- operators precede the variables the operations are called pre-increment and pre-decrement respectively. int x 10 --x x now equals 9 x x now equals 10 If the operator precedes the variable, the value of the expression is the value of the variable after being incremented or decremented. If the operator follows the variable, the value of the expression is the value of the variable prior to being incremented or decremented. int x10 System.out.printlnx x x x x x outputs x10 x10 x11 System.out.printlnx x x x x x outputs x11 x12 x12 System.out.printlnx x x x-- x x outputs x12 x12 x11 System.out.printlnx x x --x x x outputs x11 x10 x10 Be careful not to overwrite post-increments or decrements. This happens if you use a post-indecrement operator": "input.pdf", "at the end of an expression which is reassigned to the indecremented variable itself. The indecrement will not have an e\ufb00ect. Even though the variable on the left hand side is incremented correctly, its value will be immediately overwritten with the previously evaluated result from the right hand side of the expression int x 0 x x 1 x x 0 1 1 do not do this - the last increment has no effect bug! System.out.printlnx prints 2 not 3! Correct int x 0 x x 1 x evaluates to x 0 1 1 x adds 1 System.out.printlnx prints 3 Section 40.2 The Conditional Operator ? Syntax GoalKicker.com Java Notes for Professionals 210condition-to-evaluate ? statement-executed-on-true statement-executed-on-false As shown in the syntax, the Conditional Operator also known as the Ternary Operator1 uses the ? question mark and colon characters to enable a conditional expression of two possible outcomes. It can be used to replace longer if-else blocks to return one of two values based on condition. result testCondition ? value1 value2 Is equivalent to if testCondition result value1 else result value2 It can be read as If testCondition is true, set result to value1 otherwise, set result to value2 .": "input.pdf", "For example get absolute value using conditional operator a -10 int absValue a 0 ? -a a System.out.printlnabs absValue prints abs 10 Is equivalent to get absolute value using ifelse loop a -10 int absValue if a 0 absValue -a else absValue a System.out.printlnabs absValue prints abs 10 Common Usage You can use the conditional operator for conditional assignments like null checking. String x y ! null ? y.toString where y is an object This example is equivalent to String x if y ! null x y.toString Since the Conditional Operator has the second-lowest precedence, above the Assignment Operators, there is rarely a need for use parenthesis around the condition , but parenthesis is required around the entire Conditional Operator construct when combined with other operators no parenthesis needed for expressions in the 3 parts GoalKicker.com Java Notes for Professionals 21110 a a 19 ? b 5 b 7 parenthesis required 7 a 0 ? 2 5 Conditional operators nesting can also be done in the third part, where it works more like chaining or like a switch statement. a ? a is true b ? a is false, b is true c ? a and b are false,": "input.pdf", "c is true a, b, and c are false Operator precedence can be illustrated with parenthesis a ? x b ? y c ? z w Footnote 1 - Both the Java Language Speci\ufb01cation and the Java Tutorial call the ? operator the Conditional Operator . The Tutorial says that it is also known as the Ternary Operator as it is currently the only ternary operator de\ufb01ned by Java. The Conditional Operator terminology is consistent with C and C and other languages with an equivalent operator. Section 40.3 The Bitwise and Logical Operators , , , The Java language provides 4 operators that perform bitwise or logical operations on integer or boolean operands. The complement operator is a unary operator that performs a bitwise or logical inversion of the bits of one operand see JLS 15.15.5. . The AND operator is a binary operator that performs a bitwise or logical and of two operands see JLS 15.22.2. . The OR operator is a binary operator that performs a bitwise or logical inclusive or of two operands see JLS 15.22.2. . The XOR operator is a binary operator that performs a bitwise or logical exclusive or of two operands see": "input.pdf", "JLS 15.22.2. . The logical operations performed by these operators when the operands are booleans can be summarized as follows ABAA B A B A B 0010 0 0 0110 1 1 1000 1 1 1101 1 0 Note that for integer operands, the above table describes what happens for individual bits. The operators actually operate on all 32 or 64 bits of the operand or operands in parallel. Operand types and result types. The usual arithmetic conversions apply when the operands are integers. Common use-cases for the bitwise operators The operator is used to reverse a boolean value, or change all the bits in an integer operand. GoalKicker.com Java Notes for Professionals 212The operator is used for masking out some of the bits in an integer operand. For example int word 0b00101010 int mask 0b00000011 Mask for masking out all but the bottom two bits of a word int lowBits word mask - 0b00000010 int highBits word mask - 0b00101000 The operator is used to combine the truth values of two operands. For example int word2 0b01011111 Combine the bottom 2 bits of word1 with the top 30 bits of word2 int combined word mask word2 mask -": "input.pdf", "0b01011110 The operator is used for toggling or \ufb02ipping bits int word3 0b00101010 int word4 word3 mask - 0b00101001 For more examples of the use of the bitwise operators, see Bit Manipulation Section 40.4 The String Concatenation Operator The symbol can mean three distinct operators in Java If there is no operand before the , then it is the unary Plus operator. If there are two operands, and they are both numeric. then it is the binary Addition operator. If there are two operands, and at least one of them is a String , then it it the binary Concatenation operator. In the simple case, the Concatenation operator joins two strings to give a third string. For example String s1 a String String s2 This is s1 s2 contains This is a String When one of the two operands is not a string, it is converted to a String as follows An operand whose type is a primitive type is converted as if by calling toString on the boxed value. An operand whose type is a reference type is converted by calling the operands toString method. If the operand is null , or if the toString method returns null": "input.pdf", ", then the string literal null is used instead. For example int one 1 String s3 One is one s3 contains One is 1 String s4 null is null s4 contains null is null String s5 1 is new int1 s5 contains something like is Ixxxxxxxx The explanation for the s5 example is that the toString method on array types is inherited from java.lang.Object , and the behavior is to produce a string that consists of the type name, and the objects identity hashcode. The Concatenation operator is speci\ufb01ed to create a new String object, except in the case where the expression is a Constant Expression. In the latter case, the expression is evaluated at compile type, and its runtime value is GoalKicker.com Java Notes for Professionals 213equivalent to a string literal. This means that there is no runtime overhead in splitting a long string literal like this String typing The quick brown fox jumped over the lazy dog constant expression Optimization and e\ufb03ciency As noted above, with the exception of constant expressions, each string concatenation expression creates a new String object. Consider this code public String starsint count String res for int i 0 i count i res": "input.pdf", "res return res In the method above, each iteration of the loop will create a new String that is one character longer than the previous iteration. Each concatenation copies all of the characters in the operand strings to form the new String . Thus, starsN will create N new String objects, and throw away all but the last one, copy N N 1 2 characters, and generate ON2 bytes of garbage. This is very expensive for large N. Indeed, any code that concatenates strings in a loop is liable to have this problem. A better way to write this would be as follows public String starsint count Create a string builder with capacity count StringBuilder sb new StringBuilder count for int i 0 i count i sb. append return sb.toString Ideally, you should set the capacity of the StringBuilder , but if this is not practical, the class will automatically grow the backing array that the builder uses to hold characters. Note the implementation expands the backing array exponentially. This strategy keeps that amount of character copying to a ON rather than ON2. Some people apply this pattern to all string concatenations. However, this is unnecessary because the JLS": "input.pdf", "allows a Java compiler to optimize string concatenations within a single expression. For example String s1 ... String s2 ... String test Hello s1 . Welcome to s2 n will typically be optimized by the bytecode compiler to something like this StringBuilder tmp new StringBuilder tmp.appendHello tmp.appends1 null ? null s1 tmp.appendWelcome to GoalKicker.com Java Notes for Professionals 214tmp.appends2 null ? null s2 tmp.appendn String test tmp.toString The JIT compiler may optimize that further if it can deduce that s1 or s2 cannot be null . But note that this optimization is only permitted within a single expression. In short, if you are concerned about the e\ufb03ciency of string concatenations Do hand-optimize if you are doing repeated concatenation in a loop or similar. Dont hand-optimize a single concatenation expression. Section 40.5 The Arithmetic Operators , -, , , The Java language provides 7 operators that perform arithmetic on integer and \ufb02oating point values. There are two operators The binary addition operator adds one number to another one. There is also a binary operator that performs string concatenation. That is described in a separate example. The unary plus operator does nothing apart from triggering numeric promotion see below There are": "input.pdf", "two - operators The binary subtraction operator subtracts one number from another one. The unary minus operator is equivalent to subtracting its operand from zero. The binary multiply operator multiplies one number by another. The binary divide operator divides one number by another. The binary remainder1 operator calculates the remainder when one number is divided by another. 1. This is often incorrectly referred to as the modulus operator. Remainder is the term that is used by the JLS. Modulus and remainder are not the same thing. Operand and result types, and numeric promotion The operators require numeric operands and produce numeric results. The operand types can be any primitive numeric type i.e. byte , short , char , int, long , float or double or any numeric wrapper type de\ufb01ne in java.lang i.e. Byte , Character , Short , Integer , Long , Float or Double . The result type is determined base on the types of the operand or operands, as follows If either of the operands is a double or Double , then the result type is double . Otherwise, if either of the operands is a float or Float , then the result type is float": "input.pdf", ". Otherwise, if either of the operands is a long or Long , then the result type is long . Otherwise, the result type is int. This covers byte , short and char operands as well as int. The result type of the operation determines how the arithmetic operation is performed, and how the operands are handled If the result type is double , the operands are promoted to double , and the operation is performed using 64- bit double precision binary IEE 754 \ufb02oating point arithmetic. If the result type is float , the operands are promoted to float , and the operation is performed using 32-bit single precision binary IEE 754 \ufb02oating point arithmetic. If the result type is long , the operands are promoted to long , and the operation is performed using 64-bit signed twos-complement binary integer arithmetic. If the result type is int, the operands are promoted to int, and the operation is performed using 32-bit signed twos-complement binary integer arithmetic. GoalKicker.com Java Notes for Professionals 215Promotion is performed in two stages If the operand type is a wrapper type, the operand value is unboxed to a value of the corresponding primitive type. If": "input.pdf", "necessary, the primitive type is promoted to the required type Promotion of integers to int or long is loss-less. Promotion of float to double is loss-less. Promotion of an integer to a \ufb02oating point value can lead to loss of precision. The conversion is performed using IEE 768 round-to-nearest semantics. The meaning of division The operator divides the left-hand operand n the dividend and the right-hand operand d the divisor and produces the result q the quotient . Java integer division rounds towards zero. The JLS Section 15.17.2 speci\ufb01es the behavior of Java integer division as follows The quotient produced for operands n and d is an integer value q whose magnitude is as large as possible while satisfying d q n. Moreover, q is positive when n d and n and d have the same sign, but q is negative when n d and n and d have opposite signs. There are a couple of special cases If the n is MINVALUE , and the divisor is -1, then integer over\ufb02ow occurs and the result is MINVALUE . No exception is thrown in this case. If d is 0, then ArithmeticException is thrown. Java \ufb02oating point division has": "input.pdf", "more edge cases to consider. However the basic idea is that the result q is the value that is closest to satisfying d . q n. Floating point division will never result in an exception. Instead, operations that divide by zero result in an INF and NaN values see below. The meaning of remainder Unlike C and C, the remainder operator in Java works with both integer and \ufb02oating point operations. For integer cases, the result of a b is de\ufb01ned to be the number r such that a b b r is equal to a, where , and are the appropriate Java integer operators. This applies in all cases except when b is zero. That case, remainder results in an ArithmeticException . It follows from the above de\ufb01nition that a b can be negative only if a is negative, and it be positive only if a is positive. Moreover, the magnitude of a b is always less than the magnitude of b. Floating point remainder operation is a generalization of the integer case. The result of a b is the remainder r is de\ufb01ned by the mathematical relation r a - b q where q is an integer,": "input.pdf", "it is negative only if a b is negative an positive only if a b is positive, and its magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of a and b. GoalKicker.com Java Notes for Professionals 216Floating point remainder can produce INF and NaN values in edge-cases such as when b is zero see below. It will not throw an exception. Important note The result of a \ufb02oating-point remainder operation as computed by is not the same as that produced by the remainder operation de\ufb01ned by IEEE 754. The IEEE 754 remainder may be computed using the Math.IEEEremainder library method. Integer Over\ufb02ow Java 32 and 64 bit integer values are signed and use twos-complement binary representation. For example, the range of numbers representable as 32 bit int -231 through 231 - 1. When you add, subtract or multiple two N bit integers N 32 or 64, the result of the operation may be too large to represent as an N bit integer. In this case, the operation leads to integer over\ufb02ow , and the result can be computed as follows The mathematical operation is performed to give a intermediate twos-complement representation of": "input.pdf", "the entire number. This representation will be larger than N bits. The bottom 32 or 64 bits of the intermediate representation are used as the result. It should be noted that integer over\ufb02ow does not result in exceptions under any circumstances. Floating point INF and NAN values Java uses IEE 754 \ufb02oating point representations for float and double . These representations have some special values for representing values that fall outside of the domain of Real numbers The in\ufb01nite or INF values denote numbers that are too large. The INF value denote numbers that are too large and positive. The -INF value denote numbers that are too large and negative. The inde\ufb01nite not a number or NaN denote values resulting from meaningless operations. The INF values are produced by \ufb02oating operations that cause over\ufb02ow, or by division by zero. The NaN values are produced by dividing zero by zero, or computing zero remainder zero. Surprisingly, it is possible perform arithmetic using INF and NaN operands without triggering exceptions. For example Adding INF and a \ufb01nite value gives INF. Adding INF and INF gives INF. Adding INF and -INF gives NaN. Dividing by INF gives either 0.0 or -0.0. All": "input.pdf", "operations with one or more NaN operands give NaN. For full details, please refer to the relevant subsections of JLS 15 . Note that this is largely academic. For typical calculations, an INF or NaN means that something has gone wrong e.g. you have incomplete or incorrect input data, or the calculation has been programmed incorrectly. Section 40.6 The Shift Operators , and The Java language provides three operator for performing bitwise shifting on 32 and 64 bit integer values. These GoalKicker.com Java Notes for Professionals 217are all binary operators with the \ufb01rst operand being the value to be shifted, and the second operand saying how far to shift. The or left shift operator shifts the value given by the \ufb01rst operand leftwards by the number of bit positions given by the second operand. The empty positions at the right end are \ufb01lled with zeros. The or arithmetic shift operator shifts the value given by the \ufb01rst operand rightwards by the number of bit positions given by the second operand. The empty positions at the left end are \ufb01lled by copying the left-most bit. This process is known as sign extension . The or logical right shift operator shifts": "input.pdf", "the value given by the \ufb01rst operand rightwards by the number of bit positions given by the second operand. The empty positions at the left end are \ufb01lled with zeros. Notes These operators require an int or long value as the \ufb01rst operand, and produce a value with the same type as 1. the \ufb01rst operand. You will need to use an explicit type cast when assigning the result of a shift to a byte , short or char variable. If you use a shift operator with a \ufb01rst operand that is a byte , char or short , it is promoted to an int and the 2. operation produces an int. The second operand is reduced modulo the number of bits of the operation to give the amount of the shift. For 3. more about the mod mathematical concept , see Modulus examples. The bits that are shifted o\ufb00 the left or right end by the operation are discarded. Java does not provide a4. primitive rotate operator. The arithmetic shift operator is equivalent dividing a twos complement number by a power of 2.5. The left shift operator is equivalent multiplying a twos complement number by a power of": "input.pdf", "2.6. The following table will help you see the e\ufb00ects of the three shift operators. The numbers have been expressed in binary notation to aid vizualization. Operand1 Operand2 0b0000000000001011 0 0b0000000000001011 0b0000000000001011 0b0000000000001011 0b0000000000001011 1 0b0000000000010110 0b0000000000000101 0b0000000000000101 0b0000000000001011 2 0b0000000000101100 0b0000000000000010 0b0000000000000010 0b0000000000001011 28 0b1011000000000000 0b0000000000000000 0b0000000000000000 0b0000000000001011 31 0b1000000000000000 0b0000000000000000 0b0000000000000000 0b0000000000001011 32 0b0000000000001011 0b0000000000001011 0b0000000000001011 ... ... ... ... ... 0b1000000000001011 0 0b1000000000001011 0b1000000000001011 0b1000000000001011 0b1000000000001011 1 0b0000000000010110 0b1100000000000101 0b0100000000000101 0b1000000000001011 2 0b0000000000101100 0b1110000000000010 0b00100000000000100 0b1000000000001011 31 0b1000000000000000 0b1111111111111111 0b0000000000000001 There examples of the user of shift operators in Bit manipulation Section 40.7 The Instanceof Operator This operator checks whether the object is of a particular classinterface type. instanceof operator is written as GoalKicker.com Java Notes for Professionals 218 Object reference variable instanceof classinterface type Example public class Test public static void mainString args String name Buyya following will return true since name is type of String boolean result name instanceof String System.out.println result This would produce the following result true This operator will still return true if the object being compared is the assignment compatible with the type on the right. Example class Vehicle public class Car extends Vehicle public static void mainString args Vehicle": "input.pdf", "a new Car boolean result a instanceof Car System.out.println result This would produce the following result true Section 40.8 The Assignment Operators , , -, , , , , , , , and The left hand operand for these operators must be a either a non-\ufb01nal variable or an element of an array. The right hand operand must be assignment compatible with the left hand operand. This means that either the types must be the same, or the right operand type must be convertible to the left operands type by a combination of boxing, unboxing or widening. For complete details refer to JLS 5.2 . The precise meaning of the operation and assign operators is speci\ufb01ed by JLS 15.26.2 as A compound assignment expression of the form E1 op E2 is equivalent to E1 T E1 op E2, where T is the type of E1, except that E1 is evaluated only once. Note that there is an implicit type-cast before the \ufb01nal assignment. 1. GoalKicker.com Java Notes for Professionals 219The simple assignment operator assigns the value of the right hand operand to the left hand operand. Example c a b will add the value of a b to the": "input.pdf", "value of c and assign it to c 2. The add and assign operator adds the value of right hand operand to the value of the left hand operand and assigns the result to left hand operand. If the left hand operand has type String , then this a concatenate and assign operator. Example c a is roughly the same as c c a 3. - The subtract and assign operator subtracts the value of the right operand from the value of the left hand operand and assign the result to left hand operand. Example c - a is roughly the same as c c - a 4. The multiply and assign operator multiplies the value of the right hand operand by the value of the left hand operand and assign the result to left hand operand. . Example c a is roughly the same as c c a 5. The divide and assign operator divides the value of the right hand operand by the value of the left hand operand and assign the result to left hand operand. Example c a is roughly the same as c c a 6. The modulus and assign operator calculates the modulus": "input.pdf", "of the value of the right hand operand by the value of the left hand operand and assign the result to left hand operand. Example c a is roughly the same as c c a 7. The left shift and assign operator. Example c 2 is roughly the same as c c 2 GoalKicker.com Java Notes for Professionals 2208. The arithmetic right shift and assign operator. Example c 2 is roughly the same as c c 2 9. The logical right shift and assign operator. Example c 2 is roughly the same as c c 2 10. The bitwise and and assign operator. Example c 2 is roughly the same as c c 2 11. The bitwise or and assign operator. Example c 2 is roughly the same as c c 2 12. The bitwise exclusive or and assign operator. Example c 2 is roughly the same as c c 2 Section 40.9 The conditional-and and conditional-or Operators and Java provides a conditional-and and a conditional-or operator, that both take one or two operands of type boolean and produce a boolean result. These are - the conditional-AND operator, - the conditional-OR operators. The evaluation of left-expr right-expr is equivalent": "input.pdf", "to the following pseudo-code boolean L evaluate left-expr if L return evaluate right-expr else short-circuit the evaluation of the 2nd operand expression return false GoalKicker.com Java Notes for Professionals 221 The evaluation of left-expr right-expr is equivalent to the following pseudo-code boolean L evaluate left-expr if !L return evaluate right-expr else short-circuit the evaluation of the 2nd operand expression return true As the pseudo-code above illustrates, the behavior of the short-circuit operators are equivalent to using if else statements. Example - using as a guard in an expression The following example shows the most common usage pattern for the operator. Compare these two versions of a method to test if a supplied Integer is zero. public boolean isZeroInteger value return value 0 public boolean isZeroInteger value return value ! null value 0 The \ufb01rst version works in most cases, but if the value argument is null , then a NullPointerException will be thrown. In the second version we have added a guard test. The value ! null value 0 expression is evaluated by \ufb01rst performing the value ! null test. If the null test succeeds i.e. it evaluates to true then the value 0 expression is evaluated. If the": "input.pdf", "null test fails, then the evaluation of value 0 is skipped short-circuited, and we dont get a NullPointerException . Example - using to avoid a costly calculation The following example shows how can be used to avoid a relatively costly calculation public boolean verifyint value, boolean needPrime return !needPrime isPrime value public boolean verifyint value, boolean needPrime return !needPrime isPrime value In the \ufb01rst version, both operands of the will always be evaluated, so the expensive isPrime method will be called unnecessarily. The second version avoids the unnecessary call by using instead of . Section 40.10 The Relational Operators , , , The operators , , and are binary operators for comparing numeric types. The meaning of the operators is as GoalKicker.com Java Notes for Professionals 222you would expect. For example, if a and b are declared as any of byte , short , char , int, long , float , double or the corresponding boxed types - a b tests if the value of a is less than the value of b. - a b tests if the value of a is less than or equal to the value of b. - a b tests if the value": "input.pdf", "of a is greater than the value of b. - a b tests if the value of a is greater than or equal to the value of b. The result type for these operators is boolean in all cases. Relational operators can be used to compare numbers with di\ufb00erent types. For example int i 1 long l 2 if i l System.out.printlni is smaller Relational operators can be used when either or both numbers are instances of boxed numeric types. For example Integer i 1 1 is autoboxed to an Integer Integer j 2 2 is autoboxed to an Integer if i j System.out.printlni is smaller The precise behavior is summarized as follows If one of the operands is a boxed type, it is unboxed.1. If either of the operands now a byte , short or char , it is promoted to an int. 2. If the types of the operands are not the same, then the operand with the smaller type is promoted to the3. larger type. The comparison is performed on the resulting int, long , float or double values. 4. You need to be careful with relational comparisons that involve \ufb02oating point numbers Expressions that compute": "input.pdf", "\ufb02oating point numbers often incur rounding errors due to the fact that the computer \ufb02oating-point representations have limited precision. When comparing an integer type and a \ufb02oating point type, the conversion of the integer to \ufb02oating point can also lead to rounding errors. Finally, Java does bit support the use of relational operators with any types other than the ones listed above. For example, you cannot use these operators to compare strings, arrays of numbers, and so on. Section 40.11 The Equality Operators , ! The and ! operators are binary operators that evaluate to true or false depending on whether the operands are equal. The operator gives true if the operands are equal and false otherwise. The ! operator gives false if the operands are equal and true otherwise. These operators can be used operands with primitive and reference types, but the behavior is signi\ufb01cantly di\ufb00erent. According to the JLS, there are actually three distinct sets of these operators The Boolean and ! operators. The Numeric and ! operators. GoalKicker.com Java Notes for Professionals 223The Reference and ! operators. However, in all cases, the result type of the and ! operators is boolean . The Numeric and !": "input.pdf", "operators When one or both of the operands of an or ! operator is a primitive numeric type byte , short , char , int, long , float or double , the operator is a numeric comparison. The second operand must be either a primitive numeric type, or a boxed numeric type. The behavior other numeric operators is as follows If one of the operands is a boxed type, it is unboxed.1. If either of the operands now a byte , short or char , it is promoted to an int. 2. If the types of the operands are not the same, then the operand with the smaller type is promoted to the3. larger type. The comparison is then carried out as follows4. If the promoted operands are int or long then the values are tested to see if they are identical. If the promoted operands are float or double then the two versions of zero 0.0 and -0.0 are treated as equal a NaN value is treated as not equals to anything, and other values are equal if their IEEE 754 representations are identical. Note you need to be careful when using and ! to compare \ufb02oating point": "input.pdf", "values. The Boolean and ! operators If both operands are boolean , or one is boolean and the other is Boolean , these operators the Boolean and ! operators. The behavior is as follows If one of the operands is a Boolean , it is unboxed. 1. The unboxed operands are tested and the boolean result is calculated according to the following truth table2. A BA B A ! B false false true false false true false true true false false true true true true false There are two pitfalls that make it advisable to use and ! sparingly with truth values If you use or ! to compare two Boolean objects, then the Reference operators are used. This may give an unexpected result see Pitfall using to compare primitive wrappers objects such as Integer The operator can easily be mistyped as . For most operand types, this mistake leads to a compilation error. However, for boolean and Boolean operands the mistake leads to incorrect runtime behavior see Pitfall - Using to test a boolean The Reference and ! operators If both operands are object references, the and ! operators test if the two operands refer to the same": "input.pdf", "object . This often not what you want. To test if two objects are equal by value , the .equals method should be used instead. GoalKicker.com Java Notes for Professionals 224String s1 We are equal String s2 new StringWe are equal s1.equalss2 true WARNING - dont use or ! with String values s1 s2 false Warning using and ! to compare String values is incorrect in most cases see httpstackover\ufb02ow.comdocumentationjava4388java-pitfalls16290using-to-compare-strings . A similar problem applies to primitive wrapper types see httpstackover\ufb02ow.comdocumentationjava4388java-pitfalls8996using-to-compare-primitive-wrappers-objects -such-as-integer . About the NaN edge-cases JLS 15.21.1 states the following If either operand is NaN, then the result of is false but the result of ! is true . Indeed, the test x ! x is true if and only if the value of x is NaN. This behavior is to most programmers unexpected. If you test if a NaN value is equal to itself, the answer is No it isnt!. In other words, is not re\ufb02exive for NaN values. However, this is not a Java oddity, this behavior is speci\ufb01ed in the IEEE 754 \ufb02oating-point standards, and you will \ufb01nd that it is implemented by most modern programming languages. For more information, see httpstackover\ufb02ow.coma1573715139985 ... noting": "input.pdf", "that this is written by someone who was in the room when the decisions were made! Section 40.12 The Lambda operator - From Java 8 onwards, the Lambda operator - is the operator used to introduce a Lambda Expression. There are two common syntaxes, as illustrated by these examples Version Java SE 8 a - a 1 a lambda that adds one to its argument a - return a 1 an equivalent lambda using a block. A lambda expression de\ufb01nes an anonymous function, or more correctly an instance of an anonymous class that implements a functional interface . This example is included here for completeness. Refer to the Lambda Expressions topic for the full treatment. GoalKicker.com Java Notes for Professionals 225Chapter 41 Constructors While not required, constructors in Java are methods recognized by the compiler to instantiate speci\ufb01c values for the class which may be essential to the role of the object. This topic demonstrates proper usage of Java class constructors. Section 41.1 Default Constructor The default for constructors is that they do not have any arguments. In case you do not specify any constructor, the compiler will generate a default constructor for you. This means the following two": "input.pdf", "snippets are semantically equivalent public class TestClass private String test public class TestClass private String test public TestClass The visibility of the default constructor is the same as the visibility of the class. Thus a class de\ufb01ned package- privately has a package-private default constructor However, if you have non-default constructor, the compiler will not generate a default constructor for you. So these are not equivalent public class TestClass private String test public TestClass String arg public class TestClass private String test public TestClass public TestClass String arg Beware that the generated constructor performs no non-standard initialization. This means all \ufb01elds of your class will have their default value, unless they have an initializer. public class TestClass private String testData public TestClass testData Test Constructors are called like this GoalKicker.com Java Notes for Professionals 226TestClass testClass new TestClass Section 41.2 Call parent constructor Say you have a Parent class and a Child class. To construct a Child instance always requires some Parent constructor to be run at the very gebinning of the Child constructor. We can select the Parent constructor we want by explicitly calling super... with the appropriate arguments as our \ufb01rst Child constructor statement. Doing this saves us": "input.pdf", "time by reusing the Parent classes constructor instead of rewriting the same code in the Child classes constructor. Without super... method implicitly, the no-args version super is called invisibly class Parent private String name private int age public Parent necessary because we call super without arguments public ParentString tName, int tAge name tName age tAge This does not even compile, because name and age are private, making them invisible even to the child class. class Child extends Parent public Child compiler implicitly calls super here name John age 42 With super method class Parent private String name private int age public ParentString tName, int tAge name tName age tAge class Child extends Parent public Child superJohn, 42 explicit super-call Note Calls to another constructor chaining or the super constructor MUST be the \ufb01rst statement inside the constructor. If you call the super... constructor explicitly, a matching parent constructor must exist thats straightforward, isnt it?. GoalKicker.com Java Notes for Professionals 227If you dont call any super... constructor explicitly, your parent class must have a no-args constructor - and this can be either written explicitly or created as a default by the compiler if the parent class doesnt provide any constructor.": "input.pdf", "class Parent public ParentString tName, int tAge class Child extends Parent public Child The class Parent has no default constructor, so, the compiler cant add super in the Child constructor. This code will not compile. You must change the constructors to \ufb01t both sides, or write your own super call, like that class Child extends Parent public Child super,0 Section 41.3 Constructor with Arguments Constructors can be created with any kinds of arguments. public class TestClass private String testData public TestClass String testData this.testData testData Called like this TestClass testClass new TestClass Test Data A class can have multiple constructors with di\ufb00erent signatures. To chain constructor calls call a di\ufb00erent constructor of the same class when instantiating use this. public class TestClass private String testData public TestClass String testData this.testData testData public TestClass thisTest testData defaults to Test Called like this TestClass testClass1 new TestClass Test Data GoalKicker.com Java Notes for Professionals 228TestClass testClass2 new TestClass GoalKicker.com Java Notes for Professionals 229Chapter 42 Object Class Methods and Constructor This documentation page is for showing details with example about java class constructors and about Object Class Methods which are automatically inherited from the superclass Object of any newly created class.": "input.pdf", "Section 42.1 hashCode method When a Java class overrides the equals method, it should override the hashCode method as well. As de\ufb01ned in the methods contract Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modi\ufb01ed. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equalsObject method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the equalsObject method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. Hash codes are used in hash implementations such as HashMap , HashTable , and HashSet . The result of the hashCode function determines the bucket in which an object will be put. These hash implementations are": "input.pdf", "more e\ufb03cient if the provided hashCode implementation is good. An important property of good hashCode implementation is that the distribution of the hashCode values is uniform. In other words, there is a small probability that numerous instances will be stored in the same bucket. An algorithm for computing a hash code value may be similar to the following public class Foo private int field1, field2 private String field3 public Fooint field1, int field2, String field3 this.field1 field1 this.field2 field2 this.field3 field3 Override public boolean equalsObject obj if this obj return true if obj null getClass ! obj.getClass return false Foo f Foo obj return field1 f.field1 field2 f.field2 field3 null ? f.field3 null field3. equalsf.field3 GoalKicker.com Java Notes for Professionals 230 Override public int hashCode int hash 1 hash 31 hash field1 hash 31 hash field2 hash 31 hash field3 null ? 0 field3. hashCode return hash Using Arrays.hashCode as a short cut Version Java SE 1.2 In Java 1.2 and above, instead of developing an algorithm to compute a hash code, one can be generated using java.util.ArrayshashCode by supplying an Object or primitives array containing the \ufb01eld values Override public int hashCode return Arrays.hashCode new Object field1, field2,": "input.pdf", "field3 Version Java SE 7 Java 1.7 introduced the java.util.Objects class which provides a convenience method, hashObject... objects, that computes a hash code based on the values of the objects supplied to it. This method works just like java.util.ArrayshashCode . Override public int hashCode return Objects. hashfield1, field2, field3 Note this approach is ine\ufb03cient, and produces garbage objects each time your custom hashCode method is called A temporary Object is created. In the Objects. hash version, the array is created by the varargs mechanism. If any of the \ufb01elds are primitive types, they must be boxed and that may create more temporary objects. The array must be populated. The array must iterated by the Arrays.hashCode or Objects. hash method. The calls to Object.hashCode that Arrays.hashCode or Objects. hash has to make probably cannot be inlined. Internal caching of hash codes Since the calculation of an objects hash code can be expensive, it can be attractive to cache the hash code value within the object the \ufb01rst time that it is calculated. For example public final class ImmutableArray private int array private volatile int hash 0 public ImmutableArray int initial array initial. clone Other methods GoalKicker.com Java Notes for Professionals": "input.pdf", "231 Override public boolean equalsObject obj ... Override public int hashCode int h hash if h 0 h Arrays.hashCode array hash h return h This approach trades o\ufb00 the cost of repeatedly calculating the hash code against the overhead of an extra \ufb01eld to cache the hash code. Whether this pays o\ufb00 as a performance optimization will depend on how often a given object is hashed looked up and other factors. You will also notice that if the true hashcode of an ImmutableArray happens to be zero one chance in 232, the cache is ine\ufb00ective. Finally, this approach is much harder to implement correctly if the object we are hashing is mutable. However, there are bigger concerns if hash codes change see the contract above. Section 42.2 toString method The toString method is used to create a String representation of an object by using the object s content. This method should be overridden when writing your class. toString is called implicitly when an object is concatenated to a string as in hello anObject . Consider the following public class User private String firstName private String lastName public UserString firstName, String lastName this.firstName firstName this.lastName lastName Override public String toString": "input.pdf", "return firstName lastName public static void mainString args User user new UserJohn, Doe System.out.printlnuser.toString Prints John Doe Here toString from Object class is overridden in the User class to provide meaningful data regarding the object when printing it. When using println, the objects toString method is implicitly called. Therefore, these statements do the GoalKicker.com Java Notes for Professionals 232same thing System.out.printlnuser toString is implicitly called on user System.out.printlnuser.toString If the toString is not overridden in the above mentioned User class, System.out.printlnuser may return User659e0bfd or a similar String with almost no useful information except the class name. This will be because the call will use the toString implementation of the base Java Object class which does not know anything about the User classs structure or business rules. If you want to change this functionality in your class, simply override the method. Section 42.3 equals method TLDR tests for reference equality whether they are the same object .equals tests for value equality whether they are logically equal equals is a method used to compare two objects for equality. The default implementation of the equals method in the Object class returns true if and only if both references are pointing to": "input.pdf", "the same instance. It therefore behaves the same as comparison by . public class Foo int field1, field2 String field3 public Fooint i, int j, String k field1 i field2 j field3 k public static void mainString args Foo foo1 new Foo0, 0, bar Foo foo2 new Foo0, 0, bar System.out.printlnfoo1.equalsfoo2 prints false Even though foo1 and foo2 are created with the same \ufb01elds, they are pointing to two di\ufb00erent objects in memory. The default equals implementation therefore evaluates to false . To compare the contents of an object for equality, equals has to be overridden. public class Foo int field1, field2 String field3 public Fooint i, int j, String k field1 i field2 j field3 k Override GoalKicker.com Java Notes for Professionals 233 public boolean equalsObject obj if this obj return true if obj null getClass ! obj.getClass return false Foo f Foo obj return field1 f.field1 field2 f.field2 field3 null ? f.field3 null field3. equalsf.field3 Override public int hashCode int hash 1 hash 31 hash this.field1 hash 31 hash this.field2 hash 31 hash field3 null ? 0 field3. hashCode return hash public static void mainString args Foo foo1 new Foo0, 0, bar Foo foo2 new Foo0, 0,": "input.pdf", "bar System.out.printlnfoo1.equalsfoo2 prints true Here the overridden equals method decides that the objects are equal if their \ufb01elds are the same. Notice that the hashCode method was also overwritten. The contract for that method states that when two objects are equal, their hash values must also be the same. Thats why one must almost always override hashCode and equals together. Pay special attention to the argument type of the equals method. It is Object obj , not Foo obj . If you put the latter in your method, that is not an override of the equals method. When writing your own class, you will have to write similar logic when overriding equals and hashCode . Most IDEs can automatically generate this for you. An example of an equals implementation can be found in the String class, which is part of the core Java API. Rather than comparing pointers, the String class compares the content of the String . Version Java SE 7 Java 1.7 introduced the java.util.Objects class which provides a convenience method, equals , that compares two potentially null references, so it can be used to simplify implementations of the equals method. Override public boolean equalsObject obj if": "input.pdf", "this obj return true if obj null getClass ! obj.getClass return false GoalKicker.com Java Notes for Professionals 234 Foo f Foo obj return field1 f.field1 field2 f.field2 Objects. equalsfield3, f. field3 Class Comparison Since the equals method can run against any object, one of the \ufb01rst things the method often does after checking for null is to check if the class of the object being compared matches the current class. Override public boolean equalsObject obj ...check for null if getClass ! obj.getClass return false ...compare fields This is typically done as above by comparing the class objects. However, that can fail in a few special cases which may not be obvious. For example, some frameworks generate dynamic proxies of classes and these dynamic proxies are actually a di\ufb00erent class. Here is an example using JPA. Foo detachedInstance ... Foo mergedInstance entityManager. mergedetachedInstance if mergedInstance. equalsdetachedInstance Can never get here if equality is tested with getClass as mergedInstance is a proxy subclass of Foo One mechanism to work around that limitation is to compare classes using instanceof Override public final boolean equalsObject obj if !obj instanceof Foo return false ...compare fields However, there are a few pitfalls that must be": "input.pdf", "avoided when using instanceof . Since Foo could potentially have other subclasses and those subclasses might override equals you could get into a case where a Foo is equal to a FooSubclass but the FooSubclass is not equal to Foo. Foo foo new Foo7 FooSubclass fooSubclass new FooSubclass 7, false foo.equalsfooSubclass true fooSubclass. equalsfoo false This violates the properties of symmetry and transitivity and thus is an invalid implementation of the equals method. As a result, when using instanceof , a good practice is to make the equals method final as in the above example. This will ensure that no subclass overrides equals and violates key assumptions. Section 42.4 wait and notify methods wait and notify work in tandem when one thread calls wait on an object, that thread will block until another thread calls notify or notifyAll on that same object. GoalKicker.com Java Notes for Professionals 235See Also waitnotify package com.example.examples.object import java.util.concurrent.atomic.AtomicBoolean public class WaitAndNotify public static void mainString args throws InterruptedException final Object obj new Object AtomicBoolean aHasFinishedWaiting new AtomicBoolean false Thread threadA new ThreadThread A public void run System.out.printlnA1 Could print before or after B1 System.out.printlnA2 Thread A is about to start waiting... try synchronized": "input.pdf", "obj wait must be in a synchronized block execution of thread A stops until obj.notify is called obj. wait System.out.printlnA3 Thread A has finished waiting. Guaranteed to happen after B3 catch InterruptedException e System.out.printlnThread A was interrupted while waiting finally aHasFinishedWaiting. settrue Thread threadB new ThreadThread B public void run System.out.printlnB1 Could print before or after A1 System.out.printlnB2 Thread B is about to wait for 10 seconds for int i 0 i 10 i try Thread.sleep1000 sleep for 1 second catch InterruptedException e System.err.printlnThread B was interrupted from waiting System.out.printlnB3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. while !aHasFinishedWaiting. get synchronized obj notify ONE thread which has called obj.wait obj. notify threadA. start threadB. start threadA. join threadB. join GoalKicker.com Java Notes for Professionals 236 System.out.printlnFinished! Some example output A1 Could print before or after B1 B1 Could print before or after A1 A2 Thread A is about to start waiting... B2 Thread B is about to wait for 10 seconds B3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. A3 Thread A has finished waiting. Guaranteed to happen after B3 Finished! B1 Could print before": "input.pdf", "or after A1 B2 Thread B is about to wait for 10 seconds A1 Could print before or after B1 A2 Thread A is about to start waiting... B3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. A3 Thread A has finished waiting. Guaranteed to happen after B3 Finished! A1 Could print before or after B1 A2 Thread A is about to start waiting... B1 Could print before or after A1 B2 Thread B is about to wait for 10 seconds B3 Will ALWAYS print before A3 since A3 can only happen after obj.notify is called. A3 Thread A has finished waiting. Guaranteed to happen after B3 Finished! Section 42.5 getClass method The getClass method can be used to \ufb01nd the runtime class type of an object. See the example below public class User private long userID private String name public Userlong userID, String name this.userID userID this.name name public class SpecificUser extends User private String specificUserID public SpecificUser String specificUserID, long userID, String name superuserID, name this.specificUserID specificUserID public static void mainString args User user new User879745, John SpecificUser specificUser new SpecificUser 1AAAA, 877777, Jim User anotherSpecificUser new SpecificUser 1BBBB, 812345, Jenny": "input.pdf", "System.out.printlnuser.getClass Prints class User GoalKicker.com Java Notes for Professionals 237 System.out.printlnspecificUser. getClass Prints class SpecificUser System.out.printlnanotherSpecificUser. getClass Prints class SpecificUser The getClass method will return the most speci\ufb01c class type, which is why when getClass is called on anotherSpecificUser , the return value is class SpecificUser because that is lower down the inheritance tree than User . It is noteworthy that, while the getClass method is declared as public final native Class? getClass The actual static type returned by a call to getClass is Class? extends T where T is the static type of the object on which getClass is called. i.e. the following will compile Class? extends String cls .getClass Section 42.6 clone method The clone method is used to create and return a copy of an object. This method arguable should be avoided as it is problematic and a copy constructor or some other approach for copying should be used in favour of clone. For the method to be used all classes calling the method must implement the Cloneable interface. The Cloneable interface itself is just a tag interface used to change the behaviour of the native clone method which checks if the calling objects class implements": "input.pdf", "Cloneable . If the caller does not implement this interface a CloneNotSupportedException will be thrown. The Object class itself does not implement this interface so a CloneNotSupportedException will be thrown if the calling object is of class Object . For a clone to be correct it should be independent of the object it is being cloned from, therefore it may be necessary to modify the object before it gets returned. This means to essentially create a deep copy by also copying any of the mutable objects that make up the internal structure of the object being cloned. If this is not implemented correctly the cloned object will not be independent and have the same references to the mutable objects as the object that it was cloned from. This would result in inconsistent behaviour as any changes to those in one would a\ufb00ect the other. class Foo implements Cloneable int w String x float y Date z public Foo clone try Foo result new Foo copy primitives by value result. w this.w immutable objects like String can be copied by reference result. x this.x The fields y and z refer to a mutable objects clone them recursively. if this.y !": "input.pdf", "null GoalKicker.com Java Notes for Professionals 238 result. y this.y.clone if this.z ! null result. z this.z.clone Done, return the new object return result catch CloneNotSupportedException e in case any of the cloned mutable fields do not implement Cloneable throw new AssertionError e Section 42.7 Object constructor All constructors in Java must make a call to the Object constructor. This is done with the call super. This has to be the \ufb01rst line in a constructor. The reason for this is so that the object can actually be created on the heap before any additional initialization is performed. If you do not specify the call to super in a constructor the compiler will put it in for you. So all three of these examples are functionally identical with explicit call to super constructor public class MyClass public MyClass super with implicit call to super constructor public class MyClass public MyClass empty with implicit constructor public class MyClass What about Constructor-Chaining? It is possible to call other constructors as the \ufb01rst instruction of a constructor. As both the explicit call to a super constructor and the call to another constructor have to be both \ufb01rst instructions, they are mutually exclusive.": "input.pdf", "public class MyClass GoalKicker.com Java Notes for Professionals 239 public MyClass int size doSomethingWith size public MyClass Collection ? initialValues thisinitialValues. size addInitialValues initialValues Calling new MyClassArrays.asLista, b, c will call the second constructor with the List-argument, which will in turn delegate to the \ufb01rst constructor which will delegate implicitly to super and then call addInitialValues int size with the second size of the list. This is used to reduce code duplication where multiple constructors need to do the same work. How do I call a speci\ufb01c constructor? Given the example above, one can either call new MyClass argument or new MyClass argument , 0. In other words, much like method overloading, you just call the constructor with the parameters that are necessary for your chosen constructor. What will happen in the Object class constructor? Nothing more than would happen in a sub-class that has a default empty constructor minus the call to super. The default empty constructor can be explicitly de\ufb01ned but if not the compiler will put it in for you as long as no other constructors are already de\ufb01ned. How is an Object then created from the constructor in Object? The actual creation of objects is": "input.pdf", "down to the JVM. Every constructor in Java appears as a special method named init which is responsible for instance initializing. This init method is supplied by the compiler and because init is not a valid identi\ufb01er in Java, it cannot be used directly in the language. How does the JVM invoke this init method? The JVM will invoke the init method using the invokespecial instruction and can only be invoked on uninitialized class instances. For more information take a look at the JVM speci\ufb01cation and the Java Language Speci\ufb01cation Special Methods JVM - JVMS - 2.9 Constructors - JLS - 8.8 Section 42.8 \ufb01nalize method This is a protected and non-static method of the Object class. This method is used to perform some \ufb01nal operations GoalKicker.com Java Notes for Professionals 240or clean up operations on an object before it gets removed from the memory. According to the doc, this method gets called by the garbage collector on an object when garbage collection determines that there are no more references to the object. But there are no guarantees that finalize method would gets called if the object is still reachable or no Garbage Collectors run when the object become": "input.pdf", "eligible. Thats why its better not rely on this method. In Java core libraries some usage examples could be found, for instance in FileInputStream .java protected void finalize throws IOException if fd ! null fd ! FileDescriptor .in if fd is shared, the references in FileDescriptor will ensure that finalizer is only called when safe to do so. All references using the fd have become unreachable. We can call close close In this case its the last chance to close the resource if that resource has not been closed before. Generally its considered bad practice to use finalize method in applications of any kind and should be avoided. Finalizers are not meant for freeing resources e.g., closing \ufb01les. The garbage collector gets called when if! the system runs low on heap space. You cant rely on it to be called when the system is running low on \ufb01le handles or, for any other reason. The intended use-case for \ufb01nalizers is for an object that is about to be reclaimed to notify some other object about its impending doom. A better mechanism now exists for that purpose---the java.lang.ref.WeakReference T class. If you think you need write a finalize method, then": "input.pdf", "you should look into whether you can solve the same problem using WeakReference instead. If that wont solve your problem, then you may need to re-think your design on a deeper level. For further reading here is an Item about finalize method from E\ufb00ective Java book by Joshua Bloch. GoalKicker.com Java Notes for Professionals 241Chapter 43 Annotations In Java, an annotation is a form of syntactic metadata that can be added to Java source code. It provides data about a program that is not part of the program itself. Annotations have no direct e\ufb00ect on the operation of the code they annotate. Classes, methods, variables, parameters and packages are allowed to be annotated. Section 43.1 The idea behind Annotations The Java Language Speci\ufb01cation describes Annotations as follows An annotation is a marker which associates information with a program construct, but has no e\ufb00ect at run time. Annotations may appear before types or declarations. It is possible for them to appear in a place where they could apply to both a type or a declaration. What exactly an annotation applies to is governed by the meta-annotation Target . See De\ufb01ning annotation types for more information. Annotations are used for a": "input.pdf", "multitude of purposes. Frameworks like Spring and Spring-MVC make use of annotations to de\ufb01ne where Dependencies should be injected or where requests should be routed. Other frameworks use annotations for code-generation. Lombok and JPA are prime examples, that use annotations to generate Java and SQL code. This topic aims to provide a comprehensive overview of How to de\ufb01ne your own Annotations? What Annotations does the Java Language provide? How are Annotations used in practice? Section 43.2 De\ufb01ning annotation types Annotation types are de\ufb01ned with interface . Parameters are de\ufb01ned similar to methods of a regular interface. interface MyAnnotation String param1 boolean param2 int param3 array parameter Default values interface MyAnnotation String param1 default someValue boolean param2 default true int param3 default Meta-Annotations Meta-annotations are annotations that can be applied to annotation types. Special prede\ufb01ned meta-annotation de\ufb01ne how annotation types can be used. GoalKicker.com Java Notes for Professionals 242Target The Target meta-annotation restricts the types the annotation can be applied to. TargetElementType. METHOD interface MyAnnotation this annotation can only be applied to methods Multiple values can be added using array notation, e.g. TargetElementType. FIELD, ElementType. TYPE Available Values ElementType target example usage on target element ANNOTATIONTYPE annotation typesRetention RetentionPolicy. RUNTIME": "input.pdf", "terface MyAnnotation CONSTRUCTOR constructors MyAnnotation lic MyClass FIELD \ufb01elds, enum constants XmlAttribute vate int count LOCALVARIABLEvariable declarations inside methodsfor LoopVariable int i 0 i 100 i Unused String resultVariable PACKAGEpackage in package- info.java Deprecated kage very.old METHOD methods XmlElement lic int getCount ... PARAMETERmethodconstructor parameterspublic Rectangle NamedArgwidth double width, NamedArgheight double height ... TYPE classes, interfaces, enums XmlRootElement lic class Report Version Java SE 8 ElementType target example usage on target element TYPEPARAMETER Type parameter declarations public MyAnnotation T void fT t TYPEUSE Use of a type Object o 42ing s MyAnnotation String o Retention The Retention meta-annotation de\ufb01nes the annotation visibility during the applications compilation process or execution. By default, annotations are included in .class \ufb01les, but are not visible at runtime. To make an annotation accessible at runtime, RetentionPolicy. RUNTIME has to be set on that annotation. Retention RetentionPolicy. RUNTIME interface MyAnnotation this annotation can be accessed with reflections at runtime Available values RetentionPolicy E\ufb00ect CLASS The annotation is available in the .class \ufb01le, but not at runtime RUNTIME The annotation is available at runtime and can be accessed via re\ufb02ection SOURCEThe annotation is available at compile time, but not added to the .class \ufb01les. The annotation": "input.pdf", "can be used e.g. by an annotation processor. Documented The Documented meta-annotation is used to mark annotations whose usage should be documented by API documentation generators like javadoc . It has no values. With Documented , all classes that use the annotation will list it on their generated documentation page. Without Documented , its not possible to see which classes use the GoalKicker.com Java Notes for Professionals 243annotation in the documentation. Inherited The Inherited meta-annotation is relevant to annotations that are applied to classes. It has no values. Marking an annotation as Inherited alters the way that annotation querying works. For a non-inherited annotation, the query only examines the class being examined. For an inherited annotation, the query will also check the super-class chain recursively until an instance of the annotation is found. Note that only the super-classes are queried any annotations attached to interfaces in the classes hierarchy will be ignored. Repeatable The Repeatable meta-annotation was added in Java 8. It indicates that multiple instances of the annotation can be attached to the annotations target. This meta-annotation has no values. Section 43.3 Runtime annotation checks via re\ufb02ection Javas Re\ufb02ection API allows the programmer to perform various checks and": "input.pdf", "operations on class \ufb01elds, methods and annotations during runtime. However, in order for an annotation to be at all visible at runtime, the RetentionPolicy must be changed to RUNTIME , as demonstrated in the example below interface MyDefaultAnnotation Retention RetentionPolicy. RUNTIME interface MyRuntimeVisibleAnnotation public class AnnotationAtRuntimeTest MyDefaultAnnotation static class RuntimeCheck1 MyRuntimeVisibleAnnotation static class RuntimeCheck2 public static void mainString args Annotation annotationsByType RuntimeCheck1. class.getAnnotations Annotation annotationsByType2 RuntimeCheck2. class.getAnnotations System.out.printlndefault retention Arrays.toString annotationsByType System.out.printlnruntime retention Arrays.toString annotationsByType2 Section 43.4 Built-in annotations The Standard Edition of Java comes with some annotations prede\ufb01ned. You do not need to de\ufb01ne them by yourself and you can use them immediately. They allow the compiler to enable some fundamental checking of methods, GoalKicker.com Java Notes for Professionals 244classes and code. Override This annotation applies to a method and says that this method must override a superclass method or implement an abstract superclass method de\ufb01nition. If this annotation is used with any other kind of method, the compiler will throw an error. Concrete superclass public class Vehicle public void drive System.out.printlnI am driving class Car extends Vehicle Fine Override public void drive System.out.prinlnBrrrm, brrm Abstract class abstract class Animal public abstract void makeNoise class Dog extends Animal": "input.pdf", "Fine Override public void makeNoise System.out.prinlnWoof Does not work class Logger1 public void logString logString System.out.prinlnlogString class Logger2 This will throw compile-time error. Logger2 is not a subclass of Logger1. log method is not overriding anything Override public void logString logString System.out.printlnLog 2 logString The main purpose is to catch mistyping, where you think you are overriding a method, but are actually de\ufb01ning a new one. class Vehicle GoalKicker.com Java Notes for Professionals 245 public void drive System.out.printlnI am driving class Car extends Vehicle Compiler error. dirve is not the correct method name to override. Override public void dirve System.out.prinlnBrrrm, brrm Note that the meaning of Override has changed over time In Java 5, it meant that the annotated method had to override a non-abstract method declared in the superclass chain. From Java 6 onward, it is also satis\ufb01ed if the annotated method implements an abstract method declared in the classes superclass interface hierarchy. This can occasionally cause problems when back-porting code to Java 5. Deprecated This marks the method as deprecated. There can be several reasons for this the API is \ufb02awed and is impractical to \ufb01x, usage of the API is likely to lead to errors, the": "input.pdf", "API has been superseded by another API, the API is obsolete, the API is experimental and is subject to incompatible changes, or any combination of the above. The speci\ufb01c reason for deprecation can usually be found in the documentation of the API. The annotation will cause the compiler to emit an error if you use it. IDEs may also highlight this method somehow as deprecated class ComplexAlgorithm Deprecated public void oldSlowUnthreadSafeMethod stuff here public void quickThreadSafeMethod client code should use this instead SuppressWarnings In almost all cases, when the compiler emits a warning, the most appropriate action is to \ufb01x the cause. In some instances Generics code using untype-safe pre-generics code, for example this may not be possible and its better to suppress those warnings that you expect and cannot \ufb01x, so you can more clearly see unexpected warnings. GoalKicker.com Java Notes for Professionals 246This annotation can be applied to a whole class, method or line. It takes the category of warning as a parameter. SuppressWarnings deprecation public class RiddledWithWarnings several methods calling deprecated code here SuppressWarning finally public boolean checkData method calling return from within finally block It is better to limit the scope of the annotation as": "input.pdf", "much as possible, to prevent unexpected warnings also being suppressed. For example, con\ufb01ning the scope of the annotation to a single-line ComplexAlgorithm algorithm new ComplexAlgorithm SuppressWarnings deprecation algoritm. slowUnthreadSafeMethod we marked this method deprecated in an example above SuppressWarnings unsafe ListInteger list getUntypeSafeList old library returns, non-generic List containing only integers The warnings supported by this annotation may vary from compiler to compiler. Only the unchecked and deprecation warnings are speci\ufb01cally mentioned in the JLS. Unrecognized warning types will be ignored. SafeVarargs Because of type erasure, void methodT... t will be converted to void methodObject t meaning that the compiler is not always able to verify that the use of varargs is type-safe. For instance private static T void generatesVarargsWarning T... lists There are instances where the use is safe, in which case you can annotate the method with the SafeVarargs annotation to suppress the warning. This obviously hides the warning if your use is unsafe too. FunctionalInterface This is an optional annotation used to mark a FunctionalInterface. It will cause the compiler to complain if it does not conform to the FunctionalInterface spec has a single abstract method FunctionalInterface public interface ITrade public boolean checkTrade t FunctionalInterface public": "input.pdf", "interface Predicate T boolean testT t Section 43.5 Compile time processing using annotation processor This example demonstrates how to do compile time checking of an annotated element. The annotation GoalKicker.com Java Notes for Professionals 247The Setter annotation is a marker can be applied to methods. The annotation will be discarded during compilation not be available afterwards. package annotation import java.lang.annotation.ElementType import java.lang.annotation.Retention import java.lang.annotation.RetentionPolicy import java.lang.annotation.Target Retention RetentionPolicy. SOURCE TargetElementType. METHOD public interface Setter The annotation processor The SetterProcessor class is used by the compiler to process the annotations. It checks, if the methods annotated with the Setter annotation are public , non-static methods with a name starting with set and having a uppercase letter as 4th letter. If one of these conditions isnt met, a error is written to the Messager . The compiler writes this to stderr, but other tools could use this information di\ufb00erently. E.g. the NetBeans IDE allows the user specify annotation processors that are used to display error messages in the editor. package annotation.processor import annotation.Setter import java.util.Set import javax.annotation.processing.AbstractProcessor import javax.annotation.processing.Messager import javax.annotation.processing.ProcessingEnvironment import javax.annotation.processing.RoundEnvironment import javax.annotation.processing.SupportedAnnotationTypes import javax.annotation.processing.SupportedSourceVersion import javax.lang.model.SourceVersion import javax.lang.model.element.Element import javax.lang.model.element.ElementKind import javax.lang.model.element.ExecutableElement import javax.lang.model.element.Modifier import javax.lang.model.element.TypeElement import javax.tools.Diagnostic": "input.pdf", "SupportedAnnotationTypes annotation.Setter SupportedSourceVersion SourceVersion. RELEASE8 public class SetterProcessor extends AbstractProcessor private Messager messager Override public boolean process Set? extends TypeElement annotations, RoundEnvironment roundEnv get elements annotated with the Setter annotation Set ? extends Element annotatedElements roundEnv. getElementsAnnotatedWith Setter.class for Element element annotatedElements if element. getKind ElementKind. METHOD only handle methods as targets checkMethod ExecutableElement element dont claim annotations to allow other processors to process them return false GoalKicker.com Java Notes for Professionals 248 private void checkMethod ExecutableElement method check for valid name String name method. getSimpleName .toString if !name.startsWith set printError method, setter name must start with set else if name.length 3 printError method, the method name must contain more than just set else if Character .isLowerCase name.charAt3 if method.getParameters .size ! 1 printError method, character following set must be upper case check, if setter is public if !method.getModifiers .contains Modifier .PUBLIC printError method, setter must be public check, if method is static if method.getModifiers .contains Modifier .STATIC printError method, setter must not be static private void printError Element element, String message messager. printMessage Diagnostic. Kind.ERROR, message, element Override public void initProcessingEnvironment processingEnvironment super.initprocessingEnvironment get messager for printing errors messager processingEnvironment. getMessager Packaging To be applied by the compiler,": "input.pdf", "the annotation processor needs to be made available to the SPI see ServiceLoader. To do this a text \ufb01le META-INFservices javax.annotation .processing .Processor needs to be added to the jar \ufb01le containing the annotation processor and the annotation in addition to the other \ufb01les. The \ufb01le needs to include the fully quali\ufb01ed name of the annotation processor, i.e. it should look like this annotation. processor .SetterProcessor Well assume the jar \ufb01le is called AnnotationProcessor. jar below. Example annotated class The following class is example class in the default package with the annotations being applied to the correct elements according to the retention policy. However only the annotation processor only considers the second method a valid annotation target. import annotation.Setter GoalKicker.com Java Notes for Professionals 249public class AnnotationProcessorTest Setter private void setValue String value Setter public void setString String value Setter public static void mainString args Using the annotation processor with javac If the annotation processor is discovered using the SPI, it is automatically used to process annotated elements. E.g. compiling the AnnotationProcessorTest class using javac -cp AnnotationProcessor. jar AnnotationProcessorTest. java yields the following output AnnotationProcessorTest.java6 error setter must be public private void setValueString value AnnotationProcessorTest.java12 error setter name must": "input.pdf", "start with set public static void mainString args 2 errors instead of compiling normally. No .class \ufb01le is created. This could be prevented by specifying the -procnone option for javac . You could also forgo the usual compilation by specifying -proconly instead. IDE integration Netbeans Annotation processors can be used in the NetBeans editor. To do this the annotation processor needs to be speci\ufb01ed in the project settings go to Project Properties Build Compiling 1. add check marks for Enable Annotation Processing and Enable Annotation Processing in Editor 2. click Add next to the annotation processor list 3. in the popup that appears enter the fully quali\ufb01ed class name of the annotation processor and click Ok. 4. Result GoalKicker.com Java Notes for Professionals 250 Section 43.6 Repeating Annotations Until Java 8, two instances of the same annotation could not be applied to a single element. The standard workaround was to use a container annotation holding an array of some other annotation Author.java Retention RetentionPolicy. RUNTIME public interface Author String value Authors.java Retention RetentionPolicy. RUNTIME public interface Authors Author value Test.java Authors Author Mary, Author Sam public class Test public static void mainString args Author authors Test.class.getAnnotation Authors. class.value for": "input.pdf", "Author author authors System.out.printlnauthor.value Output Mary Sam Version Java SE 8 Java 8 provides a cleaner, more transparent way of using container annotations, using the Repeatable annotation. First we add this to the Author class Repeatable Authors. class This tells Java to treat multiple Author annotations as though they were surrounded by the Authors container. We can also use Class.getAnnotationsByType to access the Author array by its own class, instead of through its GoalKicker.com Java Notes for Professionals 251container AuthorMary AuthorSam public class Test public static void mainString args Author authors Test.class.getAnnotationsByType Author.class for Author author authors System.out.printlnauthor.value Output Mary Sam Section 43.7 Inherited Annotations By default class annotations do not apply to types extending them. This can be changed by adding the Inherited annotation to the annotation de\ufb01nition Example Consider the following 2 Annotations Inherited TargetElementType. TYPE Retention RetentionPolicy. RUNTIME public interface InheritedAnnotationType and TargetElementType. TYPE Retention RetentionPolicy. RUNTIME public interface UninheritedAnnotationType If three classes are annotated like this UninheritedAnnotationType class A InheritedAnnotationType class B extends A class C extends B running this code System.out.printlnnew A.getClass .getAnnotation InheritedAnnotationType. class System.out.printlnnew B.getClass .getAnnotation InheritedAnnotationType. class System.out.printlnnew C.getClass .getAnnotation InheritedAnnotationType. class System.out.println System.out.printlnnew A.getClass .getAnnotation UninheritedAnnotationType. class GoalKicker.com Java Notes": "input.pdf", "for Professionals 252System.out.printlnnew B.getClass .getAnnotation UninheritedAnnotationType. class System.out.printlnnew C.getClass .getAnnotation UninheritedAnnotationType. class will print a result similar to this depending on the packages of the annotation null InheritedAnnotationType InheritedAnnotationType UninheritedAnnotationType null null Note that annotations can only be inherited from classes, not interfaces. Section 43.8 Getting Annotation values at run-time You can fetch the current properties of the Annotation by using Re\ufb02ection to fetch the Method or Field or Class which has an Annotation applied to it, and then fetching the desired properties. Retention RetentionPolicy. RUNTIME interface MyAnnotation String key default foo String value default bar class AnnotationExample Put the Annotation on the method, but leave the defaults MyAnnotation public void testDefaults throws Exception Using reflection, get the public method testDefaults, which is this method with no args Method method AnnotationExample. class.getMethod testDefaults , null Fetch the Annotation that is of type MyAnnotation from the Method MyAnnotation annotation MyAnnotation method.getAnnotation MyAnnotation. class Print out the settings of the Annotation print annotation Put the Annotation on the method, but override the settings MyAnnotation keybaz, valuebuzz public void testValues throws Exception Using reflection, get the public method testValues, which is this method with no args Method method AnnotationExample. class.getMethod testValues ,": "input.pdf", "null Fetch the Annotation that is of type MyAnnotation from the Method MyAnnotation annotation MyAnnotation method.getAnnotation MyAnnotation. class Print out the settings of the Annotation print annotation public void printMyAnnotation annotation Fetch the MyAnnotation key value properties, and print them out System.out.printlnannotation. key annotation. value public static void mainString args GoalKicker.com Java Notes for Professionals 253 AnnotationExample example new AnnotationExample try example. testDefaults example. testValues catch Exception e Shouldnt throw any Exceptions System.err.printlnException e.getClass .getName - e.getMessage e. printStackTrace System.err The output will be foo bar baz buzz Section 43.9 Annotations for this and receiver parameters When Java annotations were \ufb01rst introduced there was no provision for annotating the target of an instance method or the hidden constructor parameter for an inner classes constructor. This was remedied in Java 8 with addition of receiver parameter declarations see JLS 8.4.1 . The receiver parameter is an optional syntactic device for an instance method or an inner classs constructor. For an instance method, the receiver parameter represents the object for which the method is invoked. For an inner classs constructor, the receiver parameter represents the immediately enclosing instance of the newly constructed object. Either way, the receiver parameter exists solely to": "input.pdf", "allow the type of the represented object to be denoted in source code, so that the type may be annotated. The receiver parameter is not a formal parameter more precisely, it is not a declaration of any kind of variable 4.12.3, it is never bound to any value passed as an argument in a method invocation expression or quali\ufb01ed class instance creation expression, and it has no e\ufb00ect whatsoever at run time. The following example illustrates the syntax for both kinds of receiver parameter public class Outer public class Inner public Inner Outer this ... public void doItInner this ... The sole purpose of receiver parameters is to allow you to add annotations. For example, you might have a custom annotation IsOpen whose purpose is to assert that a Closeable object has not been closed when a method is called. For example public class MyResource extends Closeable public void updateIsOpen MyResource this, int value ... GoalKicker.com Java Notes for Professionals 254 public void close ... At one level, the IsOpen annotation on this could simply serve as documentation. However, we could potentially do more. For example An annotation processor could insert a runtime check that this is not in": "input.pdf", "closed state when update is called. A code checker could perform a static code analysis to \ufb01nd cases where this could be closed when update is called. Section 43.10 Add multiple annotation values An Annotation parameter can accept multiple values if it is de\ufb01ned as an array. For example the standard annotation SuppressWarnings is de\ufb01ned like this public interface SuppressWarnings String value The value parameter is an array of Strings. You can set multiple values by using a notation similar to Array initializers SuppressWarnings unused SuppressWarnings unused , javadoc If you only need to set a single value, the brackets can be omitted SuppressWarnings unused GoalKicker.com Java Notes for Professionals 255Chapter 44 Immutable Class Immutable objects are instances whose state doesn t change after it has been initialized. For example, String is an immutable class and once instantiated its value never changes. Section 44.1 Example without mutable refs public final class Color final private int red final private int green final private int blue private void checkint red, int green, int blue if red 0 red 255 green 0 green 255 blue 0 blue 255 throw new IllegalArgumentException public Colorint red, int green, int blue check red, green, blue": "input.pdf", "this.red red this.green green this.blue blue public Color invert return new Color255 - red, 255 - green, 255 - blue Section 44.2 What is the advantage of immutability? The advantage of immutability comes with concurrency. It is di\ufb03cult to maintain correctness in mutable objects, as multiple threads could be trying to change the state of the same object, leading to some threads seeing a di\ufb00erent state of the same object, depending on the timing of the reads and writes to the said object. By having an immutable object, one can ensure that all threads that are looking at the object will be seeing the same state, as the state of an immutable object will not change. Section 44.3 Rules to de\ufb01ne immutable classes The following rules de\ufb01ne a simple strategy for creating immutable objects. Dont provide setter methods - methods that modify \ufb01elds or objects referred to by \ufb01elds.1. Make all \ufb01elds \ufb01nal and private.2. Dont allow subclasses to override methods. The simplest way to do this is to declare the class as \ufb01nal. A3. more sophisticated approach is to make the constructor private and construct instances in factory methods. If the instance \ufb01elds include references to mutable objects,": "input.pdf", "dont allow those objects to be changed4. Dont provide methods that modify the mutable objects.5. Dont share references to the mutable objects. Never store references to external, mutable objects passed to6. the constructor if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods. GoalKicker.com Java Notes for Professionals 256Section 44.4 Example with mutable refs In this case class Point is mutable and some user can modify state of object of this class. class Point private int x, y public Pointint x, int y this.x x this.y y public int getX return x public void setXint x this.x x public int getY return y public void setYint y this.y y ... public final class ImmutableCircle private final Point center private final double radius public ImmutableCircle Point center, double radius we create new object here because it shouldnt be changed this.center new Pointcenter.getX, center. getY this.radius radius GoalKicker.com Java Notes for Professionals 257Chapter 45 Immutable Objects Section 45.1 Creating an immutable version of a type using defensive copying Some basic types and classes in Java are fundamentally mutable. For example, all array types": "input.pdf", "are mutable, and so are classes like java.util.Data . This can be awkward in situations where an immutable type is mandated. One way to deal with this is to create an immutable wrapper for the mutable type. Here is a simple wrapper for an array of integers public class ImmutableIntArray private final int array public ImmutableIntArray int array this.array array.clone public int getValue return this.clone This class works by using defensive copying to isolate the mutable state the int from any code that might mutate it The constructor uses clone to create a distinct copy of the parameter array. If the caller of the constructor subsequent changed the parameter array, it would not a\ufb00ect the state of the ImmutableIntArray . The getValue method also uses clone to create the array that is returned. If the caller were to change the result array, it would not a\ufb00ect the state of the ImmutableIntArray . We could also add methods to ImmutableIntArray to perform read-only operations on the wrapped array e.g. get its length, get the value at a particular index, and so on. Note that an immutable wrapper type implemented this way is not type compatible with the original type. You": "input.pdf", "cannot simply substitute the former for the latter. Section 45.2 The recipe for an immutable class An immutable object is an object whose state cannot be changed. An immutable class is a class whose instances are immutable by design, and implementation. The Java class which is most commonly presented as an example of immutability is java.lang.String . The following is a stereotypical example public final class Person private final String name private final String ssn SSN social security number public PersonString name, String ssn this.name name this.ssn ssn GoalKicker.com Java Notes for Professionals 258 public String getName return name public String getSSN return ssn A variation on this is to declare the constructor as private and provide a public static factory method instead. The standard recipe for an immutable class is as follows All properties must be set in the constructors or factory methods. There should be no setters. If it is necessary to include setters for interface compatibility reasons, they should either do nothing or throw an exception. All properties should be declared as private and final . For all properties that are references to mutable types the property should be initialized with a deep copy of the": "input.pdf", "value passed via the constructor, and the propertys getter should return a deep copy of the property value. The class should be declared as final to prevent someone creating a mutable subclass of an immutable class. A couple of other things to note Immutability does not prevent object from being nullable e.g. null can be assigned to a String variable. If an immutable classes properties are declared as final , instances are inherently thread-safe. This makes immutable classes a good building block for implementing multi-threaded applications. Section 45.3 Typical design \ufb02aws which prevent a class from being immutable Using some setters, without setting all needed properties in the constructors public final class Person example of a bad immutability private final String name private final String surname public PersonString name this.name name public String getName return name public String getSurname return surname public void setSurname String surname this.surname surname Its easy to show that Person class is not immutable Person person new PersonJoe person.setSurname Average NOT OK, change surname field after creation To \ufb01x it, simply delete setSurname and refactor the constructor as follows public PersonString name, String surname this.name name this.surname surname GoalKicker.com Java Notes for Professionals 259 Not": "input.pdf", "marking instance variables as private and \ufb01nal Take a look at the following class public final class Person public String name public PersonString name this.name name public String getName return name The following snippet shows that the above class is not immutable Person person new PersonAverage Joe person.name Magic Mike not OK, new name for person after creation To \ufb01x it, simply mark name property as private and final . Exposing a mutable object of the class in a getter Take a look at the following class import java.util.List import java.util.ArrayList public final class Names private final ListString names public NamesListString names this.names new ArrayList Stringnames public ListString getNames return names public int size return names.size Names class seems immutable at the \ufb01rst sight, but it is not as the following code shows ListString namesList new ArrayList String namesList. addAverage Joe Names names new NamesnamesList System.out.printlnnames.size 1, only containing Average Joe namesList names.getNames namesList. addMagic Mike System.out.printlnnames.size 2, NOT OK, now names also contains Magic Mike This happened because a change to the reference List returned by getNames can modify the actual list of Names . To \ufb01x this, simply avoid returning references that reference classs mutable objects either": "input.pdf", "by making defensive copies, as follows GoalKicker.com Java Notes for Professionals 260public ListString getNames return new ArrayList Stringthis.names copies elements or by designing getters in way that only other immutable objects and primitives are returned, as follows public String getName int index return names.getindex public int size return names.size Injecting constructor with objects that can be modi\ufb01ed outside the immutable class This is a variation of the previous \ufb02aw. Take a look at the following class import java.util.List public final class NewNames private final ListString names public NamesListString names this.names names public String getName int index return names.getindex public int size return names.size As Names class before, also NewNames class seems immutable at the \ufb01rst sight, but it is not, in fact the following snippet proves the contrary ListString namesList new ArrayList String namesList. addAverage Joe NewNames names new NewNames namesList System.out.printlnnames.size 1, only containing Average Joe namesList. addMagic Mike System.out.printlnnames.size 2, NOT OK, now names also contains Magic Mike To \ufb01x this, as in the previous \ufb02aw, simply make defensive copies of the object without assigning it directly to the immutable class, i.e. constructor can be changed as follows public NamesListString names this.names new ArrayList Stringnames Letting the": "input.pdf", "methods of the class being overridden Take a look at the following class public class Person private final String name public PersonString name this.name name public String getName return name GoalKicker.com Java Notes for Professionals 261 Person class seems immutable at the \ufb01rst sight, but suppose a new subclass of Person is de\ufb01ned public class MutablePerson extends Person private String newName public MutablePerson String name supername Override public String getName return newName public void setName String name newName name now Person immutability can be exploited through polymorphism by using the new subclass Person person new MutablePerson Average Joe System.out.printlnperson.getName prints Average Joe person.setNameMagic Mike NOT OK, person has now a new name! System.out.printlnperson.getName prints Magic Mike To \ufb01x this, either mark the class as final so it cannot be extended or declare all of its constructors as private . GoalKicker.com Java Notes for Professionals 262Chapter 46 Visibility controlling access to members of a class Section 46.1 Private Visibility private visibility allows a variable to only be accessed by its class. They are often used in conjunction with public getters and setters. class SomeClass private int variable public int getVariable return variable public void setVariable int variable this.variable variable public": "input.pdf", "class SomeOtherClass public static void mainString args SomeClass sc new SomeClass These statement wont compile because SomeClassvariable is private sc. variable 7 System.out.printlnsc.variable Instead, you should use the public getter and setter sc. setVariable 7 System.out.printlnsc.getVariable Section 46.2 Public Visibility Visible to the class, package, and subclass. Lets see an example with the class Test. public class Test public int number 2 public Test Now lets try to create an instance of the class. In this example, we can access number because it is public . public class Other public static void mainString args Test t new Test System.out.printlnt.number GoalKicker.com Java Notes for Professionals 263 Section 46.3 Package Visibility With no modi\ufb01er , the default is package visibility. From the Java Documentation, package visibility indicates whether classes in the same package as the class regardless of their parentage have access to the member. In this example from javax.swing , package javax.swing public abstract class JComponent extends Container static boolean DEBUGGRAPHICSLOADED DebugGraphics is in the same package, so DEBUGGRAPHICSLOADED is accessible. package javax.swing public class DebugGraphics extends Graphics static JComponent .DEBUGGRAPHICSLOADED true This article gives some background on the topic. Section 46.4 Protected Visibility Protected visibility causes means that this": "input.pdf", "member is visible to its package, along with any of its subclasses. As an example package com.stackexchange.docs public class MyClass protected int variable This is the variable that we are trying to access public MyClass variable 2 Now well extend this class and try to access one of its protected members. package some.other.pack import com.stackexchange.docs.MyClass public class SubClass extends MyClass public SubClass super System.out.printlnsuper.variable You would be also able to access a protected member without extending it if you are accessing it from the same package. GoalKicker.com Java Notes for Professionals 264Note that this modi\ufb01er only works on members of a class, not on the class itself. Section 46.5 Summary of Class Member Access Modi\ufb01ers Access Modi\ufb01er Visibility Inheritance Private Class only Cant be inherited No modi\ufb01er Package In package Available if subclass in package Protected In package Available in subclass Public Everywhere Available in subclass There was once a private protected both keywords at once modi\ufb01er that could be applied to methods or variables to make them accessible from a subclass outside the package, but make them private to the classes in that package. However, this was removed in Java 1.0s release . Section 46.6 Interface members public": "input.pdf", "interface MyInterface public void foo int bar public String TEXT Hello int ANSWER 42 public class X class Y Interface members always have public visibility, even if the public keyword is omitted. So both foo, bar, TEXT , ANSWER , X, and Y have public visibility. However, access may still be limited by the containing interface - since MyInterface has public visibility, its members may be accessed from anywhere, but if MyInterface had had package visibility, its members would only have been accessible from within the same package. GoalKicker.com Java Notes for Professionals 265Chapter 47 Generics Generics are a facility of generic programming that extend Javas type system to allow a type or method to operate on objects of various types while providing compile-time type safety. In particular, the Java collections framework supports generics to specify the type of objects stored in a collection instance. Section 47.1 Creating a Generic Class Generics enable classes, interfaces, and methods to take other classes and interfaces as type parameters. This example uses generic class Param to take a single type parameter T, delimited by angle brackets public class ParamT private T value public T getValue return value public void setValue T value": "input.pdf", "this.value value To instantiate this class, provide a type argument in place of T. For example, Integer ParamInteger integerParam new ParamInteger The type argument can be any reference type, including arrays and other generic types ParamString stringArrayParam Paramint int2dArrayParam ParamParamObject objectNestedParam In Java SE 7 and later, the type argument can be replaced with an empty set of type arguments called the diamond Version Java SE 7 ParamInteger integerParam new Param Unlike other identi\ufb01ers, type parameters have no naming constraints. However their names are commonly the \ufb01rst letter of their purpose in upper case. This is true even throughout the o\ufb03cial JavaDocs. Examples include T for type , E for element and KV for keyvalue . Extending a generic class public abstract class AbstractParam T private T value public T getValue return value public void setValue T value this.value value GoalKicker.com Java Notes for Professionals 266 AbstractParam is an abstract class declared with a type parameter of T. When extending this class, that type parameter can be replaced by a type argument written inside , or the type parameter can remain unchanged. In the \ufb01rst and second examples below, String and Integer replace the type parameter. In the third": "input.pdf", "example, the type parameter remains unchanged. The fourth example doesnt use generics at all, so its similar to if the class had an Object parameter. The compiler will warn about AbstractParam being a raw type, but it will compile the ObjectParam class. The \ufb01fth example has 2 type parameters see multiple type parameters below, choosing the second parameter as the type parameter passed to the superclass. public class Email extends AbstractParam String ... public class Age extends AbstractParam Integer ... public class HeightT extends AbstractParam T ... public class ObjectParam extends AbstractParam ... public class MultiParam T, E extends AbstractParam E ... The following is the usage Email email new Email email.setValue testexample.com String retrievedEmail email.getValue Age age new Age age.setValue 25 Integer retrievedAge age.getValue int autounboxedAge age.getValue HeightInteger heightInInt new Height heightInInt. setValue 125 HeightFloat heightInFloat new Height heightInFloat. setValue 120.3f MultiParam String, Double multiParam new MultiParam multiParam. setValue 3.3 Notice that in the Email class, the T getValue method acts as if it had a signature of String getValue , and the void setValue T method acts as if it was declared void setValue String. It is also possible to instantiate with anonymous inner class with an": "input.pdf", "empty curly braces AbstractParam Double height new AbstractParam Double height.setValue 198.6 GoalKicker.com Java Notes for Professionals 267Note that using the diamond with anonymous inner classes is not allowed. Multiple type parameters Java provides the ability to use more than one type parameter in a generic class or interface. Multiple type parameters can be used in a class or interface by placing a comma-separated list of types between the angle brackets. Example public class MultiGenericParam T, S private T firstParam private S secondParam public MultiGenericParam T firstParam, S secondParam this.firstParam firstParam this.secondParam secondParam public T getFirstParam return firstParam public void setFirstParam T firstParam this.firstParam firstParam public S getSecondParam return secondParam public void setSecondParam S secondParam this.secondParam secondParam The usage can be done as below MultiGenericParam String, String aParam new MultiGenericParam String, String value1 , value2 MultiGenericParam Integer, Double dayOfWeekDegrees new MultiGenericParam Integer, Double 1, 2.6 Section 47.2 Deciding between T, ? super T, and ? extends T The syntax for Java generics bounded wildcards, representing the unknown type by ? is ? extends T represents an upper bounded wildcard. The unknown type represents a type that must be a subtype of T, or type T itself. ? super T represents": "input.pdf", "a lower bounded wildcard. The unknown type represents a type that must be a supertype of T, or type T itself. As a rule of thumb, you should use ? extends T if you only need read access input ? super T if you need write access output GoalKicker.com Java Notes for Professionals 268T if you need both modify Using extends or super is usually better because it makes your code more \ufb02exible as in allowing the use of subtypes and supertypes, as you will see below. class Shoe class IPhone interface Fruit class Apple implements Fruit class Banana implements Fruit class GrannySmith extends Apple public class FruitHelper public void eatAllCollection ? extends Fruit fruits public void addApple Collection ? super Apple apples The compiler will now be able to detect certain bad usage public class GenericsTest public static void mainString args FruitHelper fruitHelper new FruitHelper List Fruit fruits new ArrayList Fruit fruits. addnew Apple Allowed, as Apple is a Fruit fruits. addnew Banana Allowed, as Banana is a Fruit fruitHelper. addApple fruits Allowed, as Fruit super Apple fruitHelper. eatAllfruits Allowed Collection Banana bananas new ArrayList bananas. addnew Banana Allowed fruitHelper.addApplebananas Compile error may only contain Bananas! fruitHelper. eatAllbananas": "input.pdf", "Allowed, as all Bananas are Fruits Collection Apple apples new ArrayList fruitHelper. addApple apples Allowed apples. addnew GrannySmith Allowed, as this is an Apple fruitHelper. eatAllapples Allowed, as all Apples are Fruits. Collection GrannySmith grannySmithApples new ArrayList fruitHelper. addApple grannySmithApples Compile error Not allowed. GrannySmith is not a supertype of Apple apples. addnew GrannySmith Still allowed, GrannySmith is an Apple fruitHelper. eatAllgrannySmithApples Still allowed, GrannySmith is a Fruit Collection Object objects new ArrayList fruitHelper. addApple objects Allowed, as Object super Apple objects. addnew Shoe Not a fruit objects. addnew IPhone Not a fruit fruitHelper.eatAllobjects Compile error may contain a Shoe, too! Choosing the right T, ? super T or ? extends T is necessary to allow the use with subtypes. The compiler can then ensure type safety you should not need to cast which is not type safe, and may cause programming errors if you use them properly. If it is not easy to understand, please remember PECS rule GoalKicker.com Java Notes for Professionals 269Producer uses Extends and Consumer uses Super. Producer has only write access, and Consumer has only read access Section 47.3 The Diamond Version Java SE 7 Java 7 introduced the Diamond 1 to remove some": "input.pdf", "boiler-plate around generic class instantiation. With Java 7 you can write ListString list new LinkedList Where you had to write in previous versions, this ListString list new LinkedList String One limitation is for Anonymous Classes, where you still must provide the type parameter in the instantiation This will compile Comparator String caseInsensitiveComparator new Comparator String Override public int compare String s1, String s2 return s1.compareToIgnoreCase s2 But this will not Comparator String caseInsensitiveComparator new Comparator Override public int compare String s1, String s2 return s1.compareToIgnoreCase s2 Version Java SE 8 Although using the diamond with Anonymous Inner Classes is not supported in Java 7 and 8, it will be included as a new feature in Java 9 . Footnote 1 - Some people call the usage the diamond operator . This is incorrect. The diamond does not behave as an operator, and is not described or listed anywhere in the JLS or the o\ufb03cial Java Tutorials as an operator. Indeed, is not even a distinct Java token. Rather it is a token followed by a token, and it is legal though bad style to have whitespace or comments between the two. The JLS and the Tutorials consistently refer to": "input.pdf", "as the diamond, and that is therefore the correct term for it. Section 47.4 Declaring a Generic Method Methods can also have generic type parameters. public class Example GoalKicker.com Java Notes for Professionals 270 The type parameter T is scoped to the method and is independent of type parameters of other methods. public T ListT makeList T t1, T t2 List T result new ArrayList T result. addt1 result. addt2 return result public void usage List String listString makeList Jeff, Atwood List Integer listInteger makeList 1, 2 Notice that we dont have to pass an actual type argument to a generic method. The compiler infers the type argument for us, based on the target type e.g. the variable we assign the result to, or on the types of the actual arguments. It will generally infer the most speci\ufb01c type argument that will make the call type-correct. Sometimes, albeit rarely, it can be necessary to override this type inference with explicit type arguments void usage consumeObjects this.ObjectmakeList Jeff, Atwood .stream void consumeObjects StreamObject stream ... Its necessary in this example because the compiler cant look ahead to see that Object is desired for T after calling stream and it would": "input.pdf", "otherwise infer String based on the makeList arguments. Note that the Java language doesnt support omitting the class or object on which the method is called this in the above example when type arguments are explicitly provided. Section 47.5 Requiring multiple upper bounds extends A B You can require a generic type to extend multiple upper bounds. Example we want to sort a list of numbers but Number doesnt implement Comparable . public T extends Number Comparable T void sortNumbers ListT n Collections .sort n In this example T must extend Number and implement Comparable T which should \ufb01t all normal built-in number implementations like Integer or BigDecimal but doesnt \ufb01t the more exotic ones like Striped64 . Since multiple inheritance is not allowed, you can use at most one class as a bound and it must be the \ufb01rst listed. For example, T extends Comparable T Number is not allowed because Comparable is an interface, and not a class. Section 47.6 Obtain class that satis\ufb01es generic parameter at runtime Many unbound generic parameters, like those used in a static method, cannot be recovered at runtime see Other Threads on Erasure . However there is a common strategy employed": "input.pdf", "for accessing the type satisfying a generic parameter on a class at runtime. This allows for generic code that depends on access to type without having to GoalKicker.com Java Notes for Professionals 271thread type information through every call. Background Generic parameterization on a class can be inspected by creating an anonymous inner class. This class will capture the type information. In general this mechanism is referred to as super type tokens , which are detailed in Neal Gafters blog post . Implementations Three common implementations in Java are Guavas TypeToken Springs ParameterizedTypeReference Jacksons TypeReference Example usage public class DataService MODELTYPE private final DataDao dataDao new DataDao private final ClassMODELTYPE type ClassMODELTYPE new TypeToken MODELTYPE getClass .getRawType public ListMODELTYPE getAll return dataDao. getAllOfType type the subclass definitively binds the parameterization to User for all instances of this class, so that information can be recovered at runtime public class UserService extends DataService User public class Main public static void mainString args UserService service new UserService List User users service. getAll Section 47.7 Bene\ufb01ts of Generic class and interface Code that uses generics has many bene\ufb01ts over non-generic code. Below are the main bene\ufb01ts Stronger type checks at compile time A Java": "input.pdf", "compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than \ufb01xing runtime errors, which can be di\ufb03cult to \ufb01nd. Elimination of casts The following code snippet without generics requires casting List list new ArrayList list.addhello String s String list.get0 GoalKicker.com Java Notes for Professionals 272When re-written to use generics , the code does not require casting ListString list new ArrayList list.addhello String s list.get0 no cast Enabling programmers to implement generic algorithms By using generics, programmers can implement generic algorithms that work on collections of di\ufb00erent types, can be customized, and are type safe and easier to read. Section 47.8 Instantiating a generic type Due to type erasure the following will not work public T void genericMethod T t new T Can not instantiate the type T. The type T is erased. Since, at runtime, the JVM does not know what T originally was, it does not know which constructor to call. Workarounds Passing Ts class when calling genericMethod 1. public T void genericMethod ClassT cls try T t cls.newInstance catch InstantiationException IllegalAccessException e System.err.printlnCould not instantiate cls.getName genericMethod String.class Which throws exceptions, since there is": "input.pdf", "no way to know if the passed class has an accessible default constructor. Version Java SE 8 Passing a reference to Ts constructor 2. public T void genericMethod Supplier T cons T t cons.get genericMethod Stringnew Section 47.9 Creating a Bounded Generic Class You can restrict the valid types used in a generic class by bounding that type in the class de\ufb01nition. Given the following simple type hierarchy GoalKicker.com Java Notes for Professionals 273public abstract class Animal public abstract String getSound public class Cat extends Animal public String getSound return Meow public class Dog extends Animal public String getSound return Woof Without bounded generics , we cannot make a container class that is both generic and knows that each element is an animal public class AnimalContainer T private Collection T col public AnimalContainer col new ArrayList T public void addT t col. addt public void printAllSounds for T t col Illegal, type T doesnt have makeSound it is used as an java.lang.Object here System.out.printlnt.makeSound With generic bound in class de\ufb01nition, this is now possible. public class BoundedAnimalContainer T extends Animal Note bound here. private Collection T col public BoundedAnimalContainer col new ArrayList T public void addT t col. addt": "input.pdf", "public void printAllSounds for T t col Now works because T is extending Animal System.out.printlnt.makeSound GoalKicker.com Java Notes for Professionals 274 This also restricts the valid instantiations of the generic type Legal AnimalContainer Cat a new AnimalContainer Cat Legal AnimalContainer String a new AnimalContainer String Legal because Cat extends Animal BoundedAnimalContainer Cat b new BoundedAnimalContainer Cat Illegal because String doesnt extends Animal BoundedAnimalContainer String b new BoundedAnimalContainer String Section 47.10 Referring to the declared generic type within its own declaration How do you go about using an instance of a possibly further inherited generic type within a method declaration in the generic type itself being declared? This is one of the problems you will face when you dig a bit deeper into generics, but still a fairly common one. Assume we have a DataSeries T type interface here, which de\ufb01nes a generic data series containing values of type T. It is cumbersome to work with this type directly when we want to perform a lot of operations with e.g. double values, so we de\ufb01ne DoubleSeries extends DataSeries Double. Now assume, the original DataSeries T type has a method addvalues which adds another series of the same length and returns": "input.pdf", "a new one. How do we enforce the type of values and the type of the return to be DoubleSeries rather than DataSeries Double in our derived class? The problem can be solved by adding a generic type parameter referring back to and extending the type being declared applied to an interface here, but the same stands for classes public interface DataSeries T, DS extends DataSeries T, DS DS add DS values List T data Here T represents the data type the series holds, e.g. Double and DS the series itself. An inherited type or types can now be easily implemented by substituting the above mentioned parameter by a corresponding derived type, thus, yielding a concrete Double -based de\ufb01nition of the form public interface DoubleSeries extends DataSeries Double, DoubleSeries static DoubleSeries instance Collection Double data return new DoubleSeriesImpl data At this moment even an IDE will implement the above interface with correct types in place, which, after a bit of content \ufb01lling may look like this class DoubleSeriesImpl implements DoubleSeries private final ListDouble data DoubleSeriesImpl Collection Double data this.data new ArrayList data GoalKicker.com Java Notes for Professionals 275 Override public DoubleSeries add DoubleSeries values List Double incoming values !": "input.pdf", "null ? values. data null if incoming null incoming. size ! data.size throw new IllegalArgumentException bad series List Double newdata new ArrayList data.size for int i 0 i data.size i newdata. addthis.data.geti incoming. geti beware autoboxing return DoubleSeries. instance newdata Override public ListDouble data return Collections .unmodifiableList data As you can see the add method is declared as DoubleSeries add DoubleSeries values and the compiler is happy. The pattern can be further nested if required. Section 47.11 Binding generic parameter to more than 1 type Generic parameters can also be bound to more than one type using the T extends Type1 Type2 ... syntax. Lets say you want to create a class whose Generic type should implement both Flushable and Closeable , you can write class ExampleClass T extends Flushable Closeable Now, the ExampleClass only accepts as generic parameters, types which implement both Flushable and Closeable . ExampleClass BufferedWriter arg1 Works because BufferedWriter implements both Flushable and Closeable ExampleClass Console arg4 Does NOT work because Console only implements Flushable ExampleClass ZipFile arg5 Does NOT work because ZipFile only implements Closeable ExampleClass Flushable arg2 Does NOT work because Closeable bound is not satisfied. ExampleClass Closeable arg3 Does NOT work because": "input.pdf", "Flushable bound is not satisfied. The class methods can choose to infer generic type arguments as either Closeable or Flushable . class ExampleClass T extends Flushable Closeable Assign it to a valid type as you want. public void test T param Flushable arg1 param Works Closeable arg2 param Works too. You can even invoke the methods of any valid type directly. GoalKicker.com Java Notes for Professionals 276 public void test2 T param param. flush Method of Flushable called on T and works fine. param. close Method of Closeable called on T and works fine too. Note You cannot bind the generic parameter to either of the type using OR clause. Only the AND clause is supported. Generic type can extends only one class and many interfaces. Class must be placed at the beginning of the list. Section 47.12 Using Generics to auto-cast With generics, its possible to return whatever the caller expects private MapString, Object data public T T getString key return T data.getkey The method will compile with a warning. The code is actually more safe than it looks because the Java runtime will do a cast when you use it Bar bar foo.getbar Its less safe when": "input.pdf", "you use generic types ListBar bars foo.getbars Here, the cast will work when the returned type is any kind of List i.e. returning ListString would not trigger a ClassCastException youd eventually get it when taking elements out of the list. To work around this problem, you can create an API which uses typed keys public final static KeyListBar BARS new KeyBARS along with this put method public T T putKeyT key, T value With this approach, you cant put the wrong type into the map, so the result will always be correct unless you accidentally create two keys with the same name but di\ufb00erent types. Related Type-safe Map Section 47.13 Use of instanceof with Generics Using generics to de\ufb01ne the type in instanceof Consider the following generic class Example declared with the formal parameter T class Example T GoalKicker.com Java Notes for Professionals 277 public boolean isTypeAString String s return s instanceof T Compilation error, cannot use T as class type here This will always give a Compilation error because as soon as the compiler compiles the Java source into Java bytecode it applies a process known as type erasure , which converts all generic code into non-generic code,": "input.pdf", "making impossible to distinguish among T types at runtime. The type used with instanceof has to be rei\ufb01able , which means that all information about the type has to be available at runtime, and this is usually not the case for generic types. The following class represents what two di\ufb00erent classes of Example , ExampleString and ExampleNumber, look like after generics has stripped o\ufb00 by type erasure class Example formal parameter is gone public boolean isTypeAString String s return s instanceof Object Both String and Number are now Object Since types are gone, its not possible for the JVM to know which type is T. Exception to the previous rule You can always use unbounded wildcard ? for specifying a type in the instanceof as follows public boolean isAList Object obj return obj instanceof List? This can be useful to evaluate whether an instance obj is a List or not System.out.printlnisAListfoo prints false System.out.printlnisAListnew ArrayList String prints true System.out.printlnisAListnew ArrayList Float prints true In fact, unbounded wildcard is considered a rei\ufb01able type. Using a generic instance with instanceof The other side of the coin is that using an instance t of T with instanceof is legal, as shown in": "input.pdf", "the following example class Example T public boolean isTypeAString T t return t instanceof String No compilation error this time because after the type erasure the class will look like the following class Example formal parameter is gone public boolean isTypeAString Object t return t instanceof String No compilation error this time GoalKicker.com Java Notes for Professionals 278Since, even if the type erasure happen anyway, now the JVM can distinguish among di\ufb00erent types in memory, even if they use the same reference type Object , as the following snippet shows Object obj1 new Stringfoo reference type Object, object type String Object obj2 new Integer11 reference type Object, object type Integer System.out.printlnobj1 instanceof String true System.out.printlnobj2 instanceof String false, its an Integer, not a String Section 47.14 Dierent ways for implementing a Generic Interface or extending a Generic Class Suppose the following generic interface has been declared public interface MyGenericInterface T public void fooT t Below are listed the possible ways to implement it. Non-generic class implementation with a speci\ufb01c type Choose a speci\ufb01c type to replace the formal type parameter T of MyGenericClass and implement it, as the following example does public class NonGenericClass implements MyGenericInterface String public void": "input.pdf", "fooString t type T has been replaced by String This class only deals with String , and this means that using MyGenericInterface with di\ufb00erent parameters e.g. Integer , Object etc. wont compile, as the following snippet shows NonGenericClass myClass new NonGenericClass myClass. foofoostring OK, legal myClass. foo11 NOT OK, does not compile myClass. foonew Object NOT OK, does not compile Generic class implementation Declare another generic interface with the formal type parameter T which implements MyGenericInterface , as follows public class MyGenericSubclass T implements MyGenericInterface T public void fooT t type T is still the same other methods... Note that a di\ufb00erent formal type parameter may have been used, as follows public class MyGenericSubclass U implements MyGenericInterface U equivalent to the previous declaration public void fooU t other methods... Raw type class implementation GoalKicker.com Java Notes for Professionals 279Declare a non-generic class which implements MyGenericInteface as a raw type not using generic at all, as follows public class MyGenericSubclass implements MyGenericInterface public void fooObject t type T has been replaced by Object other possible methods This way is not recommended, since it is not 100 safe at runtime because it mixes up raw type of the subclass with generics": "input.pdf", "of the interface and it is also confusing. Modern Java compilers will raise a warning with this kind of implementation, nevertheless the code - for compatibility reasons with older JVM 1.4 or earlier - will compile. All the ways listed above are also allowed when using a generic class as a supertype instead of a generic interface. GoalKicker.com Java Notes for Professionals 280Chapter 48 Classes and Objects Objects have states and behaviors. Example A dog has states - color, name, breed as well as behaviors wagging the tail, barking, eating. An object is an instance of a class. Class A class can be de\ufb01ned as a templateblueprint that describes the behaviorstate that the object of its type support. Section 48.1 Overloading Methods Sometimes the same functionality has to be written for di\ufb00erent kinds of inputs. At that time, one can use the same method name with a di\ufb00erent set of parameters. Each di\ufb00erent set of parameters is known as a method signature. As seen per the example, a single method can have multiple signatures. public class Displayer public void displayName String firstName System.out.printlnName is firstName public void displayName String firstName, String lastName System.out.printlnName is firstName lastName public static void": "input.pdf", "mainString args Displayer displayer new Displayer displayer. displayName Ram prints Name is Ram displayer. displayName Jon, Skeet prints Name is Jon Skeet The advantage is that the same functionality is called with two di\ufb00erent numbers of inputs. While invoking the method according to the input we are passing, In this case either one string value or two string values the corresponding method is executed. Methods can be overloaded Based on the number of parameters passed. 1. Example methodString s and methodString s1, String s2. Based on the order of parameters . 2. Example methodint i, float f and methodfloat f, int i. Note Methods cannot be overloaded by changing just the return type int method is considered the same as String method and will throw a RuntimeException if attempted. If you change the return type you must also change the parameters in order to overload. GoalKicker.com Java Notes for Professionals 281Section 48.2 Explaining what is method overloading and overriding Method Overriding and Overloading are two forms of polymorphism supported by Java. Method Overloading Method overloading also known as static Polymorphism is a way you can have two or more methods functions with same name in a single class. Yes": "input.pdf", "its as simple as that. public class Shape It could be a circle or rectangle or square private String type To calculate area of rectangle public Double areaLong length, Long breadth return Double length breadth To calculate area of a circle public Double areaLong radius return Double 3.14 r r This way user can call the same method for area depending on the type of shape it has. But the real question now is, how will java compiler will distinguish which method body is to be executed? Well Java have made it clear that even though the method names area in our case can be same but the arguments method is taking should be di\ufb00erent. Overloaded methods must have di\ufb00erent arguments list quantity and types. That being said we cannot add another method to calculate area of a square like this public Double areaLong side because in this case, it will con\ufb02ict with area method of circle and will cause ambiguity for java compiler. Thank god, there are some relaxations while writing overloaded methods like May have di\ufb00erent return types. May have di\ufb00erent access modi\ufb01ers. May throw di\ufb00erent exceptions. Why is this called static polymorphism? Well thats because which": "input.pdf", "overloaded methods is to be invoked is decided at compile time, based on the actual number of arguments and the compile-time types of the arguments. GoalKicker.com Java Notes for Professionals 282One of common reasons of using method overloading is the simplicity of code it provides. For example remember String.valueOf which takes almost any type of argument? What is written behind the scene is probably something like this static String valueOf boolean b static String valueOf char c static String valueOf char data static String valueOf char data, int offset, int count static String valueOf double d static String valueOf float f static String valueOf int i static String valueOf long l static String valueOf Object obj Method Overriding Well, method overriding yes you guess it right, it is also known as dynamic polymorphism is somewhat more interesting and complex topic. In method overriding we overwrite the method body provided by the parent class. Got it? No? Lets go through an example. public abstract class Shape public abstract Double area return 0.0 So we have a class called Shape and it has method called area which will probably return the area of the shape. Lets say now we have two": "input.pdf", "classes called Circle and Rectangle. public class Circle extends Shape private Double radius 5.0 See this annotation Override, it is telling that this method is from parent class Shape and is overridden here Override public Double area return 3.14 radius radius Similarly rectangle class public class Rectangle extends Shape private Double length 5.0 private Double breadth 10.0 See this annotation Override, it is telling that this method is from parent class Shape and is overridden here Override public Double area return length breadth GoalKicker.com Java Notes for Professionals 283 So, now both of your children classes have updated method body provided by the parent Shape class. Now question is how to see the result? Well lets do it the old psvm way. public class AreaFinder public static void mainString args This will create an object of circle class Shape circle new Circle This will create an object of Rectangle class Shape rectangle new Rectangle Drumbeats ...... This should print 78.5 System.out.printlnShape of circle circle.area This should print 50.0 System.out.printlnShape of rectangle rectangle. area Wow! isnt it great? Two objects of same type calling same methods and returning di\ufb00erent values. My friend, thats the power of dynamic polymorphism. Heres a": "input.pdf", "chart to better compare the di\ufb00erences between these two Method Overloading Method Overriding Method overloading is used to increase the readability of the program.Method overriding is used to provide the speci\ufb01c implementation of the method that is already provided by its super class. Method overloading is performed within class.Method overriding occurs in two classes that have IS-A inheritance relationship. In case of method overloading, parameter must be di\ufb00erent.In case of method overriding, parameter must be same. Method overloading is the example of compile time polymorphism.Method overriding is the example of run time polymorphism. In java, method overloading cant be performed by changing return type of the method only. Return type can be same or di\ufb00erent in method overloading. But you must have to change the parameter.Return type must be same or covariant in method overriding. Section 48.3 Constructors Constructors are special methods named after the class and without a return type, and are used to construct objects. Constructors, like methods, can take input parameters. Constructors are used to initialize objects. Abstract classes can have constructors also. public class Hello constructor public HelloString wordToPrint printHello wordToPrint public void printHello String word System.out.printlnword GoalKicker.com Java Notes for Professionals 284 instantiates the": "input.pdf", "object during creating and prints out the content of wordToPrint It is important to understand that constructors are di\ufb00erent from methods in several ways Constructors can only take the modi\ufb01ers public , private , and protected , and cannot be declared abstract , 1. final , static , or synchronized . Constructors do not have a return type.2. Constructors MUST be named the same as the class name. In the Hello example, the Hello objects 3. constructor name is the same as the class name. The this keyword has an additional usage inside constructors. this.method... calls a method on the 4. current instance, while this... refers to another constructor in the current class with di\ufb00erent signatures. Constructors also can be called through inheritance using the keyword super . public class SuperManClass public SuperManClass some implementation ... methods public class BatmanClass extends SupermanClass public BatmanClass super ... methods... See Java Language Speci\ufb01cation 8.8 and 15.9 Section 48.4 Initializing static \ufb01nal \ufb01elds using a static initializer To initialize a static final \ufb01elds that require using more than a single expression, a static initializer can be used to assign the value. The following example initializes a unmodi\ufb01able set of String s public": "input.pdf", "class MyClass public static final SetString WORDS static Set String set new HashSet set. addHello set. addWorld set. addfoo set. addbar set. add42 WORDS Collections .unmodifiableSet set GoalKicker.com Java Notes for Professionals 285 Section 48.5 Basic Object Construction and Use Objects come in their own class, so a simple example would be a car detailed explanations below public class Car Variables describing the characteristics of an individual car, varies per object private int milesPerGallon private String name private String color public int numGallonsInTank public Car milesPerGallon 0 name color numGallonsInTank 0 this is where an individual object is created public Carint mpg, int, gallonsInTank, String carName, String carColor milesPerGallon mpg name carName color carColor numGallonsInTank gallonsInTank methods to make the object more usable Cars need to drive public void driveint distanceInMiles get miles left in car int miles numGallonsInTank milesPerGallon check that car has enough gas to drive distanceInMiles if miles distanceInMiles numGallonsInTank numGallonsInTank - distanceInMiles milesPerGallon System.out.printlnDrove numGallonsInTank miles! else System.out.printlnCould not drive! public void paintCar String newColor color newColor set new Miles Per Gallon public void setMPGint newMPG milesPerGallon newMPG set new number of Gallon In Tank public void setGallonsInTank int numGallons numGallonsInTank numGallons public void nameCar": "input.pdf", "String newName name newName GoalKicker.com Java Notes for Professionals 286 Get the Car color public String getColor return color Get the Car name public String getName return name Get the number of Gallons public String getGallons return numGallonsInTank Objects are instances of their class. So, the way you would create an object would be by calling the Car class in one of two ways in your main class main method in Java or onCreate in Android. Option 1 Car newCar new Car30, 10, Ferrari , Red Option 1 is where you essentially tell the program everything about the Car upon creation of the object. Changing any property of the car would require calling one of the methods such as the repaintCar method. Example newCar. repaintCar Blue Note Make sure you pass the correct data type to the method. In the example above, you may also pass a variable to the repaintCar method as long as the data type is correct . That was an example of changing properties of an object, receiving properties of an object would require using a method from the Car class that has a return value meaning a method that is not void . Example": "input.pdf", "String myCarName newCar. getName returns string Ferrari Option 1 is the best option when you have all the objects data at the time of creation. Option 2 Car newCar new Car Option 2 gets the same e\ufb00ect but required more work to create an object correctly. I want to recall this Constructor in the Car class public void Car milesPerGallon 0 name color numGallonsInTank 0 Notice that you do not have to actually pass any parameters into the object to create it. This is very useful for when you do not have all the aspects of the object but you need to use the parts that you do have. This sets generic data into each of the instance variables of the object so that, if you call for a piece of data that does not exist, no errors GoalKicker.com Java Notes for Professionals 287are thrown. Note Do not forget that you have to set the parts of the object later that you did not initialize it with. For example, Car myCar new Car String color Car.getColor returns empty string This is a common mistake amongst objects that are not initialized with all their data. Errors were avoided because there": "input.pdf", "is a Constructor that allows an empty Car object to be created with stand-in variables public Car, but no part of the myCar was actually customized. Correct example of creating Car Object Car myCar new Car myCar.nameCarFerrari myCar.paintCar Purple myCar.setGallonsInTank 10 myCar.setMPG30 And, as a reminder, get an objects properties by calling a method in your main class. Example String myCarName myCar.getName returns string Ferrari Section 48.6 Simplest Possible Class class TrivialClass A class consists at a minimum of the class keyword, a name, and a body, which might be empty. You instantiate a class with the new operator. TrivialClass tc new TrivialClass Section 48.7 Object Member vs Static Member With this class class ObjectMemberVsStaticMember static int staticCounter 0 int memberCounter 0 void increment staticCounter memberCounter the following code snippet final ObjectMemberVsStaticMember o1 new ObjectMemberVsStaticMember final ObjectMemberVsStaticMember o2 new ObjectMemberVsStaticMember o1.increment o2.increment o2.increment GoalKicker.com Java Notes for Professionals 288System.out.printlno1 static counter o1.staticCounter System.out.printlno1 member counter o1.memberCounter System.out.println System.out.printlno2 static counter o2.staticCounter System.out.printlno2 member counter o2.memberCounter System.out.println System.out.printlnObjectMemberVsStaticMember.staticCounter ObjectMemberVsStaticMember. staticCounter the following line does not compile. You need an object to access its members System.out.printlnObjectMemberVsStaticMember.staticCounter ObjectMemberVsStaticMember.memberCounter produces this output o1 static counter 3 o1 member counter 1 o2 static counter": "input.pdf", "3 o2 member counter 2 ObjectMemberVsStaticMember.staticCounter 3 Note You should not call static members on objects, but on classes. While it does not make a di\ufb00erence for the JVM, human readers will appreciate it. static members are part of the class and exists only once per class. Non- static members exist on instances, there is an independent copy for each instance. This also means that you need access to an object of that class to access its members. GoalKicker.com Java Notes for Professionals 289Chapter 49 Local Inner Class A class i.e. created inside a method is called local inner class in java. If you want to invoke the methods of local inner class, you must instantiate this class inside the method. Section 49.1 Local Inner Class public class localInner1 private int data30instance variable void display class Local void msgSystem.out.printlndata Local l new Local l.msg public static void mainString args localInner1 obj new localInner1 obj.display GoalKicker.com Java Notes for Professionals 290Chapter 50 Nested and Inner Classes Using Java, developers have the ability to de\ufb01ne a class within another class. Such a class is called a Nested Class . Nested Classes are called Inner Classes if they were declared as non-static,": "input.pdf", "if not, they are simply called Static Nested Classes. This page is to document and provide details with examples on how to use Java Nested and Inner Classes. Section 50.1 A Simple Stack Using a Nested Class public class IntStack private IntStackNode head IntStackNode is the inner class of the class IntStack Each instance of this inner class functions as one link in the Overall stack that it helps to represent private static class IntStackNode private int val private IntStackNode next private IntStackNode int v, IntStackNode n val v next n public IntStack push int v head new IntStackNode v, head return this public int pop int x head.val head head.next return x And the use thereof, which notably does not at all acknowledge the existence of the nested class. public class Main public static void mainString args IntStack s new IntStack s. push4.push3.push2.push1.push0 prints 0, 1, 2, 3, 4, forint i 0 i 5 i System.out.prints.pop , Section 50.2 Static vs Non Static Nested Classes When creating a nested class, you face a choice of having that nested class static GoalKicker.com Java Notes for Professionals 291public class OuterClass1 private static class StaticNestedClass Or non-static public class OuterClass2 private": "input.pdf", "class NestedClass At its core, static nested classes do not have a surrounding instance of the outer class, whereas non-static nested classes do. This a\ufb00ects both wherewhen one is allowed to instantiate a nested class, and what instances of those nested classes are allowed to access. Adding to the above example public class OuterClass1 private int aField public void aMethod private static class StaticNestedClass private int innerField private StaticNestedClass innerField aField Illegal, cant access aField from static context aMethod Illegal, cant call aMethod from static context private StaticNestedClass OuterClass1 instance innerField instance. aField Legal public static void aStaticMethod StaticNestedClass s new StaticNestedClass Legal, able to construct in static context Do stuff involving s... public class OuterClass2 private int aField public void aMethod private class NestedClass private int innerField private NestedClass innerField aField Legal aMethod Legal GoalKicker.com Java Notes for Professionals 292 public void aNonStaticMethod NestedClass s new NestedClass Legal public static void aStaticMethod NestedClass s new NestedClass Illegal. Cant construct without surrounding OuterClass2 instance. As this is a static context, there is no surrounding OuterClass2 instance Thus, your decision of static vs non-static mainly depends on whether or not you need to be able to directly access \ufb01elds and": "input.pdf", "methods of the outer class, though it also has consequences for when and where you can construct the nested class. As a rule of thumb, make your nested classes static unless you need to access \ufb01elds and methods of the outer class. Similar to making your \ufb01elds private unless you need them public, this decreases the visibility available to the nested class by not allowing access to an outer instance, reducing the likelihood of error. Section 50.3 Access Modi\ufb01ers for Inner Classes A full explanation of Access Modi\ufb01ers in Java can be found here. But how do they interact with Inner classes? public , as usual, gives unrestricted access to any scope able to access the type. public class OuterClass public class InnerClass public int x 5 public InnerClass createInner return new InnerClass public class SomeOtherClass public static void mainString args int x new OuterClass .createInner .x Direct field access is legal both protected and the default modi\ufb01er of nothing behave as expected as well, the same as they do for non- nested classes. private , interestingly enough, does not restrict to the class it belongs to. Rather, it restricts to the compilation unit - the .java \ufb01le. This": "input.pdf", "means that Outer classes have full access to Inner class \ufb01elds and methods, even if they are marked private . public class OuterClass GoalKicker.com Java Notes for Professionals 293 public class InnerClass private int x private void anInnerMethod public InnerClass aMethod InnerClass a new InnerClass a. x 5 Legal a. anInnerMethod Legal return a The Inner Class itself can have a visibility other than public . By marking it private or another restricted access modi\ufb01er, other external classes will not be allowed to import and assign the type. They can still get references to objects of that type, however. public class OuterClass private class InnerClass public InnerClass makeInnerClass return new InnerClass public class AnotherClass public static void mainString args OuterClass o new OuterClass InnerClass x o.makeInnerClass Illegal, cant find type OuterClass. InnerClass x o.makeInnerClass Illegal, InnerClass has visibility private Object x o.makeInnerClass Legal Section 50.4 Anonymous Inner Classes An anonymous inner class is a form of inner class that is declared and instantiated with a single statement. As a consequence, there is no name for the class that can be used elsewhere in the program i.e. it is anonymous. Anonymous classes are typically used in situations where you need": "input.pdf", "to be able to create a light-weight class to be passed as a parameter. This is typically done with an interface. For example public static Comparator String CASEINSENSITIVE new Comparator String Override public int compare String string1, String string2 return string1. toUpperCase .compareTo string2. toUpperCase This anonymous class de\ufb01nes a Comparator String object CASEINSENSITIVE that compares two strings ignoring di\ufb00erences in case. Other interfaces that are frequently implemented and instantiated using anonymous classes are Runnable and GoalKicker.com Java Notes for Professionals 294Callable . For example An anonymous Runnable class is used to provide an instance that the Thread will run when started. Thread t new Threadnew Runnable Override public void run System.out.printlnHello world t.start Prints Hello world Anonymous inner classes can also be based on classes. In this case, the anonymous class implicitly extends the existing class. If the class being extended is abstract, then the anonymous class must implement all abstract methods. It may also override non-abstract methods. Constructors An anonymous class cannot have an explicit constructor. Instead, an implicit constructor is de\ufb01ned that uses super... to pass any parameters to a constructor in the class that is being extended. For example SomeClass anon new SomeClass 1, happiness": "input.pdf", "Override public int someMethod int arg do something The implicit constructor for our anonymous subclass of SomeClass will call a constructor of SomeClass that matches the call signature SomeClass int, String. If no constructor is available, you will get a compilation error. Any exceptions that are thrown by the matched constructor are also thrown by the implicit constructor. Naturally, this does not work when extending an interface. When you create an anonymous class from an interface, the classes superclass is java.lang.Object which only has a no-args constructor. Section 50.5 Create instance of non-static inner class from outside An inner class which is visible to any outside class can be created from this class as well. The inner class depends on the outside class and requires a reference to an instance of it. To create an instance of the inner class, the new operator only needs to be called on an instance of the outer class. class OuterClass class InnerClass class OutsideClass OuterClass outer new OuterClass OuterClass. InnerClass createInner return outer.new InnerClass GoalKicker.com Java Notes for Professionals 295Note the usage as outer.new. Section 50.6 Method Local Inner Classes A class written within a method called method local inner class .": "input.pdf", "In that case the scope of the inner class is restricted within the method. A method-local inner class can be instantiated only within the method where the inner class is de\ufb01ned. The example of using method local inner class public class OuterClass private void outerMethod final int outerInt 1 Method Local Inner Class class MethodLocalInnerClass private void print System.out.printlnMethod local inner class outerInt Accessing the inner class MethodLocalInnerClass inner new MethodLocalInnerClass inner. print public static void mainString args OuterClass outer new OuterClass outer. outerMethod Executing will give an output Method local inner class 1 . Section 50.7 Accessing the outer class from a non-static inner class The reference to the outer class uses the class name and this public class OuterClass public class InnerClass public void method System.out.printlnI can access my enclosing class OuterClass. this You can access \ufb01elds and methods of the outer class directly. public class OuterClass private int counter public class InnerClass public void method System.out.printlnI can access counter GoalKicker.com Java Notes for Professionals 296 But in case of name collision you can use the outer class reference. public class OuterClass private int counter public class InnerClass private int counter public void method System.out.printlnMy counter counter": "input.pdf", "System.out.printlnOuter counter OuterClass. this.counter updating my counter counter OuterClass. this.counter GoalKicker.com Java Notes for Professionals 297Chapter 51 The java.util.Objects Class Section 51.1 Basic use for object null check For null check in method Object nullableObject methodReturnObject if Objects. isNullnullableObject return For not null check in method Object nullableObject methodReturnObject if Objects. nonNullnullableObject return Section 51.2 Objects.nonNull method reference use in stream api In the old fashion way for collection null check ListObject someObjects methodGetList for Object obj someObjects if obj null continue doSomething obj With the Objects. nonNull method and Java8 Stream API, we can do the above in this way ListObject someObjects methodGetList someObjects. stream . filterObjectsnonNull . forEachthisdoSomething GoalKicker.com Java Notes for Professionals 298Chapter 52 Default Methods Default Method introduced in Java 8, allows developers to add new methods to an interface without breaking the existing implementations of this interface. It provides \ufb02exibility to allow the interface to de\ufb01ne an implementation which will be used as default when a class which implements that interface fails to provide an implementation of that method. Section 52.1 Basic usage of default methods Interface with default method public interface Printable default void printString System.out.println default implementation Class which falls back to": "input.pdf", "default implementation of link printString public class WithDefault implements Printable Custom implementation of link printString public class OverrideDefault implements Printable Override public void printString System.out.println overridden implementation The following statements new WithDefault .printString new OverrideDefault .printString Will produce this output default implementation overridden implementation Section 52.2 Accessing overridden default methods from implementing class In classes, super.foo will look in superclasses only. If you want to call a default implementation from a superinterface, you need to qualify super with the interface name Fooable. super.foo. public interface Fooable GoalKicker.com Java Notes for Professionals 299 default int foo return 3 public class A extends Object implements Fooable Override public int foo return super.foo 1 error no method foo in java.lang.Object return Fooable. super.foo 1 okay, returns 4 Section 52.3 Why use Default Methods? The simple answer is that it allows you to evolve an existing interface without breaking existing implementations. For example, you have Swim interface that you published 20 years ago. public interface Swim void backStroke We did a great job, our interface is very popular, there are many implementation on that around the world and you dont have control over their source code. public class FooSwimmer implements Swim public void": "input.pdf", "backStroke System.out.printlnDo backstroke After 20 years, youve decided to add new functionality to the interface, but it looks like our interface is frozen because it will break existing implementations. Luckily Java 8 introduces brand new feature called Default method. We can now add new method to the Swim interface. public interface Swim void backStroke default void sideStroke System.out.printlnDefault sidestroke implementation. Can be overridden Now all existing implementations of our interface can still work. But most importantly they can implement the newly added method in their own time. One of the biggest reasons for this change, and one of its biggest uses, is in the Java Collections framework. Oracle could not add a foreach method to the existing Iterable interface without breaking all existing code which implemented Iterable. By adding default methods, existing Iterable implementation will inherit the default implementation. Section 52.4 Accessing other interface methods within default method You can as well access other interface methods from within your default method. GoalKicker.com Java Notes for Professionals 300public interface Summable int getA int getB default int calculateSum return getA getB public class Sum implements Summable Override public int getA return 1 Override public int getB return 2 The following statement": "input.pdf", "will print 3 System.out.printlnnew Sum.calculateSum Default methods could be used along with interface static methods as well public interface Summable static int getA return 1 static int getB return 2 default int calculateSum return getA getB public class Sum implements Summable The following statement will also print 3 System.out.printlnnew Sum.calculateSum Section 52.5 Default method multiple inheritance collision Consider next example public interface A default void foo System.out.printlnA.foo public interface B default void foo System.out.printlnB.foo GoalKicker.com Java Notes for Professionals 301 Here are two interfaces declaring default method foo with the same signature. If you will try to extend these both interfaces in the new interface you have to make choice of two, because Java forces you to resolve this collision explicitly. First , you can declare method foo with the same signature as abstract , which will override A and B behaviour. public interface ABExtendsAbstract extends A, B Override void foo And when you will implement ABExtendsAbstract in the class you will have to provide foo implementation public class ABExtendsAbstractImpl implements ABExtendsAbstract Override public void foo System.out.printlnABImpl.foo Or second , you can provide a completely new default implementation. You also may reuse code of A and B foo methods": "input.pdf", "by Accessing overridden default methods from implementing class. public interface ABExtends extends A, B Override default void foo System.out.printlnABExtends.foo And when you will implement ABExtends in the class you will not have to provide foo implementation public class ABExtendsImpl implements ABExtends Section 52.6 Class, Abstract class and Interface method precedence Implementations in classes, including abstract declarations, take precedence over all interface defaults. Abstract class method takes precedence over Interface Default Method . public interface Swim default void backStroke System.out.printlnSwim.backStroke public abstract class AbstractSwimmer implements Swim public void backStroke System.out.printlnAbstractSwimmer.backStroke public class FooSwimmer extends AbstractSwimmer The following statement GoalKicker.com Java Notes for Professionals 302new FooSwimmer .backStroke Will produce AbstractSwimmer. backStroke Class method takes precedence over Interface Default Method public interface Swim default void backStroke System.out.printlnSwim.backStroke public abstract class AbstractSwimmer implements Swim public class FooSwimmer extends AbstractSwimmer public void backStroke System.out.printlnFooSwimmer.backStroke The following statement new FooSwimmer .backStroke Will produce FooSwimmer. backStroke GoalKicker.com Java Notes for Professionals 303Chapter 53 Packages package in java is used to group class and interfaces. This helps developer to avoid con\ufb02ict when there are huge numbers of classes. If we use this package the classes we can create a classinterface with same name in di\ufb00erent packages. By": "input.pdf", "using packages we can import the piece of again in another class. There many built in packages in java like 1.java.util 2.java.lang 3.java.io We can de\ufb01ne our own user de\ufb01ned packages . Section 53.1 Using Packages to create classes with the same name First Test.class package foo.bar public class Test Also Test.class in another package package foo.bar.baz public class Test The above is \ufb01ne because the two classes exist in di\ufb00erent packages. Section 53.2 Using Package Protected Scope In Java if you dont provide an access modi\ufb01er the default scope for variables is package-protected level. This means that classes can access the variables of other classes within the same package as if those variables were publicly available. package foo.bar public class ExampleClass double exampleNumber String exampleString public ExampleClass exampleNumber 3 exampleString Test String No getters or setters package foo.bar public class AnotherClass ExampleClass clazz new ExampleClass System.out.printlnExample Number clazz.exampleNumber Prints Example Number 3 System.out.printlnExample String clazz.exampleString Prints Example String Test String GoalKicker.com Java Notes for Professionals 304 This method will not work for a class in another package package baz.foo public class ThisShouldNotWork ExampleClass clazz new ExampleClass System.out.printlnExample Number clazz.exampleNumber Throws an exception System.out.printlnExample String clazz.exampleString Throws an exception": "input.pdf", "GoalKicker.com Java Notes for Professionals 305Chapter 54 Inheritance Inheritance is a basic object oriented feature in which one class acquires and extends upon the properties of another class, using the keyword extends . For Interfaces and the keyword implements , see interfaces. Section 54.1 Inheritance With the use of the extends keyword among classes, all the properties of the superclass also known as the Parent Class or Base Class are present in the subclass also known as the Child Class or Derived Class public class BaseClass public void baseMethod System.out.printlnDoing base class stuff public class SubClass extends BaseClass Instances of SubClass have inherited the method baseMethod SubClass s new SubClass s.baseMethod Valid, prints Doing base class stuff Additional content can be added to a subclass. Doing so allows for additional functionality in the subclass without any change to the base class or any other subclasses from that same base class public class Subclass2 extends BaseClass public void anotherMethod System.out.printlnDoing subclass2 stuff Subclass2 s2 new Subclass2 s2.baseMethod Still valid , prints Doing base class stuff s2.anotherMethod Also valid, prints Doing subclass2 stuff Fields are also inherited public class BaseClassWithField public int x public class SubClassWithField extends BaseClassWithField public SubClassWithField int": "input.pdf", "x this.x x Can access fields private \ufb01elds and methods still exist within the subclass, but are not accessible GoalKicker.com Java Notes for Professionals 306public class BaseClassWithPrivateField private int x 5 public int getX return x public class SubClassInheritsPrivateField extends BaseClassWithPrivateField public void printX System.out.printlnx Illegal, cant access private field x System.out.printlngetX Legal, prints 5 SubClassInheritsPrivateField s new SubClassInheritsPrivateField int x s.getX x will have a value of 5. In Java, each class may extend at most one other class. public class A public class B public class ExtendsTwoClasses extends A, B Illegal This is known as multiple inheritance, and while it is legal in some languages, Java does not permit it with classes. As a result of this, every class has an unbranching ancestral chain of classes leading to Object , from which all classes descend. Section 54.2 Abstract Classes An abstract class is a class marked with the abstract keyword. It, contrary to non-abstract class, may contain abstract - implementation-less - methods. It is, however, valid to create an abstract class without abstract methods. An abstract class cannot be instantiated. It can be sub-classed extended as long as the sub-class is either also abstract, or implements all": "input.pdf", "methods marked as abstract by super classes. An example of an abstract class public abstract class Component private int x, y public setPosition int x, int y this.x x this.y y public abstract void render The class must be marked abstract, when it has at least one abstract method. An abstract method is a method that has no implementation. Other methods can be declared within an abstract class that have implementation in order to provide common code for any sub-classes. Attempting to instantiate this class will provide a compile error GoalKicker.com Java Notes for Professionals 307error Component is abstract cannot be instantiated Component myComponent new Component However a class that extends Component , and provides an implementation for all of its abstract methods and can be instantiated. public class Button extends Component Override public void render render a button public class TextBox extends Component Override public void render render a textbox Instances of inheriting classes also can be cast as the parent class normal inheritance and they provide a polymorphic e\ufb00ect when the abstract method is called. Component myButton new Button Component myTextBox new TextBox myButton. render renders a button myTextBox. render renders a text box Abstract classes vs": "input.pdf", "Interfaces Abstract classes and interfaces both provide a way to de\ufb01ne method signatures while requiring the extendingimplementing class to provide the implementation. There are two key di\ufb00erences between abstract classes and interfaces A class may only extend a single class, but may implement many interfaces. An abstract class can contain instance non- static \ufb01elds, but interfaces may only contain static \ufb01elds. Version Java SE 8 Methods declared in interfaces could not contain implementations, so abstract classes were used when it was useful to provide additional methods which implementations called the abstract methods. Version Java SE 8 Java 8 allows interfaces to contain default methods, usually implemented using the other methods of the interface, making interfaces and abstract classes equally powerful in this regard. Anonymous subclasses of Abstract Classes As a convenience java allows for instantiation of anonymous instances of subclasses of abstract classes, which provide implementations for the abstract methods upon creating the new object. Using the above example this could look like this GoalKicker.com Java Notes for Professionals 308Component myAnonymousComponent new Component Override public void render render a quick 1-time use component Section 54.3 Using \ufb01nal to restrict inheritance and overriding Final classes When used in a class": "input.pdf", "declaration, the final modi\ufb01er prevents other classes from being declared that extend the class. A final class is a leaf class in the inheritance class hierarchy. This declares a final class final class MyFinalClass some code Compilation error cannot inherit from final MyFinalClass class MySubClass extends MyFinalClass more code Use-cases for \ufb01nal classes Final classes can be combined with a private constructor to control or prevent the instantiation of a class. This can be used to create a so-called utility class that only de\ufb01nes static members i.e. constants and static methods. public final class UtilityClass Private constructor to replace the default visible constructor private UtilityClass Static members can still be used as usual public static int doSomethingCool return 123 Immutable classes should also be declared as final . An immutable class is one whose instances cannot be changed after they have been created see the Immutable Objects topic. By doing this, you make it impossible to create a mutable subclass of an immutable class. That would violate the Liskov Substitution Principle which requires that a subtype should obey the behavioral contract of its supertypes. From a practical perspective, declaring an immutable class to be final makes it easier to": "input.pdf", "reason about program behavior. It also addresses security concerns in the scenario where untrusted code is executed in a security sandbox. For instance, since String is declared as final , a trusted class does not need to worry that it might be tricked into accepting mutable subclass, which the untrusted caller could then surreptitiously change. One disadvantage of final classes is that they do not work with some mocking frameworks such as Mockito. Update Mockito version 2 now support mocking of \ufb01nal classes. Final methods GoalKicker.com Java Notes for Professionals 309The final modi\ufb01er can also be applied to methods to prevent them being overridden in sub-classes public class MyClassWithFinalMethod public final void someMethod public class MySubClass extends MyClassWithFinalMethod Override public void someMethod Compiler error overridden method is final Final methods are typically used when you want to restrict what a subclass can change in a class without forbidding subclasses entirely. The final modi\ufb01er can also be applied to variables, but the meaning of final for variables is unrelated to inheritance. Section 54.4 The Liskov Substitution Principle Substitutability is a principle in object-oriented programming introduced by Barbara Liskov in a 1987 conference keynote stating that, if class B is a": "input.pdf", "subclass of class A, then wherever A is expected, B can be used instead class A ... class B extends A ... public void methodA obj ... A a new B Assignment OK methodnew B Passing as parameter OK This also applies when the type is an interface, where there doesnt need to any hierarchical relationship between the objects interface Foo void bar class A implements Foo void bar ... class B implements Foo void bar ... ListFoo foos new ArrayList foos.addnew A OK foos.addnew B OK Now the list contains objects that are not from the same class hierarchy. GoalKicker.com Java Notes for Professionals 310Section 54.5 Abstract class and Interface usage Is-a relation vs Has-a capability When to use abstract classes To implement the same or di\ufb00erent behaviour among multiple related objects When to use interfaces to implement a contract by multiple unrelated objects Abstract classes create is a relations while interfaces provide has a capability. This can be seen in the code below public class InterfaceAndAbstractClassDemo public static void mainString args Dog dog new DogJack,16 Cat cat new CatJoe,20 System.out.printlnDogdog System.out.printlnCatcat dog. remember dog. protectOwner Learn dl dog dl. learn cat. remember cat. protectOwner Climb c cat": "input.pdf", "c. climb Man man new ManRavindra ,40 System.out.printlnman Climb cm man cm. climb Think t man t. think Learn l man l. learn Apply a man a. apply abstract class Animal String name int lifeExpentency public AnimalString name,int lifeExpentency this.name name this.lifeExpentency lifeExpentency public abstract void remember public abstract void protectOwner public String toString return this.getClass .getSimpleName namelifeExpentency class Dog extends Animal implements Learn GoalKicker.com Java Notes for Professionals 311 public DogString name,int age supername,age public void remember System.out.printlnthis.getClass .getSimpleName can remember for 5 minutes public void protectOwner System.out.printlnthis.getClass .getSimpleName will protect owner public void learn System.out.printlnthis.getClass .getSimpleName can learn class Cat extends Animal implements Climb public CatString name,int age supername,age public void remember System.out.printlnthis.getClass .getSimpleName can remember for 16 hours public void protectOwner System.out.printlnthis.getClass .getSimpleName wont protect owner public void climb System.out.printlnthis.getClass .getSimpleName can climb interface Climb void climb interface Think void think interface Learn void learn interface Apply void apply class Man implements Think,Learn,Apply,Climb String name int age public ManString name,int age this.name name this.age age public void think System.out.printlnI can think this.getClass .getSimpleName public void learn System.out.printlnI can learn this.getClass .getSimpleName public void apply System.out.printlnI can apply this.getClass .getSimpleName public void climb System.out.printlnI can climb this.getClass": "input.pdf", ".getSimpleName public String toString GoalKicker.com Java Notes for Professionals 312 return Man nameAgeage output DogDogJack16 CatCatJoe20 Dog can remember for 5 minutes Dog will protect owner Dog can learn Cat can remember for 16 hours Cat wont protect owner Cat can climb Man RavindraAge40 I can climbMan I can thinkMan I can learnMan I can applyMan Key notes Animal is an abstract class with shared attributes name and lifeExpectancy and abstract methods 1. remember and protectOwner . Dog and Cat are Animals that have implemented the remember and protectOwner methods. Cat can climb but Dog cannot. Dog can think but Cat cannot. These speci\ufb01c capabilities are added to Cat 2. and Dog by implementation. Man is not an Animal but he can Think , Learn , Apply , and Climb . 3. Cat is not a Man but it can Climb . 4. Dog is not a Man but it can Learn 5. Man is neither a Cat nor a Dog but can have some of the capabilities of the latter two without extending 6. Animal , Cat, or Dog. This is done with Interfaces. Even though Animal is an abstract class, it has a constructor, unlike an interface.": "input.pdf", "7. TLDR Unrelated classes can have capabilities through interfaces, but related classes change the behaviour through extension of base classes. Refer to the Java documentation page to understand which one to use in a speci\ufb01c use case. Consider using abstract classes if... You want to share code among several closely related classes.1. You expect that classes that extend your abstract class have many common methods or \ufb01elds, or require2. access modi\ufb01ers other than public such as protected and private. You want to declare non-static or non-\ufb01nal \ufb01elds.3. Consider using interfaces if... You expect that unrelated classes would implement your interface. For example, many unrelated objects can1. implement the Serializable interface. GoalKicker.com Java Notes for Professionals 313You want to specify the behaviour of a particular data type but are not concerned about who implements its2. behaviour. You want to take advantage of multiple inheritance of type.3. Section 54.6 Static Inheritance Static method can be inherited similar to normal methods, however unlike normal methods it is impossible to create abstract methods in order to force static method overriding. Writing a method with the same signature as a static method in a super class appears to be a form of overriding, but": "input.pdf", "really this simply creates a new function hides the other. public class BaseClass public static int num 5 public static void sayHello System.out.printlnHello public static void mainString args BaseClass. sayHello System.out.printlnBaseClasss num BaseClass. num SubClass. sayHello This will be different than the above statements output, since it runs A different method SubClass. sayHello true StaticOverride. sayHello System.out.printlnStaticOverrides num StaticOverride. num public class SubClass extends BaseClass Inherits the sayHello function, but does not override it public static void sayHello boolean test System.out.printlnHey public static class StaticOverride extends BaseClass Hides the num field from BaseClass You can even change the type, since this doesnt affect the signature public static String num test Cannot use Override annotation, since this is static This overrides the sayHello method from BaseClass public static void sayHello System.out.printlnStatic says Hi Running any of these classes produces the output Hello BaseClasss num 5 GoalKicker.com Java Notes for Professionals 314Hello Hey Static says Hi StaticOverrides num test Note that unlike normal inheritance, in static inheritance methods are not hidden. You can always call the base sayHello method by using BaseClass. sayHello . But classes do inherit static methods if no methods with the same signature are found in the": "input.pdf", "subclass. If two methods signatures vary, both methods can be run from the subclass, even if the name is the same. Static \ufb01elds hide each other in a similar way. Section 54.7 Programming to an interface The idea behind programming to an interface is to base the code primarily on interfaces and only use concrete classes at the time of instantiation. In this context, good code dealing with e.g. Java collections will look something like this not that the method itself is of any use at all, just illustration public T SetT toSetCollection T collection return Sets.newHashSet collection while bad code might look like this public T HashSet T toSetArrayList T collection return Sets.newHashSet collection Not only the former can be applied to a wider choice of arguments, its results will be more compatible with code provided by other developers that generally adhere to the concept of programming to an interface. However, the most important reasons to use the former are most of the time the context, in which the result is used, does not and should not need that many details as the concrete implementation provides adhering to an interface forces cleaner code and less hacks such as": "input.pdf", "yet another public method gets added to a class serving some speci\ufb01c scenario the code is more testable as interfaces are easily mockable \ufb01nally, the concept helps even if only one implementation is expected at least for testability. So how can one easily apply the concept of programming to an interface when writing new code having in mind one particular implementation? One option that we commonly use is a combination of the following patterns programming to an interface factory builder The following example based on these principles is a simpli\ufb01ed and truncated version of an RPC implementation written for a number of di\ufb00erent protocols public interface RemoteInvoker RQ, RS CompletableFuture RS invokeRQ request, Class RS responseClass The above interface is not supposed to be instantiated directly via a factory, instead we derive further more GoalKicker.com Java Notes for Professionals 315concrete interfaces, one for HTTP invocation and one for AMQP, each then having a factory and a builder to construct instances, which in turn are also instances of the above interface public interface AmqpInvoker extends RemoteInvoker static AmqpInvokerBuilder with String instanceId, ConnectionFactory factory return new AmqpInvokerBuilder instanceId, factory Instances of RemoteInvoker for the use with AMQP can now be constructed": "input.pdf", "as easy as or more involved depending on the builder RemoteInvoker invoker AmqpInvoker. withinstanceId, factory .requestRouter router .build And an invocation of a request is as easy as Response res invoker. invokenew Requestdata, Response. class.get Due to Java 8 permitting placing of static methods directly into interfaces, the intermediate factory has become implicit in the above code replaced with AmqpInvoker. with. In Java prior to version 8, the same e\ufb00ect can be achieved with an inner Factory class public interface AmqpInvoker extends RemoteInvoker class Factory public static AmqpInvokerBuilder with String instanceId, ConnectionFactory factory return new AmqpInvokerBuilder instanceId, factory The corresponding instantiation would then turn into RemoteInvoker invoker AmqpInvoker. Factory.withinstanceId, factory .requestRouter router .build The builder used above could look like this although this is a simpli\ufb01cation as the actual one permits de\ufb01ning of up to 15 parameters deviating from defaults. Note that the construct is not public, so it is speci\ufb01cally usable only from the above AmqpInvoker interface public class AmqpInvokerBuilder ... AmqpInvokerBuilder String instanceId, ConnectionFactory factory this.instanceId instanceId this.factory factory public AmqpInvokerBuilder requestRouter RequestRouter requestRouter this.requestRouter requestRouter return this public AmqpInvoker build throws TimeoutException, IOException return new AmqpInvokerImpl instanceId, factory, requestRouter GoalKicker.com Java Notes for Professionals 316 Generally,": "input.pdf", "a builder can also be generated using a tool like FreeBuilder. Finally, the standard and the only expected implementation of this interface is de\ufb01ned as a package-local class to enforce the use of the interface, the factory and the builder class AmqpInvokerImpl implements AmqpInvoker AmqpInvokerImpl String instanceId, ConnectionFactory factory, RequestRouter requestRouter ... Override public RQ, RS CompletableFuture RS invokefinal RQ request, final ClassRS respClass ... Meanwhile, this pattern proved to be very e\ufb03cient in developing all our new code not matter how simple or complex the functionality is. Section 54.8 Overriding in Inheritance Overriding in Inheritance is used when you use a already de\ufb01ned method from a super class in a sub class, but in a di\ufb00erent way than how the method was originally designed in the super class. Overriding allows the user to reuse code by using existing material and modifying it to suit the users needs better. The following example demonstrates how ClassB overrides the functionality of ClassA by changing what gets sent out through the printing method Example public static void mainString args ClassA a new ClassA ClassA b new ClassB a.printing b.printing class ClassA public void printing System.out.printlnA class ClassB extends ClassA public void printing": "input.pdf", "System.out.printlnB Output A GoalKicker.com Java Notes for Professionals 317B Section 54.9 Variable shadowing Variables are SHADOWED and methods are OVERRIDDEN. Which variable will be used depends on the class that the variable is declared of. Which method will be used depends on the actual class of the object that is referenced by the variable. class Car public int gearRatio 8 public String accelerate return Accelerate Car class SportsCar extends Car public int gearRatio 9 public String accelerate return Accelerate SportsCar public void test public static void mainString args Car car new SportsCar System.out.printlncar.gearRatio car.accelerate will print out 8 Accelerate SportsCar Section 54.10 Narrowing and Widening of object references Casting an instance of a base class to a subclass as in b B a is called narrowing as you are trying to narrow the base class object to a more speci\ufb01c class object and needs an explicit type-cast. Casting an instance of a subclass to a base class as in A a b is called widening and does not need a type-cast. To illustrate, consider the following class declarations, and test code class Vehicle class Car extends Vehicle class Truck extends Vehicle class MotorCycle extends Vehicle class Test GoalKicker.com Java": "input.pdf", "Notes for Professionals 318 public static void mainString args Vehicle vehicle new Car Car car new Car vehicle car is valid, no cast needed Car c vehicle not valid Car c Car vehicle valid The statement Vehicle vehicle new Car is a valid Java statement. Every instance of Car is also a Vehicle . Therefore, the assignment is legal without the need for an explicit type-cast. On the other hand, Car c vehicle is not valid. The static type of the vehicle variable is Vehicle which means that it could refer to an instance of Car, Truck,MotorCycle , or any other current or future subclass ofVehicle. Or indeed, an instance of Vehicleitself, since we did not declare it as an abstractclass. The assignment cannot be allowed, since that might lead to carreferring to a Truck instance. To prevent this situation, we need to add an explicit type-cast Car c Car vehicle The type-cast tells the compiler that we expect the value of vehicle to be a Car or a subclass of Car. If necessary, compiler will insert code to perform a run-time type check. If the check fails, then a ClassCastException will be thrown when the code is executed.": "input.pdf", "Note that not all type-casts are valid. For example String s String vehicle not valid The Java compiler knows that an instance that is type compatible with Vehicle cannot ever be type compatible with String . The type-cast could never succeed, and the JLS mandates that this gives in a compilation error. Section 54.11 Inheritance and Static Methods In Java, parent and child class both can have static methods with the same name. But in such cases implementation of static method in child is hiding parent class implementation, its not method overriding. For example class StaticMethodTest static method and inheritance public static void mainString args Parent p new Child p.staticMethod prints Inside Parent Child p.staticMethod prints Inside Child static class Parent public static void staticMethod System.out.printlnInside Parent static class Child extends Parent public static void staticMethod GoalKicker.com Java Notes for Professionals 319 System.out.printlnInside Child Static methods are bind to a class not to an instance and this method binding happens at compile time. Since in the \ufb01rst call to staticMethod , parent class reference p was used, Parent s version of staticMethod is invoked. In second case, we did cast p into Child class, Child s staticMethod executed. GoalKicker.com": "input.pdf", "Java Notes for Professionals 320Chapter 55 Reference Types Section 55.1 Dierent Reference Types java.lang.ref package provides reference-object classes, which support a limited degree of interaction with the garbage collector. Java has four main di\ufb00erent reference types. They are Strong Reference Weak Reference Soft Reference Phantom Reference 1. Strong Reference This is the usual form of creating objects. MyObject myObject new MyObject The variable holder is holding a strong reference to the object created. As long as this variable is live and holds this value, the MyObject instance will not be collected by the garbage collector. 2. Weak Reference When you do not want to keep an object longer, and you need to clearfree the memory allocated for an object as soon as possible, this is the way to do so. WeakReference myObjectRef new WeakReference MyObject Simply, a weak reference is a reference that isnt strong enough to force an object to remain in memory. Weak references allow you to leverage the garbage collectors ability to determine reachability for you, so you dont have to do it yourself. When you need the object you created, just use .get method myObjectRef. get Following code will exemplify this WeakReference myObjectRef new WeakReference": "input.pdf", "MyObject System.out.printlnmyObjectRef. get This will print the object reference address System.gc System.out.printlnmyObjectRef. get This will print null if the GC cleaned up the object 3. Soft Reference Soft references are slightly stronger than weak references. You can create a soft referenced object as following SoftReference myObjectRef new SoftReference MyObject They can hold onto the memory more strongly than the weak reference. If you have enough memory supplyresources, garbage collector will not clean the soft references as enthusiastically as weak references. GoalKicker.com Java Notes for Professionals 321Soft references are handy to use in caching. You can create soft referenced objects as a cache, where they kept until your memory runs out. When your memory cant supply enough resources, garbage collector will remove soft references. SoftReference myObjectRef new SoftReference MyObject System.out.printlnmyObjectRef. get This will print the reference address of the Object System.gc System.out.printlnmyObjectRef. get This may or may not print the reference address of the Object 4. Phantom Reference This is the weakest referencing type. If you created an object reference using Phantom Reference, the get method will always return null! The use of this referencing is that Phantom reference objects, which are enqueued after the collector determines that their referents": "input.pdf", "may otherwise be reclaimed. Phantom references are most often used for scheduling pre- mortem cleanup actions in a more \ufb02exible way than is possible with the Java \ufb01nalization mechanism. - From Phantom Reference Javadoc from Oracle. You can create an object of Phantom Reference as following PhantomReference myObjectRef new PhantomReference MyObject GoalKicker.com Java Notes for Professionals 322Chapter 56 Console IO Section 56.1 Reading user input from the console Using BufferedReader System.out.printlnPlease type your name and press Enter. BufferedReader reader new BufferedReader new InputStreamReader System.in try String name reader. readLine System.out.printlnHello, name ! catchIOException e System.out.printlnAn error occurred e.getMessage The following imports are needed for this code import java.io.BufferedReader import java.io.IOException import java.io.InputStreamReader Using Scanner Version Java SE 5 System.out.printlnPlease type your name and press Enter Scanner scanner new Scanner System.in String name scanner. nextLine System.out.printlnHello, name ! The following import is needed for this example import java.util.Scanner To read more than one line, invoke scanner. nextLine repeatedly System.out.printlnPlease enter your first and your last name, on separate lines. Scanner scanner new Scanner System.in String firstName scanner. nextLine String lastName scanner. nextLine System.out.printlnHello, firstName lastName ! There are two methods for obtaining Strings , next and nextLine . next returns": "input.pdf", "text up until the \ufb01rst space also known as a token, and nextLine returns all text that the user inputted until pressing enter. Scanner also provides utility methods for reading data types other than String . These include scanner. nextByte scanner. nextShort scanner. nextInt scanner. nextLong scanner. nextFloat scanner. nextDouble scanner. nextBigInteger GoalKicker.com Java Notes for Professionals 323scanner. nextBigDecimal Pre\ufb01xing any of these methods with has as in hasNextLine , hasNextInt returns true if the stream has any more of the request type. Note These methods will crash the program if the input is not of the requested type for example, typing a for nextInt . You can use a try catch to prevent this see Exceptions Scanner scanner new Scanner System.in Create the scanner scanner. useLocale Locale.US Set number format excepted System.out.printlnPlease input a float, decimal separator is . if scanner. hasNextFloat Check if it is a float float fValue scanner. nextFloat retrive the value directly as float System.out.printlnfValue is a float else String sValue scanner. next We can not retrive as float System.out.printlnsValue is not a float Using System.console Version Java SE 6 String name System.console.readLine Please type your name and press Entern System.out.printfHello, s! , name": "input.pdf", "To read passwords without echoing as in unix terminal char password System.console.readPassword Advantages Reading methods are synchronized Format string syntax can be used Note This will only work if the program is run from a real command line without redirecting the standard input and output streams. It does not work when the program is run from within certain IDEs, such as Eclipse. For code that works within IDEs and with stream redirection, see the other examples. Section 56.2 Aligning strings in console The method PrintWriter .format called through System.out.format can be used to print aligned strings in console. The method receives a String with the format information and a series of objects to format String rowsStrings new String 1, 1234, 1234567 , 123456789 String column1Format -3s min 3 characters, left aligned String column2Format -5.8s min 5 and max 8 characters, left aligned String column3Format 6.6s fixed size 6 characters, right aligned String formatInfo column1Format column2Format column3Format forint i 0 i rowsStrings. length i System.out.formatformatInfo, rowsStrings i, rowsStrings i, rowsStrings i System.out.println Output GoalKicker.com Java Notes for Professionals 3241 1 1 1234 1234 1234 1234567 1234567 123456 123456789 12345678 123456 Using format strings with \ufb01xed size permits to print the": "input.pdf", "strings in a table-like appearance with \ufb01xed size columns String rowsStrings new String 1, 1234, 1234567 , 123456789 String column1Format -3.3s fixed size 3 characters, left aligned String column2Format -8.8s fixed size 8 characters, left aligned String column3Format 6.6s fixed size 6 characters, right aligned String formatInfo column1Format column2Format column3Format forint i 0 i rowsStrings. length i System.out.formatformatInfo, rowsStrings i, rowsStrings i, rowsStrings i System.out.println Output 1 1 1 123 1234 1234 123 1234567 123456 123 12345678 123456 Format strings examples s just a string with no formatting 5s format the string with a minimum of 5 characters if the string is shorter it will be padded to 5 characters and right aligned -5s format the string with a minimum of 5 characters if the string is shorter it will be padded to 5 characters and left aligned 5.10s format the string with a minimum of 5 characters and a maximum of 10 characters if the string is shorter than 5 it will be padded to 5 characters and right aligned if the string is longer than 10 it will be truncated to 10 characters and right aligned -5.5s format the string with a \ufb01xed size of 5 characters": "input.pdf", "minimum and maximum are equals if the string is shorter than 5 it will be padded to 5 characters and left aligned if the string is longer than 5 it will be truncated to 5 characters and left aligned Section 56.3 Implementing Basic Command-Line Behavior For basic prototypes or basic command-line behavior, the following loop comes in handy. public class ExampleCli private static final String CLILINE example-cli console like string private static final String CMDQUIT quit string for exiting the program private static final String CMDHELLO hello string for printing Hello World! on the screen private static final String CMDANSWER answer string for printing 42 on the screen GoalKicker.com Java Notes for Professionals 325 public static void mainString args ExampleCli claimCli new ExampleCli creates an object of this class try claimCli. start calls the start function to do the work like console catch IOException e e. printStackTrace prints the exception log if it is failed to do get the user input or something like that private void start throws IOException String cmd BufferedReader reader new BufferedReader new InputStreamReader System.in while !cmd.equalsCMDQUIT terminates console if user input is quit System.out.printCLILINE prints the console-like string cmd reader. readLine takes input from": "input.pdf", "user. user input should be started with hello, answer or quit String cmdArr cmd.split if cmdArr0.equalsCMDHELLO executes when user input starts with hello hello cmdArr else if cmdArr0.equalsCMDANSWER executes when user input starts with answer answer cmdArr prints Hello World! on the screen if user input starts with hello private void helloString cmdArr System.out.printlnHello World! prints 42 on the screen if user input starts with answer private void answerString cmdArr System.out.println42 GoalKicker.com Java Notes for Professionals 326Chapter 57 Streams A Stream represents a sequence of elements and supports di\ufb00erent kind of operations to perform computations upon those elements. With Java 8, Collection interface has two methods to generate a Stream stream and parallelStream . Stream operations are either intermediate or terminal. Intermediate operations return a Stream so multiple intermediate operations can be chained before the Stream is closed. Terminal operations are either void or return a non-stream result. Section 57.1 Using Streams A Stream is a sequence of elements upon which sequential and parallel aggregate operations can be performed. Any given Stream can potentially have an unlimited amount of data \ufb02owing through it. As a result, data received from a Stream is processed individually as it arrives, as opposed": "input.pdf", "to performing batch processing on the data altogether. When combined with lambda expressions they provide a concise way to perform operations on sequences of data using a functional approach. Example see it work on Ideone StreamString fruitStream Stream. ofapple, banana , pear, kiwi, orange fruitStream. filters - s.contains a . mapStringtoUpperCase . sorted . forEachSystem.outprintln Output APPLE BANANA ORANGE PEAR The operations performed by the above code can be summarized as follows Create a StreamString containing a sequenced ordered Stream of fruit String elements using the static 1. factory method Stream.ofvalues. The filter operation retains only elements that match a given predicate the elements that when tested 2. by the predicate return true. In this case, it retains the elements containing an a. The predicate is given as a lambda expression. The map operation transforms each element using a given function, called a mapper. In this case, each fruit 3. String is mapped to its uppercase String version using the method-reference StringtoUppercase . Note that the map operation will return a stream with a di\ufb00erent generic type if the mapping function returns a type di\ufb00erent to its input parameter. For example on a StreamString calling .mapStringisEmpty returns a StreamBoolean": "input.pdf", "The sorted operation sorts the elements of the Stream according to their natural ordering 4. GoalKicker.com Java Notes for Professionals 327lexicographically, in the case of String . Finally, the forEachaction operation performs an action which acts on each element of the Stream , 5. passing it to a Consumer . In the example, each element is simply being printed to the console. This operation is a terminal operation, thus making it impossible to operate on it again. Note that operations de\ufb01ned on the Stream are performed because of the terminal operation. Without a terminal operation, the stream is not processed. Streams can not be reused. Once a terminal operation is called, the Stream object becomes unusable. Operations as seen above are chained together to form what can be seen as a query on the data. Closing Streams Note that a Stream generally does not have to be closed. It is only required to close streams that operate on IO channels. Most Stream types dont operate on resources and therefore dont require closing. The Stream interface extends AutoCloseable . Streams can be closed by calling the close method or by using try- with-resource statements. An example use case where a": "input.pdf", "Stream should be closed is when you create a Stream of lines from a \ufb01le try StreamString lines Files.linesPaths.getsomePath lines. forEachSystem.outprintln The Stream interface also declares the Stream.onClose method which allows you to register Runnable handlers which will be called when the stream is closed. An example use case is where code which produces a stream needs to know when it is consumed to perform some cleanup. public StreamStringstreamAndDelete Path path throws IOException return Files.linespath.onClose - someClass. deletePath path The run handler will only execute if the close method gets called, either explicitly or implicitly by a try-with- resources statement. Processing Order GoalKicker.com Java Notes for Professionals 328A Stream objects processing can be sequential or parallel. In a sequential mode, the elements are processed in the order of the source of the Stream . If the Stream is ordered such as a SortedMap implementation or a List the processing is guaranteed to match the ordering of the source. In other cases, however, care should be taken not to depend on the ordering see is the Java HashMap keySet iteration order consistent? . Example ListInteger integerList Arrays.asList0, 1, 2, 3, 42 sequential long howManyOddNumbers integerList. stream . filtere - e": "input.pdf", "2 1 . count System.out.printlnhowManyOddNumbers Output 2 Live on Ideone Parallel mode allows the use of multiple threads on multiple cores but there is no guarantee of the order in which elements are processed. If multiple methods are called on a sequential Stream , not every method has to be invoked. For example, if a Stream is \ufb01ltered and the number of elements is reduced to one, a subsequent call to a method such as sort will not occur. This can increase the performance of a sequential Stream an optimization that is not possible with a parallel Stream . Example parallel long howManyOddNumbersParallel integerList. parallelStream . filtere - e 2 1 . count System.out.printlnhowManyOddNumbersParallel Output 2 Live on Ideone Di\ufb00erences from Containers or Collections While some actions can be performed on both Containers and Streams, they ultimately serve di\ufb00erent purposes and support di\ufb00erent operations. Containers are more focused on how the elements are stored and how those elements can be accessed e\ufb03ciently. A Stream , on the other hand, doesnt provide direct access and manipulation to its elements it is more dedicated to the group of objects as a collective entity and performing operations on that entity as a": "input.pdf", "whole. Stream and Collection are separate high-level abstractions for these di\ufb00ering purposes. Section 57.2 Consuming Streams A Stream will only be traversed when there is a terminal operation , like count, collect or forEach. Otherwise, no operation on the Stream will be performed. In the following example, no terminal operation is added to the Stream , so the filter operation will not be invoked and no output will be produced because peek is NOT a terminal operation . GoalKicker.com Java Notes for Professionals 329IntStream. range1, 10.filtera - a 2 0.peekSystem.outprintln Live on Ideone This is a Stream sequence with a valid terminal operation , thus an output is produced. You could also use forEach instead of peek IntStream. range1, 10.filtera - a 2 0.forEachSystem.outprintln Live on Ideone Output 2 4 6 8 After the terminal operation is performed, the Stream is consumed and cannot be reused. Although a given stream object cannot be reused, its easy to create a reusable Iterable that delegates to a stream pipeline. This can be useful for returning a modi\ufb01ed view of a live data set without having to collect results into a temporary structure. ListString list Arrays.asListFOO, BAR Iterable String iterable - list.stream.mapStringtoLowerCase": "input.pdf", ".iterator for String str iterable System.out.printlnstr for String str iterable System.out.printlnstr Output foo bar foo bar This works because Iterable declares a single abstract method Iterator T iterator . That makes it e\ufb00ectively a functional interface, implemented by a lambda that creates a new stream on each call. In general, a Stream operates as shown in the following image GoalKicker.com Java Notes for Professionals 330 NOTE Argument checks are always performed, even without a terminal operation try IntStream. range1, 10.filternull catch NullPointerException e System.out.printlnWe got a NullPointerException as null was passed as an argument to filter Live on Ideone Output We got a NullPointerException as null was passed as an argument to \ufb01lter Section 57.3 Creating a Frequency Map The groupingBy classifier, downstream collector allows the collection of Stream elements into a Map by classifying each element in a group and performing a downstream operation on the elements classi\ufb01ed in the same group. A classic example of this principle is to use a Map to count the occurrences of elements in a Stream . In this example, the classi\ufb01er is simply the identity function, which returns the element as-is. The downstream operation counts the number of equal elements, using": "input.pdf", "counting . Stream.ofapple, orange , banana , apple .collectCollectors. groupingBy Function. identity , Collectors. counting .entrySet .forEachSystem.outprintln The downstream operation is itself a collector Collectors. counting that operates on elements of type String and produces a result of type Long . The result of the collect method call is a MapString, Long. This would produce the following output banana1 orange1 apple2 Section 57.4 In\ufb01nite Streams It is possible to generate a Stream that does not end. Calling a terminal method on an in\ufb01nite Stream causes the Stream to enter an in\ufb01nite loop. The limit method of a Stream can be used to limit the number of terms of the Stream that Java processes. GoalKicker.com Java Notes for Professionals 331This example generates a Stream of all natural numbers, starting with the number 1. Each successive term of the Stream is one higher than the previous. By calling the limit method of this Stream , only the \ufb01rst \ufb01ve terms of the Stream are considered and printed. Generate infinite stream - 1, 2, 3, 4, 5, 6, 7, ... IntStream naturalNumbers IntStream. iterate1, x - x 1 Print out only the first 5 terms naturalNumbers. limit5.forEachSystem.outprintln Output 1 2 3 4": "input.pdf", "5 Another way of generating an in\ufb01nite stream is using the Stream.generate method. This method takes a lambda of type Supplier . Generate an infinite stream of random numbers StreamDouble infiniteRandomNumbers Stream. generate Mathrandom Print out only the first 10 random numbers infiniteRandomNumbers. limit10.forEachSystem.outprintln Section 57.5 Collect Elements of a Stream into a Collection Collect with toList and toSet Elements from a Stream can be easily collected into a container by using the Stream.collect operation System.out.printlnArrays .asListapple, banana , pear, kiwi, orange .stream .filters - s.contains a .collectCollectors. toList prints apple, banana, pear, orange Other collection instances, such as a Set, can be made by using other Collectors built-in methods. For example, Collectors. toSet collects the elements of a Stream into a Set. Explicit control over the implementation of List or Set According to documentation of CollectorstoList and CollectorstoSet , there are no guarantees on the type, mutability, serializability, or thread-safety of the List or Set returned. For explicit control over the implementation to be returned, CollectorstoCollection Supplier can be used instead, where the given supplier returns a new and empty collection. syntax with method reference GoalKicker.com Java Notes for Professionals 332System.out.printlnstrings . stream . filters - s !": "input.pdf", "null s.length 3 . collectCollectors. toCollection ArrayList new syntax with lambda System.out.printlnstrings . stream . filters - s ! null s.length 3 . collectCollectors. toCollection - new LinkedHashSet Collecting Elements using toMap Collector accumulates elements into a Map, Where key is the Student Id and Value is Student Value. ListStudent students new ArrayList Student students. addnew Student 1,test1 students. addnew Student 2,test2 students. addnew Student 3,test3 MapInteger, String IdToName students. stream . collectCollectors. toMapStudentgetId, Student getName System.out.printlnIdToName Output 1test1, 2test2, 3test3 The Collectors.toMap has another implementation Collector T, ?, MapK,U toMapFunction ? super T, ? extends K keyMapper, Function ? super T, ? extends U valueMapper, BinaryOperator U mergeFunction .The mergeFunction is mostly used to select either new value or retain old value if the key is repeated when adding a new member in the Map from a list. The mergeFunction often looks like s1, s2 - s1 to retain value corresponding to the repeated key, or s1, s2 - s2 to put new value for the repeated key. Collecting Elements to Map of Collections Example from ArrayList to MapString, List Often it requires to make a map of list out of a primary list. Example From a student": "input.pdf", "of list, we need to make a map of list of subjects for each student. List Student list new ArrayList list. addnew Student Davis, SUBJECT. MATH, 35.0 list. addnew Student Davis, SUBJECT. SCIENCE, 12.9 list. addnew Student Davis, SUBJECT. GEOGRAPHY , 37.0 list. addnew Student Sascha , SUBJECT. ENGLISH, 85.0 list. addnew Student Sascha , SUBJECT. MATH, 80.0 list. addnew Student Sascha , SUBJECT. SCIENCE, 12.0 list. addnew Student Sascha , SUBJECT. LITERATURE , 50.0 list. addnew Student Robert , SUBJECT. LITERATURE , 12.0 GoalKicker.com Java Notes for Professionals 333 MapString, ListSUBJECT map new HashMap list. stream.forEachs - map. computeIfAbsent s.getName, x - new ArrayList .adds.getSubject System.out.printlnmap Output RobertLITERATURE, SaschaENGLISH, MATH, SCIENCE, LITERATURE, DavisMATH, SCIENCE, GEOGRAPHY Example from ArrayList to MapString, Map List Student list new ArrayList list. addnew Student Davis, SUBJECT. MATH, 1, 35.0 list. addnew Student Davis, SUBJECT. SCIENCE, 2, 12.9 list. addnew Student Davis, SUBJECT. MATH, 3, 37.0 list. addnew Student Davis, SUBJECT. SCIENCE, 4, 37.0 list. addnew Student Sascha , SUBJECT. ENGLISH, 5, 85.0 list. addnew Student Sascha , SUBJECT. MATH, 1, 80.0 list. addnew Student Sascha , SUBJECT. ENGLISH, 6, 12.0 list. addnew Student Sascha , SUBJECT. MATH, 3, 50.0 list. addnew Student Robert": "input.pdf", ", SUBJECT. ENGLISH, 5, 12.0 MapString, MapSUBJECT, List Double map new HashMap list. stream.forEachstudent - map. computeIfAbsent student. getName, s - new HashMap . computeIfAbsent student. getSubject , s - new ArrayList . addstudent. getMarks System.out.printlnmap Output RobertENGLISH12.0, SaschaMATH80.0, 50.0, ENGLISH85.0, 12.0, DavisMATH35.0, 37.0, SCIENCE12.9, 37.0 Cheat-Sheet Goal Code Collect to a List Collectors. toList Collect to an ArrayList with pre- allocated sizeCollectors. toCollection - new ArrayList size Collect to a Set Collectors. toSet Collect to a Set with better iteration performanceCollectors. toCollection - new LinkedHashSet Collect to a case-insensitive SetStringCollectors. toCollection - new TreeSetString.CASEINSENSITIVEORDER Collect to an EnumSetAnEnum best performance for enumsCollectors. toCollection - EnumSet. noneOfAnEnum.class GoalKicker.com Java Notes for Professionals 334Collect to a MapK,V with unique keys Collectors. toMapkeyFunc,valFunc Map MyObject.getter to unique MyObjectCollectors. toMapMyObject getter, Function. identity Map MyObject.getter to multiple MyObjectsCollectors. groupingBy MyObject getter Section 57.6 Using Streams to Implement Mathematical Functions Stream s, and especially IntStream s, are an elegant way of implementing summation terms . The ranges of the Stream can be used as the bounds of the summation. E.g., Madhavas approximation of Pi is given by the formula Source wikipedia This can be calculated with an arbitrary precision. E.g., for 101 terms": "input.pdf", "double pi Math.sqrt12 IntStream. rangeClosed 0, 100 . mapToDouble k - Math.pow-3, -1 k 2 k 1 . sum Note With double s precision, selecting an upper bound of 29 is su\ufb03cient to get a result thats indistinguishable from Math.Pi. Section 57.7 Flatten Streams with \ufb02atMap A Stream of items that are in turn streamable can be \ufb02attened into a single continuous Stream Array of List of Items can be converted into a single List. ListString list1 Arrays.asListone, two List String list2 Arrays.asListthree,four,five List String list3 Arrays.asListsix List String finalList Stream. oflist1, list2, list3.flatMapCollection stream.collectCollectors. toList System.out.printlnfinalList one, two, three, four, five, six Map containing List of Items as values can be Flattened to a Combined List MapString, ListInteger map new LinkedHashMap map.puta, Arrays.asList1, 2, 3 map.putb, Arrays.asList4, 5, 6 ListInteger allValues map.values CollectionListInteger . stream StreamListInteger . flatMapListstream StreamInteger . collectCollectors. toList System.out.printlnallValues 1, 2, 3, 4, 5, 6 List of Map can be \ufb02attened into a single continuous Stream GoalKicker.com Java Notes for Professionals 335ListMapString, String list new ArrayList MapString,String map1 new HashMap map1.put1, one map1.put2, two MapString,String map2 new HashMap map2.put3, three map2.put4, four list.addmap1 list.addmap2 SetString output list.stream StreamMapString, String .mapMapvalues StreamListString .flatMapCollection stream StreamString": "input.pdf", ".collectCollectors. toSet SetString one, two, three,four Section 57.8 Parallel Stream Note Before deciding which Stream to use please have a look at ParallelStream vs Sequential Stream behavior . When you want to perform Stream operations concurrently, you could use either of these ways. ListString data Arrays.asListOne, Two, Three, Four, Five StreamString aParallelStream data.stream.parallel Or StreamString aParallelStream data.parallelStream To execute the operations de\ufb01ned for the parallel stream, call a terminal operator aParallelStream. forEachSystem.outprintln A possible output from the parallel Stream Three Four One Two Five The order might change as all the elements are processed in parallel Which may make it faster. Use parallelStream when ordering does not matter. Performance impact In case networking is involved, parallel Stream s may degrade the overall performance of an application because all parallel Stream s use a common fork-join thread pool for the network. On the other hand, parallel Stream s may signi\ufb01cantly improve performance in many other cases, depending of the number of available cores in the running CPU at the moment. GoalKicker.com Java Notes for Professionals 336Section 57.9 Creating a Stream All java Collection Es have stream and parallelStream methods from which a StreamE can be constructed Collection String stringList new": "input.pdf", "ArrayList StreamString stringStream stringList. parallelStream A StreamE can be created from an array using one of two methods String values aaa, bbbb, ddd, cccc StreamString stringStream Arrays.streamvalues StreamString stringStreamAlternative Stream. ofvalues The di\ufb00erence between Arrays.stream and Stream.of is that Stream.of has a varargs parameter, so it can be used like StreamInteger integerStream Stream. of1, 2, 3 There are also primitive Stream s that you can use. For example IntStream intStream IntStream. of1, 2, 3 DoubleStream doubleStream DoubleStream. of1.0, 2.0, 3.0 These primitive streams can also be constructed using the Arrays.stream method IntStream intStream Arrays.streamnew int 1, 2, 3 It is possible to create a Stream from an array with a speci\ufb01ed range. int values new int1, 2, 3, 4, 5 IntStream intStram Arrays.streamvalues, 1, 3 Note that any primitive stream can be converted to boxed type stream using the boxed method StreamInteger integerStream intStream. boxed This can be useful in some case if you want to collect the data since primitive stream does not have any collect method that takes a Collector as argument. Reusing intermediate operations of a stream chain Stream is closed when ever terminal operation is called. Reusing the stream of intermediate operations, when only terminal": "input.pdf", "operation is only varying. we could create a stream supplier to construct a new stream with all intermediate operations already set up. Supplier StreamString streamSupplier - Stream. ofapple, banana ,orange , grapes , melon,blueberry ,blackberry .mapStringtoUpperCase .sorted streamSupplier. get.filters - s.startsWith A.forEachSystem.outprintln APPLE streamSupplier. get.filters - s.startsWith B.forEachSystem.outprintln GoalKicker.com Java Notes for Professionals 337 BANANA BLACKBERRY BLUEBERRY int arrays can be converted to ListInteger using streams int ints 1,2,3 ListInteger list IntStream. ofints.boxed.collectCollectors. toList Section 57.10 Finding Statistics about Numerical Streams Java 8 provides classes called IntSummaryStatistics , DoubleSummaryStatistics and LongSummaryStatistics which give a state object for collecting statistics such as count , min, max, sum, and average . Version Java SE 8 ListInteger naturalNumbers Arrays.asList1, 2, 3, 4, 5, 6, 7, 8, 9, 10 IntSummaryStatistics stats naturalNumbers. stream . mapToInt x - x . summaryStatistics System.out.printlnstats Which will result in Version Java SE 8 IntSummaryStatistics count10, sum55, min1, max10, average 5.500000 Section 57.11 Converting an iterator to a stream Use Spliterators. spliterator or Spliterators. spliteratorUnknownSize to convert an iterator to a stream Iterator String iterator Arrays.asListA, B, C.iterator Spliterator String spliterator Spliterators. spliteratorUnknownSize iterator, 0 StreamString stream StreamSupport. streamspliterator, false Section 57.12 Using IntStream to iterate over indexes": "input.pdf", "Stream s of elements usually do not allow access to the index value of the current item. To iterate over an array or ArrayList while having access to indexes, use IntStream. rangestart, endExclusive . String names Jon, Darin, Bauke, Hans, Marc IntStream. range0, names. length .mapToObj i - String.formatd s , i 1, namesi .forEachSystem.outprintln The rangestart, endExclusive method returns another \u00ccntStream and the mapToObj mapper returns a stream of String . Output 1 Jon 2 Darin 3 Bauke 4 Hans GoalKicker.com Java Notes for Professionals 3385 Marc This is very similar to using a normal for loop with a counter, but with the bene\ufb01t of pipelining and parallelization for int i 0 i names.length i String newName String.formatd s , i 1, namesi System.out.printlnnewName Section 57.13 Concatenate Streams Variable declaration for examples Collection String abc Arrays.asLista, b, c Collection String digits Arrays.asList1, 2, 3 Collection String greekAbc Arrays.asListalpha, beta, gamma Example 1 - Concatenate two Stream s final StreamString concat1 Stream. concatabc.stream, digits. stream concat1. forEachSystem.outprint prints abc123 Example 2 - Concatenate more than two Stream s final StreamString concat2 Stream. concat Stream. concatabc.stream, digits. stream, greekAbc. stream System.out.printlnconcat2. collectCollectors. joining, prints a, b, c, 1, 2, 3,": "input.pdf", "alpha, beta, gamma Alternatively to simplify the nested concat syntax the Stream s can also be concatenated with flatMap final StreamString concat3 Stream. of abc. stream, digits. stream, greekAbc. stream .flatMaps - s or .flatMapFunction.identity java.util.function.Function System.out.printlnconcat3. collectCollectors. joining, prints a, b, c, 1, 2, 3, alpha, beta, gamma Be careful when constructing Stream s from repeated concatenation, because accessing an element of a deeply concatenated Stream can result in deep call chains or even a StackOverflowException . Section 57.14 Reduction with Streams Reduction is the process of applying a binary operator to every element of a stream to result in one value. The sum method of an IntStream is an example of a reduction it applies addition to every term of the Stream, resulting in one \ufb01nal value GoalKicker.com Java Notes for Professionals 339 This is equivalent to 1234 The reduce method of a Stream allows one to create a custom reduction. It is possible to use the reduce method to implement the sum method IntStream istr Initialize istr OptionalInt istr. reducea,b-ab The Optional version is returned so that empty Streams can be handled appropriately. Another example of reduction is combining a StreamLinkedList T into a single LinkedList": "input.pdf", "T StreamLinkedList T listStream Create a StreamLinkedListT GoalKicker.com Java Notes for Professionals 340 Optional LinkedList T bigList listStream. reduceLinkedList T list1, LinkedList T list2- LinkedList T retList new LinkedList T retList. addAlllist1 retList. addAlllist2 return retList You can also provide an identity element . For example, the identity element for addition is 0, as x0x. For multiplication, the identity element is 1, as x1x. In the case above, the identity element is an empty LinkedList T, because if you add an empty list to another list, the list that you are adding to doesnt change StreamLinkedList T listStream Create a StreamLinkedListT LinkedList T bigList listStream. reducenew LinkedList T, LinkedList T list1, LinkedList T list2- LinkedList T retList new LinkedList T retList. addAlllist1 retList. addAlllist2 return retList Note that when an identity element is provided, the return value is not wrapped in an Optional if called on an empty stream, reduce will return the identity element. The binary operator must also be associative , meaning that abcabc. This is because the elements may be reduced in any order. For example, the above addition reduction could be performed like this GoalKicker.com Java Notes for Professionals 341This reduction is equivalent to writing": "input.pdf", "1234. The property of associativity also allows Java to reduce the Stream in parallel a portion of the Stream can be reduced by each processor, with a reduction combining the result of each processor at the end. Section 57.15 Using Streams of Map.Entry to Preserve Initial Values after Mapping When you have a Stream you need to map but want to preserve the initial values as well, you can map the Stream to a Map.EntryK,V using a utility method like the following public static K, V Function K, Map.EntryK, V entryMapper Function K, V mapper return k-new AbstractMap .SimpleEntry k, mapper. applyk Then you can use your converter to process Stream s having access to both the original and mapped values SetK mySet Function K, V transformer SomeClass transformerMethod StreamMap.EntryK, V entryStream mySet.stream .mapentryMapper transformer You can then continue to process that Stream as normal. This avoids the overhead of creating an intermediate collection. Section 57.16 IntStream to String Java does not have a Char Stream , so when working with String s and constructing a Stream of Character s, an option is to get a IntStream of code points using String.codePoints method. So IntStream can be obtained as": "input.pdf", "below public IntStream stringToIntStream String in return in.codePoints It is a bit more involved to do the conversion other way around i.e. IntStreamToString. That can be done as follows public String intStreamToString IntStream intStream return intStream. collectStringBuilder new, StringBuilder appendCodePoint, StringBuilder append.toString Section 57.17 Finding the First Element that Matches a Predicate It is possible to \ufb01nd the \ufb01rst element of a Stream that matches a condition. For this example, we will \ufb01nd the \ufb01rst Integer whose square is over 50000 . IntStream. iterate1, i - i 1 Generate an infinite stream 1,2,3,4... .filteri - ii 50000 Filter to find elements where the square is 50000 .findFirst Find the first filtered element This expression will return an OptionalInt with the result. GoalKicker.com Java Notes for Professionals 342Note that with an in\ufb01nite Stream , Java will keep checking each element until it \ufb01nds a result. With a \ufb01nite Stream , if Java runs out of elements but still cant \ufb01nd a result, it returns an empty OptionalInt . Section 57.18 Using Streams and Method References to Write Self-Documenting Processes Method references make excellent self-documenting code, and using method references with Stream s makes complicated processes simple to read and understand.": "input.pdf", "Consider the following code public interface Ordered default int getOrder return 0 public interface ValuedV extends Ordered boolean hasPropertyTwo V getValue public interface ThingV extends Ordered boolean hasPropertyOne Valued V getValuedProperty public V extends Ordered ListV myMethod ListThingV things List V results new ArrayList V for ThingV thing things if thing.hasPropertyOne Valued V valued thing.getValuedProperty if valued ! null valued. hasPropertyTwo V value valued. getValue if value ! null results. addvalue results. sorta, b- return Integer.comparea.getOrder , b.getOrder return results This last method rewritten using Stream s and method references is much more legible and each step of the process is quickly and easily understood - its not just shorter, it also shows at a glance which interfaces and classes are responsible for the code in each step public V extends Ordered ListV myMethod ListThingV things return things. stream . filterThinghasPropertyOne . mapThinggetValuedProperty . filterObjectsnonNull . filterValuedhasPropertyTwo . mapValuedgetValue . filterObjectsnonNull . sortedComparator .comparing OrderedgetOrder . collectCollectors. toList GoalKicker.com Java Notes for Professionals 343 Section 57.19 Converting a Stream of Optional to a Stream of Values You may need to convert a Stream emitting Optional to a Stream of values, emitting only values from existing Optional . ie without": "input.pdf", "null value and not dealing with Optional. empty. Optional String op1 Optional. empty Optional String op2 Optional. ofHello World ListString result Stream. ofop1, op2 . filterOptional isPresent . mapOptional get . collectCollectors. toList System.out.printlnresult Hello World Section 57.20 Get a Slice of a Stream Example Get a Stream of 30 elements, containing 21st to 50th inclusive element of a collection. final long n 20L the number of elements to skip final long maxSize 30L the number of elements the stream should be limited to final StreamT slice collection. stream.skipn.limitmaxSize Notes IllegalArgumentException is thrown if n is negative or maxSize is negative both skiplong and limitlong are intermediate operations if a stream contains fewer than n elements then skipn returns an empty stream both skiplong and limitlong are cheap operations on sequential stream pipelines, but can be quite expensive on ordered parallel pipelines Section 57.21 Create a Map based on a Stream Simple case without duplicate keys StreamString characters Stream. ofA, B, C MapInteger, String map characters . collectCollectors. toMapelement - element. hashCode , element - element map 65A, 66B, 67C To make things more declarative, we can use static method in Function interface - Function. identity . We can": "input.pdf", "replace this lambda element - element with Function. identity . Case where there might be duplicate keys The javadoc for Collectors. toMap states If the mapped keys contains duplicates according to Object.equalsObject, an IllegalStateException is thrown when the collection operation is performed. If the mapped keys may have duplicates, use toMapFunction, Function, BinaryOperator instead. GoalKicker.com Java Notes for Professionals 344StreamString characters Stream. ofA, B, B, C MapInteger, String map characters . collectCollectors. toMap element - element. hashCode , element - element, existingVal, newVal - existingVal newVal map 65A, 66BB, 67C The BinaryOperator passed to Collectors. toMap... generates the value to be stored in the case of a collision. It can return the old value, so that the \ufb01rst value in the stream takes precedence, return the new value, so that the last value in the stream takes precedence, or combine the old and new values Grouping by value You can use Collectors. groupingBy when you need to perform the equivalent of a database cascaded group by operation. To illustrate, the following creates a map in which peoples names are mapped to surnames ListPerson people Arrays.asList new PersonSam, Rossi, new PersonSam, Verdi, new PersonJohn, Bianchi , new PersonJohn, Rossi, new": "input.pdf", "PersonJohn, Verdi MapString, ListString map people. stream . collect function mapping input elements to keys Collectors. groupingBy PersongetName, function mapping input elements to values, how to store values Collectors. mappingPersongetSurname, Collectors. toList map JohnBianchi, Rossi, Verdi, SamRossi, Verdi Live on Ideone Section 57.22 Joining a stream to a single String A use case that comes across frequently, is creating a String from a stream, where the stream-items are separated by a certain character. The Collectors. joining method can be used for this, like in the following example StreamString fruitStream Stream. ofapple, banana , pear, kiwi, orange String result fruitStream. filters - s.contains a . mapStringtoUpperCase . sorted . collectCollectors. joining, System.out.printlnresult Output GoalKicker.com Java Notes for Professionals 345APPLE, BANANA, ORANGE, PEAR The Collectors. joining method can also cater for pre- and post\ufb01xes String result fruitStream. filters - s.contains e . mapStringtoUpperCase . sorted . collectCollectors. joining, , Fruits , . System.out.printlnresult Output Fruits APPLE, ORANGE, PEAR. Live on Ideone Section 57.23 Sort Using Stream ListString data new ArrayList data.addSydney data.addLondon data.addNew York data.addAmsterdam data.addMumbai data.addCalifornia System.out.printlndata ListString sortedData data.stream.sorted.collectCollectors. toList System.out.printlnsortedData Output Sydney, London, New York, Amsterdam, Mumbai, California Amsterdam, California, London, Mumbai, New York, Sydney Its also possible": "input.pdf", "to use di\ufb00erent comparison mechanism as there is a overloaded sorted version which takes a comparator as its argument. Also, you can use a lambda expression for sorting ListString sortedData2 data.stream.sorteds1,s2 - s2.compareTo s1.collectCollectors. toList This would output Sydney, New York, Mumbai, London, California, Amsterdam You can use Comparator .reverseOrder to have a comparator that imposes the reverse of the natural ordering. ListString reverseSortedData GoalKicker.com Java Notes for Professionals 346data.stream.sortedComparator .reverseOrder .collectCollectors. toList Section 57.24 Streams of Primitives Java provides specialized Stream s for three types of primitives IntStream for ints, LongStream for long s and DoubleStream for double s. Besides being optimized implementations for their respective primitives, they also provide several speci\ufb01c terminal methods, typically for mathematical operations. E.g. IntStream is IntStream. of10, 20, 30 double average is.average.getAsDouble average is 20.0 Section 57.25 Stream operations categories Stream operations fall into two main categories, intermediate and terminal operations, and two sub-categories, stateless and stateful. Intermediate Operations An intermediate operation is always lazy, such as a simple Stream.map. It is not invoked until the stream is actually consumed. This can be veri\ufb01ed easily Arrays.asList1, 2 ,3.stream.mapi - throw new RuntimeException not gonna happen return i Intermediate operations are the common": "input.pdf", "building blocks of a stream, chained after the source and are usually followed by a terminal operation triggering the stream chain. Terminal Operations Terminal operations are what triggers the consumption of a stream. Some of the more common are Stream.forEach or Stream.collect . They are usually placed after a chain of intermediate operations and are almost always eager . Stateless Operations Statelessness means that each item is processed without the context of other items. Stateless operations allow for memory-e\ufb03cient processing of streams. Operations like Stream.map and Stream.filter that do not require information on other items of the stream are considered to be stateless. Stateful operations Statefulness means the operation on each item depends on some other items of the stream. This requires a state to be preserved. Statefulness operations may break with long, or in\ufb01nite, streams. Operations like Stream.sorted require the entirety of the stream to be processed before any item is emitted which will break in a long enough stream of items. This can be demonstrated by a long stream run at your own risk works - stateless stream long BIGENOUGHNUMBER 999999999 GoalKicker.com Java Notes for Professionals 347IntStream. iterate0, i - i 1.limitBIGENOUGHNUMBER .forEachSystem.outprintln This will cause an": "input.pdf", "out-of-memory due to statefulness of Stream.sorted Out of memory - stateful stream IntStream. iterate0, i - i 1.limitBIGENOUGHNUMBER .sorted.forEachSystem.outprintln Section 57.26 Collect Results of a Stream into an Array Analog to get a collection for a Stream by collect an array can be obtained by the Stream.toArray method ListString fruits Arrays.asListapple, banana , pear, kiwi, orange String filteredFruits fruits. stream .filters - s.contains a .toArrayStringnew prints apple, banana, pear, orange System.out.printlnArrays.toString filteredFruits Stringnew is a special kind of method reference a constructor reference. Section 57.27 Generating random Strings using Streams It is sometimes useful to create random Strings , maybe as Session-ID for a web-service or an initial password after registration for an application. This can be easily achieved using Stream s. First we need to initialize a random number generator. To enhance security for the generated String s, it is a good idea to use SecureRandom . Note Creating a SecureRandom is quite expensive, so it is best practice to only do this once and call one of its setSeed methods from time to time to reseed it. private static final SecureRandom rng new SecureRandom SecureRandom .generateSeed 20 20 Bytes as a seed is rather arbitrary, it is": "input.pdf", "the number used in the JavaDoc example When creating random String s, we usually want them to use only certain characters e.g. only letters and digits. Therefore we can create a method returning a boolean which can later be used to \ufb01lter the Stream . returns true for all chars in 0-9, a-z and A-Z boolean useThisCharacter char c check for range to avoid using all unicode Letter e.g. some chinese symbols return c 0 c z Character .isLetterOrDigit c Next we can utilize the RNG to generate a random String of speci\ufb01c length containing the charset which pass our useThisCharacter check. public String generateRandomString long length Since there is no native CharStream, we use an IntStream instead and convert it to a StreamCharacter using mapToObj. We need to specify the boundaries for the int values to ensure they can safely be cast to char Stream Character randomCharStream rng.intsCharacter .MINCODEPOINT , Character .MAXCODEPOINT .mapToObj i - chari.filterc - thisuseThisCharacter .limitlength now we can use this Stream to build a String utilizing the collect method. GoalKicker.com Java Notes for Professionals 348 String randomString randomCharStream. collectStringBuilder new, StringBuilder append, StringBuilder append.toString return randomString GoalKicker.com Java Notes for Professionals 349Chapter 58 InputStreams": "input.pdf", "and OutputStreams Section 58.1 Closing Streams Most streams must be closed when you are done with them, otherwise you could introduce a memory leak or leave a \ufb01le open. It is important that streams are closed even if an exception is thrown. Version Java SE 7 tryFileWriter fw new FileWriter outfilename BufferedWriter bw new BufferedWriter fw PrintWriter out new PrintWriter bw out. printlnthe text more code out. printlnmore text more code catch IOException e handle this however you Remember try-with-resources guarantees, that the resources have been closed when the block is exited, whether that happens with the usual control \ufb02ow or because of an exception. Version Java SE 6 Sometimes, try-with-resources is not an option, or maybe youre supporting older version of Java 6 or earlier. In this case, proper handling is to use a finally block FileWriter fw null BufferedWriter bw null PrintWriter out null try fw new FileWriter myfile.txt bw new BufferedWriter fw out new PrintWriter bw out. printlnthe text out. close catch IOException e handle this however you want finally try ifout ! null out. close catch IOException e typically not much you can do here... Note that closing a wrapper stream will also close its": "input.pdf", "underlying stream. This means you cannot wrap a stream, close the wrapper and then continue using the original stream. Section 58.2 Reading InputStream into a String Sometimes you may wish to read byte-input into a String. To do this you will need to \ufb01nd something that converts GoalKicker.com Java Notes for Professionals 350between byte and the native Java UTF-16 Codepoints used as char . That is done with a InputStreamReader . To speed the process up a bit, its usual to allocate a bu\ufb00er, so that we dont have too much overhead when reading from Input. Version Java SE 7 public String inputStreamToString InputStream inputStream throws Exception StringWriter writer new StringWriter char buffer new char1024 try Reader reader new BufferedReader new InputStreamReader inputStream, UTF-8 int n while n reader. readbuffer ! -1 all this code does is redirect the output of reader to writer in 1024 byte chunks writer. writebuffer, 0, n return writer. toString Transforming this example to Java SE 6 and lower-compatible code is left out as an exercise for the reader. Section 58.3 Wrapping InputOutput Streams OutputStream and InputStream have many di\ufb00erent classes, each of them with a unique functionality. By wrapping a stream around another,": "input.pdf", "you gain the functionality of both streams. You can wrap a stream any number of times, just take note of the ordering. Useful combinations Writing characters to a \ufb01le while using a bu\ufb00er File myFile new FiletargetFile.txt PrintWriter writer new PrintWriter new BufferedOutputStream new FileOutputStream myFile Compressing and encrypting data before writing to a \ufb01le while using a bu\ufb00er Cipher cipher ... Initialize cipher File myFile new FiletargetFile.enc BufferedOutputStream outputStream new BufferedOutputStream new DeflaterOutputStream new CipherOutputStream new FileOutputStream myFile, cipher List of InputOutput Stream wrappers Wrapper Description Bu\ufb00eredOutputStream Bu\ufb00eredInputStreamWhile OutputStream writes data one byte at a time, BufferedOutputStream writes data in chunks. This reduces the number of system calls, thus improving performance. De\ufb02aterOutputStream De\ufb02aterInputStreamPerforms data compression. In\ufb02aterOutputStream In\ufb02aterInputStream Performs data decompression. CipherOutputStream CipherInputStream EncryptsDecrypts data. DigestOutputStream DigestInputStream Generates Message Digest to verify data integrity. CheckedOutputStream CheckedInputStreamGenerates a CheckSum. CheckSum is a more trivial version of Message Digest. GoalKicker.com Java Notes for Professionals 351DataOutputStream DataInputStreamAllows writing of primitive data types and Strings. Meant for writing bytes. Platform independent. PrintStreamAllows writing of primitive data types and Strings. Meant for writing bytes. Platform dependent. OutputStreamWriterConverts a OutputStream into a Writer. An OutputStream deals with bytes while Writers deals with characters PrintWriterAutomatically calls": "input.pdf", "OutputStreamWriter. Allows writing of primitive data types and Strings. Strictly for writing characters and best for writing characters Section 58.4 DataInputStream Example package com.streams import java.io. public class DataStreamDemo public static void mainString args throws IOException InputStream input new FileInputStream Ddatastreamdemo.txt DataInputStream inst new DataInputStream input int count input.available byte arr new bytecount inst. readarr for byte byt arr char ki char byt System.out.printki- Section 58.5 Writing bytes to an OutputStream Writing bytes to an OutputStream one byte at a time OutputStream stream object. getOutputStream byte b 0x00 stream.write b Writing a byte array byte bytes new byte 0x00, 0x00 stream.write bytes Writing a section of a byte array int offset 1 int length 2 byte bytes new byte 0xFF, 0x00, 0x00, 0xFF stream.write bytes, offset, length Section 58.6 Copying Input Stream to Output Stream This function copies data between two streams - void copyInputStream in, OutputStream out throws IOException GoalKicker.com Java Notes for Professionals 352 byte buffer new byte8192 while bytesRead in.readbuffer 0 out. writebuffer, 0, bytesRead Example - reading from System.in and writing to System.out copySystem.in, System.out GoalKicker.com Java Notes for Professionals 353Chapter 59 Readers and Writers Readers and Writers and their respective subclasses provide simple IO": "input.pdf", "for text character-based data. Section 59.1 BueredReader Introduction The BufferedReader class is a wrapper for other Reader classes that serves two main purposes A BufferedReader provides bu\ufb00ering for the wrapped Reader . This allows an application to read characters 1. one at a time without undue IO overheads. A BufferedReader provides functionality for reading text a line at a time. 2. Basics of using a Bu\ufb00eredReader The normal pattern for using a BufferedReader is as follows. First, you obtain the Reader that you want to read characters from. Next you instantiate a BufferedReader that wraps the Reader . Then you read character data. Finally you close the BufferedReader which close the wrapped Reader. For example File someFile new File... int aCount 0 try FileReader fr new FileReader someFile BufferedReader br new BufferedReader fr Count the number of a characters. int ch while ch br.read ! -1 if ch a aCount System.out.printlnThere are aCount a characters in someFile You can apply this pattern to any Reader Notes We have used Java 7 or later try-with-resources to ensure that the underlying reader is always closed. This 1. avoids a potential resource leak. In earlier versions of Java, you would explicitly close": "input.pdf", "the BufferedReader in a finally block. The code inside the try block is virtually identical to what we would use if we read directly from the 2. FileReader . In fact, a BufferedReader functions exactly like the Reader that it wraps would behave. The di\ufb00erence is that this version is a lot more e\ufb03cient. The Bu\ufb00eredReader bu\ufb00er size The Bu\ufb00eredReader.readLine method Example reading all lines of a File into a List This is done by getting each line in a \ufb01le, and adding it into a ListString. The list is then returned public ListString getAllLines String filename throws IOException List String lines new ArrayList String GoalKicker.com Java Notes for Professionals 354 try BufferedReader br new BufferedReader new FileReader filename String line null while line reader. readLine ! null lines. addline return lines Java 8 provides a more concise way to do this using the lines method public ListString getAllLines String filename throws IOException try BufferedReader br new BufferedReader new FileReader filename return br.lines.collectCollectors. toList return Collections .empty Section 59.2 StringWriter Example Java StringWriter class is a character stream that collects output from string bu\ufb00er, which can be used to construct a string. The StringWriter class extends the Writer class.": "input.pdf", "In StringWriter class, system resources like network sockets and \ufb01les are not used, therefore closing the StringWriter is not necessary. import java.io. public class StringWriterDemo public static void mainString args throws IOException char ary new char1024 StringWriter writer new StringWriter FileInputStream input null BufferedReader buffer null input new FileInputStream cstringwriter.txt buffer new BufferedReader new InputStreamReader input, UTF-8 int x while x buffer. readary ! -1 writer. writeary, 0, x System.out.printlnwriter.toString writer. close buffer. close The above example helps us to know simple example of StringWriter using Bu\ufb00eredReader to read \ufb01le data from the stream. GoalKicker.com Java Notes for Professionals 355Chapter 60 Preferences Section 60.1 Using preferences Preferences can be used to store user settings that re\ufb02ect a users personal application settings, e.g. their editor font, whether they prefer the application to be started in full-screen mode, whether they checked a dont show this again checkbox and things like that. public class ExitConfirmer private static boolean confirmExit Preferences preferences Preferences. userNodeForPackage ExitConfirmer. class boolean doShowDialog preferences. getBoolean showExitConfirmation , true true is default value if !doShowDialog return true Show a dialog here... boolean exitWasConfirmed ... whether the user clicked OK or Cancel boolean doNotShowAgain ... get value from Do not": "input.pdf", "show again checkbox if exitWasConfirmed doNotShowAgain Exit was confirmed and the user chose that the dialog should not be shown again Save these settings to the Preferences object so the dialog will not show again next time preferences. putBoolean showExitConfirmation , false return exitWasConfirmed public static void exit if confirmExit System.exit0 Section 60.2 Adding event listeners There are two types of events emitted by a Preferences object PreferenceChangeEvent and NodeChangeEvent . PreferenceChangeEvent A PreferenceChangeEvent gets emitted by a Properties object every time one of the nodes key-value-pairs changes. PreferenceChangeEvent s can be listened for with a PreferenceChangeListener Version Java SE 8 preferences. addPreferenceChangeListener evt - String newValue evt.getNewValue String changedPreferenceKey evt.getKey Preferences changedNode evt.getNode Version Java SE 8 GoalKicker.com Java Notes for Professionals 356preferences. addPreferenceChangeListener new PreferenceChangeListener Override public void preferenceChange PreferenceChangeEvent evt String newValue evt.getNewValue String changedPreferenceKey evt.getKey Preferences changedNode evt.getNode This listener will not listen to changed key-value pairs of child nodes. NodeChangeEvent This event will be \ufb01red whenever a child node of a Properties node is added or removed. preferences. addNodeChangeListener new NodeChangeListener Override public void childAdded NodeChangeEvent evt Preferences addedChild evt.getChild Preferences parentOfAddedChild evt.getParent Override public void childRemoved NodeChangeEvent evt Preferences removedChild evt.getChild Preferences parentOfRemovedChild": "input.pdf", "evt.getParent Section 60.3 Getting sub-nodes of Preferences Preferences objects always represent a speci\ufb01c node in a whole Preferences tree, kind of like this rRoot com mycompany myapp darkApplicationModetrue showExitCon\ufb01rmationfalse windowMaximizedtrue org myorganization anotherapp defaultFontHelvetica defaultSavePathhomemattDocuments exporting defaultFormatpdf openInBrowserAfterExportfalse To select the commycompany myapp node By convention, based on the package of a class1. package com.mycompany.myapp ... Because this class is in the com.mycompany.myapp package, the node commycompanymyapp will be returned. Preferences myApp Preferences. userNodeForPackage getClass By relative path2. Preferences myApp Preferences. userRoot .nodecommycompanymyapp Using a relative path a path not starting with a will cause the path to be resolved relative to the parent node it is resolved on. For example, the following example will return the node of the path GoalKicker.com Java Notes for Professionals 357onetwothreecommycompany myapp Preferences prefix Preferences. userRoot .nodeonetwothree Preferences myAppWithPrefix prefix. nodecommycompanymyapp prefix is onetwothree myAppWithPrefix is onetwothreecommycompanymyapp By absolute path3. Preferences myApp Preferences. userRoot .nodecommycompanymyapp Using an absolute path on the root node will not be di\ufb00erent from using a relative path. The di\ufb00erence is that, if called on a sub-node, the path will be resolved relative to the root node. Preferences prefix Preferences. userRoot .nodeonetwothree Preferences myAppWitoutPrefix prefix. nodecommycompanymyapp prefix is onetwothree": "input.pdf", "myAppWitoutPrefix is commycompanymyapp Section 60.4 Coordinating preferences access across multiple application instances All instances of Preferences are always thread-safe across the threads of a single Java Virtual Machine JVM. Because Preferences can be shared across multiple JVMs, there are special methods that deal with synchronizing changes across virtual machines. If you have an application which is supposed to run in a single instance only, then no external synchronization is required. If you have an application which runs in multiple instances on a single system and therefore Preferences access needs to be coordinated between the JVMs on the system, then the sync method of any Preferences node may be used to ensure changes to the Preferences node are visible to other JVMs on the system Warning dont use this if your application is intended to only run a single instance on a machine once this is probably the case for most desktop applications try preferences. sync catch BackingStoreException e Deal with any errors while saving the preferences to the backing storage e.printStackTrace Section 60.5 Exporting preferences Preferences nodes can be exported into a XML document representing that node. The resulting XML tree can be imported again. The resulting XML document": "input.pdf", "will remember whether it was exported from the user or system Preferences . To export a single node, but not its child nodes Version Java SE 7 try OutputStream os ... preferences. exportNode os catch IOException ioe GoalKicker.com Java Notes for Professionals 358 Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace Version Java SE 7 OutputStream os null try os ... preferences. exportSubtree os catch IOException ioe Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace finally if os ! null try os. close catch IOException ignored To export a single node with its child nodes Version Java SE 7 try OutputStream os ... preferences. exportNode os catch IOException ioe Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace Version Java SE 7 OutputStream os null try os ... preferences. exportSubtree os catch IOException ioe Exception whilst writing data to the OutputStream ioe. printStackTrace catch BackingStoreException bse Exception whilst reading from the backing preferences store bse. printStackTrace finally if": "input.pdf", "os ! null try os. close catch IOException ignored Section 60.6 Importing preferences Preferences nodes can be imported from a XML document. Importing is meant to be used in conjunction with the GoalKicker.com Java Notes for Professionals 359exporting functionality of Preferences , since it creates the correct corresponding XML documents. The XML documents will remember whether they were exported from the user or system Preferences . Therefore, they can be imported into their respective Preferences trees again, without you having to \ufb01gure out or know where they came from. The static function will automatically \ufb01nd out whether the XML document was exported from the user or system Preferences and will automatically import them into the tree they were exported from. Version Java SE 7 try InputStream is ... This is a static call on the Preferences class Preferences. importPreferences is catch IOException ioe Exception whilst reading data from the InputStream ioe. printStackTrace catch InvalidPreferencesFormatException ipfe Exception whilst parsing the XML document tree ipfe. printStackTrace Version Java SE 7 InputStream is null try is ... This is a static call on the Preferences class Preferences. importPreferences is catch IOException ioe Exception whilst reading data from the InputStream ioe. printStackTrace catch": "input.pdf", "InvalidPreferencesFormatException ipfe Exception whilst parsing the XML document tree ipfe. printStackTrace finally if is ! null try is. close catch IOException ignored Section 60.7 Removing event listeners Event listeners can be removed again from any Properties node, but the instance of the listener has to be kept around for that. Version Java SE 8 Preferences preferences Preferences. userNodeForPackage getClass PreferenceChangeListener listener evt - System.out.printlnevt.getKey got new value evt.getNewValue preferences. addPreferenceChangeListener listener later... preferences. removePreferenceChangeListener listener Version Java SE 8 Preferences preferences Preferences. userNodeForPackage getClass GoalKicker.com Java Notes for Professionals 360PreferenceChangeListener listener new PreferenceChangeListener Override public void preferenceChange PreferenceChangeEvent evt System.out.printlnevt.getKey got new value evt.getNewValue preferences. addPreferenceChangeListener listener later... preferences. removePreferenceChangeListener listener The same applies for NodeChangeListener . Section 60.8 Getting preferences values A value of a Preferences node can be of the type String , boolean , byte, double , float , int or long . All invocations must provide a default value, in case the speci\ufb01ed value is not present in the Preferences node. Preferences preferences Preferences. userNodeForPackage getClass String someString preferences. getsomeKey , this is the default value boolean someBoolean preferences. getBoolean someKey , true byte someByteArray preferences. getByteArray someKey , new byte0 double someDouble preferences. getDouble": "input.pdf", "someKey , 887284.4d float someFloat preferences. getFloat someKey , 38723.3f int someInt preferences. getIntsomeKey , 13232 long someLong preferences. getLongsomeKey , 2827637868234L Section 60.9 Setting preferences values To store a value into the Preferences node, one of the putXXX methods is used. A value of a Preferences node can be of the type String , boolean , byte, double , float , int or long . Preferences preferences Preferences. userNodeForPackage getClass preferences. putsomeKey , some String value preferences. putBoolean someKey , false preferences. putByteArray someKey , new byte0 preferences. putDouble someKey , 187398123.4454d preferences. putFloat someKey , 298321.445f preferences. putIntsomeKey , 77637 preferences. putLongsomeKey , 2873984729834L GoalKicker.com Java Notes for Professionals 361Chapter 61 Collection Factory Methods Method w Parameter Description List.ofE e A generic type that can be a class or interface. Set.ofE e A generic type that can be a class or interface. Map.ofK k, V v A key-value pair of generic types that can each be a class or interface. Map.ofMap.Entry? extends K, ? extends V entryA Map.Entry instance where its key can be K or one of its children, and its value can be V or any of its children. The arrival of Java 9 brings": "input.pdf", "many new features to Javas Collections API, one of which being collection factory methods. These methods allow for easy initialization of immutable collections, whether they be empty or nonempty. Note that these factory methods are only available for the following interfaces ListE, SetE, and MapK, V Section 61.1 ListE Factory Method Examples ListInteger immutableEmptyList List.of Initializes an empty, immutable ListInteger. ListInteger immutableList List.of1, 2, 3, 4, 5 Initializes an immutable ListInteger with \ufb01ve initial elements. ListInteger mutableList new ArrayList immutableList Initializes a mutable ListInteger from an immutable ListInteger. Section 61.2 SetE Factory Method Examples SetInteger immutableEmptySet Set.of Initializes an empty, immutable SetInteger. SetInteger immutableSet Set.of1, 2, 3, 4, 5 Initializes an immutable SetInteger with \ufb01ve initial elements. SetInteger mutableSet new HashSet immutableSet Initializes a mutable SetInteger from an immutable SetInteger. Section 61.3 MapK, V Factory Method Examples MapInteger, Integer immutableEmptyMap Map.of Initializes an empty, immutable MapInteger, Integer . MapInteger, Integer immutableMap Map.of1, 2, 3, 4 Initializes an immutable MapInteger, Integer with two initial key-value entries. MapInteger, Integer immutableMap Map.ofEntries Map.entry1, 2, Map.entry3, 4 Initializes an immutable MapInteger, Integer with two initial key-value entries. MapInteger, Integer mutableMap new HashMap immutableMap Initializes a mutable MapInteger, Integer from an immutable MapInteger, Integer": "input.pdf", ". GoalKicker.com Java Notes for Professionals 362Chapter 62 Alternative Collections Section 62.1 Multimap in Guava, Apache and Eclipse Collections This multimap allows duplicate key-value pairs. JDK analogs are HashMapK, List, HashMapK, Set and so on. Keys order Values order Duplicate Analog key Analog value Guava ApacheEclipse GS CollectionsJDK not de\ufb01ned Insertion-order yes HashMap ArrayList ArrayListMultimap MultiValueMap FastListMultimapHashMapK, ArrayList V not de\ufb01ned not de\ufb01ned no HashMap HashSet HashMultimapMultiValueMap. multiValueMap new HashMapK, Set, HashSet.classUnifiedSetMultimapHashMapK, HashSetV not de\ufb01ned sorted no HashMap TreeSetMultimaps. newMultimap HashMap, Supplier TreeSetMultiValueMap. multiValueMap new HashMap K, Set, TreeSet.classTreeSortedSet - MultimapHashMapK, TreeSetV Insertion-order Insertion-order yes LinkedHashMap ArrayList LinkedListMultimapMultiValueMap. multiValueMapnew LinkedHashMapK, List, ArrayList.classLinkedHashMap K, ArrayList Insertion-order Insertion-order no LinkedHashMap LinkedHashSet LinkedHashMultimapMultiValueMap. multiValueMap new LinkedHashMap K, Set, LinkedHashSet. classLinkedHashMap K, LinkedHashSet V sorted sorted no TreeMap TreeSet TreeMultimapMultiValueMap. multiValueMap new TreeMapK, Set,TreeSet.classTreeMapK, TreeSetV Examples using Multimap Task Parse Hello World! Hello All! Hi World! string to separate words and print all indexes of every word using MultiMap for example, Hello0, 2, World!1, 5 and so on 1. MultiValueMap from Apache String INPUTTEXT Hello World! Hello All! Hi World! Parse text to words and index List String words Arrays.asListINPUTTEXT. split Create Multimap MultiMap String, Integer multiMap new MultiValueMap String, Integer Fill Multimap": "input.pdf", "int i 0 forString word words multiMap. putword, i i Print all words System.out.printlnmultiMap print Hi4, Hello0, 2, World!1, 5, All!3 - in random orders Print all unique words System.out.printlnmultiMap. keySet print Hi, Hello, World!, All! - in random orders Print all indexes System.out.printlnHello multiMap. getHello print 0, 2 System.out.printlnWorld multiMap. getWorld! print 1, 5 System.out.printlnAll multiMap. getAll! print 3 System.out.printlnHi multiMap. getHi print 4 System.out.printlnEmpty multiMap. getEmpty print null Print count unique words GoalKicker.com Java Notes for Professionals 363 System.out.printlnmultiMap. keySet.size print 4 2. HashBiMap from GS Eclipse Collection String englishWords one, two, three,ball,snow String russianWords jeden, dwa, trzy, kula, snieg Create Multiset MutableBiMap String, String biMap new HashBiMap englishWords. length Create English-Polish dictionary int i 0 forString englishWord englishWords biMap. putenglishWord, russianWords i i Print count words System.out.printlnbiMap print twodwa, ballkula, onejeden, snowsnieg, threetrzy - in random orders Print all unique words System.out.printlnbiMap.keySet print snow, two, one, three, ball - in random orders System.out.printlnbiMap.values print dwa, kula, jeden, snieg, trzy - in random orders Print translate by words System.out.printlnone biMap.getone print one jeden System.out.printlntwo biMap.gettwo print two dwa System.out.printlnkula biMap.inverse.getkula print kula ball System.out.printlnsnieg biMap.inverse.getsnieg print snieg snow System.out.printlnempty biMap.getempty print empty null Print count words pair": "input.pdf", "System.out.printlnbiMap.size print 5 HashMultiMap from Guava3. String INPUTTEXT Hello World! Hello All! Hi World! Parse text to words and index ListString words Arrays.asListINPUTTEXT. split Create Multimap Multimap String, Integer multiMap HashMultimap. create Fill Multimap int i 0 forString word words multiMap. putword, i i Print all words System.out.printlnmultiMap print Hi4, Hello0, 2, World!1, 5, All!3 - keys and values in random orders Print all unique words System.out.printlnmultiMap. keySet print Hi, Hello, World!, All! - in random orders Print all indexes System.out.printlnHello multiMap. getHello print 0, 2 System.out.printlnWorld multiMap. getWorld! print 1, 5 System.out.printlnAll multiMap. getAll! print 3 System.out.printlnHi multiMap. getHi print 4 GoalKicker.com Java Notes for Professionals 364 System.out.printlnEmpty multiMap. getEmpty print Print count all words System.out.printlnmultiMap. size print 6 Print count unique words System.out.printlnmultiMap. keySet.size print 4 Nore examples I. Apache Collection MultiValueMap1. MultiValueMapLinked2. MultiValueMapTree3. II. GS Eclipse Collection FastListMultimap1. HashBagMultimap2. TreeSortedSetMultimap3. Uni\ufb01edSetMultimap4. III. Guava HashMultiMap1. LinkedHashMultimap2. LinkedListMultimap3. TreeMultimap4. ArrayListMultimap5. Section 62.2 Apache HashBag, Guava HashMultiset and Eclipse HashBag A Bagultiset stores each object in the collection together with a count of occurrences. Extra methods on the interface allow multiple copies of an object to be added or removed at once. JDK analog is HashMapT, Integer, when values": "input.pdf", "is count of copies this key. Type GuavaApache Commons CollectionsGS Collections JDK Order not de\ufb01nedHashMultiset HashBag HashBag HashMap Sorted TreeMultiset TreeBag TreeBag TreeMap Insertion-order LinkedHashMultiset - - LinkedHashMap Concurrent variantConcurrentHashMultiset SynchronizedBag SynchronizedBag Collections .synchronizedMap HashMapString, Integer Concurrent and sorted- SynchronizedSortedBag SynchronizedSortedBag Collections .synchronizedSortedMap TreeMapString,Integer Immutable collectionImmutableMultiset Unmodi\ufb01ableBag Unmodi\ufb01ableBag Collections .unmodifiableMap HashMapString, Integer Immutable and sortedImmutableSortedMultiset Unmodi\ufb01ableSortedBag Unmodi\ufb01ableSortedBagCollections .unmodifiableSortedMap TreeMapString, Integer Examples 1. Using SynchronizedSortedBag from Apache Parse text to separate words String INPUTTEXT Hello World! Hello All! Hi World! GoalKicker.com Java Notes for Professionals 365 Create Multiset Bag bag SynchronizedSortedBag. synchronizedBag new TreeBag Arrays.asListINPUTTEXT. split Print count words System.out.printlnbag print 1All!,2Hello,1Hi,2World!- in natural alphabet order Print all unique words System.out.printlnbag.uniqueSet print All!, Hello, Hi, World!- in natural alphabet order Print count occurrences of words System.out.printlnHello bag.getCount Hello print 2 System.out.printlnWorld bag.getCount World! print 2 System.out.printlnAll bag.getCount All! print 1 System.out.printlnHi bag.getCount Hi print 1 System.out.printlnEmpty bag.getCount Empty print 0 Print count all words System.out.printlnbag.size print 6 Print count unique words System.out.printlnbag.uniqueSet .size print 4 2. Using TreeBag from EclipseGC Parse text to separate words String INPUTTEXT Hello World! Hello All! Hi World! Create Multiset MutableSortedBag String bag TreeBag. newBagArrays.asListINPUTTEXT. split Print count words System.out.printlnbag print All!, Hello, Hello, Hi,": "input.pdf", "World!, World!- in natural order Print all unique words System.out.printlnbag.toSortedSet print All!, Hello, Hi, World!- in natural order Print count occurrences of words System.out.printlnHello bag.occurrencesOf Hello print 2 System.out.printlnWorld bag.occurrencesOf World! print 2 System.out.printlnAll bag.occurrencesOf All! print 1 System.out.printlnHi bag.occurrencesOf Hi print 1 System.out.printlnEmpty bag.occurrencesOf Empty print 0 Print count all words System.out.printlnbag.size print 6 Print count unique words System.out.printlnbag.toSet.size print 4 3. Using LinkedHashMultiset from Guava Parse text to separate words String INPUTTEXT Hello World! Hello All! Hi World! Create Multiset Multiset String multiset LinkedHashMultiset. createArrays.asListINPUTTEXT. split Print count words System.out.printlnmultiset print Hello x 2, World! x 2, All!, Hi- in predictable iteration order Print all unique words System.out.printlnmultiset. elementSet print Hello, World!, All!, Hi - in predictable iteration order Print count occurrences of words GoalKicker.com Java Notes for Professionals 366 System.out.printlnHello multiset. countHello print 2 System.out.printlnWorld multiset. countWorld! print 2 System.out.printlnAll multiset. countAll! print 1 System.out.printlnHi multiset. countHi print 1 System.out.printlnEmpty multiset. countEmpty print 0 Print count all words System.out.printlnmultiset. size print 6 Print count unique words System.out.printlnmultiset. elementSet .size print 4 More examples I. Apache Collection HashBag - order not de\ufb01ned 1. SynchronizedBag - concurrent and order not de\ufb01ned 2. SynchronizedSortedBag - - concurrent and sorted": "input.pdf", "order 3. TreeBag - sorted order 4. II. GS Eclipse Collection MutableBag - order not de\ufb01ned 5. MutableSortedBag - sorted order 6. III. Guava HashMultiset - order not de\ufb01ned 7. TreeMultiset - sorted order 8. LinkedHashMultiset - insertion order 9. ConcurrentHashMultiset - concurrent and order not de\ufb01ned 10. Section 62.3 Compare operation with collections - Create collections Compare operation with collections - Create collections 1. Create List Description JDK guava gs-collections Create empty listnew ArrayList Lists.newArrayList FastList. newList Create list from valuesArrays.asList1, 2, 3Lists.newArrayList 1, 2, 3FastList. newListWith 1, 2, 3 Create list with capacity 100new ArrayList 100Lists.newArrayListWithCapacity 100FastList. newList100 Create list from any collectinnew ArrayList collection Lists.newArrayList collection FastList. newListcollection Create list from any Iterable- Lists.newArrayList iterable FastList. newListiterable Create list from Iterator- Lists.newArrayList iterator - GoalKicker.com Java Notes for Professionals 367Create list from arrayArrays.asListarrayLists.newArrayList array FastList. newListWith array Create list using factory- -FastList. newWithNValues 10, - 1 Examples System.out.printlncreateArrayList start Create empty list List String emptyGuava Lists.newArrayList using guava List String emptyJDK new ArrayList using JDK MutableList String emptyGS FastList. newList using gs Create list with 100 element List String exactly100 Lists.newArrayListWithCapacity 100 using guava List String exactly100JDK new ArrayList 100 using JDK MutableList String empty100GS FastList.": "input.pdf", "newList100 using gs Create list with about 100 element List String approx100 Lists.newArrayListWithExpectedSize 100 using guava List String approx100JDK new ArrayList 115 using JDK MutableList String approx100GS FastList. newList115 using gs Create list with some elements List String withElements Lists.newArrayList alpha, beta, gamma using guava List String withElementsJDK Arrays.asListalpha, beta, gamma using JDK MutableList String withElementsGS FastList. newListWith alpha, beta, gamma using gs System.out.printlnwithElements System.out.printlnwithElementsJDK System.out.printlnwithElementsGS Create list from any Iterable interface any collection Collection String collection new HashSet 3 collection. add1 collection. add2 collection. add3 List String fromIterable Lists.newArrayList collection using guava List String fromIterableJDK new ArrayList collection using JDK MutableList String fromIterableGS FastList. newListcollection using gs System.out.printlnfromIterable System.out.printlnfromIterableJDK System.out.printlnfromIterableGS Attention JDK create list only from Collection, but guava and gs can create list from Iterable and Collection Create list from any Iterator Iterator String iterator collection. iterator List String fromIterator Lists.newArrayList iterator using guava System.out.printlnfromIterator Create list from any array String array 4, 5, 6 List String fromArray Lists.newArrayList array using guava List String fromArrayJDK Arrays.asListarray using JDK MutableList String fromArrayGS FastList. newListWith array using gs System.out.printlnfromArray GoalKicker.com Java Notes for Professionals 368 System.out.printlnfromArrayJDK System.out.printlnfromArrayGS Create list using fabric MutableList String fromFabricGS FastList. newWithNValues 10, - String.valueOfMath.random": "input.pdf", "using gs System.out.printlnfromFabricGS System.out.printlncreateArrayList end 2 Create Set Description JDK guava gs-collections Create empty setnew HashSet Sets.newHashSet UnifiedSet. newSet Creatre set from valuesnew HashSetArrays.asListalpha, beta, gammaSets.newHashSet alpha, beta, gammaUnifiedSet. newSetWith alpha, beta, gamma Create set from any collectionsnew HashSet collection Sets.newHashSet collection UnifiedSet. newSetcollection Create set from any Iterable- Sets.newHashSet iterable UnifiedSet. newSetiterable Create set from any Iterator- Sets.newHashSet iterator - Create set from Arraynew HashSetArrays.asListarraySets.newHashSet arrayUnifiedSet. newSetWith array Examples System.out.printlncreateHashSet start Create empty set SetString emptyGuava Sets.newHashSet using guava SetString emptyJDK new HashSet using JDK SetString emptyGS UnifiedSet. newSet using gs Create set with 100 element SetString approx100 Sets.newHashSetWithExpectedSize 100 using guava SetString approx100JDK new HashSet 130 using JDK SetString approx100GS UnifiedSet. newSet130 using gs Create set from some elements SetString withElements Sets.newHashSet alpha, beta, gamma using guava SetString withElementsJDK new HashSet Arrays.asListalpha, beta, gamma using JDK SetString withElementsGS UnifiedSet. newSetWith alpha, beta, gamma using gs System.out.printlnwithElements System.out.printlnwithElementsJDK System.out.printlnwithElementsGS Create set from any Iterable interface any collection Collection String collection new ArrayList 3 collection. add1 collection. add2 collection. add3 SetString fromIterable Sets.newHashSet collection using guava SetString fromIterableJDK new HashSet collection using JDK SetString fromIterableGS UnifiedSet. newSetcollection using gs GoalKicker.com Java Notes for Professionals 369 System.out.printlnfromIterable System.out.printlnfromIterableJDK System.out.printlnfromIterableGS Attention": "input.pdf", "JDK create set only from Collection, but guava and gs can create set from Iterable and Collection Create set from any Iterator Iterator String iterator collection. iterator SetString fromIterator Sets.newHashSet iterator using guava System.out.printlnfromIterator Create set from any array String array 4, 5, 6 SetString fromArray Sets.newHashSet array using guava SetString fromArrayJDK new HashSet Arrays.asListarray using JDK SetString fromArrayGS UnifiedSet. newSetWith array using gs System.out.printlnfromArray System.out.printlnfromArrayJDK System.out.printlnfromArrayGS System.out.printlncreateHashSet end 3 Create Map Description JDK guava gs-collections Create empty mapnew HashMapMaps.newHashMap UnifiedMap. newMap Create map with capacity 130new HashMap130Maps.newHashMapWithExpectedSize 100UnifiedMap. newMap130 Create map from other mapnew HashMapmapMaps.newHashMap map UnifiedMap. newMapmap Create map from keys- -UnifiedMap. newWithKeysValues 1, a, 2, b Examples System.out.printlncreateHashMap start Create empty map MapString, String emptyGuava Maps.newHashMap using guava MapString, String emptyJDK new HashMap using JDK MapString, String emptyGS UnifiedMap. newMap using gs Create map with about 100 element MapString, String approx100 Maps.newHashMapWithExpectedSize 100 using guava MapString, String approx100JDK new HashMap 130 using JDK MapString, String approx100GS UnifiedMap. newMap130 using gs Create map from another map MapString, String map new HashMap 3 map. putk1,v1 map. putk2,v2 MapString, String withMap Maps.newHashMap map using guava MapString, String withMapJDK new HashMap map using JDK MapString, String withMapGS UnifiedMap. newMapmap using": "input.pdf", "gs System.out.printlnwithMap System.out.printlnwithMapJDK System.out.printlnwithMapGS Create map from keys GoalKicker.com Java Notes for Professionals 370 MapString, String withKeys UnifiedMap. newWithKeysValues 1, a, 2, b System.out.printlnwithKeys System.out.printlncreateHashMap end More examples CreateCollectionTest CollectionCompare1. CollectionSearch2. JavaTransform3. GoalKicker.com Java Notes for Professionals 371Chapter 63 Concurrent Collections A concurrent collection is a collection1 which permits access by more than one thread at the same time. Di\ufb00erent threads can typically iterate through the contents of the collection and add or remove elements. The collection is responsible for ensuring that the collection doesnt become corrupt. 1 httpstackover\ufb02ow.comdocumentationjava90collectionst201612221936497298484 Section 63.1 Thread-safe Collections By default, the various Collection types are not thread-safe. However, its fairly easy to make a collection thread-safe. ListString threadSafeList Collections .synchronizedList new ArrayList String SetString threadSafeSet Collections .synchronizedSet new HashSet String MapString, String threadSafeMap Collections .synchronizedMap new HashMap String, String When you make a thread-safe collection, you should never access it through the original collection, only through the thread-safe wrapper. Version Java SE 5 Starting in Java 5, java.util.collections has several new thread-safe collections that dont need the various Collections .synchronized methods. ListString threadSafeList new CopyOnWriteArrayList String SetString threadSafeSet new ConcurrentHashSet String MapString, String threadSafeMap new ConcurrentHashMap String, String Section 63.2 Insertion into ConcurrentHashMap public": "input.pdf", "class InsertIntoConcurrentHashMap public static void mainString args ConcurrentHashMap Integer, SomeObject concurrentHashMap new ConcurrentHashMap SomeObject value new SomeObject Integer key 1 SomeObject previousValue concurrentHashMap. putIfAbsent 1, value if previousValue ! null Then some other value was mapped to key 1. value that was passed to putIfAbsent method is NOT inserted, hence, any other thread which calls concurrentHashMap.get1 would NOT receive a reference to the value that your thread attempted to insert. Decide how you wish to handle this situation. else value reference is mapped to key 1. GoalKicker.com Java Notes for Professionals 372 Section 63.3 Concurrent Collections Concurrent collections are a generalization of thread-safe collections, that allow for a broader usage in a concurrent environment. While thread-safe collections have safe element addition or removal from multiple threads, they do not necessarily have safe iteration in the same context one may not be able to safely iterate through the collection in one thread, while another one modi\ufb01es it by addingremoving elements. This is where concurrent collections are used. As iteration is often the base implementation of several bulk methods in collections, like addAll , removeAll , or also collection copying through a constructor, or other means, sorting, ... the use case": "input.pdf", "for concurrent collections is actually pretty large. For example, the Java SE 5 java.util.concurrent .CopyOnWriteArrayList is a thread safe and concurrent List implementation, its javadoc states The snapshot style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModi\ufb01cationException. Therefore, the following code is safe public class ThreadSafeAndConcurrent public static final ListInteger LIST new CopyOnWriteArrayList public static void mainString args throws InterruptedException Thread modifier new Threadnew ModifierRunnable Thread iterator new Threadnew IteratorRunnable modifier. start iterator. start modifier. join iterator. join public static final class ModifierRunnable implements Runnable Override public void run try for int i 0 i 50000 i LIST. addi catch Exception e e. printStackTrace public static final class IteratorRunnable implements Runnable Override public void run try GoalKicker.com Java Notes for Professionals 373 for int i 0 i 10000 i long total 0 forInteger inList LIST total inList System.out.printlntotal catch Exception e e. printStackTrace Another concurrent collection regarding iteration is ConcurrentLinkedQueue , which states Iterators are weakly consistent, returning elements re\ufb02ecting the state of the queue": "input.pdf", "at some point at or since the creation of the iterator. They do not throw java.util.ConcurrentModi\ufb01cationException, and may proceed concurrently with other operations. Elements contained in the queue since the creation of the iterator will be returned exactly once. One should check the javadocs to see if a collection is concurrent, or not. The attributes of the iterator returned by the iterator method fail fast, weakly consistent, ... is the most important attribute to look for. Thread safe but non concurrent examples In the above code, changing the LIST declaration to public static final ListInteger LIST Collections .synchronizedList new ArrayList Could and statistically will on most modern, multi CPUcore architectures lead to exceptions. Synchronized collections from the Collections utility methods are thread safe for additionremoval of elements, but not iteration unless the underlying collection being passed to it already is. GoalKicker.com Java Notes for Professionals 374Chapter 64 Choosing Collections Java o\ufb00ers a wide variety of Collections. Choosing which Collection to use can be tricky. See the Examples section for an easy-to-follow \ufb02owchart to choose the right Collection for the job. Section 64.1 Java Collections Flowchart Use the following \ufb02owchart to choose the right Collection for the job. This \ufb02owchart": "input.pdf", "was based o\ufb00 httpi.stack.imgur.comaSDsG.png . GoalKicker.com Java Notes for Professionals 375Chapter 65 super keyword Section 65.1 Super keyword use with examples super keyword performs important role in three places Constructor Level1. Method Level2. Variable Level3. Constructor Level super keyword is used to call parent class constructor. This constructor can be default constructor or parameterized constructor. Default constructor super Parameterized constructor superint no, double amount, String name class Parentclass Parentclass System.out.printlnConstructor of Superclass class Subclass extends Parentclass Subclass Compile adds super here at the first line of this constructor implicitly System.out.printlnConstructor of Subclass Subclass int n1 Compile adds super here at the first line of this constructor implicitly System.out.printlnConstructor with arg void display System.out.printlnHello public static void mainString args Creating object using default constructor Subclass obj new Subclass Calling sub class method obj. display Creating object 2 using arg constructor Subclass obj2 new Subclass 10 obj2. display Note super must be the \ufb01rst statement in constructor otherwise we will get the compilation error message. Method Level GoalKicker.com Java Notes for Professionals 376super keyword can also be used in case of method overriding. super keyword can be used to invoke or call parent class method. class Parentclass Overridden method void display": "input.pdf", "System.out.printlnParent class method class Subclass extends Parentclass Overriding method void display System.out.printlnChild class method void printMsg This would call Overriding method display This would call Overridden method super.display public static void mainString args Subclass obj new Subclass obj. printMsg Note If there is not method overriding then we do not need to use super keyword to call parent class method. Variable Level super is used to refer immediate parent class instance variable. In case of inheritance, there may be possibility of base class and derived class may have similar data members.In order to di\ufb00erentiate between the data member of baseparent class and derivedchild class, in the context of derived class the base class data members must be preceded by super keyword. Parent class or Superclass class Parentclass int num100 Child class or subclass class Subclass extends Parentclass I am declaring the same variable num in child class too. int num110 void printNumber System.out.printlnnum It will print value 110 System.out.printlnsuper.num It will print value 100 public static void mainString args Subclass obj new Subclass obj. printNumber GoalKicker.com Java Notes for Professionals 377Note If we are not writing super keyword before the base class data member name then it will be": "input.pdf", "referred as current class data member and base class data member are hidden in the context of derived class. GoalKicker.com Java Notes for Professionals 378Chapter 66 Serialization Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes that includes the objects data as well as information about the objects type and the types of data stored in the object. After a serialized object has been written into a \ufb01le, it can be read from the \ufb01le and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory. Section 66.1 Basic Serialization in Java What is Serialization Serialization is the process of converting an objects state including its references to a sequence of bytes, as well as the process of rebuilding those bytes into a live object at some future time. Serialization is used when you want to persist the object. It is also used by Java RMI to pass objects between JVMs, either as arguments in a method invocation from a client to a server or as return values from a method invocation, or as exceptions thrown": "input.pdf", "by remote methods. In general, serialization is used when we want the object to exist beyond the lifetime of the JVM. java.io.Serializable is a marker interface has no body. It is just used to mark Java classes as serializable. The serialization runtime associates with each serializable class a version number, called a serialVersionUID , which is used during de-serialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a di\ufb00erent serialVersionUID than that of the corresponding senders class, then deserialization will result in an InvalidClassException . A serializable class can declare its own serialVersionUID explicitly by declaring a \ufb01eld named serialVersionUID that must be static, final, and of type long ANY-ACCESS-MODIFIER static final long serialVersionUID 1L How to make a class eligible for serialization To persist an object the respective class must implement the java.io.Serializable interface. import java.io.Serializable public class SerialClass implements Serializable private static final long serialVersionUID 1L private Date currentTime public SerialClass currentTime Calendar .getInstance .getTime public Date getCurrentTime return currentTime How to write an object into a \ufb01le Now": "input.pdf", "we need to write this object to a \ufb01le system. We use java.io.ObjectOutputStream for this purpose. import java.io.FileOutputStream GoalKicker.com Java Notes for Professionals 379import java.io.ObjectOutputStream import java.io.IOException public class PersistSerialClass public static void mainString args String filename time.ser SerialClass time new SerialClass We will write this object to file system. try ObjectOutputStream out new ObjectOutputStream new FileOutputStream filename out. writeObject time Write byte stream to file system. out. close catchIOException ex ex. printStackTrace How to recreate an object from its serialized state The stored object can be read from \ufb01le system at later time using java.io.ObjectInputStream as shown below import java.io.FileInputStream import java.io.ObjectInputStream import java.io.IOException import java.io.java.lang.ClassNotFoundException public class ReadSerialClass public static void mainString args String filename time.ser SerialClass time null try ObjectInputStream in new ObjectInputStream new FileInputStream filename time SerialClass in.readObject in. close catchIOException ex ex. printStackTrace catchClassNotFoundException cnfe cnfe. printStackTrace print out restored time System.out.printlnRestored time time.getTime The serialized class is in binary form. The deserialization can be problematic if the class de\ufb01nition changes see the Versioning of Serialized Objects chapter of the Java Serialization Speci\ufb01cation for details. Serializing an object serializes the entire object graph of which it is the root, and operates correctly in the": "input.pdf", "presence of cyclic graphs. A reset method is provided to force the ObjectOutputStream to forget about objects that have already been serialized. Transient-\ufb01elds - Serialization Section 66.2 Custom Serialization In this example we want to create a class that will generate and output to console, a random number between a GoalKicker.com Java Notes for Professionals 380range of two integers which are passed as arguments during the initialization. public class SimpleRangeRandom implements Runnable private int min private int max private Thread thread public SimpleRangeRandom int min, int max this.min min this.max max thread new Threadthis thread. start Override private void WriteObject ObjectOutputStreamout throws IO Exception private void ReadObject ObjectInputStream in throws IOException , ClassNotFoundException public void run whiletrue Random rand new Random System.out.printlnThread thread. getId Random rand.nextIntmax - min try Thread.sleep10000 catch InterruptedException e e. printStackTrace Now if we want to make this class Serializable there will be some problems. The Thread is one of the certain system-level classes that are not Serializable. So we need to declare the thread as transient . By doing this we will be able to serialize the objects of this class but we will still have an issue. As you can see in the": "input.pdf", "constructor we set the min and the max values of our randomizer and after this we start the thread which is responsible for generating and printing the random value. Thus when restoring the persisted object by calling the readObject the constructor will not run again as there is no creation of a new object. In that case we need to develop a Custom Serialization by providing two methods inside the class. Those methods are private void writeObject ObjectOutputStream out throws IOException private void readObject ObjectInputStream in throws IOException , ClassNotFoundException Thus by adding our implementation in the readObject we can initiate and start our thread class RangeRandom implements Serializable , Runnable private int min private int max private transient Thread thread transient should be any field that either cannot be serialized e.g Thread or any field you do not want serialized public RangeRandom int min, int max this.min min this.max max thread new Threadthis thread. start GoalKicker.com Java Notes for Professionals 381Override public void run whiletrue Random rand new Random System.out.printlnThread thread. getId Random rand.nextIntmax - min try Thread.sleep10000 catch InterruptedException e e. printStackTrace private void writeObject ObjectOutputStream oos throws IOException oos. defaultWriteObject private void readObject ObjectInputStream in throws": "input.pdf", "IOException , ClassNotFoundException in.defaultReadObject thread new Threadthis thread. start Here is the main for our example public class Main public static void mainString args System.out.printlnHello RangeRandom rangeRandom new RangeRandom 1,10 FileOutputStream fos null ObjectOutputStream out null try fos new FileOutputStream test out new ObjectOutputStream fos out. writeObject rangeRandom out. close catchIOException ex ex. printStackTrace RangeRandom rangeRandom2 null FileInputStream fis null ObjectInputStream in null try fis new FileInputStream test in new ObjectInputStream fis rangeRandom2 RangeRandom in.readObject in. close catchIOException ex ex. printStackTrace catchClassNotFoundException ex GoalKicker.com Java Notes for Professionals 382 ex. printStackTrace If you run the main you will see that there are two threads running for each RangeRandom instance and that is because the Thread.start method is now in both the constructor and the readObject . Section 66.3 Versioning and serialVersionUID When you implement java.io.Serializable interface to make a class serializable, the compiler looks for a static final \ufb01eld named serialVersionUID of type long . If the class doesnt have this \ufb01eld declared explicitly then the compiler will create one such \ufb01eld and assign it with a value which comes out of a implementation dependent computation of serialVersionUID . This computation depends upon various aspects of the class and": "input.pdf", "it follows the Object Serialization Speci\ufb01cations given by Sun. But, the value is not guaranteed to be the same across all compiler implementations. This value is used for checking the compatibility of the classes with respect to serialization and this is done while de- serializing a saved object. The Serialization Runtime veri\ufb01es that serialVersionUID read from the de-serialized data and the serialVersionUID declared in the class are exactly the same. If that is not the case, it throws an InvalidClassException . Its highly recommended that you explicitly declare and initialize the static, \ufb01nal \ufb01eld of type long and named serialVersionUID in all your classes you want to make Serializable instead of relying on the default computation of the value for this \ufb01eld even if you are not gonna use versioning. serialVersionUID computation is extremely sensitive and may vary from one compiler implementation to another and hence you may turn up getting the InvalidClassException even for the same class just because you used di\ufb00erent compiler implementations on the sender and the receiver ends of the serialization process. public class Example implements Serializable static final long serialVersionUID 1L or some other value ... As long as serialVersionUID is the same, Java": "input.pdf", "Serialization can handle di\ufb00erent versions of a class. Compatible and incompatible changes are Compatible Changes Adding \ufb01elds When the class being reconstituted has a \ufb01eld that does not occur in the stream, that \ufb01eld in the object will be initialized to the default value for its type. If class-speci\ufb01c initialization is needed, the class may provide a readObject method that can initialize the \ufb01eld to nondefault values. Adding classes The stream will contain the type hierarchy of each object in the stream. Comparing this hierarchy in the stream with the current class can detect additional classes. Since there is no information in the stream from which to initialize the object, the classs \ufb01elds will be initialized to the default values. Removing classes Comparing the class hierarchy in the stream with that of the current class can detect that a class has been deleted. In this case, the \ufb01elds and objects corresponding to that class are read from the stream. Primitive \ufb01elds are discarded, but the objects referenced by the deleted class are created, since they may be referred to later in the stream. They will be garbage-collected when the stream is garbage- collected or reset. Adding writeObjectreadObject methods If": "input.pdf", "the version reading the stream has these methods then readObject is expected, as usual, to read the required data written to the stream by the default serialization. GoalKicker.com Java Notes for Professionals 383It should call defaultReadObject \ufb01rst before reading any optional data. The writeObject method is expected as usual to call defaultWriteObject to write the required data and then may write optional data. Adding java.io.Serializable This is equivalent to adding types. There will be no values in the stream for this class so its \ufb01elds will be initialized to default values. The support for subclassing nonserializable classes requires that the classs supertype have a no-arg constructor and the class itself will be initialized to default values. If the no-arg constructor is not available, the InvalidClassException is thrown. Changing the access to a \ufb01eld The access modi\ufb01ers public, package, protected, and private have no e\ufb00ect on the ability of serialization to assign values to the \ufb01elds. Changing a \ufb01eld from static to nonstatic or transient to nontransient When relying on default serialization to compute the serializable \ufb01elds, this change is equivalent to adding a \ufb01eld to the class. The new \ufb01eld will be written to the stream but earlier classes": "input.pdf", "will ignore the value since serialization will not assign values to static or transient \ufb01elds. Incompatible Changes Deleting \ufb01elds If a \ufb01eld is deleted in a class, the stream written will not contain its value. When the stream is read by an earlier class, the value of the \ufb01eld will be set to the default value because no value is available in the stream. However, this default value may adversely impair the ability of the earlier version to ful\ufb01ll its contract. Moving classes up or down the hierarchy This cannot be allowed since the data in the stream appears in the wrong sequence. Changing a nonstatic \ufb01eld to static or a nontransient \ufb01eld to transient When relying on default serialization, this change is equivalent to deleting a \ufb01eld from the class. This version of the class will not write that data to the stream, so it will not be available to be read by earlier versions of the class. As when deleting a \ufb01eld, the \ufb01eld of the earlier version will be initialized to the default value, which can cause the class to fail in unexpected ways. Changing the declared type of a primitive \ufb01eld Each version of the": "input.pdf", "class writes the data with its declared type. Earlier versions of the class attempting to read the \ufb01eld will fail because the type of the data in the stream does not match the type of the \ufb01eld. Changing the writeObject or readObject method so that it no longer writes or reads the default \ufb01eld data or changing it so that it attempts to write it or read it when the previous version did not. The default \ufb01eld data must consistently either appear or not appear in the stream. Changing a class from Serializable to Externalizable or vice versa is an incompatible change since the stream will contain data that is incompatible with the implementation of the available class. Changing a class from a non-enum type to an enum type or vice versa since the stream will contain data that is incompatible with the implementation of the available class. Removing either Serializable or Externalizable is an incompatible change since when written it will no longer supply the \ufb01elds needed by older versions of the class. Adding the writeReplace or readResolve method to a class is incompatible if the behavior would produce an object that is incompatible with any older version": "input.pdf", "of the class. Section 66.4 Serialization with Gson Serialization with Gson is easy and will output correct JSON. public class Employe private String firstName private String lastName private int age private BigDecimal salary private ListString skills GoalKicker.com Java Notes for Professionals 384 getters and setters Serialization Skills ListString skills new LinkedList String skills.addleadership skills.addJava Experience Employe Employe obj new Employe obj.setFirstName Christian obj.setLastName Lusardi obj.setAge25 obj.setSalary new BigDecimal 10000 obj.setSkills skills Serialization process Gson gson new Gson String json gson.toJsonobj firstNameChristian,lastNameLusardi,age25,salary10000,skillsleadership,Java Experience Note that you can not serialize objects with circular references since that will result in in\ufb01nite recursion. Deserialization its very simple... Assuming that json is the previous String object.... Employe obj2 gson.fromJson json, Employe. class obj2 is just like obj Section 66.5 Custom JSON Deserialization with Jackson We consume rest API as a JSON format and then unmarshal it to a POJO. Jackson s org.codehaus.jackson.map.ObjectMapper just works out of the box and we really don t do anything in most cases. But sometimes we need custom deserializer to ful\ufb01ll our custom needs and this tutorial will guide you through the process of creating your own custom deserializer. Lets say we have following entities. public class User private": "input.pdf", "Long id private String name private String email getter setter are omitted for clarity And public class Program private Long id private String name private User createdBy private String contents GoalKicker.com Java Notes for Professionals 385 getter setter are omitted for clarity Lets serializemarshal an object \ufb01rst. User user new User user.setId1L user.setEmail exampleexample.com user.setNameBazlur Rahman Program program new Program program. setId1L program. setNameProgram 1 program. setCreatedBy user program. setContents Some contents ObjectMapper objectMapper new ObjectMapper \ufb01nal String json objectMapper.writeValueAsStringprogram System.out.printlnjson The above code will produce following JSON- id 1, name Program 1 , createdBy id 1, name Bazlur Rahman , email exampleexample.com , contents Some contents Now can do the opposite very easily. If we have this JSON, we can unmarshal to a program object using ObjectMapper as following Now let s say, this is not the real case, we are going to have a di\ufb00erent JSON from an API which doesn t match with our Program class. id 1, name Program 1 , ownerId 1 contents Some contents Look at the JSON string, you can see, it has a di\ufb00erent \ufb01eld that is owenerId. Now if you want to serialize this JSON as we did earlier, you": "input.pdf", "will have exceptions. There are two ways to avoid exceptions and have this serialized Ignore the unknown \ufb01elds Ignore the onwerId . Add the following annotation in the Program class JsonIgnoreProperties ignoreUnknown true public class Program GoalKicker.com Java Notes for Professionals 386Write custom deserializer But there are cases when you actually need this owerId \ufb01eld. Lets say you want to relate it as an id of the User class. In such case, you need to write a custom deserializer- As you can see, \ufb01rst you have to access the JsonNode from the JonsParser . And then you can easily extract information from a JsonNode using the get method. and you have to make sure about the \ufb01eld name. It should be the exact name, spelling mistake will cause exceptions. And \ufb01nally, you have to register your ProgramDeserializer to the ObjectMapper . ObjectMapper mapper new ObjectMapper SimpleModule module new SimpleModule module.addDeserializer Program. class, new ProgramDeserializer mapper.registerModule module String newJsonString id1,nameProgram 1 ,ownerId1,contents Some contents final Program program2 mapper. readValue newJsonString, Program. class Alternatively, you can use annotation to register the deserializer directly JsonDeserialize using ProgramDeserializer. class public class Program GoalKicker.com Java Notes for Professionals 387Chapter 67 Optional Optional is a": "input.pdf", "container object which may or may not contain a non-null value. If a value is present, isPresent will return true and get will return the value. Additional methods that depend on the presence of the contained value are provided, such as orElse, which returns a default value if value not present, and ifPresent which executes a block of code if the value is present. Section 67.1 Map Use the map method of Optional to work with values that might be null without doing explicit null checks Note that the map and filter operations are evaluated immediately, unlike their Stream counterparts which are only evaluated upon a terminal operation . Syntax public U Optional U mapFunction ? super T,? extends U mapper Code examples String value null return Optional. ofNullable value.mapStringtoUpperCase .orElseNONE returns NONE String value something return Optional. ofNullable value.mapStringtoUpperCase .orElseNONE returns SOMETHING Because Optional.map returns an empty optional when its mapping function returns null, you can chain several map operations as a form of null-safe dereferencing. This is also known as Null-safe chaining . Consider the following example String value foo.getBar.getBaz.toString Any of getBar , getBaz , and toString can potentially throw a NullPointerException . Here is an": "input.pdf", "alternative way to get the value from toString using Optional String value Optional. ofNullable foo . mapFoogetBar . mapBargetBaz . mapBaztoString . orElse This will return an empty string if any of the mapping functions returned null. Below is an another example, but slightly di\ufb00erent. It will print the value only if none of the mapping functions returned null. Optional. ofNullable foo . mapFoogetBar . mapBargetBaz GoalKicker.com Java Notes for Professionals 388 . mapBaztoString . ifPresent System.outprintln Section 67.2 Return default value if Optional is empty Dont just use Optional. get since that may throw NoSuchElementException . The Optional. orElseT and Optional. orElseGet Supplier ? extends T methods provide a way to supply a default value in case the Optional is empty. String value something return Optional. ofNullable value.orElsedefaultValue returns something return Optional. ofNullable value.orElseGet - getDefaultValue returns something never calls the getDefaultValue method String value null return Optional. ofNullable value.orElsedefaultValue returns defaultValue return Optional. ofNullable value.orElseGet - getDefaultValue calls getDefaultValue and returns its results The crucial di\ufb00erence between the orElse and orElseGet is that the latter is only evaluated when the Optional is empty while the argument supplied to the former one is evaluated even if the Optional": "input.pdf", "is not empty. The orElse should therefore only be used for constants and never for supplying value based on any sort of computation. Section 67.3 Throw an exception, if there is no value Use the orElseThrow method of Optional to get the contained value or throw an exception, if it hasnt been set. This is similar to calling get, except that it allows for arbitrary exception types. The method takes a supplier that must return the exception to be thrown. In the \ufb01rst example, the method simply returns the contained value Optional optional Optional. ofsomething return optional. orElseThrow IllegalArgumentException new returns something string In the second example, the method throws an exception because a value hasnt been set Optional optional Optional. empty return optional. orElseThrow IllegalArgumentException new throws IllegalArgumentException You can also use the lambda syntax if throwing an exception with message is needed optional. orElseThrow - new IllegalArgumentException Illegal Section 67.4 Lazily provide a default value using a Supplier The normal orElse method takes an Object , so you might wonder why there is an option to provide a Supplier GoalKicker.com Java Notes for Professionals 389here the orElseGet method. Consider String value something return Optional. ofNullable value .": "input.pdf", "orElsegetValueThatIsHardToCalculate returns something It would still call getValueThatIsHardToCalculate even though its result is not used as the optional is not empty. To avoid this penalty you supply a supplier String value something return Optional. ofNullable value . orElseGet - getValueThatIsHardToCalculate returns something This way getValueThatIsHardToCalculate will only be called if the Optional is empty. Section 67.5 Filter filter is used to indicate that you would like the value only if it matches your predicate. Think of it like if !somePredicate x x null . Code examples String value null Optional. ofNullable value nothing . filterx - x.equalscool string this is never run since value is null . isPresent false String value cool string Optional. ofNullable value something . filterx - x.equalscool string this is run and passes . isPresent true String value hot string Optional. ofNullable value something . filterx - x.equalscool string this is run and fails . isPresent false Section 67.6 Using Optional containers for primitive number types OptionalDouble , OptionalInt and OptionalLong work like Optional , but are speci\ufb01cally designed to wrap primitive types OptionalInt presentInt OptionalInt. ofvalue OptionalInt absentInt OptionalInt. empty Because numeric types do have a value, there is no special handling for null.": "input.pdf", "Empty containers can be checked with presentInt. isPresent Is true. absentInt. isPresent Is false. Similarly, shorthands exist to aid value management GoalKicker.com Java Notes for Professionals 390 Prints the value since it is provided on creation. presentInt. ifPresent System.outprintln Gives the other value as the original Optional is empty. int finalValue absentInt. orElseGet thisotherValue Will throw a NoSuchElementException. int nonexistentValue absentInt. getAsInt Section 67.7 Run code only if there is a value present Optional String optionalWithValue Optional. offoo optionalWithValue. ifPresent System.outprintlnPrints foo. Optional String emptyOptional Optional. empty emptyOptional. ifPresent System.outprintlnDoes nothing. Section 67.8 FlatMap flatMap is similar to map. The di\ufb00erence is described by the javadoc as follows This method is similar to mapFunction , but the provided mapper is one whose result is already an Optional , and if invoked, flatMap does not wrap it with an additional Optional . In other words, when you chain a method call that returns an Optional , using Optional. flatMap avoids creating nested Optionals . For example, given the following classes public class Foo Optional Bar getBar return Optional. ofnew Bar public class Bar If you use Optional. map, you will get a nested Optional i.e. Optional Optional Bar. Optional Optional": "input.pdf", "Bar nestedOptionalBar Optional. ofnew Foo . mapFoogetBar However, if you use Optional. flatMap , you will get a simple Optional i.e. Optional Bar. Optional Bar optionalBar Optional. ofnew Foo . flatMapFoogetBar GoalKicker.com Java Notes for Professionals 391Chapter 68 Object References Section 68.1 Object References as method parameters This topic explains the concept of an object reference it is targeted at people who are new to programming in Java. You should already be familiar with some terms and meanings class de\ufb01nition, main method, object instance, and the calling of methods on an object, and passing parameters to methods. public class Person private String name public void setName String name this.name name public String getName return name public static void mainString arguments Person person new Person person. setNameBob int i 5 setPersonName person, i System.out.printlnperson.getName i private static void setPersonName Person person, int num person. setNameLinda num 99 To be fully competent in Java programming, you should be able to explain this example to someone else o\ufb00 the top of your head. Its concepts are fundamental to understanding how Java works. As you can see, we have a main that instantiates an object to the variable person , and calls a": "input.pdf", "method to set the name \ufb01eld in that object to Bob . Then it calls another method, and passes person as one of two parameters the other parameter is an integer variable, set to 5. The method called sets the name value on the passed object to Linda, and sets the integer variable passed to 99, then returns. So what would get printed? Linda 5 So why does the change made to person take e\ufb00ect in main , but the change made to the integer does not? When the call is made, the main method passes an object reference for person to the setPersonName method any change that setAnotherName makes to that object is part of that object, and so those changes are still part of that object when the method returns. Another way of saying the same thing person points to an object stored on the heap, if youre interested. Any change the method makes to that object are made on that object, and are not a\ufb00ected by whether the method making the change is still active or has returned. When the method returns, any changes made to the object are still stored on that object. GoalKicker.com Java": "input.pdf", "Notes for Professionals 392Contrast this with the integer that is passed. Since this is a primitive int and not an Integer object instance, it is passed by value, meaning its value is provided to the method, not a pointer to the original integer passed in. The method can change it for the methods own purposes, but that does not a\ufb00ect the variable used when the method call is made. In Java, all primitives are passed by value. Objects are passed by reference, which means that a pointer to the object is passed as the parameter to any methods that take them. One less-obvious thing this means it is not possible for a called method to create a new object and return it as one of the parameters. The only way for a method to return an object that is created, directly or indirectly, by the method call, is as a return value from the method. Lets \ufb01rst see how that would not work, and then how it would work. Lets add another method to our little example here private static void getAnotherObjectNot Person person person new Person person. setNameGeorge And, back in the main , below the call to": "input.pdf", "setAnotherName , lets put a call to this method and another println call getAnotherObjectNot person System.out.printlnperson.getName Now the program would print out Linda 5 Linda What happened to the object that had George? Well, the parameter that was passed in was a pointer to Linda when the getAnotherObjectNot method created a new object, it replaced the reference to the Linda object with a reference to the George object. The Linda object still exists on the heap, the main method can still access it, but the getAnotherObjectNot method wouldnt be able to do anything with it after that, because it has no reference to it. It would appear that the writer of the code intended for the method to create a new object and pass it back, but if so, it didnt work. If that is what the writer wanted to do, he would need to return the newly created object from the method, something like this private static Person getAnotherObject Person person new Person person. setNameMary return person Then call it like this Person mary mary getAnotherObject System.out.printlnmary.getName And the entire program output would now be Linda 5 GoalKicker.com Java Notes for Professionals 393Linda Mary Here is the entire": "input.pdf", "program, with both additions public class Person private String name public void setName String name this.name name public String getName return name public static void mainString arguments Person person new Person person. setNameBob int i 5 setPersonName person, i System.out.printlnperson.getName i getAnotherObjectNot person System.out.printlnperson.getName Person person person getAnotherObject System.out.printlnperson.getName private static void setPersonName Person person, int num person. setNameLinda num 99 private static void getAnotherObjectNot Person person person new Person person. setMyName George private static person getAnotherObject Person person new Person person. setMyName Mary return person GoalKicker.com Java Notes for Professionals 394Chapter 69 Exceptions and exception handling Objects of type Throwable and its subtypes can be sent up the stack with the throw keyword and caught with trycatch statements. Section 69.1 Catching an exception with try-catch An exception can be caught and handled using the try...catch statement. In fact try statements take other forms, as described in other examples about try...catch...finally and try-with-resources . Try-catch with one catch block The most simple form looks like this try doSomething catch SomeException e handle e next statement The behavior of a simple try...catch is as follows The statements in the try block are executed. If no exception is thrown by the": "input.pdf", "statements in the try block, then control passes to the next statement after the try...catch . If an exception is thrown within the try block. The exception object is tested to see if it is an instance of SomeException or a subtype. If it is, then the catch block will catch the exception The variable e is bound to the exception object. The code within the catch block is executed. If that code throws an exception, then the newly thrown exception is propagated in place of the original one. Otherwise, control passes to the next statement after the try...catch . If it is not, the original exception continues to propagate. Try-catch with multiple catches A try...catch can also have multiple catch blocks. For example try doSomething catch SomeException e handleOneWay e catch SomeOtherException e handleAnotherWay e next statement If there are multiple catch blocks, they are tried one at a time starting with the \ufb01rst one, until a match is found for the exception. The corresponding handler is executed as above, and then control is passed to the next statement after the try...catch statement. The catch blocks after the one that matches are always skipped, even if the handler": "input.pdf", "code throws an exception . GoalKicker.com Java Notes for Professionals 395The top down matching strategy has consequences for cases where the exceptions in the catch blocks are not disjoint. For example try throw new RuntimeException test catch Exception e System.out.printlnException catch RuntimeException e System.out.printlnRuntimeException This code snippet will output Exception rather than RuntimeException. Since RuntimeException is a subtype of Exception , the \ufb01rst more general catch will be matched. The second more speci\ufb01c catch will never be executed. The lesson to learn from this is that the most speci\ufb01c catch blocks in terms of the exception types should appear \ufb01rst, and the most general ones should be last. Some Java compilers will warn you if a catch can never be executed, but this is not a compilation error. Multi-exception catch blocks Version Java SE 7 Starting with Java SE 7, a single catch block can handle a list of unrelated exceptions. The exception type are listed, separated with a vertical bar symbol. For example try doSomething catch SomeException SomeOtherException e handleSomeException e The behavior of a multi-exception catch is a simple extension for the single-exception case. The catch matches if the thrown exception matches at least one of the": "input.pdf", "listed exceptions. There is some additional subtlety in the speci\ufb01cation. The type of e is a synthetic union of the exception types in the list. When the value of e is used, its static type is the least common supertype of the type union. However, if e is rethrown within the catch block, the exception types that are thrown are the types in the union. For example public void method throws IOException , SQLException try doSomething catch IOException SQLException e report e throw e In the above, IOException and SQLException are checked exceptions whose least common supertype is Exception . This means that the report method must match reportException . However, the compiler knows that the throw can throw only an IOException or an SQLException . Thus, method can be declared as throws IOException , SQLException rather than throws Exception . Which is a good thing see Pitfall - Throwing Throwable, Exception, Error or RuntimeException. Section 69.2 The try-with-resources statement Version Java SE 7 GoalKicker.com Java Notes for Professionals 396As the try-catch-\ufb01nal statement example illustrates, resource cleanup using a finally clause requires a signi\ufb01cant amount of boiler-plate code to implement the edge-cases correctly. Java 7 provides a much simpler": "input.pdf", "way to deal with this problem in the form of the try-with-resources statement. What is a resource? Java 7 introduced the java.lang.AutoCloseable interface to allow classes to be managed using the try-with- resources statement. Instances of classes that implement AutoCloseable are referred to as resources . These typically need to be disposed of in a timely fashion rather than relying on the garbage collector to dispose of them. The AutoCloseable interface de\ufb01nes a single method public void close throws Exception A close method should dispose of the resource in an appropriate fashion. The speci\ufb01cation states that it should be safe to call the method on a resource that has already been disposed of. In addition, classes that implement Autocloseable are strongly encouraged to declare the close method to throw a more speci\ufb01c exception than Exception , or no exception at all. A wide range of standard Java classes and interfaces implement AutoCloseable . These include InputStream , OutputStream and their subclasses Reader , Writer and their subclasses Socket and ServerSocket and their subclasses Channel and its subclasses, and the JDBC interfaces Connection , Statement and ResultSet and their subclasses. Application and third party classes may do this as well.": "input.pdf", "The basic try-with-resource statement The syntax of a try-with-resources is based on classical try-catch , try-\ufb01nally and try-catch-\ufb01nally forms. Here is an example of a basic form i.e. the form without a catch or finally . try PrintStream stream new PrintStream hello.txt stream. printlnHello world! The resources to be manage are declared as variables in the ... section after the try clause. In the example above, we declare a resource variable stream and initialize it to a newly created PrintStream . Once the resource variables have been initialized, the try block is executed. When that completes, stream.close will be called automatically to ensure that the resource does not leak. Note that the close call happens no matter how the block completes. The enhanced try-with-resource statements The try-with-resources statement can be enhanced with catch and finally blocks, as with the pre-Java 7 try-catch- \ufb01nally syntax. The following code snippet adds a catch block to our previous one to deal with the FileNotFoundException that the PrintStream constructor can throw try PrintStream stream new PrintStream hello.txt stream. printlnHello world! catch FileNotFoundException ex System.err.printlnCannot open the file GoalKicker.com Java Notes for Professionals 397 finally System.err.printlnAll done If either the resource initialization or the": "input.pdf", "try block throws the exception, then the catch block will be executed. The finally block will always be executed, as with a conventional try-catch-\ufb01nally statement. There are a couple of things to note though The resource variable is out of scope in the catch and finally blocks. The resource cleanup will happen before the statement tries to match the catch block. If the automatic resource cleanup threw an exception, then that could be caught in one of the catch blocks. Managing multiple resources The code snippets above show a single resource being managed. In fact, try-with-resources can manage multiple resources in one statement. For example try InputStream is new FileInputStream file1 OutputStream os new FileOutputStream file2 Copy is to os This behaves as you would expect. Both is and os are closed automatically at the end of the try block. There are a couple of points to note The initializations occur in the code order, and later resource variable initializers can use of the values of the earlier ones. All resource variables that were successfully initialized will be cleaned up. Resource variables are cleaned up in reverse order of their declarations. Thus, in the above example, is is initialized": "input.pdf", "before os and cleaned up after it, and is will be cleaned up if there is an exception while initializing os. Equivalence of try-with-resource and classical try-catch-\ufb01nally The Java Language Speci\ufb01cation speci\ufb01es the behavior of try-with-resource forms in terms of the classical try-catch- \ufb01nally statement. Please refer to the JLS for the full details. For example, this basic try-with-resource try PrintStream stream new PrintStream hello.txt stream. printlnHello world! is de\ufb01ned to be equivalent to this try-catch-\ufb01nally Note that the constructor is not part of the try-catch statement PrintStream stream new PrintStream hello.txt This variable is used to keep track of the primary exception thrown in the try statement. If an exception is thrown in the try block, any exception thrown by AutoCloseable.close will be suppressed. Throwable primaryException null The actual try block try GoalKicker.com Java Notes for Professionals 398 stream. printlnHello world! catch Throwable t If an exception is thrown, remember it for the finally block primaryException t throw t finally if primaryException null If no exception was thrown so far, exceptions thrown in close will not be caught and therefore be passed on to the enclosing code. stream. close else If an exception has already been thrown, any": "input.pdf", "exception thrown in close will be suppressed as it is likely to be related to the previous exception. The suppressed exception can be retrieved using primaryException.getSuppressed. try stream. close catch Throwable suppressedException primaryException. addSuppressed suppressedException The JLS speci\ufb01es that the actual t and primaryException variables will be invisible to normal Java code. The enhanced form of try-with-resources is speci\ufb01ed as an equivalence with the basic form. For example try PrintStream stream new PrintStream fileName stream. printlnHello world! catch NullPointerException ex System.err.printlnNull filename finally System.err.printlnAll done is equivalent to try try PrintStream stream new PrintStream fileName stream. printlnHello world! catch NullPointerException ex System.err.printlnNull filename finally System.err.printlnAll done Section 69.3 Custom Exceptions Under most circumstances, it is simpler from a code-design standpoint to use existing generic Exception classes when throwing exceptions. This is especially true if you only need the exception to carry a simple error message. In that case, RuntimeException is usually preferred, since it is not a checked Exception. Other exception classes exist for common classes of errors UnsupportedOperationException - a certain operation is not supported IllegalArgumentException - an invalid parameter value was passed to a method IllegalStateException - your API has internally reached a condition that should never": "input.pdf", "happen, or which occurs as a result of using your API in an invalid way GoalKicker.com Java Notes for Professionals 399Cases where you do want to use a custom exception class include the following You are writing an API or library for use by others, and you want to allow users of your API to be able to speci\ufb01cally catch and handle exceptions from your API, and be able to di\ufb00erentiate those exceptions from other, more generic exceptions . You are throwing exceptions for a speci\ufb01c kind of error in one part of your program, which you want to catch and handle in another part of your program, and you want to be able to di\ufb00erentiate these errors from other, more generic errors. You can create your own custom exceptions by extending RuntimeException for an unchecked exception, or checked exception by extending any Exception which is not also subclass of RuntimeException , because Subclasses of Exception that are not also subclasses of RuntimeException are checked exceptions public class StringTooLongException extends RuntimeException Exceptions can have methods and fields like other classes those can be useful to communicate information to pieces of code catching such an exception public final String value": "input.pdf", "public final int maximumLength public StringTooLongException String value, int maximumLength superString.formatString exceeds maximum Length of s s , maximumLength, value this.value value this.maximumLength maximumLength Those can be used just as prede\ufb01ned exceptions void validateString String value if value.length 30 throw new StringTooLongException value, 30 And the \ufb01elds can be used where the exception is caught and handled void anotherMethod String value try validateString value catchStringTooLongException e System.out.printlnThe string e.value was longer than the max of e.maximumLength Keep in mind that, according to Oracles Java Documentation ... If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception. More GoalKicker.com Java Notes for Professionals 400Why does RuntimeException not require an explicit exception handling? Section 69.4 Handling InterruptedException InterruptedException is a confusing beast - it shows up in seemingly innocuous methods like Thread.sleep, but handling it incorrectly leads to hard-to-manage code that behaves poorly in concurrent environments. At its most basic, if an InterruptedException is caught it means someone, somewhere, called Thread.interrupt on the thread your code is currently running in. You might be inclined to say Its my": "input.pdf", "code! Ill never interrupt it! and therefore do something like this Bad. Dont do this. try Thread.sleep1000 catch InterruptedException e disregard But this is exactly the wrong way to handle an impossible event occurring. If you know your application will never encounter an InterruptedException you should treat such an event as a serious violation of your programs assumptions and exit as quickly as possible. The proper way to handle an impossible interrupt is like so When nothing will interrupt your code try Thread.sleep1000 catch InterruptedException e Thread.currentThread .interrupt throw new AssertionError e This does two things it \ufb01rst restores the interrupt status of the thread as if the InterruptedException had not been thrown in the \ufb01rst place, and then it throws an AssertionError indicating the basic invariants of your application have been violated. If you know for certain that youll never interrupt the thread this code runs in this is safe since the catch block should never be reached. Using Guavas Uninterruptibles class helps simplify this pattern calling Uninterruptibles. sleepUninterruptibly disregards the interrupted state of a thread until the sleep duration has expired at which point its restored for later calls to inspect and throw their own InterruptedException .": "input.pdf", "If you know youll never interrupt such code this safely avoids needing to wrap your sleep calls in a try-catch block. More often, however, you cannot guarantee that your thread will never be interrupted. In particular if youre writing code that will be executed by an Executor or some other thread-management its critical that your code responds promptly to interrupts, otherwise your application will stall or even deadlock. In such cases the best thing to do is generally to allow the InterruptedException to propagate up the call stack, adding a throws InterruptedException to each method in turn. This may seem kludgy but its actually a desirable property - your methods signatures now indicates to callers that it will respond promptly to interrupts. Let the caller determine how to handle the interrupt if youre unsure public void myLongRunningMethod throws InterruptedException ... GoalKicker.com Java Notes for Professionals 401In limited cases e.g. while overriding a method that doesnt throw any checked exceptions you can reset the interrupted status without raising an exception, expecting whatever code is executed next to handle the interrupt. This delays handling the interruption but doesnt suppress it entirely. Suppresses the exception but resets the interrupted state letting later": "input.pdf", "code detect the interrupt and handle it properly. try Thread.sleep1000 catch InterruptedException e Thread.currentThread .interrupt return ... your expectations are still broken at this point - try not to do more work. Section 69.5 Return statements in try catch block Although its bad practice, its possible to add multiple return statements in a exception handling block public static int returnTest int number try ifnumber2 0 throw new Exception Exception thrown else return x catchException e return 3 finally return 7 This method will always return 7 since the \ufb01nally block associated with the trycatch block is executed before anything is returned. Now, as \ufb01nally has return 7, this value supersedes the trycatch return values. If the catch block returns a primitive value and that primitive value is subsequently changed in the \ufb01nally block, the value returned in the catch block will be returned and the changes from the \ufb01nally block will be ignored. The example below will print 0, not 1. public class FinallyExample public static void mainString args int n returnTest 4 System.out.printlnn public static int returnTest int number int returnNumber 0 try if number 2 0 throw new Exception Exception thrown else return returnNumber catch Exception e": "input.pdf", "return returnNumber finally returnNumber 1 GoalKicker.com Java Notes for Professionals 402 Section 69.6 Introduction Exceptions are errors which occur when a program is executing. Consider the Java program below which divides two integers. class Division public static void mainString args int a, b, result Scanner input new Scanner System.in System.out.printlnInput two integers a input.nextInt b input.nextInt result a b System.out.printlnResult result Now we compile and execute the above code, and see the output for an attempted division by zero Input two integers 7 0 Exception in thread main java.lang.ArithmeticException by zero at Division.mainDisivion.java14 Division by zero is an invalid operation that would produce a value that cannot be represented as an integer. Java deals with this by throwing an exception . In this case, the exception is an instance of the ArithmeticException class. Note The example on creating and reading stack traces explains what the output after the two numbers means. The utility of an exception is the \ufb02ow control that it allows. Without using exceptions, a typical solution to this problem may be to \ufb01rst check if b 0 class Division public static void mainString args int a, b, result Scanner input new Scanner System.in System.out.printlnInput two integers": "input.pdf", "a input.nextInt b input.nextInt if b 0 System.out.printlnYou cannot divide by zero. return GoalKicker.com Java Notes for Professionals 403 result a b System.out.printlnResult result This prints the message You cannot divide by zero. to the console and quits the program in a graceful way when the user tries to divide by zero. An equivalent way of dealing with this problem via exception handling would be to replace the if \ufb02ow control with a try-catch block ... a input.nextInt b input.nextInt try result a b catch ArithmeticException e System.out.printlnAn ArithmeticException occurred. Perhaps you tried to divide by zero. return ... A try catch block is executed as follows Begin executing the code in the try block. 1. If an exception occurs in the try block, immediately abort and check to see if this exception is caught by the 2. catch block in this case, when the Exception is an instance of ArithmeticException . If the exception is caught , it is assigned to the variable e and the catch block is executed. 3. If either the try or catch block is completed i.e. no uncaught exceptions occur during code execution then 4. continue to execute code below the try-catch block.": "input.pdf", "It is generally considered good practice to use exception handling as part of the normal \ufb02ow control of an application where behavior would otherwise be unde\ufb01ned or unexpected. For instance, instead of returning null when a method fails, it is usually better practice to throw an exception so that the application making use of the method can de\ufb01ne its own \ufb02ow control for the situation via exception handling of the kind illustrated above. In some sense, this gets around the problem of having to return a particular type, as any one of multiple kinds of exceptions may be thrown to indicate the speci\ufb01c problem that occurred. For more advice on how and how not to use exceptions, refer to Java Pitfalls - Exception usage Section 69.7 The Java Exception Hierarchy - Unchecked and Checked Exceptions All Java exceptions are instances of classes in the Exception class hierarchy. This can be represented as follows java.lang.Throwable - This is the base class for all exception classes. Its methods and constructors implement a range of functionality common to all exceptions. java.lang.Exception - This is the superclass of all normal exceptions. various standard and custom exception classes. java.lang.RuntimeException - This the superclass of": "input.pdf", "all normal exceptions that are unchecked exceptions . various standard and custom runtime exception classes. GoalKicker.com Java Notes for Professionals 404java.lang.Error - This is the superclass of all fatal error exceptions. Notes The distinction between checked and unchecked exceptions is described below. 1. The Throwable , Exception and RuntimeException class should be treated as abstract see Pitfall - Throwing 2. Throwable, Exception, Error or RuntimeException. The Error exceptions are thrown by the JVM in situations where it would be unsafe or unwise for an 3. application to attempt to recover. It would be unwise to declare custom subtypes of Throwable . Java tools and libraries may assume that Error 4. and Exception are the only direct subtypes of Throwable , and misbehave if that assumption is incorrect. Checked versus Unchecked Exceptions One of the criticisms of exception support in some programming languages is that is di\ufb03cult to know which exceptions a given method or procedure might throw. Given that an unhandled exception is liable to cause a program to crash, this can make exceptions a source of fragility. The Java language addresses this concern with the checked exception mechanism. First, Java classi\ufb01es exceptions into two categories Checked exceptions typically": "input.pdf", "represent anticipated events that an application should be able to deal with. For instance, IOException and its subtypes represent error conditions that can occur in IO operations. Examples include, \ufb01le opens failing because a \ufb01le or directory does not exist, network reads and writes failing because a network connection has been broken and so on. Unchecked exceptions typically represent unanticipated events that an application cannot deal with. These are typically the result of a bug in the application. In the following, thrown refers to any exception thrown explicitly by a throw statement, or implicitly in a failed dereference, type cast and so on. Similarly, propagated refers to an exception that was thrown in a nested call, and not caught within that call. The sample code below will illustrate this. The second part of the checked exception mechanism is that there are restrictions on methods where a checked exception may occur When a checked exception is thrown or propagated in a method, it must either be caught by the method, or listed in the methods throws clause. The signi\ufb01cance of the throws clause is described in this example. When a checked exception is thrown or propagated in an initializer block,": "input.pdf", "it must be caught the the block. A checked exception cannot be propagated by a method call in a \ufb01eld initialization expression. There is no way to catch such an exception. In short, a checked exception must be either handled, or declared. These restrictions do not apply to unchecked exceptions. This includes all cases where an exception is thrown implicitly, since all such cases throw unchecked exceptions. Checked exception examples These code snippets are intended to illustrate the checked exception restrictions. In each case, we show a version of the code with a compilation error, and a second version with the error corrected. This declares a custom checked exception. public class MyException extends Exception constructors omitted. GoalKicker.com Java Notes for Professionals 405 This declares a custom unchecked exception. public class MyException2 extends RuntimeException constructors omitted. The \ufb01rst example shows how explicitly thrown checked exceptions can be declared as thrown if they should not be handled in the method. INCORRECT public void methodThrowingCheckedException boolean flag int i 1 0 Compiles OK, throws ArithmeticException if flag throw new MyException Compilation error else throw new MyException2 Compiles OK CORRECTED public void methodThrowingCheckedException boolean flag throws MyException int i 1 0 Compiles OK,": "input.pdf", "throws ArithmeticException if flag throw new MyException Compilation error else throw new MyException2 Compiles OK The second example shows how a propagated checked exception can be dealt with. INCORRECT public void methodWithPropagatedCheckedException InputStream is new FileInputStream someFile.txt Compilation error FileInputStream throws IOException or a subclass if the file cannot be opened. IOException is a checked exception. ... CORRECTED Version A public void methodWithPropagatedCheckedException throws IOException InputStream is new FileInputStream someFile.txt ... CORRECTED Version B public void methodWithPropagatedCheckedException try InputStream is new FileInputStream someFile.txt ... catch IOException ex System.out.printlnCannot open file ex.getMessage The \ufb01nal example shows how to deal with a checked exception in a static \ufb01eld initializer. INCORRECT public class Test GoalKicker.com Java Notes for Professionals 406 private static final InputStream is new FileInputStream someFile.txt Compilation error CORRECTED public class Test private static final InputStream is static InputStream tmp null try tmp new FileInputStream someFile.txt catch IOException ex System.out.printlnCannot open file ex.getMessage is tmp Note that in this last case, we also have to deal with the problems that is cannot be assigned to more than once, and yet also has to be assigned to, even in the case of an exception. Section 69.8 Creating and reading stacktraces When": "input.pdf", "an exception object is created i.e. when you new it, the Throwable constructor captures information about the context in which the exception was created. Later on, this information can be output in the form of a stacktrace, which can be used to help diagnose the problem that caused the exception in the \ufb01rst place. Printing a stacktrace Printing a stacktrace is simply a matter of calling the printStackTrace method. For example try int a 0 int b 0 int c a b catch ArithmeticException ex This prints the stacktrace to standard output ex.printStackTrace The printStackTrace method without arguments will print to the applications standard output i.e. the current System.out. There are also printStackTrace PrintStream and printStackTrace PrintWriter overloads that print to a speci\ufb01ed Stream or Writer . Notes The stacktrace does not include the details of the exception itself. You can use the toString method to get 1. those details e.g. Print exception and stacktrace System.out.printlnex ex.printStackTrace Stacktrace printing should be used sparingly see Pitfall - Excessive or inappropriate stacktraces . It is often2. better to use a logging framework, and pass the exception object to be logged. Understanding a stacktrace GoalKicker.com Java Notes for Professionals 407Consider the following": "input.pdf", "simple program consisting of two classes in two \ufb01les. We have shown the \ufb01lenames and added line numbers for illustration purposes. File Main.java 1 public class Main 2 public static void mainString args 3 new Test.foo 4 5 File Test.java 1 class Test 2 public void foo 3 bar 4 5 6 public int bar 7 int a 1 8 int b 0 9 return a b 10 When these \ufb01les are compiled and run, we will get the following output. Exception in thread main java.lang.ArithmeticException by zero at Test.barTest.java9 at Test.fooTest.java3 at Main.mainMain.java3 Let us read this one line at a time to \ufb01gure out what it is telling us. Line 1 tells us that the thread called main has terminated due to an uncaught exception. The full name of the exception is java.lang.ArithmeticException , and the exception message is by zero. If we look up the javadocs for this exception, it says Thrown when an exceptional arithmetic condition has occurred. For example, an integer divide by zero throws an instance of this class. Indeed, the message by zero is a strong hint that the cause of the exception is that some code has attempted to divide something": "input.pdf", "by zero. But what? The remaining 3 lines are the stack trace. Each line represents a method or constructor call on the call stack, and each one tells us three things the name of the class and method that was being executed, the source code \ufb01lename, the source code line number of the statement that was being executed These lines of a stacktrace are listed with the frame for the current call at the top. The top frame in our example above is in the Test.bar method, and at line 9 of the Test.java \ufb01le. That is the following line return a b GoalKicker.com Java Notes for Professionals 408If we look a couple of lines earlier in the \ufb01le to where b is initialized, it is apparent that b will have the value zero. We can say without any doubt that this is the cause of the exception. If we needed to go further, we can see from the stacktrace that bar was called from foo at line 3 of Test.java, and that foo was in turn called from Main.main. Note The class and method names in the stack frames are the internal names for the classes and methods.": "input.pdf", "You will need to recognize the following unusual cases A nested or inner class will look like OuterClassInnerClass. An anonymous inner class will look like OuterClass1, OuterClass2, etcetera. When code in a constructor, instance \ufb01eld initializer or an instance initializer block is being executed, the method name will be . When code in a static \ufb01eld initializer or static initializer block is being executed, the method name will be . In some versions of Java, the stacktrace formatting code will detect and elide repeated stackframe sequences, as can occur when an application fails due to excessive recursion. Exception chaining and nested stacktraces Version Java SE 1.4 Exception chaining happens when a piece of code catches an exception, and then creates and throws a new one, passing the \ufb01rst exception as the cause. Here is an example File Test,java 1 public class Test 2 int foo 3 return 0 0 4 5 6 public Test 7 try 8 foo 9 catch ArithmeticException ex 10 throw new RuntimeException A bad thing happened , ex 11 12 13 14 public static void mainString args 15 new Test 16 17 When the above class is compiled and run, we get the following stacktrace": "input.pdf", "Exception in thread main java.lang.RuntimeException A bad thing happened at Test. initTest.java10 at Test. mainTest.java15 Caused by java.lang.ArithmeticException by zero at Test. fooTest.java3 at Test. initTest.java8 ... 1 more The stacktrace starts with the class name, method and call stack for the exception that in this case caused the application to crash. This is followed by a Caused by line that reports the cause exception. The class name and message are reported, followed by the cause exceptions stack frames. The trace ends with an ... N more which indicates that the last N frames are the same as for the previous exception. GoalKicker.com Java Notes for Professionals 409The Caused by is only included in the output when the primary exceptions cause is not null . Exceptions can be chained inde\ufb01nitely, and in that case the stacktrace can have multiple Caused by traces. Note the cause mechanism was only exposed in the Throwable API in Java 1.4.0. Prior to that, exception chaining needed to be implemented by the application using a custom exception \ufb01eld to represent the cause, and a custom printStackTrace method. Capturing a stacktrace as a String Sometimes, an application needs to be able to capture a stacktrace": "input.pdf", "as a Java String , so that it can be used for other purposes. The general approach for doing this is to create a temporary OutputStream or Writer that writes to an in- memory bu\ufb00er and pass that to the printStackTrace .... The Apache Commons and Guava libraries provide utility methods for capturing a stacktrace as a String org.apache.commons.lang.exception .ExceptionUtils .getStackTrace Throwable com.google.common.base.Throwables .getStackTraceAsString Throwable If you cannot use third party libraries in your code base, then the following method with do the task Returns the string representation of the stack trace. param throwable the throwable return the string. public static String stackTraceToString Throwable throwable StringWriter stringWriter new StringWriter throwable. printStackTrace new PrintWriter stringWriter return stringWriter. toString Note that if your intention is to analyze the stacktrace, it is simpler to use getStackTrace and getCause than to attempt to parse a stacktrace. Section 69.9 Throwing an exception The following example shows the basics of throwing an exception public void checkNumber int number throws IllegalArgumentException if number 0 throw new IllegalArgumentException Number must be positive number The exception is thrown on the 3rd line. This statement can be broken down into two parts new IllegalArgumentException ... is creating an instance": "input.pdf", "of the IllegalArgumentException class, with a message that describes the error that exception is reporting. throw ... is then throwing the exception object. When the exception is thrown, it causes the enclosing statements to terminate abnormally until the exception is handled . This is described in other examples. GoalKicker.com Java Notes for Professionals 410It is good practice to both create and throw the exception object in a single statement, as shown above. It is also good practice to include a meaningful error message in the exception to help the programmer to understand the cause of the problem. However, this is not necessarily the message that you should be showing to the end user. For a start, Java has no direct support for internationalizing exception messages. There are a couple more points to be made We have declared the checkNumber as throws IllegalArgumentException . This was not strictly necessary, since IllegalArgumentException is a checked exception see The Java Exception Hierarchy - Unchecked and Checked Exceptions. However, it is good practice to do this, and also to include the exceptions thrown a methods javadoc comments. Code immediately after a throw statement is unreachable . Hence if we wrote this throw new": "input.pdf", "IllegalArgumentException it is bad return the compiler would report a compilation error for the return statement. Exception chaining Many standard exceptions have a constructor with a second cause argument in addition to the conventional message argument. The cause allows you to chain exceptions. Here is an example. First we de\ufb01ne an unchecked exception that our application is going throw when it encounters a non-recoverable error. Note that we have included a constructor that accepts a cause argument. public class AppErrorException extends RuntimeException public AppErrorException super public AppErrorException String message supermessage public AppErrorException String message, Throwable cause supermessage, cause Next, here is some code that illustrates exception chaining. public String readFirstLine String file throws AppErrorException try Reader r new BufferedReader new FileReader file String line r.readLine if line ! null return line else throw new AppErrorException File is empty file catch IOException ex throw new AppErrorException Cannot read file file, ex GoalKicker.com Java Notes for Professionals 411The throw within the try block detects a problem and reports it via an exception with a simple message. By contrast, the throw within the catch block is handling the IOException by wrapping it in a new checked exception. However, it is not throwing": "input.pdf", "away the original exception. By passing the IOException as the cause , we record it so that it can be printed in the stacktrace, as explained in Creating and reading stacktraces. Section 69.10 Advanced features of Exceptions This example covers some advanced features and use-cases for Exceptions. Examining the callstack programmatically Version Java SE 1.4 The primary use of exception stacktraces is to provide information about an application error and its context so that the programmer can diagnose and \ufb01x the problem. Sometimes it can be used for other things. For example, a SecurityManager class may need to examine the call stack to decide whether the code that is making a call should be trusted. You can use exceptions to examine the call stack programmatically as follows Exception ex new Exception this captures the call stack StackTraceElement frames ex.getStackTrace System.out.printlnThis method is frames0.getMethodName System.out.printlnCalled from method frames1.getMethodName There are some important caveats on this The information available in a StackTraceElement is limited. There is no more information available than is 1. displayed by printStackTrace . The values of the local variables in the frame are not available. The javadocs for getStackTrace state that a JVM is permitted to leave": "input.pdf", "out frames 2. Some virtual machines may, under some circumstances, omit one or more stack frames from the stack trace. In the extreme case, a virtual machine that has no stack trace information concerning this throwable is permitted to return a zero-length array from this method. Optimizing exception construction As mentioned elsewhere, constructing an exception is rather expensive because it entails capturing and recording information about all stack frames on the current thread. Sometimes, we know that that information is never going to be used for a given exception e.g. the stacktrace will never be printed. In that case, there is an implementation trick that we can use in a custom exception to cause the information to not be captured. The stack frame information needed for stacktraces, is captured when the Throwable constructors call the Throwable .fillInStackTrace method. This method is public , which means that a subclass can override it. The trick is to override the method inherited from Throwable with one that does nothing e.g. public class MyException extends Exception constructors Override public void fillInStackTrace do nothing GoalKicker.com Java Notes for Professionals 412 The problem with this approach is that an exception that overrides fillInStackTrace can never": "input.pdf", "capture the stacktrace, and is useless in scenarios where you need one. Erasing or replacing the stacktrace Version Java SE 1.4 In some situations, the stacktrace for an exception created in the normal way contains either incorrect information, or information that the developer does not want to reveal to the user. For these scenarios, the Throwable .setStackTrace can be used to replace the array of StackTraceElement objects that holds the information. For example, the following can be used to discard an exceptions stack information exception. setStackTrace new StackTraceElement 0 Suppressed exceptions Version Java SE 7 Java 7 introduced the try-with-resources construct, and the associated concept of exception suppression. Consider the following snippet try Writer w new BufferedWriter new FileWriter someFilename do stuff int temp 0 0 throws an ArithmeticException When the exception is thrown, the try will call close on the w which will \ufb02ush any bu\ufb00ered output and then close the FileWriter . But what happens if an IOException is thrown while \ufb02ushing the output? What happens is that any exception that is thrown while cleaning up a resource is suppressed . The exception is caught, and added to the primary exceptions suppressed exception list. Next the try-with-resources": "input.pdf", "will continue with the cleanup of the other resources. Finally, primary exception will be rethrown. A similar pattern occurs if an exception it thrown during the resource initialization, or if the try block completes normally. The \ufb01rst exception thrown becomes the primary exception, and subsequent ones arising from cleanup are suppressed. The suppressed exceptions can be retrieved from the primary exception object by calling getSuppressedExceptions . Section 69.11 The try-\ufb01nally and try-catch-\ufb01nally statements The try...catch...finally statement combines exception handling with clean-up code. The finally block contains code that will be executed in all circumstances. This makes them suitable for resource management, and other kinds of cleanup. Try-\ufb01nally Here is an example of the simpler try...finally form try doSomething finally cleanUp GoalKicker.com Java Notes for Professionals 413 The behavior of the try...finally is as follows The code in the try block is executed. If no exception was thrown in the try block The code in the finally block is executed. If the finally block throws an exception, that exception is propagated. Otherwise, control passes to the next statement after the try...finally . If an exception was thrown in the try block The code in the finally block is executed. If": "input.pdf", "the finally block throws an exception, that exception is propagated. Otherwise, the original exception continues to propagate. The code within finally block will always be executed. The only exceptions are if System.exitint is called, or if the JVM panics. Thus a finally block is the correct place code that always needs to be executed e.g. closing \ufb01les and other resources or releasing locks. try-catch-\ufb01nally Our second example shows how catch and finally can be used together. It also illustrates that cleaning up resources is not straightforward. This code snippet writes the first line of a file to a string String result null Reader reader null try reader new BufferedReader new FileReader fileName result reader. readLine catch IOException ex Logger. getLogger .warnUnexpected IO error , ex logging the exception finally if reader ! null try reader. close catch IOException ex ignore discard this exception The complete set of hypothetical behaviors of try...catch...finally in this example are too complicated to describe here. The simple version is that the code in the finally block will always be executed. Looking at this from the perspective of resource management We declare the resource i.e. reader variable before the try block so that it will": "input.pdf", "be in scope for the finally block. By putting the new FileReader ..., the catch is able to handle any IOError exception from thrown when opening the \ufb01le. We need a reader.close in the finally block because there are some exception paths that we cannot intercept either in the try block or in catch block. However, since an exception might have been thrown before reader was initialized, we also need an explicit null test. Finally, the reader.close call might hypothetically throw an exception. We dont care about that, but if we dont catch the exception at source, we would need to deal with it further up the call stack. GoalKicker.com Java Notes for Professionals 414Version Java SE 7 Java 7 and later provide an alternative try-with-resources syntax which signi\ufb01cantly simpli\ufb01es resource clean-up. Section 69.12 The throws clause in a method declaration Javas checked exception mechanism requires the programmer to declare that certain methods could throw specifed checked exceptions. This is done using the throws clause. For example public class OddNumberException extends Exception a checked exception public void checkEven int number throws OddNumberException if number 2 ! 0 throw new OddNumberException The throws OddNumberException declares that a call to checkEven": "input.pdf", "could throw an exception that is of type OddNumberException . A throws clause can declare a list of types, and can include unchecked exceptions as well as checked exceptions. public void checkEven Double number throws OddNumberException, ArithmeticException if !Double.isFinite number throw new ArithmeticException INF or NaN else if number 2 ! 0 throw new OddNumberException What is the point of declaring unchecked exceptions as thrown? The throws clause in a method declaration serves two purposes It tells the compiler which exceptions are thrown so that the compiler can report uncaught checked1. exceptions as errors. It tells a programmer who is writing code that calls the method what exceptions to expect. For this purpose,2. it often makes to senses to include unchecked exceptions in a throws list. Note that the throws list is also used by the javadoc tool when generating API documentation, and by a typical IDEs hover text method tips. Throws and method overriding The throws clause forms part of a methods signature for the purpose of method overriding. An override method can be declared with the same set of checked exceptions as thrown by the overridden method, or with a subset. However the override method cannot add": "input.pdf", "extra checked exceptions. For example Override public void checkEven int number throws NullPointerException OK NullPointerException is an unchecked exception ... GoalKicker.com Java Notes for Professionals 415Override public void checkEven Double number throws OddNumberException OK identical to the superclass ... class PrimeNumberException extends OddNumberException class NonEvenNumberException extends OddNumberException Override public void checkEven int number throws PrimeNumberException, NonEvenNumberException OK these are both subclasses Override public void checkEven Double number throws IOExcepion ERROR The reason for this rule is that if an overridden method can throw a checked exception that the overridden method could not throw, that would break type substitutability. GoalKicker.com Java Notes for Professionals 416Chapter 70 Calendar and its Subclasses Section 70.1 Creating Calendar objects Calendar objects can be created by using getInstance or by using the constructor GregorianCalendar . Its important to notice that months in Calendar are zero based, which means that JANUARY is represented by an int value 0. In order to provide a better code, always use Calendar constants, such as Calendar .JANUARY to avoid misunderstandings. Calendar calendar Calendar .getInstance Calendar gregorianCalendar new GregorianCalendar Calendar gregorianCalendarAtSpecificDay new GregorianCalendar 2016, Calendar .JANUARY, 1 Calendar gregorianCalendarAtSpecificDayAndTime new GregorianCalendar 2016, Calendar .JANUARY, 1, 6, 55, 10 Note Always use": "input.pdf", "the month constants The numeric representation is misleading , e.g. Calendar .JANUARY has the value 0 Section 70.2 Increasing Decreasing calendar \ufb01elds add and roll can be used to increasedecrease Calendar \ufb01elds. Calendar calendar new GregorianCalendar 2016, Calendar .MARCH, 31 31 March 2016 The add method a\ufb00ects all \ufb01elds, and behaves e\ufb00ectively if one were to add or subtract actual dates from the calendar calendar. addCalendar .MONTH, -6 The above operation removes six months from the calendar, taking us back to 30 September 2015. To change a particular \ufb01eld without a\ufb00ecting the other \ufb01elds, use roll. calendar. rollCalendar .MONTH, -6 The above operation removes six months from the current month , so the month is identi\ufb01ed as September. No other \ufb01elds have been adjusted the year has not changed with this operation. Section 70.3 Subtracting calendars To get a di\ufb00erence between two Calendar s, use getTimeInMillis method Calendar c1 Calendar .getInstance Calendar c2 Calendar .getInstance c2.setCalendar .DATE, c2.getCalendar .DATE 1 System.out.printlnc2.getTimeInMillis - c1.getTimeInMillis outputs 86400000 24 60 60 1000 Section 70.4 Finding AMPM With Calendar class it is easy to \ufb01nd AM or PM. GoalKicker.com Java Notes for Professionals 417 Calendar cal Calendar .getInstance cal.setTimenew Date if cal.getCalendar .AMPM": "input.pdf", "Calendar .PM System.out.printlnIt is PM GoalKicker.com Java Notes for Professionals 418Chapter 71 Using the static keyword Section 71.1 Reference to non-static member from static context Static variables and methods are not part of an instance, There will always be a single copy of that variable no matter how many objects you create of a particular class. For example you might want to have an immutable list of constants, it would be a good idea to keep it static and initialize it just once inside a static method. This would give you a signi\ufb01cant performance gain if you are creating several instances of a particular class on a regular basis. Furthermore you can also have a static block in a class as well. You can use it to assign a default value to a static variable. They are executed only once when the class is loaded into memory. Instance variable as the name suggest are dependent on an instance of a particular object, they live to serve the whims of it. You can play around with them during a particular life cycle of an object. All the \ufb01elds and methods of a class used inside a static method of that": "input.pdf", "class must be static or local. If you try to use instance non-static variables or methods, your code will not compile. public class Week static int daysOfTheWeek 7 static variable int dayOfTheWeek instance variable public static int getDaysLeftInWeek return Week.daysOfTheWeek -dayOfTheWeek this will cause errors public int getDaysLeftInWeek return Week.daysOfTheWeek -dayOfTheWeek this is valid public static int getDaysLeftInTheWeek int today return Week.daysOfTheWeek -today this is valid Section 71.2 Using static to declare constants As the static keyword is used for accessing \ufb01elds and methods without an instantiated class, it can be used to declare constants for use in other classes. These variables will remain constant across every instantiation of the class. By convention, static variables are always ALLCAPS and use underscores rather than camel case. ex static E STATICVARIABLENAME As constants cannot change, static can also be used with the final modi\ufb01er For example, to de\ufb01ne the mathematical constant of pi public class MathUtilities static final double PI 3.14159265358 GoalKicker.com Java Notes for Professionals 419 Which can be used in any class as a constant, for example public class MathCalculations Calculates the circumference of a circle public double calculateCircumference double radius return 2 radius MathUtilities. PI GoalKicker.com Java Notes": "input.pdf", "for Professionals 420Chapter 72 Properties Class The properties object contains key and value pair both as a string. The java.util.Properties class is the subclass of Hashtable. It can be used to get property value based on the property key. The Properties class provides methods to get data from properties \ufb01le and store data into properties \ufb01le. Moreover, it can be used to get properties of system. Advantage of properties \ufb01le Recompilation is not required, if information is changed from properties \ufb01le If any information is changed from Section 72.1 Loading properties To load a properties \ufb01le bundled with your application public class Defaults public static Properties loadDefaults try InputStream bundledResource Defaults. class.getResourceAsStream defaults.properties Properties defaults new Properties defaults. loadbundledResource return defaults catch IOException e Since the resource is bundled with the application, we should never get here. throw new UncheckedIOException defaults.properties not properly packaged with application , e Section 72.2 Saving Properties as XML Storing Properties in a XML File The way you store properties \ufb01les as XML \ufb01les is very similar to the way you would store them as .properties \ufb01les. Just instead of using the store you would use storeToXML . public void saveProperties String location throws": "input.pdf", "IOException make new instance of properties Properties prop new Properties set the property values prop. setProperty name, Steve prop. setProperty color, green prop. setProperty age, 23 check to see if the file already exists File file new Filelocation if !file.exists file. createNewFile GoalKicker.com Java Notes for Professionals 421 save the properties prop. storeToXML new FileOutputStream file, testing properties with xml When you open the \ufb01le it will look like this. Loading Properties from a XML File Now to load this \ufb01le as a properties you need to call the loadFromXML instead of the load that you would use with regular .properties \ufb01les. public static void loadProperties String location throws FileNotFoundException , IOException make new properties instance to load the file into Properties prop new Properties check to make sure the file exists File file new Filelocation if file.exists load the file prop. loadFromXML new FileInputStream file print out all the properties for String name prop.stringPropertyNames System.out.printlnname prop.getProperty name else System.err.printlnError No file found at location When you run this code you will get the following in the console age23 colorgreen nameSteve Section 72.3 Property \ufb01les caveat trailing whitespace Take a close look at these two property \ufb01les which are": "input.pdf", "seemingly completely identical except they are really not identical GoalKicker.com Java Notes for Professionals 422 screenshots are from Notepad Since trailing whitespace is preserved the value of lastName would be Smith in the \ufb01rst case and Smith in the second case. Very rarely this is what users expect and one and can only speculate why this is the default behavior of Properties class. It is however easy to create an enhanced version of Properties that \ufb01xes this problem. The following class, TrimmedProperties , does just that. It is a drop-in replacement for standard Properties class. import java.io.FileInputStream import java.io.FileReader import java.io.IOException import java.io.InputStream import java.io.Reader import java.util.Map.Entry import java.util.Properties Properties class where values are trimmed for trailing whitespace if the properties are loaded from a file. p In the standard link java.util.Properties Properties class trailing whitespace is always preserved. When loading properties from a file such trailing whitespace is almost always iunintentionali. This class fixes this problem. The trimming of trailing whitespace only takes place if the source of input is a file and only where the input is line oriented meaning that for example loading from XML file is inoti changed by this class. For this reason this": "input.pdf", "class is almost in all cases a safe drop-in replacement for the standard ttPropertiestt class. p Whitespace is defined here as any of space U0020 or tab U0009. public class TrimmedProperties extends Properties Reads a property list key and element pairs from the input byte stream. pBehaves exactly as link java.util.Propertiesloadjava.io.InputStream with the exception that trailing whitespace is trimmed from property values if ttinStreamtt is an instance of ttFileInputStreamtt. see java.util.Propertiesloadjava.io.InputStream param inStream the input stream. throws IOException if an error occurred when reading from the input stream. Override public void loadInputStream inStream throws IOException if inStream instanceof FileInputStream First read into temporary props using the standard way Properties tempProps new Properties tempProps. loadinStream GoalKicker.com Java Notes for Professionals 423 Now trim and put into target trimAndLoad tempProps else super.loadinStream Reads a property list key and element pairs from the input character stream in a simple line-oriented format. pBehaves exactly as link java.util.Propertiesloadjava.io.Reader with the exception that trailing whitespace is trimmed on property values if ttreadertt is an instance of ttFileReadertt. see java.util.Propertiesloadjava.io.Reader param reader the input character stream. throws IOException if an error occurred when reading from the input stream. Override public void loadReader reader throws IOException if": "input.pdf", "reader instanceof FileReader First read into temporary props using the standard way Properties tempProps new Properties tempProps. loadreader Now trim and put into target trimAndLoad tempProps else super.loadreader private void trimAndLoad Properties p for EntryObject, Object entry p.entrySet if entry.getValue instanceof String put entry.getKey, trimTrailing String entry.getValue else put entry.getKey, entry. getValue Trims trailing space or tabs from a string. param str return public static String trimTrailing String str if str ! null read str from tail until char is no longer whitespace for int i str.length - 1 i 0 i-- if str.charAti ! str.charAti ! t return str.substring 0, i 1 return str GoalKicker.com Java Notes for Professionals 424Chapter 73 Lambda Expressions Lambda expressions provide a clear and concise way of implementing a single-method interface using an expression. They allow you to reduce the amount of code you have to create and maintain. While similar to anonymous classes, they have no type information by themselves. Type inference needs to happen. Method references implement functional interfaces using existing methods rather than expressions. They belong to the lambda family as well. Section 73.1 Introduction to Java lambdas Functional Interfaces Lambdas can only operate on a functional interface, which is": "input.pdf", "an interface with just one abstract method. Functional interfaces can have any number of default or static methods. For this reason, they are sometimes referred to as Single Abstract Method Interfaces, or SAM Interfaces. interface Foo1 void bar interface Foo2 int barboolean baz interface Foo3 String barObject baz, int mink interface Foo4 default String bar default so not counted return baz void quux When declaring a functional interface the FunctionalInterface annotation can be added. This has no special e\ufb00ect, but a compiler error will be generated if this annotation is applied to an interface which is not functional, thus acting as a reminder that the interface should not be changed. FunctionalInterface interface Foo5 void bar FunctionalInterface interface BlankFoo1 extends Foo3 inherits abstract method from Foo3 FunctionalInterface interface Foo6 void bar boolean equalsObject obj overrides one of Objects method so not counted Conversely, this is not a functional interface, as it has more than one abstract method GoalKicker.com Java Notes for Professionals 425interface BadFoo void bar void quux -- Second method prevents lambda which one should be considered as lambda? This is also not a functional interface, as it does not have any methods interface BlankFoo2 Take note of the": "input.pdf", "following. Suppose you have interface Parent public int parentMethod and interface Child extends Parent public int ChildMethod Then Child cannot be a functional interface since it has two speci\ufb01ed methods. Java 8 also provides a number of generic templated functional interfaces in the package java.util.function . For example, the built-in interface Predicate T wraps a single method which inputs a value of type T and returns a boolean . Lambda Expressions The basic structure of a Lambda expression is fi will then hold a singleton instance of a class, similar to an anonymous class, which implements FunctionalInterface and where the one methods de\ufb01nition is System.out.printlnHello . In other words, the above is mostly equivalent to FunctionalInterface fi new FunctionalInterface Override public void theOneMethod System.out.printlnHello The lambda is only mostly equivalent to the anonymous class because in a lambda, the meaning of expressions like this , super or toString reference the class within which the assignment takes place, not the newly created object. You cannot specify the name of the method when using a lambda but you shouldnt need to, because a functional interface must have only one abstract method, so Java overrides that one. GoalKicker.com Java Notes for Professionals": "input.pdf", "426In cases where the type of the lambda is not certain, e.g. overloaded methods you can add a cast to the lambda to tell the compiler what its type should be, like so Object fooHolder Foo1 - System.out.printlnHello System.out.printlnfooHolder instanceof Foo1 returns true If the functional interfaces single method takes parameters, the local formal names of these should appear between the brackets of the lambda. There is no need to declare the type of the parameter or return as these are taken from the interface although it is not an error to declare the parameter types if you want to. Thus, these two examples are equivalent Foo2 longFoo new Foo2 Override public int barboolean baz return baz ? 1 0 Foo2 shortFoo x - return x ? 1 0 The parentheses around the argument can be omitted if the function only has one argument Foo2 np x - return x ? 1 0 okay Foo3 np2 x, y - x.toString y not okay Implicit Returns If the code placed inside a lambda is a Java expression rather than a statement , it is treated as a method which returns the value of the expression. Thus, the following two are": "input.pdf", "equivalent IntUnaryOperator addOneShort x - x 1 IntUnaryOperator addOneLong x - return x 1 Accessing Local Variables value closures Since lambdas are syntactic shorthand for anonymous classes, they follow the same rules for accessing local variables in the enclosing scope the variables must be treated as final and not modi\ufb01ed inside the lambda. IntUnaryOperator makeAdder int amount return x - x amount Legal even though amount will go out of scope because amount is not modified IntUnaryOperator makeAccumulator int value return x - value x return value Will not compile If it is necessary to wrap a changing variable in this way, a regular object that keeps a copy of the variable should be used. Read more in Java Closures with lambda expressions. Accepting Lambdas Because a lambda is an implementation of an interface, nothing special needs to be done to make a method accept a lambda any function which takes a functional interface can also accept a lambda. GoalKicker.com Java Notes for Professionals 427public void passMeALambda Foo1 f f.bar passMeALambda - System.out.printlnLambda called The Type of a Lambda Expression A lambda expression, by itself, does not have a speci\ufb01c type. While it is true that the types and": "input.pdf", "number of parameters, along with the type of a return value can convey some type information, such information will only constrain what types it can be assigned to. The lambda receives a type when it is assigned to a functional interface type in one of the following ways Direct assignment to a functional type, e.g. myPredicate s - s.isEmpty Passing it as a parameter that has a functional type, e.g. stream.filters - s.isEmpty Returning it from a function that returns a functional type, e.g. return s - s.isEmpty Casting it to a functional type, e.g. Predicate String s - s.isEmpty Until any such assignment to a functional type is made, the lambda does not have a de\ufb01nite type. To illustrate, consider the lambda expression o - o.isEmpty. The same lambda expression can be assigned to many di\ufb00erent functional types Predicate String javaStringPred o - o.isEmpty Function String, Boolean javaFunc o - o.isEmpty Predicate List javaListPred o - o.isEmpty Consumer String javaStringConsumer o - o.isEmpty return value is ignored! com.google.common.base.Predicate String guavaPredicate o - o.isEmpty Now that they are assigned, the examples shown are of completely di\ufb00erent types even though the lambda expressions looked the same, and they cannot be": "input.pdf", "assigned to each other. Section 73.2 Using Lambda Expressions to Sort a Collection Sorting lists Prior to Java 8, it was necessary to implement the java.util.Comparator interface with an anonymous or named class when sorting a list1 Version Java SE 1.2 ListPerson people ... Collections .sort people, new Comparator Person public int compare Person p1, Person p2 return p1.getFirstName .compareTo p2.getFirstName Starting with Java 8, the anonymous class can be replaced with a lambda expression. Note that the types for the parameters p1 and p2 can be left out, as the compiler will infer them automatically Collections .sort people, p1, p2 - p1.getFirstName .compareTo p2.getFirstName The example can be simpli\ufb01ed by using Comparator .comparing and method references expressed using the GoalKicker.com Java Notes for Professionals 428double colon symbol. Collections .sort people, Comparator .comparing PersongetFirstName A static import allows us to express this more concisely, but it is debatable whether this improves overall readability import static java.util.Collections .sort import static java.util.Comparator .comparing ... sortpeople, comparing PersongetFirstName Comparators built this way can also be chained together. For example, after comparing people by their \ufb01rst name, if there are people with the same \ufb01rst name, the thenComparing method with also compare by": "input.pdf", "last name sortpeople, comparing PersongetFirstName .thenComparing PersongetLastName 1 - Note that Collections.sort... only works on collections that are subtypes of List . The Set and Collection APIs do not imply any ordering of the elements. Sorting maps You can sort the entries of a HashMap by value in a similar fashion. Note that a LinkedHashMap must be used as the target. The keys in an ordinary HashMap are unordered. MapString, Integer map new HashMap ... or any other Map class populate the map map map.entrySet .stream .sortedMap.Entry.String, Integer comparingByValue .collectCollectors. toMapk - k.getKey, v - v.getValue , k, v - k, LinkedHashMap new Section 73.3 Method References Method references allow prede\ufb01ned static or instance methods that adhere to a compatible functional interface to be passed as arguments instead of an anonymous lambda expression. Assume that we have a model class Person private final String name private final String surname public PersonString name, String surname this.name name this.surname surname public String getName return name public String getSurname return surname GoalKicker.com Java Notes for Professionals 429ListPerson people getSomePeople Instance method reference to an arbitrary instance people.stream.mapPersongetName The equivalent lambda people.stream.mapperson - person. getName In this example, a method reference to the": "input.pdf", "instance method getName of type Person , is being passed. Since its known to be of the collection type, the method on the instance known later will be invoked. Instance method reference to a speci\ufb01c instance people.forEachSystem.outprintln Since System.out is an instance of PrintStream , a method reference to this speci\ufb01c instance is being passed as an argument. The equivalent lambda people.forEachperson - System.out.printlnperson Static method reference Also for transforming streams we can apply references to static methods ListInteger numbers Arrays.asList1, 2, 3, 4, 5, 6 numbers. stream.mapStringvalueOf This example passes a reference to the static valueOf method on the String type. Therefore, the instance object in the collection is passed as an argument to valueOf. The equivalent lambda numbers. stream.mapnum - String.valueOfnum Reference to a constructor ListString strings Arrays.asList1, 2, 3 strings. stream.mapIntegernew Read Collect Elements of a Stream into a Collection to see how to collect elements to collection. The single String argument constructor of the Integer type is being used here, to construct an integer given the string provided as the argument. In this case, as long as the string represents a number, the stream will be mapped to Integers. The equivalent lambda strings. stream.maps -": "input.pdf", "new Integers Cheat-Sheet Method Reference Format Code Equivalent Lambda Static method TypeName methodargs - TypeName. methodargs GoalKicker.com Java Notes for Professionals 430Non-static method on instance instance methodargs - instance. methodargs Non-static method no instance TypeName methodinstance, args - instance. methodargs Constructor TypeName newargs - new TypeName args Array constructor TypeName newint size - new TypeName size instance can be any expression that evaluates to a reference to an instance, e.g. getInstance method , thismethod If TypeName is a non-static inner class, constructor reference is only valid within the scope of an outer class instance Section 73.4 Implementing multiple interfaces Sometimes you may want to have a lambda expression implementing more than one interface. This is mostly useful with marker interfaces such as java.io.Serializable since they dont add abstract methods. For example, you want to create a TreeSet with a custom Comparator and then serialize it and send it over the network. The trivial approach TreeSetLong ts new TreeSet x, y - Long.comparey, x doesnt work since the lambda for the comparator does not implement Serializable . You can \ufb01x this by using intersection types and explicitly specifying that this lambda needs to be serializable TreeSetLong ts new TreeSet Comparator": "input.pdf", "Long Serializable x, y - Long.comparey, x If youre frequently using intersection types for example, if youre using a framework such as Apache Spark where almost everything has to be serializable, you can create empty interfaces and use them in your code instead public interface SerializableComparator extends Comparator Long, Serializable public class CustomTreeSet public CustomTreeSet SerializableComparator comparator This way youre guaranteed that the passed comparator will be serializable. Section 73.5 Lambda - Listener Example Anonymous class listener Before Java 8, it s very common that an anonymous class is used to handle click event of a JButton, as shown in the following code. This example shows how to implement an anonymous listener within the scope of btn.addActionListener . JButton btn new JButtonMy Button btn.addActionListener new ActionListener Override public void actionPerformed ActionEvent e System.out.printlnButton was pressed GoalKicker.com Java Notes for Professionals 431Lambda listener Because the ActionListener interface de\ufb01nes only one method actionPerformed , it is a functional interface which means there s a place to use Lambda expressions to replace the boilerplate code. The above example can be re-written using Lambda expressions as follows JButton btn new JButtonMy Button btn.addActionListener e - System.out.printlnButton was pressed Section 73.6 Java Closures with": "input.pdf", "lambda expressions A lambda closure is created when a lambda expression references the variables of an enclosing scope global or local. The rules for doing this are the same as those for inline methods and anonymous classes. Local variables from an enclosing scope that are used within a lambda have to be final . With Java 8 the earliest version that supports lambdas, they dont need to be declared final in the outside context, but must be treated that way. For example int n 0 With Java 8 there is no need to explicit final Runnable r - Using lambda int i n do something This is legal as long as the value of the n variable is not changed. If you try to change the variable, inside or outside the lambda, you will get the following compilation error local variables referenced from a lambda expression must be \ufb01nal or e\ufb00ectively \ufb01nal . For example int n 0 Runnable r - Using lambda int i n do something n Will generate an error. If it is necessary to use a changing variable within a lambda, the normal approach is to declare a final copy of the variable and use": "input.pdf", "the copy. For example int n 0 final int k n With Java 8 there is no need to explicit final Runnable r - Using lambda int i k do something n Now will not generate an error r.run Will run with i 0 because k was 0 when the lambda was created Naturally, the body of the lambda does not see the changes to the original variable. Note that Java does not support true closures. A Java lambda cannot be created in a way that allows it to see GoalKicker.com Java Notes for Professionals 432changes in the environment in which it was instantiated. If you want to implement a closure that observes or makes changes to its environment, you should simulate it using a regular class. For example Does not compile ... public IntUnaryOperator createAccumulator int value 0 IntUnaryOperator accumulate x - value x return value return accumulate The above example will not compile for reasons discussed previously. We can work around the compilation error as follows Compiles, but is incorrect ... public class AccumulatorGenerator private int value 0 public IntUnaryOperator createAccumulator IntUnaryOperator accumulate x - value x return value return accumulate The problem is that this breaks": "input.pdf", "the design contract for the IntUnaryOperator interface which states that instances should be functional and stateless. If such a closure is passed to built-in functions that accept functional objects, it is liable to cause crashes or erroneous behavior. Closures that encapsulate mutable state should be implemented as regular classes. For example. Correct ... public class Accumulator private int value 0 public int accumulate int x value x return value Section 73.7 Lambdas and memory utilization Since Java lambdas are closures, they can capture the values of variables in the enclosing lexical scope. While not all lambdas capture anything -- simple lambdas like s - s.length capture nothing and are called stateless -- capturing lambdas require a temporary object to hold the captured variables. In this code snippet, the lambda - j is a capturing lambda, and may cause an object to be allocated when it is evaluated public static void mainString args throws Exception for int i 0 i 1000000000 i int j i doSomethingWithLambda - j Although it might not be immediately obvious since the new keyword doesnt appear anywhere in the snippet, this code is liable to create 1,000,000,000 separate objects to represent the instances of the": "input.pdf", "- j lambda expression. However, it should also be noted that future versions of Java1 may be able to optimize this so that at runtime the lambda instances were reused, or were represented in some other way. GoalKicker.com Java Notes for Professionals 4331 - For instance, Java 9 introduces an optional link phase to the Java build sequence which will provide the opportunity for doing global optimizations like this. Section 73.8 Using lambda expression with your own functional interface Lambdas are meant to provide inline implementation code for single method interfaces and the ability to pass them around as we have been doing with normal variables. We call them Functional Interface. For example, writing a Runnable in anonymous class and starting a Thread looks like Old way new Thread new Runnable public void run System.out.printlnrun logic... .start lambdas, from Java 8 new Thread - System.out.printlnrun logic... .start Now, in line with above, lets say you have some custom interface interface TwoArgInterface int operate int a, int b How do you use lambda to give implementation of this interface in your code? Same as Runnable example shown above. See the driver program below public class CustomLambda public static void mainString": "input.pdf", "args TwoArgInterface plusOperation a, b - a b TwoArgInterface divideOperation a,b- if b0 throw new IllegalArgumentException Divisor can not be 0 return ab System.out.printlnPlus operation of 3 and 5 is plusOperation. operate3, 5 System.out.printlnDivide operation 50 by 25 is divideOperation. operate50, 25 Section 73.9 Traditional style to Lambda style Traditional way interface MathOperation boolean unaryOperation int num GoalKicker.com Java Notes for Professionals 434public class LambdaTry public static void mainString args MathOperation isEven new MathOperation Override public boolean unaryOperation int num return num2 0 System.out.printlnisEven.unaryOperation 25 System.out.printlnisEven.unaryOperation 20 Lambda style Remove class name and functional interface body.1. public class LambdaTry public static void mainString args MathOperation isEven int num - return num2 0 System.out.printlnisEven.unaryOperation 25 System.out.printlnisEven.unaryOperation 20 Optional type declaration2. MathOperation isEven num - return num2 0 Optional parenthesis around parameter, if it is single parameter3. MathOperation isEven num - return num2 0 Optional curly braces, if there is only one line in function body4. Optional return keyword, if there is only one line in function body5. MathOperation isEven num - num2 0 Section 73.10 return only returns from the lambda, not the outer method The return method only returns from the lambda, not the outer method. Beware that this": "input.pdf", "is di\ufb00erent from Scala and Kotlin! void threeTimes IntConsumer r for int i 0 i 3 i r.accepti GoalKicker.com Java Notes for Professionals 435void demo threeTimes i - System.out.printlni return Return from lambda to threeTimes only! This can lead to unexpected behavior when attempting to write own language constructs, as in builtin constructs such as for loops return behaves di\ufb00erently void demo2 for int i 0 i 3 i System.out.printlni return Return from demo2 entirely In Scala and Kotlin, demo and demo2 would both only print 0. But this is not more consistent. The Java approach is consistent with refactoring and the use of classes - the return in the code at the top, and the code below behaves the same void demo3 threeTimes new MyIntConsumer class MyIntConsumer implements IntConsumer public void acceptint i System.out.printlni return Therefore, the Java return is more consistent with class methods and refactoring, but less with the for and while builtins, these remain special. Because of this, the following two are equivalent in Java IntStream. range1, 4 .mapx - x x .forEachSystem.outprintln IntStream. range1, 4 .mapx - return x x .forEachSystem.outprintln Furthermore, the use of try-with-resources is safe in Java class Resource implements AutoCloseable": "input.pdf", "public void close System.out.printlnclose void executeAround Consumer Resource f try Resource r new Resource System.out.printbefore f.acceptr System.out.printafter void demo4 GoalKicker.com Java Notes for Professionals 436 executeAround r - System.out.printaccept return Does not return from demo4, but frees the resource. will print before accept after close . In the Scala and Kotlin semantics, the try-with-resources would not be closed, but it would print before accept only. Section 73.11 Lambdas and Execute-around Pattern There are several good examples of using lambdas as a FunctionalInterface in simple scenarios. A fairly common use case that can be improved by lambdas is what is called the Execute-Around pattern. In this pattern, you have a set of standard setupteardown code that is needed for multiple scenarios surrounding use case speci\ufb01c code. A few common example of this are \ufb01le io, database io, trycatch blocks. interface DataProcessor void process Connection connection throws SQLException public void doProcessing DataProcessor processor throws SQLException try Connection connection DBUtil. getDatabaseConnection processor. processconnection connection. commit Then to call this method with a lambda it might look like public static void updateMyDAO MyVO vo throws DatabaseException doProcessing Connection conn - MyDAO.updateconn, ObjectMapper. mapvo This is not limited to IO operations. It can apply": "input.pdf", "to any scenario where similar setuptear down tasks are applicable with minor variations. The main bene\ufb01t of this Pattern is code re-use and enforcing DRY Dont Repeat Yourself. Section 73.12 Using lambda expressions predicates to get a certain values from a list Starting with Java 8, you can use lambda expressions predicates. Example Use a lambda expressions a predicate to get a certain value from a list. In this example every person will be printed out with the fact if they are 18 and older or not. Person Class public class Person private String name private int age public PersonString name, int age this.name name this.age age public int getAge return age public String getName return name GoalKicker.com Java Notes for Professionals 437 The built-in interface Predicate from the java.util.function.Predicate packages is a functional interface with a boolean testT t method. Example Usage import java.util.ArrayList import java.util.List import java.util.function.Predicate public class LambdaExample public static void mainString args List Person personList new ArrayList Person personList. addnew PersonJeroen , 20 personList. addnew PersonJack, 5 personList. addnew PersonLisa, 19 print personList, p - p.getAge 18 private static void printListPerson personList, Predicate Person checker for Person person personList if checker. testperson System.out.printperson matches": "input.pdf", "your expression. else System.out.printlnperson doesnt match your expression. The printpersonList, p - p.getAge 18 method takes a lambda expression because the Predicate is used a parameter where you can de\ufb01ne the expression that is needed. The checkers test method checks if this expression is correct or not checker. testperson. You can easily change this to something else, for example to printpersonList, p - p.getName.startsWith J. This will check if the persons name starts with a J. GoalKicker.com Java Notes for Professionals 438Chapter 74 Basic Control Structures Section 74.1 Switch statement The switch statement is Javas multi-way branch statement. It is used to take the place of long if-else if-else chains, and make them more readable. However, unlike if statements, one may not use inequalities each value must be concretely de\ufb01ned. There are three critical components to the switch statement case This is the value that is evaluated for equivalence with the argument to the switch statement. default This is an optional, catch-all expression, should none of the case statements evaluate to true . Abrupt completion of the case statement usually break This is required to prevent the undesired evaluation of further case statements. With the exception of continue ,": "input.pdf", "it is possible to use any statement which would cause the abrupt completion of a statement . This includes break return throw In the example below, a typical switch statement is written with four possible cases, including default . Scanner scan new Scanner System.in int i scan.nextInt switch i case 0 System.out.printlni is zero break case 1 System.out.printlni is one break case 2 System.out.printlni is two break default System.out.printlni is less than zero or greater than two By omitting break or any statement which would an abrupt completion, we can leverage what are known as fall- through cases, which evaluate against several values. This can be used to create ranges for a value to be successful against, but is still not as \ufb02exible as inequalities. Scanner scan new Scanner System.in int foo scan.nextInt switchfoo case 1 System.out.printlnIm equal or greater than one case 2 case 3 System.out.printlnIm one, two, or three break default System.out.printlnIm not either one, two, or three GoalKicker.com Java Notes for Professionals 439In case of foo 1 the output will be Im equal or greater than one Im one, two, or three In case of foo 3 the output will be Im one, two, or three": "input.pdf", "Version Java SE 5 The switch statement can also be used with enum s. enum Option BLUEPILL, REDPILL public void takeOne Option option switchoption case BLUEPILL System.out.printlnStory ends, wake up, believe whatever you want. break case REDPILL System.out.printlnI show you how deep the rabbit hole goes. break Version Java SE 7 The switch statement can also be used with String s. public void rhymingGame String phrase switch phrase case apples and pears System.out.printlnStairs break case lorry System.out.printlntruck break default System.out.printlnDont know any more Section 74.2 do...while Loop The do...while loop di\ufb00ers from other loops in that it is guaranteed to execute at least once . It is also called the post-test loop structure because the conditional statement is performed after the main loop body. int i 0 do i System.out.printlni while i 100 Condition gets checked AFTER the content of the loop executes. GoalKicker.com Java Notes for Professionals 440In this example, the loop will run until the number 100 is printed even though the condition is i 100 and not i 100, because the loop condition is evaluated after the loop executes. With the guarantee of at least one execution, it is possible to declare variables outside of the": "input.pdf", "loop and initialize them inside. String theWord Scanner scan new Scanner System.in do theWord scan.nextLine while !theWord. equalsBird System.out.printlntheWord In this context, theWord is de\ufb01ned outside of the loop, but since its guaranteed to have a value based on its natural \ufb02ow, theWord will be initialized. Section 74.3 For Each Version Java SE 5 With Java 5 and up, one can use for-each loops, also known as enhanced for-loops List strings new ArrayList strings. addThis strings. addis strings. adda for-each loop String string strings System.out.printlnstring For each loops can be used to iterate over Arrays and implementations of the Iterable interface, the later includes Collections classes, such as List or Set. The loop variable can be of any type that is assignable from the source type. The loop variable for a enhanced for loop for Iterable T or T can be of type S, if T extends S both T and S are primitive types and assignable without a cast S is a primitive type and T can be converted to a type assignable to S after unboxing conversion. T is a primitive type and can be converted to S by autoboxing conversion. Examples T elements ... for S": "input.pdf", "s elements T S Compiles int long yes long int no Iterable Byte long yes Iterable String CharSequence yes Iterable CharSequence String no int Long no GoalKicker.com Java Notes for Professionals 441int Integer yes Section 74.4 Continue Statement in Java The continue statement is used to skip the remaining steps in the current iteration and start with the next loop iteration. The control goes from the continue statement to the step value increment or decrement, if any. String programmers Adrian , Paul, John, Harry john is not printed out for String name programmers if name.equalsJohn continue System.out.printlnname The continue statement can also make the control of the program shift to the step value if any of a named loop Outer The name of the outermost loop is kept here as Outer forint i 0 i 5 forint j 0 j 5 j continue Outer Section 74.5 If Else If Else Control if i 2 System.out.printlni is less than 2 else if i 2 System.out.printlni is more than 2 else System.out.printlni is not less than 2, and not more than 2 The if block will only run when i is 1 or less. The else if condition is checked only": "input.pdf", "if all the conditions before it in previous else if constructs, and the parent if constructs have been tested to false . In this example, the else if condition will only be checked if i is greater than or equal to 2. If its result is true , its block is run, and any else if and else constructs after it will be skipped. If none of the if and else if conditions have been tested to true , the else block at the end will be run. Section 74.6 For Loops for int i 0 i 100 i System.out.printlni The three components of the for loop separated by are variable declarationinitialization here int i 0, the condition here i 100, and the increment statement here i. The variable declaration is done once as if placed just inside the on the \ufb01rst run. Then the condition is checked, if it is true the body of the loop will execute, if it is GoalKicker.com Java Notes for Professionals 442false the loop will stop. Assuming the loop continues, the body will execute and \ufb01nally when the is reached the increment statement will execute just before the condition is checked again. The": "input.pdf", "curly braces are optional you can one line with a semicolon if the loop contains just one statement. But, its always recommended to use braces to avoid misunderstandings and bugs. The for loop components are optional. If your business logic contains one of these parts, you can omit the corresponding component from your for loop. int i obj.getLastestValue i value is fetched from a method for i 100 i here initialization is not done System.out.printlni The for function -body structure is equal to a while true loop. Nested For Loops Any looping statement having another loop statement inside called nested loop. The same way for looping having more inner loop is called nested for loop. for Outer Loop Statements for Inner Loop Statements Outer Loop Statements Nested for loop can be demonstrated to print triangle shaped numbers. forint i9i0i--Outer Loop System.out.println forint kik0k--Inner Loop -1 System.out.print forint jij9jInner Loop -2 System.out.print j Section 74.7 Ternary Operator Sometimes you have to check for a condition and set the value of a variable. For ex. String name if A B name Billy else name Jimmy This can be easily written in one line as GoalKicker.com Java Notes for Professionals 443String name": "input.pdf", "A B ? Billy Jimmy The value of the variable is set to the value immediately after the condition, if the condition is true. If the condition is false, the second value will be given to the variable. Section 74.8 Try ... Catch ... Finally The try ... catch ... ... control structure is used for handling Exceptions. String ageinput abc try int age Integer.parseInt ageinput if age 18 System.out.printlnYou can vote! else System.out.printlnSorry, you cant vote yet. catch NumberFormatException ex System.err.printlnInvalid input. ageinput is not a valid integer. This would print Invalid input. abc is not a valid integer. A finally clause can be added after the catch . The finally clause would always be executed, regardless of whether an exception was thrown. try ... catch ... ... finally ... String ageinput abc try int age Integer.parseInt ageinput if age 18 System.out.printlnYou can vote! else System.out.printlnSorry, you cant vote yet. catch NumberFormatException ex System.err.printlnInvalid input. ageinput is not a valid integer. finally System.out.printlnThis code will always be run, even if an exception is thrown This would print Invalid input. abc is not a valid integer. This code will always be run, even if an exception is thrown Section": "input.pdf", "74.9 Break The break statement ends a loop like for, while or the evaluation of a switch statement. Loop GoalKicker.com Java Notes for Professionals 444whiletrue ifsomeCondition 5 break The loop in the example would run forever. But when someCondition equals 5 at some point of execution, then the loop ends. If multiple loops are cascaded, only the most inner loop ends using break . Section 74.10 While Loops int i 0 while i 100 condition gets checked BEFORE the loop body executes System.out.printlni i A while loop runs as long as the condition inside the parentheses is true . This is also called the pre-test loop structure because the conditional statement must be met before the main loop body is performed every time. The curly braces are optional if the loop contains just one statement, but some coding style conventions prefers having the braces regardless. Section 74.11 If Else int i 2 if i 2 System.out.printlni is less than 2 else System.out.printlni is greater than 2 An if statement executes code conditionally depending on the result of the condition in parentheses. When condition in parentheses is true it will enter to the block of if statement which is de\ufb01ned": "input.pdf", "by curly braces like and . opening bracket till the closing bracket is the scope of the if statement. The else block is optional and can be omitted. It runs if the if statement is false and does not run if the if statement is true Because in that case if statement executes. See also Ternary If Section 74.12 Nested break continue Its possible to break continue to an outer loop by using label statements outerloop for... innerloop for... ifcondition1 break outerloop ifcondition2 continue innerloop equivalent to continue GoalKicker.com Java Notes for Professionals 445 There is no other use for labels in Java. GoalKicker.com Java Notes for Professionals 446Chapter 75 BueredWriter Section 75.1 Write a line of text to File This code writes the string to a \ufb01le. It is important to close the writer, so this is done in a finally block. public void writeLineToFile String str throws IOException File file new Filefile.txt BufferedWriter bw null try bw new BufferedWriter new FileWriter file bw. writestr finally if bw ! null bw. close Also note that writeString s does not place newline character after string has been written. To put it use newLine method. Version Java SE 7 Java": "input.pdf", "7 adds the java.nio.file package, and try-with-resources public void writeLineToFile String str throws IOException Path path Paths.getfile.txt try BufferedWriter bw Files.newBufferedWriter path bw. writestr GoalKicker.com Java Notes for Professionals 447Chapter 76 New File IO Section 76.1 Creating paths The Path class is used to programmaticaly represent a path in the \ufb01le system and can therefore point to \ufb01les as well as directories, even to non-existent ones A path can be obtained using the helper class Paths Path p1 Paths.getvarwww Path p2 Paths.getURI.createfilehometestuserFile.txt Path p3 Paths.getCUsersDentArDocuments HHGTDG.odt Path p4 Paths.gethome, arthur , files, diary.tex Section 76.2 Manipulating paths Joining Two Paths Paths can be joined using the resolve method. The path passed has to be a partial path, which is a path that doesnt include the root element. Path p5 Paths.gethome Path p6 Paths.getarthurfiles Path joined p5.resolvep6 Path otherJoined p5.resolvefordfiles joined.toString homearthurfiles otherJoined. toString homefordfiles Normalizing a path Paths may contain the elements . which points to the directory youre currently in and ..which points to the parent directory. When used in a path, . can be removed at any time without changing the paths destination, and .. can be removed together with the preceding element. With the Paths API,": "input.pdf", "this is done using the .normalize method Path p7 Paths.gethome.arthur..fordfiles Path p8 Paths.getCUsers...Program Files p7.normalize .toString homefordfiles p8.normalize .toString CProgram Files Section 76.3 Retrieving information about a path Information about a path can be get using the methods of a Path object toString returns the string representation of the path Path p1 Paths.getvarwww p1.toString returns varwww getFileName returns the \ufb01le name or, more speci\ufb01cally, the last element of the path Path p1 Paths.getvarwww p1.getFileName returns www GoalKicker.com Java Notes for Professionals 448Path p3 Paths.getCUsersDentArDocuments HHGTDG.odt p3.getFileName returns HHGTDG.odt getNameCount returns the number of elements that form the path Path p1 Paths.getvarwww p1.getNameCount returns 2 getNameint index returns the element at the given index Path p1 Paths.getvarwww p1.getName0 returns var, p1.getName1 returns www getParent returns the path of the parent directory Path p1 Paths.getvarwww p1.getParent.toString returns var getRoot returns the root of the path Path p1 Paths.getvarwww p1.getRoot.toString returns Path p3 Paths.getCUsersDentArDocuments HHGTDG.odt p3.getRoot.toString returns C Section 76.4 Retrieving information using the \ufb01lesystem To interact with the \ufb01lesystem you use the methods of the class Files . Checking existence To check the existence of the \ufb01le or directory a path points to, you use the following methods Files.existsPath path and": "input.pdf", "Files.notExists Path path !Files.existspath does not neccesarily have to be equal to Files.notExists path, because there are three possible scenarios A \ufb01les or directorys existence is veri\ufb01ed exists returns true and notExists returns false in this case A \ufb01les or directorys nonexistence is ver\ufb01ed exists returns false and notExists returns true Neither the existence nor the nonexistence of a \ufb01le or a directory can be veri\ufb01ed for example due to access restrictions Both exists and nonExists return false. Checking whether a path points to a \ufb01le or a directory This is done using Files.isDirectory Path path and Files.isRegularFile Path path Path p1 Paths.getvarwww Path p2 Paths.gethometestuserFile.txt Files.isDirectory p1 true Files.isRegularFile p1 false Files.isDirectory p2 false GoalKicker.com Java Notes for Professionals 449Files.isRegularFile p2 true Getting properties This can be done using the following methods Files.isReadable Path path Files.isWritable Path path Files.isExecutable Path path Files.isHidden Path path Files.isSymbolicLink Path path Getting MIME type Files.probeContentType Path path This tries to get the MIME type of a \ufb01le. It returns a MIME type String, like this textplain for text \ufb01les texthtml for HTML pages application pdf for PDF \ufb01les imagepng for PNG \ufb01les Section 76.5 Reading \ufb01les Files can be read byte- and": "input.pdf", "line-wise using the Files class. Path p2 Paths.getURI.createfilehometestuserFile.txt byte content Files.readAllBytes p2 ListString linesOfContent Files.readAllLines p2 Files.readAllLines optionally takes a charset as parameter default is StandardCharsets. UTF8 ListString linesOfContent Files.readAllLines p2, StandardCharsets. ISO88591 Section 76.6 Writing \ufb01les Files can be written bite- and line-wise using the Files class Path p2 Paths.gethometestuserFile.txt ListString lines Arrays.asList new StringFirst line , Second line , Third line Files.writep2, lines Files.writePath path, byte bytes Existing \ufb01les wile be overridden, non-existing \ufb01les will be created. GoalKicker.com Java Notes for Professionals 450Chapter 77 File IO Java IO Input and Output is used to process the input and produce the output. Java uses the concept of stream to make IO operation fast. The java.io package contains all the classes required for input and output operations. Handling \ufb01les is also done in java by Java IO API. Section 77.1 Migrating from java.io.File to Java 7 NIO java.nio.\ufb01le.Path These examples assume that you already know what Java 7s NIO is in general, and you are used to writing code using java.io.File . Use these examples as a means to quickly \ufb01nd more NIO-centric documentation for migrating. There is much more to Java 7s NIO such as memory-mapped \ufb01les or": "input.pdf", "opening a ZIP or JAR \ufb01le using FileSystem . These examples will only cover a limited number of basic use cases. As a basic rule, if you are used to perform a \ufb01le system readwrite operation using a java.io.File instance method, you will \ufb01nd it as a static method within java.nio.file.Files . Point to a path - IO File file new Fileio.txt - NIO Path path Paths.getnio.txt Paths relative to another path Forward slashes can be used in place of backslashes even on a Windows operating system - IO File folder new FileC File fileInFolder new Filefolder, io.txt - NIO Path directory Paths.getC Path pathInDirectory directory. resolvenio.txt Converting File fromto Path for use with libraries - IO to NIO Path pathFromFile new Fileio.txt .toPath - NIO to IO File fileFromPath Paths.getnio.txt .toFile Check if the \ufb01le exists and delete it if it does - IO if file.exists boolean deleted file.delete if !deleted throw new IOException Unable to delete file - NIO Files.deleteIfExists path Write to a \ufb01le via an OutputStream There are several ways to write and read from a \ufb01le using NIO for di\ufb00erent performance and memory constraints, readability and use cases, such as FileChannel , Files.writePath path,": "input.pdf", "byte bytes, OpenOption... GoalKicker.com Java Notes for Professionals 451options... In this example, only OutputStream is covered, but you are strongly encouraged to learn about memory- mapped \ufb01les and the various static methods available in java.nio.file.Files . ListString lines Arrays.asList String.valueOfCalendar .getInstance .getTimeInMillis , line one , line two - IO if file.exists Note Not atomic throw new IOException File already exists try FileOutputStream outputStream new FileOutputStream file for String line lines outputStream. writeline System.lineSeparator .getBytes StandardCharsets. UTF8 - NIO try OutputStream outputStream Files.newOutputStream path, StandardOpenOption. CREATENEW for String line lines outputStream. writeline System.lineSeparator .getBytes StandardCharsets. UTF8 Iterating on each \ufb01le within a folder - IO for File selectedFile folder. listFiles Note Depending on the number of files in the directory folder.listFiles may take a long time to return System.out.printlnselectedFile. isDirectory ? d f selectedFile. getAbsolutePath - NIO Files.walkFileTree directory, EnumSet. noneOfFileVisitOption. class, 1, new SimpleFileVisitor Path Override public FileVisitResult preVisitDirectory Path selectedPath, BasicFileAttributes attrs throws IOException System.out.printlnd selectedPath. toAbsolutePath return FileVisitResult. CONTINUE Override public FileVisitResult visitFile Path selectedPath, BasicFileAttributes attrs throws IOException System.out.printlnf selectedPath. toAbsolutePath return FileVisitResult. CONTINUE Recursive folder iteration - IO recurseFolder folder - NIO Note Symbolic links are NOT followed unless explicitly passed as an argument": "input.pdf", "to Files.walkFileTree Files.walkFileTree directory, new SimpleFileVisitor Path Override GoalKicker.com Java Notes for Professionals 452 public FileVisitResult preVisitDirectory Path dir, BasicFileAttributes attrs throws IOException System.out.printlnd selectedPath. toAbsolutePath return FileVisitResult. CONTINUE Override public FileVisitResult visitFile Path selectedPath, BasicFileAttributes attrs throws IOException System.out.printlnf selectedPath. toAbsolutePath return FileVisitResult. CONTINUE private static void recurseFolder File folder for File selectedFile folder. listFiles System.out.printlnselectedFile. isDirectory ? d f selectedFile. getAbsolutePath if selectedFile. isDirectory Note Symbolic links are followed recurseFolder selectedFile Section 77.2 Reading an image from a \ufb01le import java.awt.Image import javax.imageio.ImageIO ... try Image img ImageIO. readnew FileDesktopcat.png catch IOException e e.printStackTrace Section 77.3 File ReadWrite Using FileInputStreamFileOutputStream Write to a \ufb01le test.txt String filepath Ctest.txt FileOutputStream fos null try fos new FileOutputStream filepath byte buffer This will be written in test.txt .getBytes fos. writebuffer, 0, buffer. length fos. close catch FileNotFoundException e e. printStackTrace catch IOException e e. printStackTrace finally iffos ! null fos. close GoalKicker.com Java Notes for Professionals 453Read from \ufb01le test.txt String filepath Ctest.txt FileInputStream fis null try fis new FileInputStream filepath int length int new Filefilepath .length byte buffer new bytelength fis.readbuffer, 0, length catch FileNotFoundException e e.printStackTrace catch IOException e e.printStackTrace finally iffis ! null fis. close Note, that": "input.pdf", "since Java 1.7 the try-with-resources statement was introduced what made implementation of readingwriting operation much simpler Write to a \ufb01le test.txt String filepath Ctest.txt try FileOutputStream fos new FileOutputStream filepath byte buffer This will be written in test.txt .getBytes fos. writebuffer, 0, buffer. length catch FileNotFoundException e e.printStackTrace catch IOException e e.printStackTrace Read from \ufb01le test.txt String filepath Ctest.txt try FileInputStream fis new FileInputStream filepath int length int new Filefilepath .length byte buffer new bytelength fis. readbuffer, 0, length catch FileNotFoundException e e.printStackTrace catch IOException e e.printStackTrace Section 77.4 Reading all bytes to a byte Java 7 introduced the very useful Files class Version Java SE 7 import java.nio.file.Files import java.nio.file.Paths import java.nio.file.Path Path path Paths.getpathtofile try byte data Files.readAllBytes path GoalKicker.com Java Notes for Professionals 454 catchIOException e e.printStackTrace Section 77.5 Copying a \ufb01le using Channel We can use Channel to copy \ufb01le content faster. To do so, we can use transferTo method of FileChannel . import java.io.File import java.io.FileInputStream import java.io.FileOutputStream import java.io.IOException import java.nio.channels.FileChannel public class FileCopier public static void mainString args File sourceFile new Filehello.txt File sinkFile new Filehello2.txt copy sourceFile, sinkFile public static void copyFile sourceFile, File destFile if !sourceFile. exists !destFile. exists System.out.printlnSource": "input.pdf", "or destination file doesnt exist return try FileChannel srcChannel new FileInputStream sourceFile .getChannel FileChannel sinkChanel new FileOutputStream destFile .getChannel srcChannel. transferTo 0, srcChannel. size, sinkChanel catch IOException e e. printStackTrace Section 77.6 Writing a byte to a \ufb01le Version Java SE 7 byte bytes 0x48, 0x65, 0x6c, 0x6c, 0x6f tryFileOutputStream stream new FileOutputStream Hello world.txt stream. writebytes catch IOException ioe Handle IO Exception ioe. printStackTrace Version Java SE 7 byte bytes 0x48, 0x65, 0x6c, 0x6c, 0x6f FileOutputStream stream null try stream new FileOutputStream Hello world.txt stream. writebytes catch IOException ioe Handle IO Exception GoalKicker.com Java Notes for Professionals 455 ioe. printStackTrace finally if stream ! null try stream. close catch IOException ignored Most java.io \ufb01le APIs accept both String s and File s as arguments, so you could as well use File file new FileHello world.txt FileOutputStream stream new FileOutputStream file Section 77.7 Stream vs WriterReader API Streams provide the most direct access to the binary content, so any InputStream OutputStream implementations always operate on ints and byte s. Read a single byte from the stream int b inputStream. read if b 0 A negative value represents the end of the stream, normal values are in the range 0": "input.pdf", "- 255 Write the byte to another stream outputStream. writeb Read a chunk byte data new byte1024 int nBytesRead inputStream. readdata if nBytesRead 0 A negative value represents end of stream Write the chunk to another stream outputStream. writedata, 0, nBytesRead There are some exceptions, probably most notably the PrintStream which adds the ability to print representations of various data values conveniently. This allows to use System.out both as a binary InputStream and as a textual output using methods such as System.out.println. Also, some stream implementations work as an interface to higher-level contents such as Java objects see Serialization or native types, e.g. DataOutputStream DataInputStream . With the Writer and Reader classes, Java also provides an API for explicit character streams. Although most applications will base these implementations on streams, the character stream API does not expose any methods for binary content. This example uses the platforms default charset, see below for a better implementation. Writer writer new OutputStreamWriter System.out writer.writeHello world! Reader reader new InputStreamReader System.in char singleCharacter reader. read Whenever it is necessary to encode characters into binary data e.g. when using the InputStreamWriter OutputStreamWriter classes, you should specify a charset if you do not want to": "input.pdf", "depend on the platforms default GoalKicker.com Java Notes for Professionals 456charset. When in doubt, use a Unicode-compatible encoding, e.g. UTF-8 which is supported on all Java platforms. Therefore, you should probably stay away from classes like FileWriter and FileReader as those always use the default platform charset. A better way to access \ufb01les using character streams is this Charset myCharset StandardCharsets. UTF8 Writer writer new OutputStreamWriter new FileOutputStream test.txt , myCharset writer.write\u00c4 writer.flush writer.close Reader reader new InputStreamReader new FileInputStream test.txt , myCharset char someUnicodeCharacter reader. read reader.close One of the most commonly used Reader s is BufferedReader which provides a method to read whole lines of text from another reader and is presumably the simplest way to read a character stream line by line Read from baseReader, one line at a time BufferedReader reader new BufferedReader baseReader String line whileline reader. readLine ! null Remember System.out is a stream, not a writer! System.out.printlnline Section 77.8 Reading a \ufb01le with a Scanner Reading a \ufb01le line by line public class Main public static void mainString args try Scanner scanner new Scanner new Fileexample.txt whilescanner. hasNextLine String line scanner. nextLine do stuff catch FileNotFoundException e e. printStackTrace word by word": "input.pdf", "public class Main public static void mainString args try Scanner scanner new Scanner new Fileexample.txt whilescanner. hasNext String line scanner. next do stuff GoalKicker.com Java Notes for Professionals 457 catch FileNotFoundException e e. printStackTrace and you can also change the delimeter by using scanner.useDelimeter method Section 77.9 Copying a \ufb01le using InputStream and OutputStream We can directly copy data from a source to a data sink using a loop. In this example, we are reading data from an InputStream and at the same time, writing to an OutputStream. Once we are done reading and writing, we have to close the resource. public void copyInputStream source, OutputStream destination throws IOException try int c while c source. read ! -1 destination. writec finally if source ! null source. close if destination ! null destination. close Section 77.10 Reading from a binary \ufb01le You can read an a binary \ufb01le using this piece of code in all recent versions of Java Version Java SE 1.4 File file new Filepathtothefile byte data new byteint file.length DataInputStream stream new DataInputStream new FileInputStream file stream.readFully data stream.close If you are using Java 7 or later, there is a simpler way using the nio API Version": "input.pdf", "Java SE 7 Path path Paths.getpathtothefile byte data Files.readAllBytes path Section 77.11 Reading a \ufb01le using Channel and Buer Channel uses a Buffer to readwrite data. A bu\ufb00er is a \ufb01xed sized container where we can write a block of data at once. Channel is a quite faster than stream-based IO. To read data from a \ufb01le using Channel we need to have the following steps- We need an instance of FileInputStream . FileInputStream has a method named getChannel which 1. returns a Channel. GoalKicker.com Java Notes for Professionals 458Call the getChannel method of FileInputStream and acquire Channel. 2. Create a ByteBu\ufb00er. ByteBu\ufb00er is a \ufb01xed size container of bytes.3. Channel has a read method and we have to provide a ByteBu\ufb00er as an argument to this read method.4. ByteBu\ufb00er has two modes - read-only mood and write-only mood. We can change the mode using flip method call. Bu\ufb00er has a position, limit, and capacity. Once a bu\ufb00er is created with a \ufb01xed size, its limit and capacity are the same as the size and the position starts from zero. While a bu\ufb00er is written with data, its position gradually increases. Changing mode means, changing the position. To read": "input.pdf", "data from the beginning of a bu\ufb00er, we have to set the position to zero. \ufb02ip method change the position When we call the read method of the Channel , it \ufb01lls up the bu\ufb00er using data. 5. If we need to read the data from the ByteBuffer , we need to \ufb02ip the bu\ufb00er to change its mode to write-only 6. to read-only mode and then keep reading data from the bu\ufb00er. When there is no longer data to read, the read method of channel returns 0 or -1. 7. import java.io.File import java.io.FileInputStream import java.io.IOException import java.nio.ByteBuffer import java.nio.channels.FileChannel public class FileChannelRead public static void mainString args File inputFile new Filehello.txt if !inputFile. exists System.out.printlnThe input file doesnt exit. return try FileInputStream fis new FileInputStream inputFile FileChannel fileChannel fis.getChannel ByteBuffer buffer ByteBuffer. allocate 1024 while fileChannel. readbuffer 0 buffer. flip while buffer.hasRemaining byte b buffer. get System.out.printchar b buffer. clear fileChannel. close catch IOException e e.printStackTrace Section 77.12 Adding Directories To make a new directory from a File instance you would need to use one of two methods mkdirs or mkdir. mkdir - Creates the directory named by this abstract pathname. source mkdirs - Creates the directory": "input.pdf", "named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary GoalKicker.com Java Notes for Professionals 459parent directories. source Note createNewFile will not create a new directory only a \ufb01le. File singleDir new FileCUsersSomeUserDesktopA New Folder File multiDir new FileCUsersSomeUserDesktopA New Folder 2Another Folder assume that neither A New Folder or A New Folder 2 exist singleDir. createNewFile will make a new file called A New Folder.file singleDir. mkdir will make the directory singleDir. mkdirs will make the directory multiDir. createNewFile will throw a IOException multiDir. mkdir will not work multiDir. mkdirs will make the directory Section 77.13 Blocking or redirecting standard output error Sometimes a poorly designed 3rd-party library will write unwanted diagnostics to System.out or System.err streams. The recommended solutions to this would be to either \ufb01nd a better library or in the case of open source \ufb01x the problem and contribute a patch to the developers. If the above solutions are not feasible, then you should consider redirecting the streams. Redirection on the command line On a UNIX, Linux or MacOSX system can be done from the shell using": "input.pdf", "redirection. For example java -jar app. jar arg1 arg2 devnull 21 java -jar app. jar arg1 arg2 out.log 2 error.log The \ufb01rst one redirects standard output and standard error to devnull, which throws away anything written to those streams. The second of redirects standard output to out.log and standard error to error.log. For more information on redirection, refer to the documentation of the command shell you are using. Similar advice applies to Windows. Alternatively, you could implement the redirection in a wrapper script or batch \ufb01le that launches the Java application. Redirection within a Java application It is also possible to redired the streams within a Java application using System.setOut and System.setErr. For example, the following snippet redirects standard output and standard error to 2 log \ufb01les System.setOutnew PrintStream new FileOutputStream new Fileout.log System.setErrnew PrintStream new FileOutputStream new Fileerr.log If you want to throw away the output entirely, you can create an output stream that writes to an invalid \ufb01le descriptor. This is functionally equivalent to writing to devnull on UNIX. System.setOutnew PrintStream new FileOutputStream new FileDescriptor System.setErrnew PrintStream new FileOutputStream new FileDescriptor GoalKicker.com Java Notes for Professionals 460Caution be careful how you use setOut and setErr The redirection": "input.pdf", "will a\ufb00ect the entire JVM.1. By doing this, you are taking away the users ability to redirect the streams from the command line.2. Section 77.14 Reading a whole \ufb01le at once File f new Filepath String content new Scanner f.useDelimiter Z.next Z is the EOF End of File Symbol. When set as delimiter the Scanner will read the \ufb01ll until the EOF Flag is reached. Section 77.15 Locking A \ufb01le can be locked using the FileChannel API that can be acquired from Input Output streams and readers Example with streams Open a file stream FileInputStream ios new FileInputStream filename get underlying channel FileChannel channel ios.getChannel try to lock the file. true means whether the lock is shared or not i.e. multiple processes can acquire a shared lock for reading only Using false with readable channel only will generate an exception. You should use a writable channel taken from FileOutputStream when using false. tryLock will always return immediately FileLock lock channel. tryLock0, Long.MAXVALUE , true if lock null System.out.printlnUnable to acquire lock else System.out.printlnLock acquired successfully you can also use blocking call which will block until a lock is acquired. channel. lock Once you have completed desired operations of file.": "input.pdf", "release the lock if lock ! null lock. release close the file stream afterwards Example with reader RandomAccessFile randomAccessFile new RandomAccessFile filename, rw FileChannel channel randomAccessFile. getChannel repeat the same steps as above but now you can use shared as true or false as the channel is in read write mode Section 77.16 Reading a \ufb01le using BueredInputStream Reading \ufb01le using a BufferedInputStream generally faster than FileInputStream because it maintains an internal GoalKicker.com Java Notes for Professionals 461bu\ufb00er to store bytes read from the underlying input stream. import java.io.BufferedInputStream import java.io.FileInputStream import java.io.IOException public class FileReadingDemo public static void mainString args String source hello.txt try BufferedInputStream bis new BufferedInputStream new FileInputStream source byte data while data byte bis.read ! -1 System.out.printlnchar data catch IOException e e. printStackTrace Section 77.17 Iterate over a directory printing subdirectories in it public void iterate final String dirPath throws IOException final DirectoryStream Path paths Files.newDirectoryStream Paths.getdirPath for final Path path paths if Files.isDirectory path System.out.printlnpath.getFileName Section 77.18 Writing a \ufb01le using Channel and Buer To write data to a \ufb01le using Channel we need to have the following steps First, we need to get an object of FileOutputStream 1. Acquire FileChannel calling the getChannel": "input.pdf", "method from the FileOutputStream 2. Create a ByteBuffer and then \ufb01ll it with data 3. Then we have to call the flip method of the ByteBuffer and pass it as an argument of the write 4. method of the FileChannel Once we are done writing, we have to close the resource5. import java.io. import java.nio. public class FileChannelWrite public static void mainString args File outputFile new Filehello.txt String text I love Bangladesh. try FileOutputStream fos new FileOutputStream outputFile GoalKicker.com Java Notes for Professionals 462 FileChannel fileChannel fos.getChannel byte bytes text.getBytes ByteBuffer buffer ByteBuffer. wrapbytes fileChannel. writebuffer fileChannel. close catch java.io.IOException e e.printStackTrace Section 77.19 Writing a \ufb01le using PrintStream We can use PrintStream class to write a \ufb01le. It has several methods that let you print any data type values. println method appends a new line. Once we are done printing, we have to \ufb02ush the PrintStream . import java.io.FileNotFoundException import java.io.PrintStream import java.time.LocalDate public class FileWritingDemo public static void mainString args String destination file1.txt tryPrintStream ps new PrintStream destination ps. printlnStackoverflow documentation seems fun. ps. println ps. printlnI love Java! ps. printfToday is 1tm1td1tY , LocalDate. now ps. flush catch FileNotFoundException e e. printStackTrace Section 77.20 Iterating over": "input.pdf", "a directory and \ufb01lter by \ufb01le extension public void iterateAndFilter throws IOException Path dir Paths.getCfoobar PathMatcher imageFileMatcher FileSystems. getDefault .getPathMatcher regex.?ijpgjpegpnggifbmpjpejfif try DirectoryStream Path stream Files.newDirectoryStream dir, entry - imageFileMatcher. matchesentry.getFileName for Path path stream System.out.printlnpath.getFileName GoalKicker.com Java Notes for Professionals 463Section 77.21 Accessing the contents of a ZIP \ufb01le The FileSystem API of Java 7 allows to read and add entries from or to a Zip \ufb01le using the Java NIO \ufb01le API in the same way as operating on any other \ufb01lesystem. The FileSystem is a resource that should be properly closed after use, therefore the try-with-resources block should be used. Reading from an existing \ufb01le Path pathToZip Paths.getpathtofile.zip tryFileSystem zipFs FileSystems. newFileSystem pathToZip, null Path root zipFs.getPath ... access the content of the zip file same as ordinary files catchIOException ex ex.printStackTrace Creating a new \ufb01le MapString, String env new HashMap env.putcreate , true required for creating a new zip file env.putencoding , UTF-8 optional default is UTF-8 URI uri URI.createjarfilepathtofile.zip try FileSystem zipfs FileSystems. newFileSystem uri, env Path newFile zipFs.getPathnewFile.txt writing to file Files. writenewFile, Hello world .getBytes catchIOException ex ex.printStackTrace GoalKicker.com Java Notes for Professionals 464Chapter 78 Scanner Parameter Details Source Source could be": "input.pdf", "either one of String, File or any kind of InputStream Section 78.1 General Pattern that does most commonly asked about tasks The following is how to properly use the java.util.Scanner class to interactively read user input from System.in correctly sometimes referred to as stdin , especially in C, C and other languages as well as in Unix and Linux. It idiomatically demonstrates the most common things that are requested to be done. package com.stackoverflow.scanner import javax.annotation.Nonnull import java.math.BigInteger import java.net.MalformedURLException import java.net.URL import java.util. import java.util.regex.Pattern import static java.lang.String.format public class ScannerExample private static final SetString EXITCOMMANDS private static final SetString HELPCOMMANDS private static final Pattern DATEPATTERN private static final String HELPMESSAGE static final SortedSet String ecmds new TreeSet StringString.CASEINSENSITIVEORDER ecmds. addAllArrays.asListexit, done, quit, end, fino EXITCOMMANDS Collections .unmodifiableSortedSet ecmds final SortedSet String hcmds new TreeSet StringString.CASEINSENSITIVEORDER hcmds. addAllArrays.asListhelp, helpi, ? HELPCOMMANDS Collections .unmodifiableSet hcmds DATEPATTERN Pattern. compiled4-d21d2 httpregex101.comrxB8dR31 HELPMESSAGE formatPlease enter some data or enter one of the following commands to exit s , EXITCOMMANDS Using exceptions to control execution flow is always bad. That is why this is encapsulated in a method, this is done this way specifically so as not to introduce any external libraries so": "input.pdf", "that this is a completely self contained example. param s possible url return true if s represents a valid url, false otherwise private static boolean isValidURL Nonnull final String s try new URLs return true catch final MalformedURLException e return false private static void outputNonnull final String format, Nonnull final Object... args GoalKicker.com Java Notes for Professionals 465 System.out.printlnformatformat, args public static void mainfinal String args final Scanner sis new Scanner System.in output HELPMESSAGE while sis.hasNext if sis.hasNextInt final int next sis.nextInt output You entered an Integer d , next else if sis.hasNextLong final long next sis.nextLong output You entered a Long d , next else if sis.hasNextDouble final double next sis.nextDouble output You entered a Double f , next else if sis.hasNextd final BigInteger next sis.nextBigInteger output You entered a BigInteger s , next else if sis.hasNextBoolean final boolean next sis.nextBoolean output You entered a Boolean representation s , next else if sis.hasNextDATEPATTERN final String next sis.nextDATEPATTERN output You entered a Date representation s , next else unclassified final String next sis.next if isValidURL next output You entered a valid URL s , next else if EXITCOMMANDS. contains next output Exit command s issued, exiting! , next break": "input.pdf", "else if HELPCOMMANDS. contains next outputHELPMESSAGE else outputYou entered an unclassified String s , next This will close the underlying Readable, in this case System.in, and free those resources. You will not be to read from System.in anymore after this you call .close. GoalKicker.com Java Notes for Professionals 466 If you wanted to use System.in for something else, then dont close the Scanner. sis. close System.exit0 Section 78.2 Using custom delimiters You can use custom delimiters regular expressions with Scanner, with .useDelimiter ,, to determine how the input is read. This works similarly to String.split.... For example, you can use Scanner to read from a list of comma separated values in a String Scanner scanner null try scanner new Scanner i,like,unicorns .useDelimiter , whilescanner. hasNext System.out.printlnscanner. next catchException e e.printStackTrace finally if scanner ! null scanner. close This will allow you to read every element in the input individually. Note that you should not use this to parse CSV data, instead, use a proper CSV parser library, see CSV parser for Java for other possibilities. Section 78.3 Reading system input using Scanner Scanner scanner new Scanner System.in Scanner obj to read System input String inputTaken new String while true": "input.pdf", "String input scanner. nextLine reading one line of input if input.matchess if it matches spacestabs, stop reading break inputTaken input System.out.printlninputTaken The scanner object is initialized to read input from keyboard. So for the below input from keyboar, itll produce the output as Reading from keyboard Reading from keyboard space Section 78.4 Reading \ufb01le input using Scanner Scanner scanner null try scanner new Scanner new FileNames.txt while scanner. hasNext System.out.printlnscanner. nextLine GoalKicker.com Java Notes for Professionals 467 catch Exception e System.err.printlnException occurred! finally if scanner ! null scanner. close Here a Scanner object is created by passing a File object containing the name of a text \ufb01le as input. This text \ufb01le will be opened by the File object and read in by the scanner object in the following lines. scanner. hasNext will check to see if there is a next line of data in the text \ufb01le. Combining that with a while loop will allow you to iterate through every line of data in the Names.txt \ufb01le. To retrieve the data itself, we can use methods such as nextLine ,nextInt,nextBoolean , etc. In the example above, scanner. nextLine is used. nextLine refers to the following line in a": "input.pdf", "text \ufb01le, and combining it with a scanner object allows you to print the contents of the line. To close a scanner object, you would use .close. Using try with resources from Java 7 onwards, the above mentioned code can be written elegantly as below. try Scanner scanner new Scanner new FileNames.txt while scanner. hasNext System.out.printlnscanner. nextLine catch Exception e System.err.printlnException occurred! Section 78.5 Read the entire input as a String using Scanner You can use Scanner to read all of the text in the input as a String, by using Z entire input as the delimiter. For example, this can be used to read all text in a text \ufb01le in one line String content new Scanner new Filefilename .useDelimiter Z.next System.out.printlncontent Remember that youll have to close the Scanner, as well as catch the IoException this may throw, as described in the example Reading \ufb01le input using Scanner. Section 78.6 Carefully Closing a Scanner it can happen that you use a scanner with the System.in as parameter for the constructor, then you need to be aware that closing the scanner will close the InputStream too giving as next that every try to read the input on that": "input.pdf", "Or any other scanner object will throw an java.util.NoSuchElementException or an java.lang.IllegalStateException example Scanner sc1 new Scanner System.in Scanner sc2 new Scanner System.in int x1 sc1.nextInt sc1. close java.util.NoSuchElementException int x2 sc2.nextInt java.lang.IllegalStateException x2 sc1.nextInt GoalKicker.com Java Notes for Professionals 468Section 78.7 Read an int from the command line import java.util.Scanner Scanner s new Scanner System.in int number s.nextInt If you want to read an int from the command line, just use this snippet. First of all, you have to create a Scanner object, that listens to System.in, which is by default the Command Line, when you start the program from the command line. After that, with the help of the Scanner object, you read the \ufb01rst int that the user passes into the command line and store it in the variable number. Now you can do whatever you want with that stored int. GoalKicker.com Java Notes for Professionals 469Chapter 79 Interfaces An interface is a reference type, similar to a class, which can be declared by using interface keyword. Interfaces can contain only constants, method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Like abstract classes, Interfaces cannot": "input.pdf", "be instantiated they can only be implemented by classes or extended by other interfaces. Interface is a common way to achieve full abstraction in Java. Section 79.1 Implementing multiple interfaces A Java class can implement multiple interfaces. public interface NoiseMaker String noise Making Noise interface variables are public static final by default String makeNoise interface methods are public abstract by default public interface FoodEater void eatFood food public class Cat implements NoiseMaker, FoodEater Override public String makeNoise return meow Override public void eatFood food System.out.printlnmeows appreciatively Notice how the Cat class must implement the inherited abstract methods in both the interfaces. Furthermore, notice how a class can practically implement as many interfaces as needed there is a limit of 65,535 due to JVM Limitation . NoiseMaker noiseMaker new Cat Valid FoodEater foodEater new Cat Valid Cat cat new Cat valid Cat invalid1 new NoiseMaker Invalid Cat invalid2 new FoodEater Invalid Note All variables declared in an interface are public static final 1. All methods declared in an interface methods are public abstract This statement is valid only through Java 2. 7. From Java 8, you are allowed to have methods in an interface, which need not be abstract such": "input.pdf", "methods are known as default methods Interfaces cannot be declared as final 3. If more than one interface declares a method that has identical signature, then e\ufb00ectively it is treated as only4. one method and you cannot distinguish from which interface method is implemented A corresponding InterfaceName.class \ufb01le would be generated for each interface, upon compilation 5. GoalKicker.com Java Notes for Professionals 470Section 79.2 Declaring and Implementing an Interface Declaration of an interface using the interface keyword public interface Animal String getSound Interface methods are public by default Override Annotation Override public String getSound Code goes here... This forces the compiler to check that we are overriding and prevents the program from de\ufb01ning a new method or messing up the method signature. Interfaces are implemented using the implements keyword. public class Cat implements Animal Override public String getSound return meow public class Dog implements Animal Override public String getSound return woof In the example, classes Cat and Dog must de\ufb01ne the getSound method as methods of an interface are inherently abstract with the exception of default methods. Using the interfaces Animal cat new Cat Animal dog new Dog System.out.printlncat.getSound prints meow System.out.printlndog.getSound prints woof Section 79.3 Extending an interface": "input.pdf", "An interface can extend another interface via the extends keyword. public interface BasicResourceService Resource getResource public interface ExtendedResourceService extends BasicResourceService void updateResource Resource resource GoalKicker.com Java Notes for Professionals 471 Now a class implementing ExtendedResourceService will need to implement both getResource and updateResource . Extending multiple interfaces Unlike classes, the extends keyword can be used to extend multiple interfaces Separated by commas allowing for combinations of interfaces into a new interface public interface BasicResourceService Resource getResource public interface AlternateResourceService Resource getAlternateResource public interface ExtendedResourceService extends BasicResourceService, AlternateResourceService Resource updateResource Resource resource In this case a class implementing ExtendedResourceService will need to implement getResource , getAlternateResource , and updateResource . Section 79.4 Usefulness of interfaces Interfaces can be extremely helpful in many cases. For example, say you had a list of animals and you wanted to loop through the list, each printing the sound they make. cat, dog, bird One way to do this would be to use interfaces. This would allow for the same method to be called on all of the classes public interface Animal public String getSound Any class that implements Animal also must have a getSound method in them, yet they can all have di\ufb00erent implementations": "input.pdf", "public class Dog implements Animal public String getSound return Woof public class Cat implements Animal public String getSound return Meow public class Bird implements Animal public String getSound return Chirp GoalKicker.com Java Notes for Professionals 472 We now have three di\ufb00erent classes, each of which has a getSound method. Because all of these classes implement the Animal interface, which declares the getSound method, any instance of an Animal can have getSound called on it Animal dog new Dog Animal cat new Cat Animal bird new Bird dog.getSound Woof cat.getSound Meow bird.getSound Chirp Because each of these is an Animal , we could even put the animals in a list, loop through them, and print out their sounds Animal animals new Dog, new Cat, new Bird for Animal animal animals System.out.printlnanimal.getSound Because the order of the array is Dog, Cat, and then Bird , Woof Meow Chirp will be printed to the console. Interfaces can also be used as the return value for functions. For example, returning a Dog if the input is dog , Cat if the input is cat , and Bird if it is bird , and then printing the sound of that animal could be done": "input.pdf", "using public Animal getAnimalByName String name switchname.toLowerCase case dog return new Dog case cat return new Cat case bird return new Bird default return null public String getAnimalSoundByName String name Animal animal getAnimalByName name if animal null return null else return animal. getSound String dogSound getAnimalSoundByName dog Woof String catSound getAnimalSoundByName cat Meow String birdSound getAnimalSoundByName bird Chirp String lightbulbSound getAnimalSoundByName lightbulb null Interfaces are also useful for extensibility, because if you want to add a new type of Animal , you wouldnt need to change anything with the operations you perform on them. GoalKicker.com Java Notes for Professionals 473Section 79.5 Default methods Introduced in Java 8, default methods are a way of specifying an implementation inside an interface. This could be used to avoid the typical Base or Abstract class by providing a partial implementation of an interface, and restricting the subclasses hierarchy. Observer pattern implementation For example, its possible to implement the Observer-Listener pattern directly into the interface, providing more \ufb02exibility to the implementing classes. interface Observer void onAction String a interface Observable public abstract ListObserver getObservers public default void addObserver Observer o getObservers .addo public default void notifyString something for Observer l getObservers l. onAction something": "input.pdf", "Now, any class can be made Observable just by implementing the Observable interface, while being free to be part of a di\ufb00erent class hierarchy. abstract class Worker public abstract void work public class MyWorker extends Worker implements Observable private ListObserver myObservers new ArrayList Observer Override public ListObserver getObservers return myObservers Override public void work notify Started work Code goes here... notify Completed work public static void mainString args MyWorker w new MyWorker w. addListener new Observer Override GoalKicker.com Java Notes for Professionals 474 public void onAction String a System.out.printlna new Date w. work Diamond problem The compiler in Java 8 is aware of the diamond problem which is caused when a class is implementing interfaces containing a method with the same signature. In order to solve it, an implementing class must override the shared method and provide its own implementation. interface InterfaceA public default String getName return a interface InterfaceB public default String getName return b public class ImpClass implements InterfaceA, InterfaceB Override public String getName Must provide its own implementation return InterfaceA. super.getName InterfaceB. super.getName public static void mainString args ImpClass c new ImpClass System.out.println c.getName Prints ab System.out.println InterfaceA c.getName Prints ab System.out.println InterfaceB c.getName Prints ab": "input.pdf", "Theres still the issue of having methods with the same name and parameters with di\ufb00erent return types, which will not compile. Use default methods to resolve compatibility issues The default method implementations come in very handy if a method is added to an interface in an existing system where the interfaces is used by several classes. To avoid breaking up the entire system, you can provide a default method implementation when you add a method to an interface. This way, the system will still compile and the actual implementations can be done step by step. For more information, see the Default Methods topic. GoalKicker.com Java Notes for Professionals 475Section 79.6 Modi\ufb01ers in Interfaces The Oracle Java Style Guide states Modi\ufb01ers should not be written out when they are implicit. See Modi\ufb01ers in Oracle O\ufb03cial Code Standard for the context and a link to the actual Oracle document. This style guidance applies particularly to interfaces. Lets consider the following code snippet interface I public static final int VARIABLE 0 public abstract void method public static void staticMethod ... public default void defaultMethod ... Variables All interface variables are implicitly constants with implicit public accessible for all, static are accessible by": "input.pdf", "interface name and final must be initialized during declaration modi\ufb01ers public static final int VARIABLE 0 Methods All methods which dont provide implementation are implicitly public and abstract . 1. public abstract void method Version Java SE 8 All methods with static or default modi\ufb01er must provide implementation and are implicitly public . 2. public static void staticMethod ... After all of the above changes have been applied, we will get the following interface I int VARIABLE 0 void method static void staticMethod ... default void defaultMethod ... Section 79.7 Using Interfaces with Generics Lets say you want to de\ufb01ne an interface that allows publishing consuming data to and from di\ufb00erent types of channels e.g. AMQP, JMS, etc, but you want to be able to switch out the implementation details ... Lets de\ufb01ne a basic IO interface that can be re-used across multiple implementations GoalKicker.com Java Notes for Professionals 476public interface IOIncomingType, OutgoingType void publish OutgoingType data IncomingType consume IncomingType RPCSubmit OutgoingType data Now I can instantiate that interface, but since we dont have default implementations for those methods, itll need an implementation when we instantiate it IOString, String mockIO new IOString, String private String channel somechannel Override public": "input.pdf", "void publish String data System.out.printlnPublishing data to channel Override public String consume System.out.printlnConsuming from channel return some useful data Override public String RPCSubmit String data return received data just now mockIO. consume prints Consuming from somechannel mockIO. publishTestData Publishing TestData to somechannel System.out.printlnmockIO.RPCSubmit TestData received TestData just now We can also do something more useful with that interface, lets say we want to use it to wrap some basic RabbitMQ functions public class RabbitMQ implements IOString, String private String exchange private String queue public RabbitMQ String exchange, String queue this.exchange exchange this.queue queue Override public void publish String data rabbit. basicPublish exchange, queue, data. getBytes Override public String consume return rabbit. basicConsume exchange, queue GoalKicker.com Java Notes for Professionals 477 Override public String RPCSubmit String data return rabbit. rpcPublish exchange, queue, data Lets say I want to use this IO interface now as a way to count visits to my website since my last system restart and then be able to display the total number of visits - you can do something like this import java.util.concurrent.atomic.AtomicLong public class VisitCounter implements IOLong, Integer private static AtomicLong websiteCounter new AtomicLong 0 Override public void publish Integer count websiteCounter. addAndGet count Override": "input.pdf", "public Long consume return websiteCounter. get Override public Long RPCSubmit Integer count return websiteCounter. addAndGet count Now lets use the VisitCounter VisitCounter counter new VisitCounter just had 4 visits, yay counter. publish4 just had another visit, yay counter. publish1 get data for stats counter System.out.printlncounter. consume prints 5 show data for stats counter page, but include that as a page view System.out.printlncounter. RPCSubmit 1 prints 6 When implementing multiple interfaces, you cant implement the same interface twice. That also applies to generic interfaces. Thus, the following code is invalid, and will result in a compile error interface Printer T void printT value Invalid! class SystemPrinter implements Printer Double, Printer Integer Override public void printDouble d System.out.printlnDecimal d Override public void printInteger i System.out.printlnDiscrete i GoalKicker.com Java Notes for Professionals 478 Section 79.8 Strengthen bounded type parameters Bounded type parameters allow you to set restrictions on generic type arguments class SomeClass class DemoT extends SomeClass But a type parameter can only bind to a single class type. An interface type can be bound to a type that already had a binding. This is achieved using the symbol interface SomeInterface class GenericClass T extends SomeClass SomeInterface This strengthens the bind, potentially": "input.pdf", "requiring type arguments to derive from multiple types. Multiple interface types can be bound to a type parameter class DemoT extends SomeClass FirstInterface SecondInterface But should be used with caution. Multiple interface bindings is usually a sign of a code smell , suggesting that a new type should be created which acts as an adapter for the other types interface NewInterface extends FirstInterface, SecondInterface class DemoT extends SomeClass NewInterface Section 79.9 Implementing interfaces in an abstract class A method de\ufb01ned in an interface is by default public abstract . When an abstract class implements an interface , any methods which are de\ufb01ned in the interface do not have to be implemented by the abstract class . This is because a class that is declared abstract can contain abstract method declarations. It is therefore the responsibility of the \ufb01rst concrete sub-class to implement any abstract methods inherited from any interfaces andor the abstract class . public interface NoiseMaker void makeNoise GoalKicker.com Java Notes for Professionals 479public abstract class Animal implements NoiseMaker Does not need to declare or implement makeNoise public abstract void eat Because Dog is concrete, it must define both makeNoise and eat public class Dog extends Animal Override": "input.pdf", "public void makeNoise System.out.printlnBorf borf Override public void eat System.out.printlnDog eats some kibble. From Java 8 onward it is possible for an interface to declare default implementations of methods which means the method wont be abstract , therefore any concrete sub-classes will not be forced to implement the method but will inherit the default implementation unless overridden. GoalKicker.com Java Notes for Professionals 480Chapter 80 Regular Expressions A regular expression is a special sequence of characters that helps in matching or \ufb01nding other strings or sets of strings, using a specialized syntax held in a pattern. Java has support for regular expression usage through the java.util.regex package. This topic is to introduce and help developers understand more with examples on how Regular Expressions must be used in Java. Section 80.1 Using capture groups If you need to extract a part of string from the input string, we can use capture groups of regex. For this example, well start with a simple phone number regex d3-d3-d4 If parentheses are added to the regex, each set of parentheses is considered a capturing group . In this case, we are using what are called numbered capture groups d3-d3-d4 ----- ----- ----- Group 1": "input.pdf", "Group 2 Group 3 Before we can use it in Java, we must not forget to follow the rules of Strings, escaping the backslashes, resulting in the following pattern d3-d3-d4 We \ufb01rst need to compile the regex pattern to make a Pattern and then we need a Matcher to match our input string with the pattern Pattern phonePattern Pattern. compiled3-d3-d4 Matcher phoneMatcher phonePattern. matcherabcd800-555-1234wxyz Next, the Matcher needs to \ufb01nd the \ufb01rst subsequence that matches the regex phoneMatcher. find Now, using the group method, we can extract the data from the string String number phoneMatcher. group0 800-555-1234 Group 0 is everything the regex matched String aCode phoneMatcher. group1 800 String threeDigit phoneMatcher. group2 555 String fourDigit phoneMatcher. group3 1234 Note Matcher. group can be used in place of Matcher. group0. Version Java SE 7 Java 7 introduced named capture groups. Named capture groups function the same as numbered capture groups but with a name instead of a number, although there are slight syntax changes. Using named capture groups improves readability. We can alter the above code to use named groups GoalKicker.com Java Notes for Professionals 481?d3-d3-d4 ---------------- ----- ----- AreaCode Group 2 Group 3 To get the contents of": "input.pdf", "AreaCode, we can instead use String aCode phoneMatcher. groupAreaCode 800 Section 80.2 Using regex with custom behaviour by compiling the Pattern with \ufb02ags A Pattern can be compiled with \ufb02ags, if the regex is used as a literal String , use inline modi\ufb01ers Pattern pattern Pattern. compilefoo., Pattern. CASEINSENSITIVE Pattern. DOTALL pattern. matcherFOOn.matches Is true. Had the regex not been compiled case insensitively and singlelined, it would fail because FOO does not match foo and n newline does not match .. Pattern anotherPattern Pattern. compile?sifoo anotherPattern. matcherFOOn.matches Is true. foOt.replaceAll ?sifoo , ca Returns cat. Section 80.3 Escape Characters Generally To use regular expression speci\ufb01c characters ? etc. in their literal meaning they need to be escaped. In common regular expression this is done by a backslash . However, as it has a special meaning in Java Strings, you have to use a double backslash . These two examples will not work ???.replaceAll ?, ! java.util.regex.PatternSyntaxException ???.replaceAll ?, ! Invalid escape sequence This example works ???.replaceAll ?, ! !!! Splitting a Pipe Delimited String This does not return the expected result ab.split a, , b This returns the expected result ab.split a, b Escaping backslash GoalKicker.com Java Notes for": "input.pdf", "Professionals 482This will give an error .matches PatternSyntaxException .matches Syntax Error This works .matches true Section 80.4 Not matching a given string To match something that does not contain a given string, one can use negative lookahead Regex syntax ?!string-to-not-match Example not matching popcorn String regexString ?!popcorn. System.out.printlnpopcorn popcorn .matchesregexString ? matched! nope! System.out.printlnunicorn unicorn .matchesregexString ? matched! nope! Output popcorn nope! unicorn matched! Section 80.5 Matching with a regex literal If you need to match characters that are a part of the regular expression syntax you can mark all or part of the pattern as a regex literal. Q marks the beginning of the regex literal. E marks the end of the regex literal. the following throws a PatternSyntaxException because of the un-closed bracket 123.matches123 wrapping the bracket in Q and E allows the pattern to match as you would expect. 123.matchesQE123 returns true An easier way of doing it without having to remember the Q and E escape sequences is to use Pattern. quote 123.matchesPattern. quote 123 returns true Section 80.6 Matching a backslash If you want to match a backslash in your regular expression, youll have to escape it. Backslash is an escape character in regular": "input.pdf", "expressions. You can use to refer to a single backslash in a regular expression. However, backslash is also an escape character in Java literal strings. To make a regular expression from a string literal, you have to escape each of its backslashes. In a string literal can be used to create a regular expression GoalKicker.com Java Notes for Professionals 483with , which in turn can match . For example, consider matching strings like Cdirmy\ufb01le.txt. A regular expression A-Za-z. will match, and provide the drive letter as a capturing group. Note the doubled backslash. To express that pattern in a Java string literal, each of the backslashes in the regular expression needs to be escaped. String path Cdirmyfile.txt System.out.println Local path path Cdirmyfile.txt String regex A-Za-z . Four to match one System.out.printlnRegex regex A-Za-z. Pattern pattern Pattern. compile regex Matcher matcher pattern. matcher path if matcher. matches System.out.println This path is on drive matcher. group 1 . This path is on drive C. If you want to match two backslashes, youll \ufb01nd yourself using eight in a literal string, to represent four in the regular expression, to match two. String path myhostsharemyfile.txt System.out.println UNC path path myhostsharemyfile.txt String regex .?.": "input.pdf", "Eight to match two System.out.printlnRegex regex .?. Pattern pattern Pattern. compile regex Matcher matcher pattern. matcher path if matcher. matches System.out.println This path is on host matcher. group 1 . This path is on host myhost. GoalKicker.com Java Notes for Professionals 484Chapter 81 Comparable and Comparator Section 81.1 Sorting a List using ComparableT or a ComparatorT Say we are working on a class representing a Person by their \ufb01rst and last names. We have created a basic class to do this and implemented proper equals and hashCode methods. public class Person private final String lastName invariant - nonnull private final String firstName invariant - nonnull public PersonString firstName, String lastName this.firstName firstName ! null ? firstName this.lastName lastName ! null ? lastName public String getFirstName return firstName public String getLastName return lastName public String toString return lastName , firstName Override public boolean equalsObject o if ! o instanceof Person return false Person p Persono return firstName. equalsp.firstName lastName. equalsp.lastName Override public int hashCode return Objects. hashfirstName, lastName Now we would like to sort a list of Person objects by their name, such as in the following scenario public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new": "input.pdf", "PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople This currently wont work. Unfortunately, as marked, the above currently wont compile. Collections .sort.. only knows how to sort a list if the elements in that list are comparable, or a custom method of comparison is given. If you were asked to sort the following list 1,3,5,4,2, youd have no problem saying the answer is 1,2,3,4,5. This GoalKicker.com Java Notes for Professionals 485is because Integers both in Java and mathematically have a natural ordering , a standard, default comparison base ordering. To give our Person class a natural ordering, we implement Comparable Person, which requires implementing the method compareTo Person p public class Person implements Comparable Person private final String lastName invariant - nonnull private final String firstName invariant - nonnull public PersonString firstName, String lastName this.firstName firstName ! null ? firstName this.lastName lastName ! null ? lastName public String getFirstName return firstName public String getLastName return lastName public String toString return lastName , firstName Override public boolean equalsObject o if ! o instanceof Person return false Person p Persono return firstName. equalsp.firstName lastName. equalsp.lastName Override public int hashCode return Objects. hashfirstName, lastName": "input.pdf", "Override public int compareTo Person other If this lastName and others lastName are not comparably equivalent, Compare this to other by comparing their last names. Otherwise, compare this to other by comparing their first names int lastNameCompare lastName. compareTo other.lastName if lastNameCompare ! 0 return lastNameCompare else return firstName. compareTo other.firstName Now, the main method given will function correctly public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople Now functions correctly GoalKicker.com Java Notes for Professionals 486 people is now sorted by last name, then first name -- Jill Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald If, however, you either do not want or are unable to modify class Person , you can provide a custom Comparator T that handles the comparison of any two Person objects. If you were asked to sort the following list circle, square, rectangle, triangle, hexagon you could not, but if you were asked to sort that list based on the number of corners , you could. Just so, providing a comparator instructs Java how to compare two normally not comparable objects. public": "input.pdf", "class PersonComparator implements Comparator Person public int compare Person p1, Person p2 If p1s lastName and p2s lastName are not comparably equivalent, Compare p1 to p2 by comparing their last names. Otherwise, compare p1 to p2 by comparing their first names if p1.getLastName .compareTo p2.getLastName ! 0 return p1.getLastName .compareTo p2.getLastName else return p1.getFirstName .compareTo p2.getFirstName Assume the first version of Person that does not implement Comparable is used here public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople Illegal, Person doesnt implement Comparable. Collections .sortpeople, new PersonComparator Legal people is now sorted by last name, then first name -- Jill Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald Comparators can also be createdused as an anonymous inner class Assume the first version of Person that does not implement Comparable is used here public static void mainString args List Person people Arrays.asListnew PersonJohn, Doe, new PersonBob, Dole, new PersonRonald , McDonald , new PersonAlice, McDonald , new PersonJill, Doe Collections .sortpeople Illegal, Person doesnt implement Comparable. Collections .sortpeople, new PersonComparator Legal people is now sorted by last name, then": "input.pdf", "first name -- Jill Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald Anonymous Class Collections .sortpeople, new Comparator Person Legal public int compare Person p1, Person p2 Method code... GoalKicker.com Java Notes for Professionals 487 Version Java SE 8 Lambda expression based comparators As of Java 8, comparators can also be expressed as lambda expressions Lambda Collections .sortpeople, p1, p2 - Legal Method code.... Comparator default methods Furthermore, there are interesting default methods on the Comparator interface for building comparators the following builds a comparator comparing by lastName and then firstName . Collections .sortpeople, Comparator .comparing PersongetLastName . thenComparing PersongetFirstName Inversing the order of a comparator Any comparator can also easily be reversed using the reversedMethod which will change ascending order to descending. Section 81.2 The compareTo and compare Methods The Comparable T interface requires one method public interface Comparable T public int compareTo T other And the Comparator T interface requires one method public interface Comparator T public int compare T t1, T t2 These two methods do essentially the same thing, with one minor di\ufb00erence compareTo compares this to other , whereas compare compares t1 to t2, not caring at all about this . Aside from": "input.pdf", "that di\ufb00erence, the two methods have similar requirements. Speci\ufb01cally for compareTo, Compares this object with the speci\ufb01ed object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the speci\ufb01ed object. Thus, for the comparison of a and b If a b, a.compareTo b and comparea,b should return a negative integer, and b.compareTo a and compareb,a should return a positive integer If a b, a.compareTo b and comparea,b should return a positive integer, and b.compareTo a and compareb,a should return a negative integer If a equals b for comparison, all comparisons should return 0. GoalKicker.com Java Notes for Professionals 488Section 81.3 Natural comparable vs explicit comparator sorting There are two Collections .sort methods One that takes a ListT as a parameter where T must implement Comparable and override the compareTo method that determines sort order. One that takes a List and a Comparator as the arguments, where the Comparator determines the sort order. First, here is a Person class that implements Comparable public class Person implements Comparable Person private String name private int age public String getName return name public void setName String name this.name name public": "input.pdf", "int getAge return age public void setAgeint age this.age age Override public int compareTo Person o return this.getAge - o.getAge Override public String toString return this.getAge-this.getName Here is how you would use the above class to sort a List in the natural ordering of its elements, de\ufb01ned by the compareTo method override -- usage ListPerson pList new ArrayList Person Person p new Person p. setNameA p. setAge10 pList. addp p new Person p. setNameZ p. setAge20 pList. addp p new Person p. setNameD p. setAge30 pList. addp -- natural sorting i.e comes with object implementation, by age Collections .sortpList GoalKicker.com Java Notes for Professionals 489 System.out.printlnpList Here is how you would use an anonymous inline Comparator to sort a List that does not implement Comparable, or in this case, to sort a List in an order other than the natural ordering -- explicit sorting, define sort on another property here goes with name Collections .sortpList, new Comparator Person Override public int compare Person o1, Person o2 return o1.getName.compareTo o2.getName System.out.printlnpList Section 81.4 Creating a Comparator using comparing method Comparator .comparing PersongetName This creates a comparator for the class Person that uses this person name as the comparison source. Also": "input.pdf", "it is possible to use method version to compare long, int and double. For example Comparator .comparingInt PersongetAge Reversed order To create a comparator that imposes the reverse ordering use reversed method Comparator .comparing PersongetName.reversed Chain of comparators Comparator .comparing PersongetLastName .thenComparing PersongetFirstName This will create a comparator that \ufb01rs compares with last name then compares with \ufb01rst name. You can chain as many comparators as you want. Section 81.5 Sorting Map entries As of Java 8, there are default methods on the Map.Entry interface to allow sorting of map iterations. Version Java SE 8 MapString, Integer numberOfEmployees new HashMap numberOfEmployees. putexecutives , 10 numberOfEmployees. puthuman ressources , 32 numberOfEmployees. putaccounting , 12 numberOfEmployees. putIT, 100 Output the smallest departement in terms of number of employees numberOfEmployees. entrySet .stream .sortedMap.Entry.comparingByValue .limit1 .forEachSystem.outprintln outputs executives10 Of course, these can also be used outside of the stream api GoalKicker.com Java Notes for Professionals 490Version Java SE 8 ListMap.EntryString, Integer entries new ArrayList numberOfEmployees. entrySet Collections .sortentries, Map.Entry.comparingByValue GoalKicker.com Java Notes for Professionals 491Chapter 82 Java Floating Point Operations Floating-point numbers are numbers that have fractional parts usually expressed with a decimal point. In Java, there is two primitive types for \ufb02oating-point": "input.pdf", "numbers which are float uses 4 bytes, and double uses 8 bytes. This documentation page is for detailing with examples operations that can be done on \ufb02oating points in Java. Section 82.1 Comparing \ufb02oating point values You should be careful when comparing \ufb02oating-point values float or double using relational operators , !, and so on. These operators give results according to the binary representations of the \ufb02oating point values. For example public class CompareTest public static void mainString args double oneThird 1.0 3.0 double one oneThird 3 System.out.printlnone 1.0 prints false The calculation oneThird has introduced a tiny rounding error, and when we multiply oneThird by 3 we get a result that is slightly di\ufb00erent to 1.0. This problem of inexact representations is more stark when we attempt to mix double and float in calculations. For example public class CompareTest2 public static void mainString args float floatVal 0.1f double doubleVal 0.1 double doubleValCopy floatVal System.out.printlnfloatVal 0.1 System.out.printlndoubleVal 0.1 System.out.printlndoubleValCopy 0.10000000149011612 System.out.printlnfloatVal doubleVal false System.out.printlndoubleVal doubleValCopy false The \ufb02oating point representations used in Java for the float and double types have limited number of digits of precision. For the float type, the precision is 23 binary digits or about 8": "input.pdf", "decimal digits. For the double type, it is 52 bits or about 15 decimal digits. On top of that, some arithmetical operations will introduce rounding errors. Therefore, when a program compares \ufb02oating point values, it standard practice to de\ufb01ne an acceptable delta for the comparison. If the di\ufb00erence between the two numbers is less than the delta, they are deemed to be equal. For example if Math.absv1 - v2 delta Delta compare example public class DeltaCompareExample GoalKicker.com Java Notes for Professionals 492 private static boolean deltaCompare double v1, double v2, double delta return true iff the difference between v1 and v2 is less than delta return Math.absv1 - v2 delta public static void mainString args double doubles 1.0, 1.0001, 1.0000001 , 1.000000001 , 1.0000000000001 double deltas 0.01, 0.00001, 0.0000001 , 0.0000000001 , 0 loop through all of deltas initialized above for int j 0 j deltas. length j double delta deltasj System.out.printlndelta delta loop through all of the doubles initialized above for int i 0 i doubles. length - 1 i double d1 doubles i double d2 doubles i 1 boolean result deltaCompare d1, d2, delta System.out.println d1 d2 ? result System.out.println Result delta 0.01 1.0 1.0001 ? true": "input.pdf", "1.0001 1.0000001 ? true 1.0000001 1.000000001 ? true 1.000000001 1.0000000000001 ? true delta 1.0E-5 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? true 1.000000001 1.0000000000001 ? true delta 1.0E-7 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? true 1.000000001 1.0000000000001 ? true delta 1.0E-10 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? false 1.000000001 1.0000000000001 ? false delta 0.0 1.0 1.0001 ? false 1.0001 1.0000001 ? false 1.0000001 1.000000001 ? false 1.000000001 1.0000000000001 ? false GoalKicker.com Java Notes for Professionals 493Also for comparison of double and float primitive types static compare method of corresponding boxing type can be used. For example double a 1.0 double b 1.0001 System.out.printlnDouble.comparea, b-1 System.out.printlnDouble.compareb, a1 Finally, determining what deltas are most appropriate for a comparison can be tricky. A commonly used approach is to pick delta values that are our intuition says are about right. However, if you know scale and true accuracy of the input values, and the calculations performed, it may be possible to come up with mathematically sound bounds on the accuracy of the results, and hence for the deltas. There is a formal branch of Mathematics known as Numerical Analysis": "input.pdf", "that used to be taught to computational scientists that covered this kind of analysis. Section 82.2 OverFlow and UnderFlow Float data type The \ufb02oat data type is a single-precision 32-bit IEEE 754 \ufb02oating point. Float over\ufb02ow Maximum possible value is 3.4028235e 38 , When it exceeds this value it produces Infinity float f 3.4e38f float result f2 System.out.printlnresult Infinity Float UnderFlow Minimum value is 1.4e-45f, when is goes below this value it produces 0.0 float f 1e-45f float result f1000 System.out.printlnresult double data type The double data type is a double-precision 64-bit IEEE 754 \ufb02oating point. Double OverFlow Maximum possible value is 1.7976931348623157e 308 , When it exceeds this value it produces Infinity double d 1e308 double resultd2 System.out.printlnresult Infinity Double UnderFlow Minimum value is 4.9e-324, when is goes below this value it produces 0.0 double d 4.8e-323 double result d1000 GoalKicker.com Java Notes for Professionals 494 System.out.printlnresult 0.0 Section 82.3 Formatting the \ufb02oating point values Floating point Numbers can be formatted as a decimal number using String.format with f \ufb02ag Two digits in fracttional part are rounded String format1 String.format.2f, 1.2399 System.out.printlnformat1 1.24 three digits in fractional part are rounded String format2 String.format.3f, 1.2399 System.out.printlnformat2 1.240 rounded to": "input.pdf", "two digits, filled with zero String format3 String.format.2f, 1.2 System.out.printlnformat3 returns 1.20 rounder to two digits String format4 String.format.2f, 3.19999 System.out.printlnformat4 3.20 Floating point Numbers can be formatted as a decimal number using DecimalFormat rounded with one digit fractional part String format new DecimalFormat 0..format4.3200 System.out.printlnformat 4.3 rounded with two digit fractional part String format new DecimalFormat 0..format1.2323000 System.out.printlnformat 1.23 formatting floating numbers to decimal number double dv 123456789 System.out.printlndv 1.23456789E8 String format new DecimalFormat 0.formatdv System.out.printlnformat 123456789 Section 82.4 Strict Adherence to the IEEE Speci\ufb01cation By default, \ufb02oating point operations on float and double do not strictly adhere to the rules of the IEEE 754 speci\ufb01cation. An expression is allowed to use implementation-speci\ufb01c extensions to the range of these values essentially allowing them to be more accurate than required. strictfp disables this behavior. It is applied to a class, interface, or method, and applies to everything contained in it, such as classes, interfaces, methods, constructors, variable initializers, etc. With strictfp , the intermediate values of a \ufb02oating-point expression must be within the \ufb02oat value set or the double value set. This causes the results of such expressions to be exactly those that the IEEE 754 speci\ufb01cation predicts. All": "input.pdf", "constant expressions are implicitly strict, even if they arent inside a strictfp scope. Therefore, strictfp has the net e\ufb00ect of sometimes making certain corner case computations less accurate, and can also make \ufb02oating point operations slower as the CPU is now doing more work to ensure any native extra precision does not a\ufb00ect the result. However, it also causes the results to be exactly the same on all platforms. It is therefore useful in things like scienti\ufb01c programs, where reproducibility is more important than speed. public class StrictFP No strictfp - default lenient GoalKicker.com Java Notes for Professionals 495 public strictfp float strictfloat input return input input 3.4f Strictly adheres to the spec. May be less accurate and may be slower. public float lenient float input return input input 3.4f Can sometimes be more accurate and faster, but results may not be reproducable. public static final strictfp class Ops strictfp affects all enclosed entities private StrictOps public static divdouble dividend, double divisor implicitly strictfp return dividend divisor GoalKicker.com Java Notes for Professionals 496Chapter 83 Currency and Money Section 83.1 Add custom currency Required JARs on classpath javax.moneymoney-api1.0 JSR354 money and currency api org.javamoneymoneta1.0 Reference implementation javaxannotation-api1.2. Common annotations used": "input.pdf", "by reference implementation Lets create non-ISO currency, such as bitcoin At first, this will throw UnknownCurrencyException MonetaryAmount moneys Money.ofnew BigDecimal 0.1, BTC This happens because bitcoin is unknown to default currency providers System.out.printlnMonetary. isCurrencyAvailable BTC false We will build new currency using CurrencyUnitBuilder provided by org.javamoney.moneta CurrencyUnit bitcoin CurrencyUnitBuilder .ofBTC, BtcCurrencyProvider Set currency code and currency provider name .setDefaultFractionDigits 2 Set default fraction digits .buildtrue Build new currency unit. Here true means currency unit is to be registered and accessible within default monetary context Now BTC is available System.out.printlnMonetary. isCurrencyAvailable BTC True GoalKicker.com Java Notes for Professionals 497Chapter 84 Object Cloning Section 84.1 Cloning performing a deep copy To copy nested objects, a deep copy must be performed, as shown in this example. import java.util.ArrayList import java.util.List public class Sheep implements Cloneable private String name private int weight private ListSheep children public SheepString name, int weight this.name name this.weight weight Override public Object clone throws CloneNotSupportedException Sheep clone Sheep super.clone if children ! null make a deep copy of the children List Sheep cloneChildren new ArrayList children. size for Sheep child children cloneChildren. addSheep child.clone clone. setChildren cloneChildren return clone public ListSheep getChildren return children public void setChildren ListSheep": "input.pdf", "children this.children children import java.util.Arrays import java.util.List create a sheep Sheep sheep new SheepDolly, 20 create children Sheep child1 new SheepChild1 , 4 Sheep child2 new SheepChild2 , 5 sheep.setChildren Arrays.asListchild1, child2 clone the sheep Sheep dolly Sheep sheep.clone GoalKicker.com Java Notes for Professionals 498ListSheep sheepChildren sheep.getChildren ListSheep dollysChildren dolly.getChildren for int i 0 i sheepChildren. size i prints false, both arrays contain copies of the objects inside System.out.printlnsheepChildren. geti dollysChildren. geti Section 84.2 Cloning using a copy factory public class Sheep private String name private int weight public SheepString name, int weight this.name name this.weight weight public static Sheep newInstance Sheep other return new Sheepother.name, other. weight Section 84.3 Cloning using a copy constructor An easy way to clone an object is by implementing a copy constructor. public class Sheep private String name private int weight public SheepString name, int weight this.name name this.weight weight copy constructor copies the fields of other into the new object public SheepSheep other this.name other.name this.weight other.weight create a sheep Sheep sheep new SheepDolly, 20 clone the sheep Sheep dolly new Sheepsheep dolly.name is Dolly and dolly.weight is 20 Section 84.4 Cloning by implementing Clonable interface Cloning an object by implementing the": "input.pdf", "Cloneable interface. GoalKicker.com Java Notes for Professionals 499public class Sheep implements Cloneable private String name private int weight public SheepString name, int weight this.name name this.weight weight Override public Object clone throws CloneNotSupportedException return super.clone create a sheep Sheep sheep new SheepDolly, 20 clone the sheep Sheep dolly Sheep sheep.clone dolly.name is Dolly and dolly.weight is 20 Section 84.5 Cloning performing a shallow copy Default behavior when cloning an object is to perform a shallow copy of the objects \ufb01elds. In that case, both the original object and the cloned object, hold references to the same objects. This example shows that behavior. import java.util.List public class Sheep implements Cloneable private String name private int weight private ListSheep children public SheepString name, int weight this.name name this.weight weight Override public Object clone throws CloneNotSupportedException return super.clone public ListSheep getChildren return children public void setChildren ListSheep children this.children children GoalKicker.com Java Notes for Professionals 500import java.util.Arrays import java.util.List create a sheep Sheep sheep new SheepDolly, 20 create children Sheep child1 new SheepChild1 , 4 Sheep child2 new SheepChild2 , 5 sheep.setChildren Arrays.asListchild1, child2 clone the sheep Sheep dolly Sheep sheep.clone ListSheep sheepChildren sheep.getChildren ListSheep dollysChildren dolly.getChildren for int i 0 i": "input.pdf", "sheepChildren. size i prints true, both arrays contain the same objects System.out.printlnsheepChildren. geti dollysChildren. geti GoalKicker.com Java Notes for Professionals 501Chapter 85 Recursion Recursion occurs when a method calls itself. Such a method is called recursive . A recursive method may be more concise than an equivalent non-recursive approach. However, for deep recursion, sometimes an iterative solution can consume less of a threads \ufb01nite stack space. This topic includes examples of recursion in Java. Section 85.1 The basic idea of recursion What is recursion In general, recursion is when a function invokes itself, either directly or indirectly. For example This method calls itself infinitely public void useless useless method calls itself directly Conditions for applying recursion to a problem There are two preconditions for using recursive functions to solving a speci\ufb01c problem There must be a base condition for the problem, which will be the endpoint for the recursion. When a1. recursive function reaches the base condition, it makes no further deeper recursive calls. Each level of recursion should be attempting a smaller problem. The recursive function thus divides the2. problem into smaller and smaller parts. Assuming that the problem is \ufb01nite, this will ensure that the recursion terminates.": "input.pdf", "In Java there is a third precondition it should not be necessary to recurse too deeply to solve the problem see Deep recursion is problematic in Java Example The following function calculates factorials using recursion. Notice how the method factorial calls itself within the function. Each time it calls itself, it reduces the parameter n by 1. When n reaches 1 the base condition the function will recurse no deeper. public int factorial int n if n 1 the base condition return 1 else return n factorial n - 1 This is not a practical way of computing factorials in Java, since it does not take account of integer over\ufb02ow, or call stack over\ufb02ow i.e. StackOverflowError exceptions for large values of n. Section 85.2 Deep recursion is problematic in Java Consider the following naive method for adding two positive numbers using recursion GoalKicker.com Java Notes for Professionals 502public static int addint a, int b if a 0 return b else return adda - 1, b 1 TAIL CALL This is algorithmically correct, but it has a major problem. If you call add with a large a, it will crash with a StackOverflowError , on any version of Java up": "input.pdf", "to at least Java 9. In a typical functional programming language and many other languages the compiler optimizes tail recursion. The compiler would notice that the call to add at the tagged line is a tail call , and would e\ufb00ectively rewrite the recursion as a loop. This transformation is called tail-call elimination. However, current generation Java compilers do not perform tail call elimination. This is not a simple oversight. There are substantial technical reasons for this see below. Instead, each recursive call of add causes a new frame to be allocated on the threads stack. For example, if you call add1000, 1, it will take 1000 recursive calls to arrive at the answer 1001 . The problem is that the size of Java thread stack is \ufb01xed when the thread is created. This includes the main thread in a single-threaded program. If too many stack frames are allocated the stack will over\ufb02ow. The JVM will detect this and throw a StackOverflowError . One approach to dealing with this is to simply use a bigger stack. There are JVM options that control the default size of a stack, and you can also specify the stack size as a Thread": "input.pdf", "constructor parameter. Unfortunately, this only puts o\ufb00 the stack over\ufb02ow. If you need to do a computation that requires an even larger stack, then the StackOverflowError comes back. The real solution is to identify recursive algorithms where deep recursion is likely, and manually perform the tail-call optimization at the source code level. For example, our add method can be rewritten as follows public static int addint a, int b while a ! 0 a a - 1 b b 1 return b Obviously, there are better ways to add two integers. The above is simply to illustrate the e\ufb00ect of manual tail-call elimination. Why tail-call elimination is not implemented in Java yet There are a number of reasons why adding tail call elimination to Java is not easy. For example Some code could rely on StackOverflowError to for example place a bound on the size of a computational problem. Sandbox security managers often rely on analyzing the call stack when deciding whether to allow non- privileged code to perform a privileged action. As John Rose explains in Tail calls in the VM The e\ufb00ects of removing the caller s stack frame are visible to some APIs, notably access control": "input.pdf", "checks and GoalKicker.com Java Notes for Professionals 503stack tracing. It is as if the caller s caller had directly called the callee. Any privileges possessed by the caller are discarded after control is transferred to the callee. However, the linkage and accessibility of the callee method are computed before the transfer of control, and take into account the tail-calling caller. In other words, tail-call elimination could cause an access control method to mistakenly think that a security sensitive API was was being called by trusted code. Section 85.3 Types of Recursion Recursion can be categorized as either Head Recursion or Tail Recursion , depending on where the recursive method call is placed. In head recursion , the recursive call, when it happens, comes before other processing in the function think of it happening at the top, or head, of the function. In tail recursion , its the opposite the processing occurs before the recursive call. Choosing between the two recursive styles may seem arbitrary, but the choice can make all the di\ufb00erence. A function with a path with a single recursive call at the beginning of the path uses what is called head recursion. The factorial function of a": "input.pdf", "previous exhibit uses head recursion. The \ufb01rst thing it does once it determines that recursion is needed is to call itself with the decremented parameter. A function with a single recursive call at the end of a path is using tail recursion. public void tailint n public void headint n ifn 1 ifn 0 return return else else System.out.printlnn head n-1 tailn-1 System.out.printlnn If the recursive call occurs at the end of a method, it is called a tail recursion . The tail recursion is similar to a loop . The method executes all the statements before jumping into the next recursive call . If the recursive call occurs at the beginning of a method, it is called a head recursion . The method saves the state before jumping into the next recursive call . Reference The di\ufb00erence between head tail recursion Section 85.4 Computing the Nth Fibonacci Number The following method computes the Nth Fibonacci number using recursion. public int fibfinal int n if n 2 return fibn - 2 fibn - 1 return 1 The method implements a base case n 2 and a recursive case n2. This illustrates the use of recursion to compute a recursive": "input.pdf", "relation. GoalKicker.com Java Notes for Professionals 504However, while this example is illustrative, it is also ine\ufb03cient each single instance of the method will call the function itself twice, leading to an exponential growth in the number of times the function is called as N increases. The above function is O2N, but an equivalent iterative solution has complexity ON. In addition, there is a closed form expression that can be evaluated in ON \ufb02oating-point multiplications. Section 85.5 StackOver\ufb02owError recursion to loop If a recursive call goes too deep, this results in a StackOverflowError . Java allocates a new frame for every method call on its threads stack. However, the space of each threads stack is limited. Too many frames on the stack leads to the Stack Over\ufb02ow SO. Example public static void recursion int depth if depth 0 recursion depth-1 Calling this method with large parameters e.g. recursion 50000 probably will result in a stack over\ufb02ow. The exact value depends on the thread stack size, which in turn depends on the thread construction, command-line parameters such as -Xss, or the default size for the JVM. Workaround A recursion can be converted to a loop by storing the data for each": "input.pdf", "recursive call in a data structure. This data structure can be stored on the heap rather than on the thread stack. In general the data required to restore the state of a method invocation can be stored in a stack and a while loop can be used to simulate the recursive calls. Data that may be required include the object the method was called for instance methods only the method parameters local variables the current position in the execution or the method Example The following class allows recursive of a tree structure printing up to a speci\ufb01ed depth. public class Node public int data public Node left public Node right public Nodeint data thisdata, null, null public Nodeint data, Node left, Node right this.data data this.left left this.right right public void printfinal int maxDepth if maxDepth 0 GoalKicker.com Java Notes for Professionals 505 System.out.print... else System.out.print if left ! null left. printmaxDepth -1 System.out.printdata if right ! null right. printmaxDepth -1 System.out.print e.g. Node n new Node10, new Node20, new Node50, new Node1, new Node30, new Node42, null n.print2 System.out.println Prints ...20...10...30 This could be converted to the following loop public class Frame public final Node node 0 before": "input.pdf", "printing anything 1 before printing data 2 before printing public int state 0 public final int maxDepth public FrameNode node, int maxDepth this.node node this.maxDepth maxDepth ListFrame stack new ArrayList stack.addnew Framen, 2 first frame initial call while !stack.isEmpty get topmost stack element int index stack.size - 1 Frame frame stack.getindex get topmost frame if frame.maxDepth 0 termial case too deep System.out.print... stack. removeindex drop frame else switch frame.state case 0 frame. state GoalKicker.com Java Notes for Professionals 506 do everything done before the first recursive call System.out.print if frame.node.left ! null add new frame recursive call to left and stop stack. addnew Frameframe.node.left, frame. maxDepth - 1 break case 1 frame. state do everything done before the second recursive call System.out.printframe.node.data if frame.node.right ! null add new frame recursive call to right and stop stack. addnew Frameframe.node.right, frame. maxDepth - 1 break case 2 do everything after the second recursive call drop frame System.out.print stack. removeindex System.out.println Note This is just an example of the general approach. Often you can come up with a much better way to represent a frame andor store the frame data. Section 85.6 Computing the Nth power of a number The following method": "input.pdf", "computes the value of num raised to the power of exp using recursion public long powerfinal int num, final int exp if exp 0 return 1 if exp 1 return num return num powernum, exp - 1 This illustrates the principles mentioned above the recursive method implements a base case two cases, n 0 and n 1 that terminates the recursion, and a recursive case that calls the method again. This method is ON and can be reduced to a simple loop using tail-call optimization. Section 85.7 Traversing a Tree data structure with recursion Consider the Node class having 3 members data, left child pointer and right child pointer like below. public class Node public int data public Node left public Node right public Nodeint data this.data data GoalKicker.com Java Notes for Professionals 507 We can traverse the tree constructed by connecting multiple Node classs object like below, the traversal is called in-order traversal of tree. public static void inOrderTraversal Node root if root ! null inOrderTraversal root.left traverse left sub tree System.out.printroot.data traverse current node inOrderTraversal root.right traverse right sub tree As demonstrated above, using recursion we can traverse the tree data structure without using any other data": "input.pdf", "structure which is not possible with the iterative approach. Section 85.8 Reverse a string using Recursion Below is a recursive code to reverse a string Just a snippet to explain the idea of recursion public class Reverse public static void main String args String string hello world System.out.printlnreversestring prints dlrow olleh public static String reverse String s if s.length 1 return s return reverse s.substring 1 s.charAt0 Section 85.9 Computing the sum of integers from 1 to N The following method computes the sum of integers from 0 to N using recursion. public int sumfinal int n if n 0 return n sumn - 1 else return n This method is ON and can be reduced to a simple loop using tail-call optimization. In fact there is a closed form expression that computes the sum in O1 operations. GoalKicker.com Java Notes for Professionals 508Chapter 86 Converting to and from Strings Section 86.1 Converting String to other datatypes You can convert a numeric string to various Java numeric types as follows String to int String number 12 int num Integer.parseInt number String to \ufb02oat String number 12.0 float num Float.parseFloat number String to double String double 1.47 double num Double.parseDouble": "input.pdf", "double String to boolean String falseString False boolean falseBool Boolean.parseBoolean falseString falseBool false String trueString True boolean trueBool Boolean.parseBoolean trueString trueBool true String to long String number 47 long num Long.parseLong number String to BigInteger String bigNumber 21 BigInteger reallyBig new BigInteger bigNumber String to BigDecimal String bigFraction 17.21455 BigDecimal reallyBig new BigDecimal bigFraction Conversion Exceptions The numeric conversions above will all throw an unchecked NumberFormatException if you attempt to parse a string that is not a suitably formatted number, or is out of range for the target type. The Exceptions topic discusses how to deal with such exceptions. If you wanted to test that you can parse a string, you could implement a tryParse... method like this GoalKicker.com Java Notes for Professionals 509boolean tryParseInt String value try String somechar Integer.parseInt value return true catch NumberFormatException e return false However, calling this tryParse... method immediately before parsing is arguably poor practice. It would be better to just call the parse... method and deal with the exception. Section 86.2 Conversion to from bytes To encode a string into a byte array, you can simply use the StringgetBytes method, with one of the standard character sets available on any Java runtime": "input.pdf", "byte bytes test.getBytes StandardCharsets. UTF8 and to decode String testString new Stringbytes, StandardCharsets. UTF8 you can further simplify the call by using a static import import static java.nio.charset.StandardCharsets .UTF8 ... byte bytes test.getBytes UTF8 For less common character sets you can indicate the character set with a string byte bytes test.getBytes UTF-8 and the reverse String testString new String bytes, UTF-8 this does however mean that you have to handle the checked UnsupportedCharsetException . The following call will use the default character set. The default character set is platform speci\ufb01c and generally di\ufb00ers between Windows, Mac and Linux platforms. byte bytes test.getBytes and the reverse String testString new Stringbytes Note that invalid characters and bytes may be replaced or skipped by these methods. For more control - for instance for validating input - youre encouraged to use the CharsetEncoder and CharsetDecoder classes. Section 86.3 Base64 Encoding Decoding Occasionally you will \ufb01nd the need to encode binary data as a base64 -encoded string. GoalKicker.com Java Notes for Professionals 510For this we can use the DatatypeConverter class from the javax.xml.bind package import javax.xml.bind.DatatypeConverter import java.util.Arrays arbitrary binary data specified as a byte array byte binaryData some arbitrary data .getBytes UTF-8 convert": "input.pdf", "the binary data to the base64-encoded string String encodedData DatatypeConverter. printBase64Binary binaryData encodedData is now c29tZSBhcmJpdHJhcnkgZGF0YQ convert the base64-encoded string back to a byte array byte decodedData DatatypeConverter. parseBase64Binary encodedData assert that the original data and the decoded data are equal assert Arrays.equalsbinaryData, decodedData Apache commons-codec Alternatively, we can use Base64 from Apache commons-codec . import org.apache.commons.codec.binary.Base64 your blob of binary as a byte array byte blob someBinaryData .getBytes use the Base64 class to encode String binaryAsAString Base64. encodeBase64String blob use the Base64 class to decode byte blob2 Base64. decodeBase64 binaryAsAString assert that the two blobs are equal System.out.printlnEqual Boolean.toString Arrays.equalsblob, blob2 If you inspect this program wile running, you will see that someBinaryData encodes to c29tZUJpbmFyeURhdGE , a very managable UTF-8 String object. Version Java SE 8 Details for the same can be found at Base64 encode with padding String encoded Base64. getEncoder .encodeToString someByteArray encode without padding String encoded Base64. getEncoder .withoutPadding .encodeToString someByteArray decode a String byte barr Base64. getDecoder .decodeencoded Reference Section 86.4 Converting other datatypes to String GoalKicker.com Java Notes for Professionals 511You can get the value of other primitive data types as a String using one the String classs valueOf methods. For example": "input.pdf", "int i 42 String string String.valueOfi string now equals 42 . This method is also overloaded for other datatypes, such as float , double , boolean , and even Object . You can also get any other Object any instance of any class as a String by calling .toString on it. For this to give useful output, the class must override toString . Most of the standard Java library classes do, such as Date and others. For example Foo foo new Foo Any class. String stringifiedFoo foo.toString . Here stringifiedFoo contains a representation of foo as a String. You can also convert any number type to String with short notation like below. int i 10 String str i Or just simple way is String str 10 Section 86.5 Getting a String from an InputStream A String can be read from an InputStream using the byte array constructor. import java.io. public String readString InputStream input throws IOException byte bytes new byte50 supply the length of the string in bytes here input. readbytes return new Stringbytes This uses the system default charset, although an alternate charset may be speci\ufb01ed return new Stringbytes, Charset. forNameUTF-8 GoalKicker.com Java Notes for Professionals 512Chapter 87": "input.pdf", "Random Number Generation Section 87.1 Pseudo Random Numbers Java provides, as part of the utils package, a basic pseudo-random number generator, appropriately named Random . This object can be used to generate a pseudo-random value as any of the built-in numerical datatypes int, float , etc. You can also use it to generate a random Boolean value, or a random array of bytes. An example usage is as follows import java.util.Random ... Random random new Random int randInt random. nextInt long randLong random. nextLong double randDouble random. nextDouble This returns a value between 0.0 and 1.0 float randFloat random. nextFloat Same as nextDouble byte randBytes new byte16 random.nextBytes randBytes nextBytes takes a user-supplied byte array, and fills it with random bytes. It returns nothing. NOTE This class only produces fairly low-quality pseudo-random numbers, and should never be used to generate random numbers for cryptographic operations or other situations where higher-quality randomness is critical For that, you would want to use the SecureRandom class, as noted below. An explanation for the distinction between secure and insecure randomness is beyond the scope of this example. Section 87.2 Pseudo Random Numbers in Speci\ufb01c Range The method nextIntint bound of Random accepts an": "input.pdf", "upper exclusive boundary, i.e. a number that the returned random value must be less than. However, only the nextInt method accepts a bound nextLong , nextDouble etc. do not. Random random new Random random.nextInt1000 0 - 999 int number 10 random. nextInt100 number is in the range of 10 to 109 Starting in Java 1.7, you may also use ThreadLocalRandom source . This class provides a thread-safe PRNG pseudo- random number generator. Note that the nextInt method of this class accepts both an upper and lower bound. import java.util.concurrent.ThreadLocalRandom nextInt is normally exclusive of the top value, so add 1 to make it inclusive ThreadLocalRandom. current.nextIntmin, max 1 Note that the o\ufb03cial documentation states that nextIntint bound can do weird things when bound is near 2301 emphasis added The algorithm is slightly tricky. It rejects values that would result in an uneven distribution due to the fact that 231 is not divisible by n. The probability of a value being rejected depends on n. The worst GoalKicker.com Java Notes for Professionals 513case is n2301, for which the probability of a reject is 12, and the expected number of iterations before the loop terminates is 2. In other words, specifying": "input.pdf", "a bound will slightly decrease the performance of the nextInt method, and this performance decrease will become more pronounced as the bound approaches half the max int value. Section 87.3 Generating cryptographically secure pseudorandom numbers Random and ThreadLocalRandom are good enough for everyday use, but they have a big problem They are based on a linear congruential generator , an algorithm whose output can be predicted rather easily. Thus, these two classes are not suitable for cryptographic uses such as key generation. One can use java.security .SecureRandom in situations where a PRNG with an output that is very hard to predict is required. Predicting the random numbers created by instances of this class is hard enough to label the class as cryptographically secure . import java.security.SecureRandom import java.util.Arrays public class Foo public static void mainString args SecureRandom rng new SecureRandom byte randomBytes new byte64 rng. nextBytes randomBytes Fills randomBytes with random bytes duh System.out.printlnArrays.toString randomBytes Besides being cryptographically secure, SecureRandom has a gigantic period of 2160, compared to Random s period of 248. It has one drawback of being considerably slower than Random and other linear PRNGs such as Mersenne Twister and Xorshift , however. Note that SecureRandom implementation": "input.pdf", "is both platform and provider dependent. The default SecureRandom given by SUN provider in sun.security .provider .SecureRandom on Unix-like systems, seeded with data from devrandom andor devurandom . on Windows, seeded with calls to CryptGenRandom in CryptoAPI . Section 87.4 Generating Random Numbers with a Speci\ufb01ed Seed Creates a Random instance with a seed of 12345. Random random new Random12345L Gets a ThreadLocalRandom instance ThreadLocalRandom tlr ThreadLocalRandom. current Set the instances seed. tlr.setSeed12345L Using the same seed to generate random numbers will return the same numbers every time, so setting a di\ufb00erent seed for every Random instance is a good idea if you dont want to end up with duplicate numbers. GoalKicker.com Java Notes for Professionals 514A good method to get a Long that is di\ufb00erent for every call is System.currentTimeMillis Random random new RandomSystem.currentTimeMillis ThreadLocalRandom. current.setSeedSystem.currentTimeMillis Section 87.5 Select random numbers without duplicates returns a array of random numbers with no duplicates param range the range of possible numbers for ex. if 100 then it can be anywhere from 1-100 param length the length of the array of random numbers return array of random numbers with no duplicates. public static int getRandomNumbersWithNoDuplicates int range, int length if lengthrange": "input.pdf", "this is where all the random numbers int randomNumbers new intlength loop through all the random numbers to set them for int q 0 q randomNumbers. length q get the remaining possible numbers int remainingNumbers range-q get a new random number from the remainingNumbers int newRandSpot int Math.randomremainingNumbers newRandSpot loop through all the possible numbers for int t 1 t range1 t check to see if this number has already been taken boolean taken false for int number randomNumbers if tnumber taken true break if it hasnt been taken then remove one from the spots if !taken newRandSpot -- if we have gone though all the spots then set the value if newRandSpot 0 randomNumbers q t return randomNumbers else invalid cant have a length larger then the range of possible numbers return null The method works by looping though an array that has the size of the requested length and \ufb01nds the remaining GoalKicker.com Java Notes for Professionals 515length of possible numbers. It sets a random number of those possible numbers newRandSpot and \ufb01nds that number within the non taken number left. It does this by looping through the range and checking to see if that number has": "input.pdf", "already been taken. For example if the range is 5 and the length is 3 and we have already chosen the number 2. Then we have 4 remaining numbers so we get a random number between 1 and 4 and we loop through the range5 skipping over any numbers that we have already used2. Now lets say the next number chosen between 1 4 is 3. On the \ufb01rst loop we get 1 which has not yet been taken so we can remove 1 from 3 making it 2. Now on the second loop we get 2 which has been taken so we do nothing. We follow this pattern until we get to 4 where once we remove 1 it becomes 0 so we set the new randomNumber to 4. Section 87.6 Generating Random number using apache- common lang3 We can use org.apache.commons.lang3.RandomUtils to generate random numbers using a single line. int x RandomUtils. nextInt1, 1000 The method nextIntint startInclusive, int endExclusive takes a range. Apart from int, we can generate random long , double , float and bytes using this class. RandomUtils class contains the following methods- static byte nextBytes int count Creates an array of random bytes.": "input.pdf", "static double nextDouble Returns a random double within 0 - Double.MAXVALUE static double nextDouble double startInclusive, double endInclusive Returns a random double within the specified range. static float nextFloat Returns a random float within 0 - Float.MAXVALUE static float nextFloat float startInclusive, float endInclusive Returns a random float within the specified range. static int nextInt Returns a random int within 0 - Integer.MAXVALUE static int nextInt int startInclusive, int endExclusive Returns a random integer within the specified range. static long nextLong Returns a random long within 0 - Long.MAXVALUE static long nextLong long startInclusive, long endExclusive Returns a random long within the specified range. GoalKicker.com Java Notes for Professionals 516Chapter 88 Singletons A singleton is a class that only ever has one single instance. For more information on the Singleton design pattern , please refer to the Singleton topic in the Design Patterns tag. Section 88.1 Enum Singleton Version Java SE 5 public enum Singleton INSTANCE public void execute String arg Perform operation here Enums have private constructors, are \ufb01nal and provide proper serialization machinery. They are also very concise and lazily initialized in a thread safe manner. The JVM provides a guarantee that enum values will not be": "input.pdf", "instantiated more than once each, which gives the enum singleton pattern a very strong defense against re\ufb02ection attacks. What the enum pattern doesnt protect against is other developers physically adding more elements to the source code. Consequently, if you choose this implementation style for your singletons it is imperative that you very clearly document that no new values should be added to those enums. This is the recommended way of implementing the singleton pattern, as explained by Joshua Bloch in E\ufb00ective Java. Section 88.2 Singleton without use of Enum eager initialization public class Singleton private static final Singleton INSTANCE new Singleton private Singleton public static Singleton getInstance return INSTANCE It can be argued that this example is e\ufb00ectively lazy initialization. Section 12.4.1 of the Java Language Speci\ufb01cation states A class or interface type T will be initialized immediately before the \ufb01rst occurrence of any one of the following T is a class and an instance of T is created T is a class and a static method declared by T is invoked A static \ufb01eld declared by T is assigned A static \ufb01eld declared by T is used and the \ufb01eld is not a constant variable T is a": "input.pdf", "top level class, and an assert statement lexically nested within T is executed. GoalKicker.com Java Notes for Professionals 517Therefore, as long as there are no other static \ufb01elds or static methods in the class, the Singleton instance will not be initialized until the method getInstance is invoked the \ufb01rst time. Section 88.3 Thread-safe lazy initialization using holder class Bill Pugh Singleton implementation public class Singleton private static class InstanceHolder static final Singleton INSTANCE new Singleton public static Singleton getInstance return InstanceHolder. INSTANCE private Singleton This initializes the INSTANCE variable on the \ufb01rst call to Singleton. getInstance , taking advantage of the languages thread safety guarantees for static initialization without requiring additional synchronization. This implementation is also known as Bill Pugh singleton pattern. Wiki Section 88.4 Thread safe Singleton with double checked locking This type of Singleton is thread safe, and prevents unnecessary locking after the Singleton instance has been created. Version Java SE 5 public class MySingleton instance of class private static volatile MySingleton instance null Private constructor private MySingleton Some code for constructing object public static MySingleton getInstance MySingleton result instance If the instance already exists, no locking is necessary ifresult null The singleton instance doesnt exist, lock": "input.pdf", "and check again synchronized MySingleton. class result instance ifresult null instance result new MySingleton return result It must be emphasized -- in versions prior to Java SE 5, the implementation above is incorrect and should be GoalKicker.com Java Notes for Professionals 518avoided. It is not possible to implement double-checked locking correctly in Java prior to Java 5. Section 88.5 Extending singleton singleton inheritance In this example, base class Singleton provides getMessage method that returns Hello world! message. Its subclasses UppercaseSingleton and LowercaseSingleton override getMessage method to provide appropriate representation of the message. Yeah, well need reflection to pull this off. import java.lang.reflect. Enumeration that represents possible classes of singleton instance. If unknown, well go with base class - Singleton. enum SingletonKind UNKNOWN, LOWERCASE, UPPERCASE Base class class Singleton Extended classes has to be private inner classes, to prevent extending them in uncontrolled manner. private class UppercaseSingleton extends Singleton private UppercaseSingleton super Override public String getMessage return super.getMessage .toUpperCase Another extended class. private class LowercaseSingleton extends Singleton private LowercaseSingleton super Override public String getMessage return super.getMessage .toLowerCase Applying Singleton pattern private static SingletonKind kind SingletonKind. UNKNOWN private static Singleton instance By using this method prior to getInstance method, you effectively": "input.pdf", "change the GoalKicker.com Java Notes for Professionals 519 type of singleton instance to be created. public static void setKind SingletonKind kind Singleton. kind kind If needed, getInstance creates instance appropriate class, based on value of singletonKind field. public static Singleton getInstance throws NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException ifinstance null synchronized Singleton. class ifinstance null Singleton singleton new Singleton switch kind case UNKNOWN instance singleton break case LOWERCASE I cant use simple instance new LowercaseSingleton because java compiler wont allow me to use constructor of inner class in static context, so I use reflection API instead. To be able to access inner class by reflection API, I have to create instance of outer class first. Therefore, in this implementation, Singleton cannot be abstract class. Get the constructor of inner class. Constructor LowercaseSingleton lcConstructor LowercaseSingleton. class.getDeclaredConstructor Singleton. class The constructor is private, so I have to make it accessible. lcConstructor. setAccessible true Use the constructor to create instance. instance lcConstructor. newInstance singleton break case UPPERCASE Same goes here, just with different type Constructor UppercaseSingleton ucConstructor UppercaseSingleton. class.getDeclaredConstructor Singleton. class GoalKicker.com Java Notes for Professionals 520 ucConstructor. setAccessible true instance ucConstructor. newInstance singleton return instance Singletons state that is to": "input.pdf", "be used by subclasses protected String message Private constructor prevents external instantiation. private Singleton message Hello world! Singletons API. Implementation can be overwritten by subclasses. public String getMessage return message Just a small test program public class ExtendingSingletonExample public static void mainString args just uncomment one of following lines to change singleton class Singleton.setKindSingletonKind.UPPERCASE Singleton.setKindSingletonKind.LOWERCASE Singleton singleton null try singleton Singleton. getInstance catch NoSuchMethodException e e. printStackTrace catch IllegalAccessException e e. printStackTrace catch InvocationTargetException e e. printStackTrace catch InstantiationException e e. printStackTrace System.out.printlnsingleton. getMessage GoalKicker.com Java Notes for Professionals 521Chapter 89 Autoboxing Autoboxing is the automatic conversion that Java compiler makes between primitive types and their corresponding object wrapper classes. Example, converting int - Integer, double - Double... If the conversion goes the other way, this is called unboxing. Typically, this is used in Collections that cannot hold other than Objects, where boxing primitive types is needed before setting them in the collection. Section 89.1 Using int and Integer interchangeably As you use generic types with utility classes, you may often \ufb01nd that number types arent very helpful when speci\ufb01ed as the object types, as they arent equal to their primitive counterparts. ListInteger ints new ArrayList Integer Version Java": "input.pdf", "SE 7 ListInteger ints new ArrayList Fortunately, expressions that evaluate to int can be used in place of an Integer when it is needed. for int i 0 i 10 i ints. addi The ints.addi statement is equivalent to ints.addInteger.valueOfi And retains properties from IntegervalueOf such as having the same Integer objects cached by the JVM when it is within the number caching range. This also applies to byte and Byte short and Short float and Float double and Double long and Long char and Character boolean and Boolean Care must be taken, however, in ambiguous situations. Consider the following code ListInteger ints new ArrayList Integer ints.add1 ints.add2 ints.add3 ints.remove1 ints is now 1, 3 The java.util.List interface contains both a removeint index List interface method and a removeObject o method inherited from java.util.Collection . In this case no boxing takes place and removeint index is called. One more example of strange Java code behavior caused by autoboxing Integers with values in range from -128 to 127 GoalKicker.com Java Notes for Professionals 522Integer a 127 Integer b 127 Integer c 128 Integer d 128 System.out.printlna b true System.out.printlnc d true System.out.printlnc d true System.out.printlnc d false This happens because": "input.pdf", "operator implicitly calls intValue which returns int while compares references , not the int values. By default, Java caches values in range -128, 127, so the operator works because the Integers in this range reference to the same objects if their values are same. Maximal value of the cacheable range can be de\ufb01ned with - XXAutoBoxCacheMax JVM option. So, if you run the program with -XXAutoBoxCacheMax 1000 , the following code will print true Integer a 1000 Integer b 1000 System.out.printlna b true Section 89.2 Auto-unboxing may lead to NullPointerException This code compiles Integer arg null int x arg But it will crash at runtime with a java.lang.NullPointerException on the second line. The problem is that a primitive int cannot have a null value. This is a minimalistic example, but in practice it often manifests in more sophisticated forms. The NullPointerException is not very intuitive and is often little help in locating such bugs. Rely on autoboxing and auto-unboxing with care, make sure that unboxed values will not have null values at runtime. Section 89.3 Using Boolean in if statement Due to auto unboxing, one can use a Boolean in an if statement Boolean a Boolean.TRUE if a a": "input.pdf", "gets converted to boolean System.out.printlnIt works! That works for while , do while and the condition in the for statements as well. Note that, if the Boolean is null , a NullPointerException will be thrown in the conversion. Section 89.4 Dierent Cases When Integer and int can be used interchangeably Case 1 While using in the place of method arguments. GoalKicker.com Java Notes for Professionals 523If a method requires an object of wrapper class as argument.Then interchangeably the argument can be passed a variable of the respective primitive type and vice versa. Example int i Integer j void exmethod Integer iIs a valid statement void exmethod1 int jIs a valid statement Case 2 While passing return values When a method returns a primitive type variable then an object of corresponding wrapper class can be passed as the return value interchangeably and vice versa. Example int i Integer j int exmethod ... return jIs a valid statement Integer exmethod1 ... return iIs a valid statement Case 3 While performing operations. Whenever performing operations on numbers the primitive type variable and object of respective wrapper class can be used interchangeably. int i5 Integer jnew Integer7 int kijIs a valid statement Integer": "input.pdf", "mijIs also a valid statement Pitfall Remember to initialize or assign a value to an object of the wrapper class. While using wrapper class object and primitive variable interchangeably never forget or miss to initialize or assign a value to the wrapper class object else it may lead to null pointer exception at runtime. Example public class Test Integer i int j public void met jiNull pointer exception SOPj SOPi public static void mainString args Test tnew Test t.goNull pointer exception In the above example, the value of the object is unassigned and uninitialized and thus at runtime the program will GoalKicker.com Java Notes for Professionals 524run into null pointer exception.So as clear from the above example the value of object should never be left uninitialized and unassigned. Section 89.5 Memory and Computational Overhead of Autoboxing Autoboxing can come at a substantial memory overhead. For example MapInteger, Integer square new HashMap Integer, Integer forint i 256 i 1024 i square. puti, i i Autoboxing of large integers will typically consume substantial amount of memory about 60kb for 6k of actual data. Furthermore, boxed integers usually require additional round-trips in the memory, and thus make CPU caches less e\ufb00ective. In": "input.pdf", "above example, the memory accessed is spread out to \ufb01ve di\ufb00erent locations that may be in entirely di\ufb00erent regions of the memory 1. the HashMap object, 2. the maps Entry table object, 3. the Entry object, 4. the entrys key object boxing the primitive key, 5. the entrys value object boxing the primitive value. class Example int primitive Stored directly in the class Example Integer boxed Reference to another memory location Reading boxed requires two memory accesses, accessing primitive only one. When getting data from this map, the seemingly innocent code int sumOfSquares 0 forint i 256 i 1024 i sumOfSquares square. geti is equivalent to int sumOfSquares 0 forint i 256 i 1024 i sumOfSquares square. getInteger.valueOfi.intValue Typically, the above code causes the creation and garbage collection of an Integer object for every MapgetInteger operation. See Note below for more details. To reduce this overhead, several libraries o\ufb00er optimized collections for primitive types that do not require boxing. In addition to avoiding the boxing overhead, these collection will require about 4x less memory per entry. While Java Hotspot may be able to optimize the autoboxing by working with objects on the stack instead of the heap, it is": "input.pdf", "not possible to optimize the memory overhead and resulting memory indirection. Java 8 streams also have optimized interfaces for primitive data types, such as IntStream that do not require boxing. Note a typical Java runtime maintains a simple cache of Integer and other primitive wrapper object that is used by the valueOf factory methods, and by autoboxing. For Integer , the default range of this cache is -128 to 127. Some JVMs provide a JVM command-line option for changing the cache size range. GoalKicker.com Java Notes for Professionals 525Chapter 90 2D Graphics in Java Graphics are visual images or designs on some surface, such as a wall, canvas, screen, paper, or stone to inform, illustrate, or entertain. It includes pictorial representation of data, as in computer-aided design and manufacture, in typesetting and the graphic arts, and in educational and recreational software. Images that are generated by a computer are called computer graphics. The Java 2D API is powerful and complex. There are multiple ways to do 2D graphics in Java. Section 90.1 Example 1 Draw and Fill a Rectangle Using Java This is an Example which print rectangle and \ufb01ll color in the rectangle. httpsi.stack.imgur.comdlC5v.jpg Most methods of the": "input.pdf", "Graphics class can be divided into two basic groups Draw and \ufb01ll methods, enabling you to render basic shapes, text, and images1. Attributes setting methods, which a\ufb00ect how that drawing and \ufb01lling appears2. Code Example Let us start this with a little example of drawing a rectangle and \ufb01lling color in it. There we declare two classes, one class is MyPanel and other Class is Test. In class MyPanel we use drawRect \ufb01llRect mathods to draw rectangle and \ufb01ll Color in it. We set the color by setColorColor.blue method. In Second Class we Test our graphic which is Test Class we make a Frame and put MyPanel with pnew MyPanel object in it.By running Test Class we see a Rectangle and a Blue Color Filled Rectangle. First Class MyPanel import javax.swing. import java.awt. MyPanel extends JPanel, which will eventually be placed in a JFrame public class MyPanel extends JPanel custom painting is performed by the paintComponent method Override public void paintComponent Graphics g GoalKicker.com Java Notes for Professionals 526 clear the previous painting super.paintComponent g cast Graphics to Graphics2D Graphics2D g2 Graphics2D g g2. setColor Color.red sets Graphics2D color draw the rectangle g2. drawRect 0,0,100,100 drawRectx-position, y-position, width, height": "input.pdf", "g2. setColor Color.blue g2. fillRect 200,0,100,100 fill new rectangle with color blue Second Class Test import javax.swing. import java.awt. public class Test the Class by which we display our rectangle JFrame f MyPanel p public Test f new JFrame get the content area of Panel. Container c f.getContentPane set the LayoutManager c. setLayout new BorderLayout p new MyPanel add MyPanel object into container c. addp set the size of the JFrame f. setSize400,400 make the JFrame visible f. setVisible true sets close behavior EXITONCLOSE invokes System.exit0 on closing the JFrame f. setDefaultCloseOperation JFrame.EXITONCLOSE public static void mainString args Test t new Test For More Explanation about Border Layout httpsdocs.oracle.comjavasetutorialuiswinglayoutborder.html paintComponent It is a main method for painting By default, it \ufb01rst paints the background After that, it performs custom painting drawing circle, rectangles etc. Graphic2D refers Graphic2D Class Note The Java 2D API enables you to easily perform the following tasks Draw lines, rectangles and any other geometric shape. Fill those shapes with solid colors or gradients and textures. Draw text with options for \ufb01ne control over the font and rendering process. Draw images, optionally applying \ufb01ltering operations. Apply operations such as compositing and transforming during any of the": "input.pdf", "above rendering operations. GoalKicker.com Java Notes for Professionals 527Section 90.2 Example 2 Drawing and Filling Oval import javax.swing. import java.awt. public class MyPanel extends JPanel Override public void paintComponent Graphics g clear the previous painting super.paintComponent g Graphics2D g2 Graphics2D g g2. setColor Color.blue g2. drawOval 0, 0, 20,20 g2. fillOval 50,50,20,20 g2.drawOvalint x,int y,int height, int width This method will draw an oval at speci\ufb01ed x and y position with given height and width. g2.\ufb01llOvalint x,int y,int height, int width This method will \ufb01ll an oval at speci\ufb01ed x and y position with given height and width. GoalKicker.com Java Notes for Professionals 528Chapter 91 JAXB Parameter Details \ufb01leObjOfXML File object of an XML \ufb01le className Name of a class with .class extension JAXB or Java Architecture for XML Binding JAXB is a software framework that allows Java developers to map Java classes to XML representations. This Page will introduce readers to JAXB using detailed examples about its functions provided mainly for marshaling and un-marshaling Java Objects into xml format and vice-versa. Section 91.1 Reading an XML \ufb01le unmarshalling To read an XML \ufb01le named UserDetails. xml with the below content ?xml version1.0 encoding UTF-8 standalone yes? user nameJon": "input.pdf", "Skeet name userID8884321userID user We need a POJO class named User.java as below import javax.xml.bind.annotation.XmlRootElement XmlRootElement public class User private long userID private String name getters and setters Here we have created the variables and class name according to the XML nodes. To map them, we use the annotation XmlRootElement on the class. public class XMLReader public static void mainString args try User user JAXB.unmarshal new FileUserDetails.xml , User.class System.out.printlnuser.getName prints Jon Skeet System.out.printlnuser.getUserID prints 8884321 catch Exception e System.err.printlnException occurred while reading the XML! Here unmarshal method is used to parse the XML \ufb01le. It takes the XML \ufb01le name and the class type as two arguments. Then we can use the getter methods of the object to print the data. Section 91.2 Writing an XML \ufb01le marshalling an object import javax.xml.bind.annotation.XmlRootElement GoalKicker.com Java Notes for Professionals 529XmlRootElement public class User private long userID private String name getters and setters By using the annotation XMLRootElement , we can mark a class as a root element of an XML \ufb01le. import java.io.File import javax.xml.bind.JAXB public class XMLCreator public static void mainString args User user new User user. setNameJon Skeet user. setUserID 8884321 try JAXB. marshaluser, new FileUserDetails.xml catch Exception": "input.pdf", "e System.err.printlnException occurred while writing in XML! finally System.out.printlnXML created marshal is used to write the objects content into an XML \ufb01le. Here user object and a new File object are passed as arguments to the marshal. On successful execution, this creates an XML \ufb01le named UserDetails. xml in the class-path with the below content. ?xml version1.0 encoding UTF-8 standalone yes? user nameJon Skeet name userID8884321userID user Section 91.3 Manual \ufb01eldproperty XML mapping con\ufb01guration Annotations XmlElement , XmlAttribute or XmlTransient and other in package javax.xml.bind.annotation allow the programmer to specify which and how marked \ufb01elds or properties should be serialized. XmlAccessorType XmlAccessType. NONE we want no automatic fieldproperty marshalling public class ManualXmlElementsExample XmlElement private String fieldfield value XmlAttribute private String attribute attr value XmlAttribute namedifferentAttribute private String oneAttribute other attr value GoalKicker.com Java Notes for Professionals 530 XmlElement namedifferent name private String oneName different name value XmlTransient private String transientField will not get serialized ever XmlElement public String getModifiedTransientValue return transientField. replace ever, , unless in a getter public void setModifiedTransientValue String val empty on purpose public static void mainString args try JAXB. marshalnew ManualXmlElementsExample , System.out catch Exception e System.err.printlnException occurred while writing in XML! Section 91.4 Binding": "input.pdf", "an XML namespace to a serializable Java class This is an example of a package-info.java \ufb01le that binds an XML namespace to a serializable Java class. This should be placed in the same package as the Java classes that should be serialized using the namespace. A package containing serializable classes. XmlSchema xmlns XmlNs prefix MySerializableClass. NAMESPACEPREFIX , namespaceURI MySerializableClass. NAMESPACE , namespace MySerializableClass. NAMESPACE , elementFormDefault XmlNsForm. QUALIFIED package com.test.jaxb import javax.xml.bind.annotation.XmlNs import javax.xml.bind.annotation.XmlNsForm import javax.xml.bind.annotation.XmlSchema Section 91.5 Using XmlAdapter to generate desired xml format When desired XML format di\ufb00ers from Java object model, an XmlAdapter implementation can be used to transform model object into xml-format object and vice versa. This example demonstrates how to put a \ufb01elds value into an attribute of an element with \ufb01elds name. public class XmlAdapterExample GoalKicker.com Java Notes for Professionals 531 XmlAccessorType XmlAccessType. FIELD public static class NodeValueElement XmlAttribute nameattrValue String value public NodeValueElement public NodeValueElement String value super this.value value public String getValue return value public void setValue String value this.value value public static class ValueAsAttrXmlAdapter extends XmlAdapter NodeValueElement, String Override public NodeValueElement marshal String v throws Exception return new NodeValueElement v Override public String unmarshal NodeValueElement v throws Exception if vnull": "input.pdf", "return return v.getValue XmlRootElement nameDataObject XmlAccessorType XmlAccessType. FIELD public static class DataObject String elementWithValue XmlJavaTypeAdapter valueValueAsAttrXmlAdapter. class String elementWithAttribute public static void mainString args DataObject data new DataObject data. elementWithValue value1 data. elementWithAttribute value2 ByteArrayOutputStream baos new ByteArrayOutputStream JAXB. marshaldata, baos String xmlString new Stringbaos.toByteArray , StandardCharsets. UTF8 System.out.printlnxmlString GoalKicker.com Java Notes for Professionals 532Section 91.6 Using XmlAdapter to trim string package com.example.xml.adapters import javax.xml.bind.annotation.adapters.XmlAdapter public class StringTrimAdapter extends XmlAdapter String, String Override public String unmarshal String v throws Exception if v null return null return v.trim Override public String marshal String v throws Exception if v null return null return v.trim And in package-info.java add following declaration. XmlJavaTypeAdapter value com.example.xml.adapters .StringTrimAdapter .class, type String.class package com.example.xml.jaxb.bindings Packge where you intend to apply trimming filter import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter Section 91.7 Automatic \ufb01eldproperty XML mapping con\ufb01guration XmlAccessorType Annotation XmlAccessorType determines whether \ufb01eldsproperties will be automatically serialized to XML. Note, that \ufb01eld and method annotations XmlElement , XmlAttribute or XmlTransient take precedence over the default settings. public class XmlAccessTypeExample XmlAccessorType XmlAccessType. FIELD static class AccessorExampleField public String fieldvalue1 public String getGetter return getter public void setGetter String value XmlAccessorType XmlAccessType. NONE static class AccessorExampleNone public String fieldvalue1 public String getGetter return getter": "input.pdf", "public void setGetter String value GoalKicker.com Java Notes for Professionals 533XmlAccessorType XmlAccessType. PROPERTY static class AccessorExampleProperty public String fieldvalue1 public String getGetter return getter public void setGetter String value XmlAccessorType XmlAccessType. PUBLICMEMBER static class AccessorExamplePublic public String fieldvalue1 public String getGetter return getter public void setGetter String value public static void mainString args try System.out.printlnnField JAXB. marshalnew AccessorExampleField , System.out System.out.printlnnNone JAXB. marshalnew AccessorExampleNone , System.out System.out.printlnnProperty JAXB. marshalnew AccessorExampleProperty , System.out System.out.printlnnPublic JAXB. marshalnew AccessorExamplePublic , System.out catch Exception e System.err.printlnException occurred while writing in XML! outer class end Output Field ?xml version1.0 encodingUTF-8 standaloneyes? value1 None ?xml version1.0 encodingUTF-8 standaloneyes? Property ?xml version1.0 encodingUTF-8 standaloneyes? getter Public ?xml version1.0 encodingUTF-8 standaloneyes? value1 GoalKicker.com Java Notes for Professionals 534getter Section 91.8 Specifying a XmlAdapter instance to reuse existing data Sometimes speci\ufb01c instances of data should be used. Recreation is not desired and referencing static data would have a code smell. It is possible to specify a XmlAdapter instance the Unmarshaller should use, which allows the user to use XmlAdapter s with no zero-arg constructor andor pass data to the adapter. Example User class The following class contains a name and a users image. import java.awt.image.BufferedImage import javax.xml.bind.annotation.XmlAttribute import": "input.pdf", "javax.xml.bind.annotation.XmlRootElement import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter XmlRootElement public class User private String name private BufferedImage image XmlAttribute public String getName return name public void setName String name this.name name XmlJavaTypeAdapter valueImageCacheAdapter. class XmlAttribute public BufferedImage getImage return image public void setImage BufferedImage image this.image image public UserString name, BufferedImage image this.name name this.image image public User this, null Adapter GoalKicker.com Java Notes for Professionals 535To avoid creating the same image in memory twice as well as downloading the data again, the adapter stores the images in a map. Version Java SE 7 For valid Java 7 code replace the getImage method with public BufferedImage getImage URL url BufferedImage image imageCache. geturl if image null try image ImageIO. readurl catch IOException ex Logger. getLogger ImageCacheAdapter. class.getName.logLevel.SEVERE, null, ex return null imageCache. puturl, image reverseIndex. putimage, url return image import java.awt.image.BufferedImage import java.io.IOException import java.net.URL import java.util.HashMap import java.util.Map import java.util.logging.Level import java.util.logging.Logger import javax.imageio.ImageIO import javax.xml.bind.annotation.adapters.XmlAdapter public class ImageCacheAdapter extends XmlAdapter String, BufferedImage private final MapURL, BufferedImage imageCache new HashMap private final MapBufferedImage , URL reverseIndex new HashMap public BufferedImage getImage URL url using a single lookup using Java 8 methods return imageCache. computeIfAbsent url, s - try BufferedImage img ImageIO. reads reverseIndex.": "input.pdf", "putimg, s return img catch IOException ex Logger. getLogger ImageCacheAdapter. class.getName.logLevel.SEVERE, null, ex return null Override public BufferedImage unmarshal String v throws Exception return getImage new URLv Override public String marshal BufferedImage v throws Exception return reverseIndex. getv.toExternalForm GoalKicker.com Java Notes for Professionals 536 Example XMLs The following 2 xmls are for Jon Skeet and his earth 2 counterpart, which both look exactly the same and therefore use the same avatar. ?xml version1.0 encoding UTF-8? user nameJon Skeet imagehttpswww.gravatar.comavatar6d8ebb117e8d83d74ea95fbdd0f87e13?s328ampdidenticonampr PG ?xml version1.0 encoding UTF-8? user nameJon Skeet Earth 2 imagehttpswww.gravatar.comavatar6d8ebb117e8d83d74ea95fbdd0f87e13?s328ampdidenticonampr PG Using the adapter ImageCacheAdapter adapter new ImageCacheAdapter JAXBContext context JAXBContext. newInstance User.class Unmarshaller unmarshaller context. createUnmarshaller specifiy the adapter instance to use for every XmlJavaTypeAdaptervalueImageCacheAdapter.class unmarshaller. setAdapter ImageCacheAdapter. class, adapter User result1 User unmarshaller. unmarshal Main.class.getResource user.xml unmarshal second xml using the same adapter instance Unmarshaller unmarshaller2 context. createUnmarshaller unmarshaller2. setAdapter ImageCacheAdapter. class, adapter User result2 User unmarshaller2. unmarshal Main.class.getResource user2.xml System.out.printlnresult1. getName System.out.printlnresult2. getName yields true, since image is reused System.out.printlnresult1. getImage result2. getImage GoalKicker.com Java Notes for Professionals 537Chapter 92 Class - Java Re\ufb02ection The java.lang.Class class provides many methods that can be used to get metadata, examine and change the run time behavior of a": "input.pdf", "class. The java.lang and java.lang.re\ufb02ect packages provide classes for java re\ufb02ection. Where it is used The Re\ufb02ection API is mainly used in IDE Integrated Development Environment e.g. Eclipse, MyEclipse, NetBeans etc. Debugger Test Tools etc. Section 92.1 getClass method of Object class class Simple class Test void printName Object obj Class c obj.getClass System.out.printlnc.getName public static void mainString args Simple s new Simple Test t new Test t. printName s GoalKicker.com Java Notes for Professionals 538Chapter 93 Networking Section 93.1 Basic Client and Server Communication using a Socket Server Start, and wait for incoming connections Open a listening ServerSocket on port 1234. ServerSocket serverSocket new ServerSocket 1234 while true Wait for a client connection. Once a client connected, we get a Socket object that can be used to send and receive messages tofrom the newly connected client Socket clientSocket serverSocket. accept Here well add the code to handle one specific client. Server Handling clients Well handle each client in a separate thread so multiple clients could interact with the server at the same time. This technique works \ufb01ne as long as the number of clients is low 1000 clients, depending on the OS architecture and the expected load of": "input.pdf", "each thread. new Thread - Get the sockets InputStream, to read bytes from the socket InputStream in clientSocket. getInputStream wrap the InputStream in a reader so you can read a String instead of bytes BufferedReader reader new BufferedReader new InputStreamReader in, StandardCharsets. UTF8 Read text from the socket and print line by line String line while line reader. readLine ! null System.out.printlnline .start Client Connect to the server and send a message 127.0.0.1 is the address of the server this is the localhost address i.e. the address of our own machine 1234 is the port that the server will be listening on Socket socket new Socket127.0.0.1 , 1234 Write a string into the socket, and flush the buffer OutputStream outStream socket. getOutputStream PrintWriter writer new PrintWriter new OutputStreamWriter outStream, StandardCharsets. UTF8 writer.printlnHello world! writer.flush Closing Sockets and Handling Exceptions The above examples left out some things to make them easier to read. Just like \ufb01les and other external resources, its important we tell the OS when were done with them. When1. GoalKicker.com Java Notes for Professionals 539were done with a socket, call socket.close to properly close it. Sockets handle IO InputOutput operations that depend on a variety of external": "input.pdf", "factors. For example what2. if the other side suddenly disconnects? What if there are network error? These things are beyond our control. This is why many socket operations might throw exceptions, especially IOException . A more complete code for the client would therefore be something like this try-with-resources will close the socket once we leave its scope try Socket socket new Socket127.0.0.1 , 1234 OutputStream outStream socket. getOutputStream PrintWriter writer new PrintWriter new OutputStreamWriter outStream, StandardCharsets. UTF8 writer. printlnHello world! writer. flush catch IOException e Handle the error Basic Server and Client - complete examples Server import java.io.BufferedReader import java.io.IOException import java.io.InputStream import java.io.InputStreamReader import java.net.ServerSocket import java.net.Socket import java.nio.charset.StandardCharsets public class Server public static void mainString args try ServerSocket serverSocket new ServerSocket 1234 while true Wait for a client connection. Socket clientSocket serverSocket. accept Create and start a thread to handle the new client new Thread - try Get the sockets InputStream, to read bytes from the socket InputStream in clientSocket. getInputStream wrap the InputStream in a reader so you can read a String instead of bytes BufferedReader reader new BufferedReader new InputStreamReader in, StandardCharsets. UTF8 Read from the socket and print line by line String line while": "input.pdf", "line reader. readLine ! null System.out.printlnline catch IOException e e. printStackTrace finally This finally block ensures the socket is closed. A try-with-resources block cannot be used because the socket is passed into a thread, so it isnt GoalKicker.com Java Notes for Professionals 540 created and closed in the same block try clientSocket. close catch IOException e e. printStackTrace .start catch IOException e e. printStackTrace Client import java.io.IOException import java.io.OutputStream import java.io.OutputStreamWriter import java.io.PrintWriter import java.net.Socket import java.nio.charset.StandardCharsets public class Client public static void mainString args try Socket socket new Socket127.0.0.1 , 1234 Well reach this code once weve connected to the server Write a string into the socket, and flush the buffer OutputStream outStream socket. getOutputStream PrintWriter writer new PrintWriter new OutputStreamWriter outStream, StandardCharsets. UTF8 writer. printlnHello world! writer. flush catch IOException e Exception should be handled. e. printStackTrace Section 93.2 Basic ClientServer Communication using UDP Datagram Client.java import java.io. import java.net. public class Client public static void mainString args throws IOException DatagramSocket clientSocket new DatagramSocket InetAddress address InetAddress .getByName args0 String ex Hello, World! byte buf ex.getBytes GoalKicker.com Java Notes for Professionals 541 DatagramPacket packet new DatagramPacket buf,buf. length, address, 4160 clientSocket. sendpacket In this case, we pass": "input.pdf", "in the address of the server, via an argument args0. The port we are using is 4160. Server.java import java.io. import java.net. public class Server public static void mainString args throws IOException DatagramSocket serverSocket new DatagramSocket 4160 byte rbuf new byte256 DatagramPacket packet new DatagramPacket rbuf, rbuf. length serverSocket. receivepacket String response new Stringpacket.getData System.out.printlnResponse response On the server-side, declare a DatagramSocket on the same port which we sent our message to 4160 and wait for a response. Section 93.3 Loading TrustStore and KeyStore from InputStream public class TrustLoader public static void mainString args try Gets the inputstream of a a trust store file under sslrpgrenadesClient.jks This path refers to the ssl folder in the jar file, in a jar file in the same directory as this jar file, or a different directory in the same directory as the jar file InputStream stream TrustLoader. class.getResourceAsStream sslrpgrenadesClient.jks Both trustStores and keyStores are represented by the KeyStore object KeyStore trustStore KeyStore .getInstance KeyStore .getDefaultType The password for the trustStore char trustStorePassword password .toCharArray This loads the trust store into the object trustStore. loadstream, trustStorePassword This is defining the SSLContext so the trust store will be used Getting default SSLContext to edit.": "input.pdf", "SSLContext context SSLContext. getInstance SSL TrustMangers hold trust stores, more than one can be added TrustManagerFactory factory TrustManagerFactory. getInstance TrustManagerFactory. getDefaultAlgorithm Adds the truststore to the factory factory. inittrustStore This is passed to the SSLContext init method TrustManager managers factory. getTrustManagers context. initnull, managers, null Sets our new SSLContext to be used. SSLContext. setDefault context GoalKicker.com Java Notes for Professionals 542 catch KeyStoreException IOException NoSuchAlgorithmException CertificateException KeyManagementException ex Handle error ex. printStackTrace Intiating a KeyStore works the same, except replace any word Trust in a object name with Key. Additionally, the KeyManager array must be passed to the the \ufb01rst argument of SSLContext. init . That is SSLContext. initkeyMangers, trustMangers, null Section 93.4 Socket example - reading a web page using a simple socket import java.io. import java.net.Socket public class Main public static void mainString args throws IOException We dont handle Exceptions in this example Open a socket to stackoverflow.com, port 80 Socket socket new Socketstackoverflow.com ,80 Prepare input, output stream before sending request OutputStream outStream socket. getOutputStream InputStream inStream socket. getInputStream BufferedReader reader new BufferedReader new InputStreamReader inStream PrintWriter writer new PrintWriter new BufferedOutputStream outStream Send a basic HTTP header writer. printGET HTTP1.1 nHoststackoverflow.com nn writer. flush Read": "input.pdf", "the response System.out.printlnreadFully reader Close the socket socket. close private static String readFully Reader in StringBuilder sb new StringBuilder int BUFFERSIZE 1024 char buffer new charBUFFERSIZE or some other size, int charsRead 0 while charsRead rd.readbuffer, 0, BUFFERSIZE ! -1 sb. appendbuffer, 0, charsRead You should get a response that starts with HTTP1.1 200 OK, which indicates a normal HTTP response, followed by the rest of the HTTP header, followed by the raw web page in HTML form. Note the readFully method is important to prevent a premature EOF exception. The last line of the web page may be missing a return, to signal the end of line, then readLine will complain, so one must read it by hand or GoalKicker.com Java Notes for Professionals 543use utility methods from Apache commons-io IOUtils This example is meant as a simple demonstration of connecting to an existing resource using a socket, its not a practical way of accessing web pages. If you need to access a web page using Java, its best to use an existing HTTP client library such as Apaches HTTP Client or Googles HTTP Client Section 93.5 Temporarily disable SSL veri\ufb01cation for testing purposes Sometimes in a development": "input.pdf", "or testing environment, the SSL certi\ufb01cate chain might not have been fully established yet. To continue developing and testing, you can turn o\ufb00 SSL veri\ufb01cation programmatically by installing an all-trusting trust manager try Create a trust manager that does not validate certificate chains TrustManager trustAllCerts new TrustManager new X509TrustManager public X509Certificate getAcceptedIssuers return null public void checkClientTrusted X509Certificate certs, String authType public void checkServerTrusted X509Certificate certs, String authType Install the all-trusting trust manager SSLContext sc SSLContext. getInstance SSL sc.initnull, trustAllCerts, new java.security .SecureRandom HttpsURLConnection. setDefaultSSLSocketFactory sc.getSocketFactory Create all-trusting host name verifier HostnameVerifier allHostsValid new HostnameVerifier public boolean verifyString hostname, SSLSession session return true Install the all-trusting host verifier HttpsURLConnection. setDefaultHostnameVerifier allHostsValid catch NoSuchAlgorithmException KeyManagementException e e.printStackTrace Section 93.6 Downloading a \ufb01le using Channel If the \ufb01le already exists, it will be overwritten! String fileName file.zip name of the file String urlToGetFrom httpwww.mywebsite.com URL to get it from String pathToSaveTo CUsersuser where to put it If the file already exists, it will be overwritten! Opening OutputStream to the destination file GoalKicker.com Java Notes for Professionals 544try ReadableByteChannel rbc Channels. newChannel new URLurlToGetFrom fileName .openStream try FileChannel channel new FileOutputStream pathToSaveTo fileName .getChannel channel. transferFrom rbc, 0, Long.MAXVALUE catch FileNotFoundException e": "input.pdf", "Output directory not found catch IOException e File IO error catch MalformedURLException e URL is malformed catch IOException e IO error connecting to website Notes Dont leave the catch blocks empty! In case of error, check if the remote \ufb01le exists This is a blocking operation, can take long time with large \ufb01les Section 93.7 Multicasting Multicasting is a type of Datagram Socket. Unlike regular Datagrams, Multicasting doesnt handle each client individually instead it sends it out to one IP Address and all subscribed clients will get the message. Example code for a server side public class Server private DatagramSocket serverSocket private String ip private int port public ServerString ip, int port throws SocketException , IOException this.ip ip this.port port socket used to send serverSocket new DatagramSocket public void send throws IOException make datagram packet byte message Multicasting... .getBytes GoalKicker.com Java Notes for Professionals 545 DatagramPacket packet new DatagramPacket message, message. length, InetAddress .getByName ip, port send packet serverSocket. sendpacket public void close serverSocket. close Example code for a client side public class Client private MulticastSocket socket public ClientString ip, int port throws IOException important that this is a multicast socket socket new MulticastSocket port join by ip socket.": "input.pdf", "joinGroup InetAddress .getByName ip public void printMessage throws IOException make datagram packet to recieve byte message new byte256 DatagramPacket packet new DatagramPacket message, message. length recieve the packet socket. receivepacket System.out.printlnnew Stringpacket.getData public void close socket. close Code for running the Server public static void mainString args try final String ip args0 final int port Integer.parseInt args1 Server server new Serverip, port server. send server. close catch IOException ex ex. printStackTrace Code for running a Client public static void mainString args try final String ip args0 GoalKicker.com Java Notes for Professionals 546 final int port Integer.parseInt args1 Client client new Clientip, port client. printMessage client. close catch IOException ex ex. printStackTrace Run the Client First The Client must subscribe to the IP before it can start receiving any packets. If you start the server and call the send method, and then make a client call printMessage . Nothing will happen because the client connected after the message was sent. GoalKicker.com Java Notes for Professionals 547Chapter 94 NIO - Networking Section 94.1 Using Selector to wait for events example with OPCONNECT NIO appeared in Java 1.4 and introduced the concept of Channels, which are supposed to be faster than regular": "input.pdf", "IO. Network-wise, the SelectableChannel is the most interesting as it allows to monitor di\ufb00erent states of the Channel. It works in a similar manner as the C SELECT system call we get woken-up when certain types of events occur connection received OPACCEPT connection realized OPCONNECT data available in read FIFO OPREAD data can be pushed to write FIFO OPWRITE It allows for separation between detecting socket IO something can be readwritten... and performing the IO readwrite.... Especially, all IO detection can be done in a single thread for multiple sockets clients, while performing IO can be handled in a thread pool or anywhere else. That allows for an application to scale easily to the number of connected clients. The following example shows the basics Create a Selector 1. Create a SocketChannel 2. Register the SocketChannel to the Selector 3. Loop with the Selector to detect events 4. Selector sel Selector .open CREATE the Selector SocketChannel sc SocketChannel .open CREATE a SocketChannel sc.configureBlocking FALSE ... non blocking sc.setOption StandardSocketOptions .SOKEEPALIVE , TRUE ... SET SOME options Register the Channel TO the Selector FOR wake-up ON CONNECT event AND USE SOME description AS an attachement sc.register sel, SelectionKey .OPCONNECT , Connection": "input.pdf", "to google.com RETURNS a SelectionKey the association BETWEEN the SocketChannel AND the Selector System.out.printlnInitiating connection IF sc.connectNEW InetSocketAddress www.google.com , 80 System .out.printlnConnected Connected right -away nothing ELSE TO do ELSE BOOLEAN exit FALSE while !exit IF sel.select100 0 Did something happen ON SOME registered Channels during the LAST 100ms? continue No, wait SOME more Something happened ... Set SelectionKey KEYS sel.selectedKeys List OF SelectionKeys ON which SOME registered operation was triggered FOR SelectionKey k KEYS System .out.printlnChecking k.attachment IF k.isConnectable CONNECT event System .out.printConnected through select on k.channel - IF sc.finishConnect Finish connection process System .out.printlndone! k .interestOps k.interestOps SelectionKey .OPCONNECT We are already connected remove interest IN CONNECT event GoalKicker.com Java Notes for Professionals 548 exit TRUE ELSE System .out.printlnunfinished... TODO ELSE IF k.isReadable ... KEYS.clear Have TO clear the selected KEYS SET once processed! System.out.printDisconnecting ... sc.shutdownOutput Initiate graceful disconnection TODO empty receive buffer sc.close System.out.printlndone Would give the following output Initiating connection Checking Connection to google.com Connected through select on java.nio.channels.SocketChannelconnection-pending remotewww.google.com216.58.208.22880 - done! Disconnecting ... done GoalKicker.com Java Notes for Professionals 549Chapter 95 HttpURLConnection Section 95.1 Get response body from a URL as a String String getText String url throws IOException HttpURLConnection connection HttpURLConnection": "input.pdf", "new URLurl.openConnection add headers to the connection, or check the status if desired.. handle error response code it occurs int responseCode conn.getResponseCode InputStream inputStream if 200 responseCode responseCode 299 inputStream connection. getInputStream else inputStream connection. getErrorStream BufferedReader in new BufferedReader new InputStreamReader inputStream StringBuilder response new StringBuilder String currentLine while currentLine in.readLine ! null response. appendcurrentLine in.close return response. toString This will download text data from the speci\ufb01ed URL, and return it as a String. How this works First, we create a HttpUrlConnection from our URL, with new URLurl.openConnection . We cast the UrlConnection this returns to a HttpUrlConnection , so we have access to things like adding headers such as User Agent, or checking the response code. This example does not do that, but its easy to add. Then, create InputStream basing on the response code for error handling Then, create a BufferedReader which allows us to read text from InputStream we get from the connection. Now, we append the text to a StringBuilder , line by line. Close the InputStream , and return the String we now have. Notes This method will throw an IoException in case of failure such as a network error, or no internet": "input.pdf", "connection, and it will also throw an unchecked MalformedUrlException if the given URL is not valid. It can be used for reading from any URL which returns text, such as webpages HTML, REST APIs which return JSON or XML, etc. See also Read URL to String in few lines of Java code . GoalKicker.com Java Notes for Professionals 550Usage Is very simple String text getText httpexample.com Do something with the text from example.com, in this case the HTML. Section 95.2 POST data public static void postString url, byte data, String contentType throws IOException HttpURLConnection connection null OutputStream out null InputStream in null try connection HttpURLConnection new URLurl.openConnection connection. setRequestProperty Content-Type , contentType connection. setDoOutput true out connection. getOutputStream out. writedata out. close in connection. getInputStream BufferedReader reader new BufferedReader new InputStreamReader in String line null while line reader. readLine ! null System.out.printlnline in. close finally if connection ! null connection. disconnect if out ! null out.close if in ! null in.close This will POST data to the speci\ufb01ed URL, then read the response line-by-line. How it works As usual we obtain the HttpURLConnection from a URL. Set the content type using setRequestProperty , by default its application x-www-form-urlencoded setDoOutput": "input.pdf", "true tells the connection that we will send data. Then we obtain the OutputStream by calling getOutputStream and write data to it. Dont forget to close it after you are done. At last we read the server response. Section 95.3 Delete resource public static void delete String urlString, String contentType throws IOException HttpURLConnection connection null try URL url new URLurlString connection HttpURLConnection url.openConnection connection. setDoInput true GoalKicker.com Java Notes for Professionals 551 connection. setRequestMethod DELETE connection. setRequestProperty Content-Type , contentType Map String, ListString map connection. getHeaderFields StringBuilder sb new StringBuilder Iterator Map.EntryString, String iterator responseHeader. entrySet .iterator whileiterator. hasNext Map.EntryString, String entry iterator. next sb. appendentry.getKey sb. append.append sb. appendentry.getValue sb. append ifiterator. hasNext sb. append,.append System.out.printlnsb.toString catch Exception e e. printStackTrace finally if connection ! null connection. disconnect This will DELETE the resource in the speci\ufb01ed URL, then print the response header. How it works we obtain the HttpURLConnection from a URL. Set the content type using setRequestProperty , by default its application x-www-form-urlencoded setDoInput true tells the connection that we intend to use the URL connection for input. setRequestMethod DELETE to perform HTTP DELETE At last we print the server response header. Section 95.4 Check if resource": "input.pdf", "exists Checks if a resource exists by sending a HEAD-Request. param url The url of a resource which has to be checked. return true if the response code is 200 OK. public static final boolean checkIfResourceExists URL url throws IOException HttpURLConnection conn HttpURLConnection url.openConnection conn. setRequestMethod HEAD int code conn.getResponseCode conn. disconnect return code 200 Explanation If you are just checking if a resource exists, it better to use a HEAD request than a GET. This avoids the overhead of transferring the resource. Note that the method only returns true if the response code is 200. If you anticipate redirect i.e. 3XX responses, then the method may need to be enhanced to honor them. GoalKicker.com Java Notes for Professionals 552Example checkIfResourceExists new URLhttpimages.google.com true checkIfResourceExists new URLhttppictures.google.com false GoalKicker.com Java Notes for Professionals 553Chapter 96 JAX-WS Section 96.1 Basic Authentication The way to do a JAX-WS call with basic authentication is a little unobvious. Here is an example where Service is the service class representation and Port is the service port you want to access. Service s new Service Port port s.getPort BindingProvider prov BindingProvider port prov.getRequestContext .putBindingProvider. USERNAMEPROPERTY , myusername prov.getRequestContext .putBindingProvider. PASSWORDPROPERTY , mypassword port.call GoalKicker.com Java": "input.pdf", "Notes for Professionals 554Chapter 97 Nashorn JavaScript engine Nashorn is a JavaScript engine developed in Java by Oracle, and has been released with Java 8. Nashorn allows embedding Javascript in Java applications via JSR-223 and allows to develop standalone Javascript applications, and it provides better runtime performance and better compliance with the ECMA normalized Javascript speci\ufb01cation. Section 97.1 Execute JavaScript \ufb01le Required imports import javax.script.ScriptEngineManager import javax.script.ScriptEngine import javax.script.ScriptException import java.io.FileReader import java.io.FileNotFoundException Obtain an instance of the JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Load and execute a script from the file demo.js try engine. evalnew FileReader demo.js catch FileNotFoundException ex ex.printStackTrace catch ScriptException ex This is the generic Exception subclass for the Scripting API ex.printStackTrace Outcome Script from file! printed on standard output demo.js printScript from file! Section 97.2 Intercept script output Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Setup a custom writer StringWriter stringWriter new StringWriter Modify the engine context so that the custom writer is now the default output writer of the engine engine.getContext .setWriter stringWriter Execute some script try engine. evalprintRedirected text! catch ScriptException ex ex.printStackTrace Outcome Nothing printed on standard output,": "input.pdf", "but GoalKicker.com Java Notes for Professionals 555 stringWriter.toString contains Redirected text! Section 97.3 Hello Nashorn Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Execute an hardcoded script try engine. evalprintHello Nashorn! catch ScriptException ex This is the generic Exception subclass for the Scripting API ex.printStackTrace Outcome Hello Nashorn! printed on standard output Section 97.4 Evaluate Arithmetic Strings Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName JavaScript String to be evaluated String str 3245 Value after doing Arithmetic operation with operator precedence will be 16 Printing the value try System.out.printlnengine.evalstr catch ScriptException ex ex.printStackTrace Outcome Value of the string after arithmetic evaluation is printed on standard output. In this case 16.0 will be printed on standard output. Section 97.5 Set global variables Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn Define a global variable engine.puttextToPrint , Data defined in Java. Print the global variable try engine. evalprinttextToPrint catch ScriptException ex ex.printStackTrace Outcome Data defined in Java. printed on standard output GoalKicker.com Java Notes for Professionals 556Section 97.6 Set and get global variables Obtain an instance of JavaScript engine ScriptEngineManager manager": "input.pdf", "new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn try Set value in the global name space of the engine engine. putname,Nashorn Execute an hardcoded script engine. evalvar valueHello name! Get value String valueStringengine.getvalue System.out.printlnvalue catch ScriptException ex This is the generic Exception subclass for the Scripting API ex.printStackTrace Outcome Hello Nashorn! printed on standard output Section 97.7 Usage of Java objects in JavaScript in Nashorn Its possible to pass Java objects to Nashorn engine to be processed in Java code. At the same time, there are some JavaScript and Nashorn speci\ufb01c constructions, and its not always clear how they work with java objects. Below there is a table which describes behaviour of native Java objects inside JavaScript constructions. Tested constructions Expression in if clause. In JS expression in if clause doesnt have to be boolean unlike Java. Its evaluated as1. false for so called falsy values null, unde\ufb01ned, 0, empty strings etc for each statement Nashorn has a special kind of loop - for each - which can iterate over di\ufb00erent JS and Java2. object. Getting object size. In JS objects have a property length, which returns size of an array or a string.3. Results Type If for each .length": "input.pdf", "Java null false No iterations Exception Java empty string false No iterations 0 Java string true Iterates over string characters Length of the string Java IntegerLong value ! 0 No iterations unde\ufb01ned Java ArrayList true Iterates over elements Length of the list Java HashMap true Iterates over values null Java HashSet true Iterates over items unde\ufb01ned Recommendatons Its advisable to use if somestring to check if a string is not null and not empty for each can be safely used to iterate over any collection, and it doesnt raise exceptions if the collection is not iterable, null or unde\ufb01ned Before getting length of an object it must be checked for null or unde\ufb01ned the same is true for any attempt of calling a method or getting a property of Java object GoalKicker.com Java Notes for Professionals 557Section 97.8 Implementing an interface from script import java.io.FileReader import java.io.IOException import javax.script.ScriptEngine import javax.script.ScriptEngineManager import javax.script.ScriptException public class InterfaceImplementationExample public static interface Pet public void eat public static void mainString args throws IOException Obtain an instance of JavaScript engine ScriptEngineManager manager new ScriptEngineManager ScriptEngine engine manager. getEngineByName nashorn try evaluate a script pet.js var Pet Java.typeInterfaceImplementationExample.Pet new Pet eat function printeat Pet": "input.pdf", "pet Pet engine. evalnew FileReader pet.js pet. eat catch ScriptException ex ex. printStackTrace Outcome eat printed on standard output GoalKicker.com Java Notes for Professionals 558Chapter 98 Java Native Interface Parameter Details JNIEnv Pointer to the JNI environment jobject The object which invoked the non- static native method jclass The class which invoked the static native method Section 98.1 Calling C methods from Java Static and member methods in Java can be marked as native to indicate that their implementation is to be found in a shared library \ufb01le. Upon execution of a native method, the JVM looks for a corresponding function in loaded libraries see Loading native libraries, using a simple name mangling scheme, performs argument conversion and stack setup, then hands over control to native code. Java code comexamplejniJNIJava.java package com.example.jni public class JNIJava static System.loadLibrary libJNICPP Obviously, native methods may not have a body defined in Java public native void printString String name public static native double average int nums public static void mainfinal String args JNIJava jniJava new JNIJava jniJava. printString Invoked C printString from Java double d average new int1, 2, 3, 4, 7 System.out.printlnGot result from C average d C code Header \ufb01les containing": "input.pdf", "native function declarations should be generated using the javah tool on target classes. Running the following command at the build directory javah -o comexamplejniJNIJava. hpp com.example.jni.JNIJava ... produces the following header \ufb01le comments stripped for brevity comexamplejniJNIJava.hpp DO NOT EDIT THIS FILE - it is machine generated include jni.h The JNI API declarations ifndef IncludedcomexamplejniJNIJava define IncludedcomexamplejniJNIJava ifdef cplusplus extern C This is absolutely required if using a C compiler endif GoalKicker.com Java Notes for Professionals 559JNIEXPORT void JNICALL JavacomexamplejniJNIJavaprintString JNIEnv , jobject, jstring JNIEXPORT jdouble JNICALL JavacomexamplejniJNIJavaaverage JNIEnv , jclass, jintArray ifdef cplusplus endif endif Here is an example implementation comexamplejniJNIJava.cpp include iostream include comexamplejniJNIJava.hpp using namespace std JNIEXPORT void JNICALL JavacomexamplejniJNIJavaprintString JNIEnv env, jobject jthis, jstring string const char stringInC env-GetStringUTFChars string, NULL if NULL stringInC return cout stringInC endl env-ReleaseStringUTFChars string, stringInC JNIEXPORT jdouble JNICALL JavacomexamplejniJNIJavaaverage JNIEnv env, jclass jthis, jintArray intArray jint intArrayInC env-GetIntArrayElements intArray, NULL if NULL intArrayInC return -1 jsize length env-GetArrayLength intArray int sum 0 for int i 0 i length i sum intArrayInC i env-ReleaseIntArrayElements intArray, intArrayInC, 0 return double sum length Output Running the example class above yields the following output Invoked C printString from Java Got result from C": "input.pdf", "average 3.4 Section 98.2 Calling Java methods from C callback Calling a Java method from native code is a two-step process obtain a method pointer with the GetMethodID JNI function, using the method name and descriptor 1. call one of the CallMethod functions listed here . 2. GoalKicker.com Java Notes for Professionals 560Java code com.example.jni.JNIJavaCallback.java package com.example.jni public class JNIJavaCallback static System.loadLibrary libJNICPP public static void mainString args new JNIJavaCallback .callback public native void callback public static void printNum int i System.out.printlnGot int from C i public void printFloat float i System.out.printlnGot float from C i C code comexamplejniJNICppCallback.cpp include iostream include comexamplejniJNIJavaCallback.h using namespace std JNIEXPORT void JNICALL JavacomexamplejniJNIJavaCallbackcallback JNIEnv env, jobject jthis jclass thisClass env-GetObjectClass jthis jmethodID printFloat env-GetMethodID thisClass, printFloat , FV if NULL printFloat return env-CallVoidMethod jthis, printFloat, 5.221 jmethodID staticPrintInt env-GetStaticMethodID thisClass, printNum , IV if NULL staticPrintInt return env-CallVoidMethod jthis, staticPrintInt, 17 Output Got \ufb02oat from C 5.221 Got int from C 17 Getting the descriptor Descriptors or internal type signatures are obtained using the javap program on the compiled .class \ufb01le. Here is the output of javap -p -s com.example.jni.JNIJavaCallback GoalKicker.com Java Notes for Professionals 561Compiled from JNIJavaCallback.java public class com.example.jni.JNIJavaCallback static": "input.pdf", "descriptor V public com.example.jni.JNIJavaCallback descriptor V public static void mainjava.lang.String descriptor LjavalangStringV public native void callback descriptor V public static void printNum int descriptor IV ---- Needed public void printFloat float descriptor FV ---- Needed Section 98.3 Loading native libraries The common idiom for loading shared library \ufb01les in Java is the following public class ClassWithNativeMethods static System.loadLibrary Example public native void someNativeMethod String arg ... Calls to System.loadLibrary are almost always static so as to occur during class loading, ensuring that no native method can execute before the shared library has been loaded. However the following is possible public class ClassWithNativeMethods Call this before using any native method public static void prepareNativeMethods System.loadLibrary Example ... This allows to defer shared library loading until necessary, but requires extra care to avoid java.lang.UnsatisfiedLinkError s. Target \ufb01le lookup Shared library \ufb01les are searched for in the paths de\ufb01ned by the java.library.path system property, which can be overridden using the -Djava.library.path JVM argument at runtime java -Djava.library.pathpathtolibpathtootherlib MainClassWithNativeMethods Watch out for system path separators for example, Windows uses instead of . Note that System.loadLibrary resolves library \ufb01lenames in a platform-dependent manner the code snippet above expects a \ufb01le named libExample. so on": "input.pdf", "Linux, and Example. dll on Windows. GoalKicker.com Java Notes for Professionals 562An alternative to System.loadLibrary is System.loadString, which takes the full path to a shared library \ufb01le, circumventing the java.library.path lookup public class ClassWithNativeMethods static System.loadpathtoliblibExample.so ... GoalKicker.com Java Notes for Professionals 563Chapter 99 Functional Interfaces In Java 8, a functional interface is an interface that has just one abstract method aside from the methods of Object. See JLS 9.8. Functional Interfaces . Section 99.1 List of standard Java Runtime Library functional interfaces by signature Parameter Types Return Type Interface void Runnable T Supplier boolean BooleanSupplier int IntSupplier long LongSupplier double DoubleSupplier T void ConsumerT T T UnaryOperatorT T R FunctionT,R T boolean PredicateT T int ToIntFunctionT T long ToLongFunctionT T double ToDoubleFunctionT T, T T BinaryOperatorT T, U void BiConsumerT,U T, U R BiFunctionT,U,R T, U boolean BiPredicateT,U T, U int ToIntBiFunctionT,U T, U long ToLongBiFunctionT,U T, U double ToDoubleBiFunctionT,U T, int void ObjIntConsumerT T, long void ObjLongConsumerT T, double void ObjDoubleConsumerT int void IntConsumer int R IntFunctionR int boolean IntPredicate int int IntUnaryOperator int long IntToLongFunction int double IntToDoubleFunction int, int int IntBinaryOperator long void LongConsumer long R LongFunctionR long boolean LongPredicate long int LongToIntFunction long long": "input.pdf", "LongUnaryOperator long double LongToDoubleFunction long, long long LongBinaryOperator GoalKicker.com Java Notes for Professionals 564double void DoubleConsumer double R DoubleFunctionR double boolean DoublePredicate double int DoubleToIntFunction double long DoubleToLongFunction double double DoubleUnaryOperator double, double double DoubleBinaryOperator GoalKicker.com Java Notes for Professionals 565Chapter 100 Fluent Interface Section 100.1 Fluent programming style In \ufb02uent programming style you return this from \ufb02uent setter methods that would return nothing in non-\ufb02uent programming style. This allows you to chain the di\ufb00erent method calls which makes your code shorter and easier to handle for the developers. Consider this non-\ufb02uent code public class Person private String firstName private String lastName public String getFirstName return firstName public void setFirstName String firstName this.firstName firstName public String getLastName return lastName public void setLastName String lastName this.lastName lastName public String whoAreYou return I am firstName lastName public static void mainString args Person person new Person person. setFirstName John person. setLastName Doe System.out.printlnperson.whoAreYou As the setter methods dont return anything, we need 4 instructions in the main method to instantiate a Person with some data and print it. With a \ufb02uent style this code can be changed to public class Person private String firstName private String lastName public String getFirstName return firstName": "input.pdf", "public Person withFirstName String firstName this.firstName firstName return this GoalKicker.com Java Notes for Professionals 566 public String getLastName return lastName public Person withLastName String lastName this.lastName lastName return this public String whoAreYou return I am firstName lastName public static void mainString args System.out.printlnnew Person.withFirstName John .withLastName Doe.whoAreYou The idea is to always return some object to enable building of a method call chain and to use method names which re\ufb02ect natural speaking. This \ufb02uent style makes the code more readable. Section 100.2 Truth - Fluent Testing Framework From How to use Truth httpgoogle.github.iotruth String string awesome assertThat string.startsWith awe assertWithMessage Without me, its just aweso .thatstring.contains me Iterable Color googleColors googleLogo. getColors assertThat googleColors .containsExactly BLUE, RED, YELLOW, BLUE, GREEN, RED .inOrder GoalKicker.com Java Notes for Professionals 567Chapter 101 Remote Method Invocation RMI Section 101.1 Callback invoking methods on a client Overview In this example 2 clients send information to each other through a server. One client sends the server a number which is relayed to the second client. The second client halves the number and sends it back to the \ufb01rst client through the server. The \ufb01rst client does the same. The server stops the communication when the": "input.pdf", "number returned to it by any of the clients is less than 10. The return value from the server to the clients the number it got converted to string representation then backtracks the process. A login server binds itself to a registry.1. A client looks up the login server and calls the login method with its information. Then 2. The login server stores the client information. It includes the clients stub with the callback methods. The login server creates and returns a server stub connection or session to the client to store. It includes the servers stub with its methods including a logout method unused in this example. A client calls the servers passInt with the name of the recipient client and an int. 3. The server calls the half on the recipient client with that int. This initiates a back-and-forth calls and 4. callbacks communication until stopped by the server. The shared remote interfaces The login server package callbackRemote import java.rmi.Remote import java.rmi.RemoteException public interface RemoteLogin extends Remote RemoteConnection login String name, RemoteClient client throws RemoteException The server package callbackRemote import java.rmi.Remote import java.rmi.RemoteException public interface RemoteConnection extends Remote void logout throws RemoteException String passInt String name, int": "input.pdf", "i throws RemoteException The client package callbackRemote import java.rmi.Remote GoalKicker.com Java Notes for Professionals 568import java.rmi.RemoteException public interface RemoteClient extends Remote void halfint i throws RemoteException The implementations The login server package callbackServer import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import java.rmi.server.UnicastRemoteObject import java.util.HashMap import java.util.Map import callbackRemote.RemoteClient import callbackRemote.RemoteConnection import callbackRemote.RemoteLogin public class LoginServer implements RemoteLogin static MapString, RemoteClient clients new HashMap Override public RemoteConnection login String name, RemoteClient client Connection connection new Connection name, client clients. putname, client System.out.printlnname logged in return connection public static void mainString args try Registry reg LocateRegistry .createRegistry Registry .REGISTRYPORT LoginServer server new LoginServer UnicastRemoteObject .exportObject server, Registry .REGISTRYPORT reg. rebindLoginServerName , server catch RemoteException e e. printStackTrace The server package callbackServer import java.rmi.NoSuchObjectException import java.rmi.RemoteException import java.rmi.registry.Registry import java.rmi.server.UnicastRemoteObject import java.rmi.server.Unreferenced import callbackRemote.RemoteClient import callbackRemote.RemoteConnection GoalKicker.com Java Notes for Professionals 569public class Connection implements RemoteConnection, Unreferenced RemoteClient client String name public Connection String name, RemoteClient client this.client client this.name name try UnicastRemoteObject .exportObject this, Registry .REGISTRYPORT catch RemoteException e e. printStackTrace Override public void unreferenced try UnicastRemoteObject .unexportObject this, true catch NoSuchObjectException e e. printStackTrace Override public void logout try UnicastRemoteObject .unexportObject this, true catch NoSuchObjectException e e. printStackTrace Override public String": "input.pdf", "passInt String recipient, int i System.out.printlnServer received from name i if i 10 return String.valueOfi RemoteClient client LoginServer. clients.getrecipient try client. halfi catch RemoteException e e. printStackTrace return String.valueOfi The client package callbackClient import java.rmi.NotBoundException import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import java.rmi.server.UnicastRemoteObject GoalKicker.com Java Notes for Professionals 570import callbackRemote.RemoteClient import callbackRemote.RemoteConnection import callbackRemote.RemoteLogin public class Client implements RemoteClient RemoteConnection connection String name, target Client String name, String target this.name name this.target target public static void mainString args Client client new Clientargs0, args1 try Registry reg LocateRegistry .getRegistry RemoteLogin login RemoteLogin reg.lookupLoginServerName UnicastRemoteObject .exportObject client, Integer.parseInt args2 client. connection login.loginclient.name, client catch RemoteException NotBoundException e e. printStackTrace if Client1 .equalsclient.name try client. connection .passIntclient.target, 120 catch RemoteException e e. printStackTrace Override public void halfint i throws RemoteException String result connection. passInttarget, i 2 System.out.printlnname received result Running the example Run the login server.1. Run a client with the arguments Client2 Client1 1097 . 2. Run a client with the arguments Client1 Client2 1098 . 3. The outputs will appear in 3 consoles since there are 3 JVMs. here they are lumped together Client2 logged in Client1 logged in Server received from Client1120 Server received from Client260 Server received from": "input.pdf", "Client130 Server received from Client215 Server received from Client17 GoalKicker.com Java Notes for Professionals 571Client1 received 7 Client2 received 15 Client1 received 30 Client2 received 60 Section 101.2 Simple RMI example with Client and Server implementation This is a simple RMI example with \ufb01ve Java classes and two packages, server and client . Server Package PersonListInterface.java public interface PersonListInterface extends Remote This interface is used by both client and server return List of Persons throws RemoteException ArrayList String getPersonList throws RemoteException PersonListImplementation.java public class PersonListImplementation extends UnicastRemoteObject implements PersonListInterface private static final long serialVersionUID 1L standard constructor needs to be available public PersonListImplementation throws RemoteException Implementation of PersonListInterface throws RemoteException Override public ArrayList String getPersonList throws RemoteException ArrayList String personList new ArrayList String personList. addPeter Pan personList. addPippi Langstrumpf add your name here return personList Server.java public class Server GoalKicker.com Java Notes for Professionals 572 Register servicer to the known public methods private static void createServer try Register registry with standard port 1099 LocateRegistry .createRegistry Registry .REGISTRYPORT System.out.printlnServer Registry created. Register PersonList to registry Naming.rebindPersonList , new PersonListImplementation System.out.printlnServer PersonList registered catch final IOException e e. printStackTrace public static void mainfinal String args createServer Client package PersonListLocal.java public class": "input.pdf", "PersonListLocal private static PersonListLocal instance private PersonListInterface personList Create a singleton instance private PersonListLocal try Lookup to the local running server with port 1099 final Registry registry LocateRegistry .getRegistry localhost , Registry .REGISTRYPORT Lookup to the registered PersonList personList PersonListInterface registry. lookupPersonList catch final RemoteException e e. printStackTrace catch final NotBoundException e e. printStackTrace public static PersonListLocal getInstance if instance null instance new PersonListLocal return instance Returns the servers PersonList public ArrayList String getPersonList GoalKicker.com Java Notes for Professionals 573 if instance ! null try return personList. getPersonList catch final RemoteException e e. printStackTrace return new ArrayList PersonTest.java public class PersonTest public static void mainString args get local PersonList ArrayList String personList PersonListLocal. getInstance .getPersonList print all persons forString person personList System.out.printlnperson Test your application Start main method of Server.java. Output Server Registry created. Server PersonList registered Start main method of PersonTest.java. Output Peter Pan Pippi Langstrumpf Section 101.3 Client-Server invoking methods in one JVM from another The shared remote interface package remote import java.rmi.Remote import java.rmi.RemoteException public interface RemoteServer extends Remote int stringToInt String string throws RemoteException GoalKicker.com Java Notes for Professionals 574The server implementing the shared remote interface package server import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import": "input.pdf", "java.rmi.server.UnicastRemoteObject import remote.RemoteServer public class Server implements RemoteServer Override public int stringToInt String string throws RemoteException System.out.printlnServer received string return Integer.parseInt string public static void mainString args try Registry reg LocateRegistry .createRegistry Registry .REGISTRYPORT Server server new Server UnicastRemoteObject .exportObject server, Registry .REGISTRYPORT reg. rebindServerName , server catch RemoteException e e. printStackTrace The client invoking a method on the server remotely package client import java.rmi.NotBoundException import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.rmi.registry.Registry import remote.RemoteServer public class Client static RemoteServer server public static void mainString args try Registry reg LocateRegistry .getRegistry server RemoteServer reg.lookupServerName catch RemoteException NotBoundException e e. printStackTrace Client client new Client client. callServer GoalKicker.com Java Notes for Professionals 575 void callServer try int i server. stringToInt 120 System.out.printlnClient received i catch RemoteException e e. printStackTrace Output Server received 120 Client received 120 GoalKicker.com Java Notes for Professionals 576Chapter 102 Iterator and Iterable The java.util.Iterator is the standard Java SE interface for object that implement the Iterator design pattern. The java.lang.Iterable interface is for objects that can provide an iterator. Section 102.1 Removing elements using an iterator The Iterator .remove method is an optional method that removes the element returned by the previous call to Iterator .next. For example,": "input.pdf", "the following code populates a list of strings and then removes all of the empty strings. ListString names new ArrayList names.addname 1 names.addname 2 names.add names.addname 3 names.add System.out.printlnOld Size names.size Iterator String it names.iterator while it.hasNext String el it.next if el.equals it.remove System.out.printlnNew Size names.size Output Old Size 5 New Size 3 Note that is the code above is the safe way to remove elements while iterating a typical collection. If instead, you attempt to do remove elements from a collection like this for String el names if el.equals names. removeel WRONG! a typical collection such as ArrayList which provides iterators with fail fast iterator semantics will throw a ConcurrentModificationException . The remove method can only called once following a next call. If it is called before calling next or if it is called twice following a next call, then the remove call will throw an IllegalStateException . The remove operation is described as an optional operation i.e. not all iterators will allow it. Examples where it is not supported include iterators for immutable collections, read-only views of collections, or \ufb01xed sized collections. If remove is called when the iterator does not support removal, it will throw an": "input.pdf", "UnsupportedOperationException . Section 102.2 Creating your own Iterable To create your own Iterable as with any interface you just implement the abstract methods in the interface. For GoalKicker.com Java Notes for Professionals 577Iterable there is only one which is called iterator . But its return type Iterator is itself an interface with three abstract methods. You can return an iterator associated with some collection or create your own custom implementation public static class Alphabet implements Iterable Character Override public Iterator Character iterator return new Iterator Character char letter a Override public boolean hasNext return letter z Override public Character next return letter Override public void remove throw new UnsupportedOperationException Doesnt make sense to remove a letter To use public static void mainString args forchar c new Alphabet System.out.printlnc c The new Iterator should come with a state pointing to the \ufb01rst item, each call to next updates its state to point to the next one. The hasNext checks to see if the iterator is at the end. If the iterator were connected to a modi\ufb01able collection then the iterators optional remove method might be implemented to remove the item currently pointed to from the underlying collection. Section 102.3 Using": "input.pdf", "Iterable in for loop Classes implementing Iterable interface can be used in for loops. This is actually only syntactic sugar for getting an iterator from the object and using it to get all elements sequentially it makes code clearer, faster to write end less error-prone. public class UsingIterable public static void mainString args List Integer intList Arrays.asList1,2,3,4,5,6,7 List extends Collection, Collection extends Iterable Iterable Integer iterable intList foreach-like loop for Integer i iterable GoalKicker.com Java Notes for Professionals 578 System.out.printlni pre java 5 way of iterating loops forIterator Integer i iterable. iterator i.hasNext Integer item i.next System.out.printlnitem Section 102.4 Using the raw iterator While using the foreach loop or extended for loop is simple, its sometimes bene\ufb01cial to use the iterator directly. For example, if you want to output a bunch of comma-separated values, but dont want the last item to have a comma ListString yourData ... Iterator String iterator yourData. iterator while iterator. hasNext next moves the iterator to the next entry and returns its value. String entry iterator. next System.out.printentry if iterator. hasNext If the iterator has another element after the current one System.out.print, This is much easier and clearer than having a isLastEntry variable or doing": "input.pdf", "calculations with the loop index. GoalKicker.com Java Notes for Professionals 579Chapter 103 Re\ufb02ection API Re\ufb02ection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the JVM. Java Re\ufb02ection API is used for that purpose where it makes it possible to inspect classes, interfaces, \ufb01elds and methods at runtime, without knowing their names at compile time. And It also makes it possible to instantiate new objects, and to invoke methods using re\ufb02ection. Section 103.1 Dynamic Proxies Dynamic Proxies do not really have much to do with Re\ufb02ection but they are part of the API. Its basically a way to create a dynamic implementation of an interface. This could be helpful when creating mockup services. A Dynamic Proxy is an instance of an interface that is created with a so-called invocation handler that intercepts all method calls and allows the handling of their invocation manually. public class DynamicProxyTest public interface MyInterface1 public void someMethod1 public int someMethod2 String s public interface MyInterface2 public void anotherMethod public static void mainString args throws Exception the dynamic proxy class Class ? proxyClass Proxy.getProxyClass ClassLoader .getSystemClassLoader , new Class MyInterface1. class, MyInterface2. class the": "input.pdf", "dynamic proxy class constructor Constructor ? proxyConstructor proxyClass. getConstructor InvocationHandler .class the invocation handler InvocationHandler handler new InvocationHandler this method is invoked for every proxy method call method is the invoked method, args holds the method parameters it must return the method result Override public Object invokeObject proxy, Method method, Object args throws Throwable String methodName method. getName ifmethodName. equalssomeMethod1 System.out.printlnsomeMethod1 was invoked! return null ifmethodName. equalssomeMethod2 System.out.printlnsomeMethod2 was invoked! System.out.printlnParameter args0 return 42 ifmethodName. equalsanotherMethod System.out.printlnanotherMethod was invoked! return null System.out.printlnUnkown method! return null GoalKicker.com Java Notes for Professionals 580 create the dynamic proxy instances MyInterface1 i1 MyInterface1 proxyConstructor. newInstance handler MyInterface2 i2 MyInterface2 proxyConstructor. newInstance handler and invoke some methods i1. someMethod1 i1. someMethod2 stackoverflow i2. anotherMethod The result of this code is this someMethod1 was invoked ! someMethod2 was invoked ! Parameter stackoverflow anotherMethod was invoked ! Section 103.2 Introduction Basics The Re\ufb02ection API allows one to check the class structure of the code at runtime and invoke code dynamically. This is very powerful, but it is also dangerous since the compiler is not able to statically determine whether dynamic invocations are valid. A simple example would be to get the public constructors and methods of": "input.pdf", "a given class import java.lang.reflect.Constructor import java.lang.reflect.Method This is a object representing the String class not an instance of String! ClassString clazz String.class Constructor ? constructors clazz.getConstructors returns all public constructors of String Method methods clazz.getMethods returns all public methods from String and parents With this information it is possible to instance the object and call di\ufb00erent methods dynamically. Re\ufb02ection and Generic Types Generic type information is available for method parameters, using getGenericParameterTypes . method return types, using getGenericReturnType . public \ufb01elds, using getGenericType . The following example shows how to extract the generic type information in all three cases import java.lang.reflect.Field import java.lang.reflect.Method import java.lang.reflect.ParameterizedType import java.lang.reflect.Type import java.util.List GoalKicker.com Java Notes for Professionals 581import java.util.Map public class GenericTest public static void mainfinal String args throws Exception final Method method GenericTest. class.getMethod testMethod , Map.class final Field field GenericTest. class.getField testField System.out.printlnMethod parameter final Type parameterType method. getGenericParameterTypes 0 displayGenericType parameterType, t System.out.printlnMethod return type final Type returnType method. getGenericReturnType displayGenericType returnType, t System.out.printlnField type final Type fieldType field.getGenericType displayGenericType fieldType, t private static void displayGenericType final Type type, final String prefix System.out.printlnprefix type.getTypeName if type instanceof ParameterizedType for final Type subtype ParameterizedType type.getActualTypeArguments displayGenericType subtype, prefix t": "input.pdf", "public MapString, MapInteger, ListString testField public ListNumber testMethod final MapString, Double arg return null This results in the following output Method parameter java.util.Map java.lang.String java.lang.Double Method return type java.util.List java.lang.Number Field type java.util.Map java.lang.String java.util.Map java.lang.Integer java.util.List java.lang.String Section 103.3 Evil Java hacks with Re\ufb02ection The Re\ufb02ection API could be used to change values of private and \ufb01nal \ufb01elds even in the JDK default library. This GoalKicker.com Java Notes for Professionals 582could be used to manipulate the behaviour of some well known classes as we will see. What is not possible Lets start \ufb01rst with the only limitation means the only \ufb01eld we cant change with Re\ufb02ection. That is the Java SecurityManager . It is declared in java.lang.System as private static volatile SecurityManager security null But it wont be listed in the System class if we run this code forField f System.class.getDeclaredFields System.out.printlnf Thats because of the fieldFilterMap in sun.reflect.Reflection that holds the map itself and the security \ufb01eld in the System.class and protects them against any access with Re\ufb02ection. So we could not deactivate the SecurityManager . Crazy Strings Each Java String is represented by the JVM as an instance of the String class. However, in some situations": "input.pdf", "the JVM saves heap space by using the same instance for Strings that are. This happens for string literals, and also for strings that have been interned by calling String.intern. So if you have hello in your code multiple times it is always the same object instance. Strings are supposed to be immutable, but it is possible to use evil re\ufb02ection to change them. The example below show how we can change the characters in a String by replacing its value \ufb01eld. public class CrazyStrings static try Field f String.class.getDeclaredField value f. setAccessible true f. sethello, you stink! .toCharArray catch Exception e public static void mainString args System.out.printlnhello So this code will print you stink! 1 42 The same idea could be used with the Integer Class public class CrazyMath static try Field value Integer.class.getDeclaredField value value. setAccessible true value. setIntInteger.valueOf1, 42 catch Exception e GoalKicker.com Java Notes for Professionals 583 public static void mainString args System.out.printlnInteger.valueOf1 Everything is true And according to this stackover\ufb02ow post we can use re\ufb02ection to do something really evil. public class Evil static try Field field Boolean.class.getField FALSE field. setAccessible true Field modifiersField Field.class.getDeclaredField modifiers modifiersField. setAccessible true modifiersField. setIntfield, field. getModifiers Modifier": "input.pdf", ".FINAL field. setnull, true catch Exception e public static void mainString args System.out.formatEverything is s , false Note that what we are doing here is going to cause the JVM to behave in inexplicable ways. This is very dangerous. Section 103.4 Misuse of Re\ufb02ection API to change private and \ufb01nal variables Re\ufb02ection is useful when it is properly used for right purpose. By using re\ufb02ection, you can access private variables and re-initialize \ufb01nal variables. Below is the code snippet, which is not recommended. import java.lang.reflect. public class ReflectionDemo public static void mainString args try Field fields A.class.getDeclaredFields A a new A for Field fieldfields iffield.getName.equalsIgnoreCase name field. setAccessible true field. seta, StackOverFlow System.out.printlnA.name field.geta iffield.getName.equalsIgnoreCase age field. seta, 20 System.out.printlnA.age field.geta iffield.getName.equalsIgnoreCase rep field. setAccessible true field. seta,New Reputation System.out.printlnA.rep field.geta iffield.getName.equalsIgnoreCase count GoalKicker.com Java Notes for Professionals 584 field. seta,25 System.out.printlnA.count field.geta catchException err err. printStackTrace class A private String name public int age public final String rep public static int count0 public A name Unset age 0 rep Reputation count Output A.nameStackOverFlow A.age20 A.repNew Reputation A.count25 Explanation In normal scenario, private variables cant be accessed outside of declared class without getter and setter methods. final variables cant": "input.pdf", "be re-assigned after initialization. Reflection breaks both barriers can be abused to change both private and \ufb01nal variables as explained above. field.setAccessible true is the key to achieve desired functionality. Section 103.5 Getting and Setting \ufb01elds Using the Re\ufb02ection API, it is possible to change or get the value of a \ufb01eld at runtime. For example, you could use it in an API to retrieve di\ufb00erent \ufb01elds based on a factor, like the OS. You can also remove modi\ufb01ers like final to allow modi\ufb01ng \ufb01elds that are \ufb01nal. To do so, you will need to use the method ClassgetField in a way such as the one shown below Get the field in class SomeClass NAME. Field nameField SomeClass. class.getDeclaredField NAME Get the field in class Field modifiers. Note that it does not need to be static Field modifiersField Field.class.getDeclaredField modifiers Allow access from anyone even if its declared private modifiersField. setAccessible true GoalKicker.com Java Notes for Professionals 585 Get the modifiers on the NAME field as an int. int existingModifiersOnNameField nameField. getModifiers Bitwise AND NOT Modifier.FINAL 16 on the existing modifiers Readup here httpsen.wikipedia.orgwikiBitwiseoperationsinC if youre unsure what bitwise operations are. int newModifiersOnNameField existingModifiersOnNameField Modifier .FINAL Set the value": "input.pdf", "of the modifiers field under an object for non-static fields modifiersField. setIntnameField, newModifiersOnNameField Set it to be accessible. This overrides normal Java privateprotectedpackageetc access control checks. nameField. setAccessible true Set the value of NAME here. Note the null argument. Pass null when modifying static fields, as there is no instance object nameField. setnull, Hacked by reflection... Here I can directly access it. If needed, use reflection to get it. Below System.out.printlnSomeClass. NAME Getting \ufb01elds is much easier. We can use Fieldget and its variants to get its value Get the field in class SomeClass NAME. Field nameField SomeClass. class.getDeclaredField NAME Set accessible for private fields nameField. setAccessible true Pass null as there is no instance, remember? String name String nameField. getnull Do note this When using ClassgetDeclaredField , use it to get a \ufb01eld in the class itself class HackMe extends Hacked public String iAmDeclared class Hacked public String someState Here, HackMeiAmDeclared is declared \ufb01eld. However, HackMesomeState is not a declared \ufb01eld as it is inherited from its superclass, Hacked. Section 103.6 Call constructor Getting the Constructor Object You can obtain Constructor class from the Class object like this Class myClass ... get a class object Constructor constructors myClass.": "input.pdf", "getConstructors Where the constructors variable will have one Constructor instance for each public constructor declared in the GoalKicker.com Java Notes for Professionals 586class. If you know the precise parameter types of the constructor you want to access, you can \ufb01lter the speci\ufb01c constructor. The next example returns the public constructor of the given class which takes a Integer as parameter Class myClass ... get a class object Constructor constructor myClass. getConstructor new ClassInteger.class If no constructor matches the given constructor arguments a NoSuchMethodException is thrown. New Instance using Constructor Object Class myClass MyObj.class get a class object Constructor constructor myClass. getConstructor Integer.class MyObj myObj MyObj constructor. newInstance Integer.valueOf123 Section 103.7 Call constructor of nested class If you want to create an instance of an inner nested class you need to provide a class object of the enclosing class as an extra parameter with ClassgetDeclaredConstructor . public class Enclosing public class Nested public NestedString a System.out.printlnConstructor String a public static void mainString args throws Exception Class ? clazzEnclosing Class.forNameEnclosing Class ? clazzNested Class.forNameEnclosingNested Enclosing objEnclosing Enclosing clazzEnclosing. newInstance Constructor ? constructor clazzNested. getDeclaredConstructor new ClassEnclosing. class, String.class Nested objInner Nestedconstructor. newInstance new ObjectobjEnclosing, StackOverFlow If the nested class is static": "input.pdf", "you will not need this enclosing instance. Section 103.8 Invoking a method Using re\ufb02ection, a method of an object can be invoked during runtime. The example shows how to invoke the methods of a String object. import java.lang.reflect.InvocationTargetException import java.lang.reflect.Method String s Hello World! method without parameters invoke s.length Method method1 String.class.getMethod length int length int method1. invokes variable length contains 12 method with parameters GoalKicker.com Java Notes for Professionals 587 invoke s.substring6 Method method2 String.class.getMethod substring , int.class String substring String method2. invokes, 6 variable substring contains World! Section 103.9 Get Class given its fully quali\ufb01ed name Given a String containing the name of a class, its Class object can be accessed using Class.forName Class clazz null try clazz Class.forNamejava.lang.Integer catch ClassNotFoundException ex throw new IllegalStateException ex Version Java SE 1.2 It can be speci\ufb01ed, if the class should be initialized second parameter of forName and which ClassLoader should be used third parameter ClassLoader classLoader ... boolean initialize ... Class clazz null try clazz Class.forNamejava.lang.Integer , initialize, classLoader catch ClassNotFoundException ex throw new IllegalStateException ex Section 103.10 Getting the Constants of an Enumeration Giving this enumeration as Example enum Compass NORTH 0, EAST 90, SOUTH 180, WEST 270": "input.pdf", "private int degree Compass int deg degree deg public int getDegree return degree In Java an enum class is like any other class but has some de\ufb01nied constants for the enum values. Additionally it has a \ufb01eld that is an array that holds all the values and two static methods with name values and valueOfString. We can see this if we use Re\ufb02ection to print all \ufb01elds in this class forField f Compass. class.getDeclaredFields System.out.printlnf.getName the output will be NORTH GoalKicker.com Java Notes for Professionals 588EAST SOUTH WEST degree ENUMVALUES So we could examine enum classes with Re\ufb02ection like any other class. But the Re\ufb02ection API o\ufb00ers three enum- speci\ufb01c methods. enum check Compass. class.isEnum Returns true for classes that represents an enum type. retrieving values Object values Compass. class.getEnumConstants Returns an array of all enum values like Compass.values but without the need of an instance. enum constant check forField f Compass. class.getDeclaredFields iff.isEnumConstant System.out.printlnf.getName Lists all the class \ufb01elds that are enum values. Section 103.11 Call overloaded constructors using re\ufb02ection Example Invoke di\ufb00erent constructors by passing relevant parameters import java.lang.reflect. class NewInstanceWithReflection public NewInstanceWithReflection System.out.printlnDefault constructor public NewInstanceWithReflection String a System.out.printlnConstructor String a public static void mainString args": "input.pdf", "throws Exception NewInstanceWithReflection object NewInstanceWithReflection Class.forNameNewInstanceWithReflection .newInstance Constructor constructor NewInstanceWithReflection. class.getDeclaredConstructor new Class String.class NewInstanceWithReflection object1 NewInstanceWithReflection constructor. newInstance new ObjectStackOverFlow output GoalKicker.com Java Notes for Professionals 589Default constructor Constructor String StackOverFlow Explanation Create instance of class using Class.forName It calls default constructor 1. Invoke getDeclaredConstructor of the class by passing type of parameters as Class array 2. After getting the constructor, create newInstance by passing parameter value as Object array 3. GoalKicker.com Java Notes for Professionals 590Chapter 104 ByteBuer The ByteBuffer class was introduced in java 1.4 to ease working on binary data. Its especially suited to use with primitive type data. It allows the creation, but also subsequent manipulation of a bytes on a higher abstraction level Section 104.1 Basic Usage - Using DirectByteBuer DirectByteBuffer is special implementation of ByteBuffer that has no byte laying underneath. We can allocate such ByteBu\ufb00er by calling ByteBuffer directBuffer ByteBuffer. allocateDirect 16 This operation will allocate 16 bytes of memory. The contents of direct bu\ufb00ers may reside outside of the normal garbage-collected heap. We can verify whether ByteBu\ufb00er is direct by calling directBuffer. isDirect true The main characteristics of DirectByteBuffer is that JVM will try to natively work on allocated memory": "input.pdf", "without any additional bu\ufb00ering so operations performed on it may be faster then those performed on ByteBu\ufb00ers with arrays lying underneath. It is recomended to use DirectByteBuffer with heavy IO operations that rely on speed of execution, like real time communication. We have to be aware that if we try using array method we will get UnsupportedOperationException . So it is a good practice to chech whether our ByteBu\ufb00er has it byte array before we try to access it byte arrayOfBytes ifbuffer.hasArray arrayOfBytes buffer. array Another use of direct byte bu\ufb00er is interop through JNI. Since a direct byte bu\ufb00er does not use a byte, but an actual block of memory, it is possible to access that memory directly through a pointer in native code. This can save a bit of trouble and overhead on marshalling between the Java and native representation of data. The JNI interface de\ufb01nes several functions to handle direct byte bu\ufb00ers NIO Support . Section 104.2 Basic Usage - Creating a ByteBuer Theres two ways to create a ByteBuffer , where one can be subdivided again. If you have an already existing byte, you can wrap it into a ByteBuffer to simplify processing byte reqBuffer": "input.pdf", "new byteBUFFERSIZE int readBytes socketInputStream. readreqBuffer final ByteBuffer reqBufferWrapper ByteBuffer. wrapreqBuffer This would be a possibility for code that handles low-level networking interactions GoalKicker.com Java Notes for Professionals 591If you do not have an already existing byte, you can create a ByteBuffer over an array thats speci\ufb01cally allocated for the bu\ufb00er like this final ByteBuffer respBuffer ByteBuffer. allocate RESPONSEBUFFERSIZE putResponseData respBuffer socketOutputStream. writerespBuffer. array If the code-path is extremely performance critical and you need direct system memory access , the ByteBuffer can even allocate direct bu\ufb00ers using allocateDirect Section 104.3 Basic Usage - Write Data to the Buer Given a ByteBuffer instance one can write primitive-type data to it using relative and absolute put. The striking di\ufb00erence is that putting data using the relative method keeps track of the index the data is inserted at for you, while the absolute method always requires giving an index to put the data at. Both methods allow chaining calls. Given a su\ufb03ciently sized bu\ufb00er one can accordingly do the following buffer.putInt0xCAFEBABE .putCharc.putFloat 0.25.putLong0xDEADBEEFCAFEBABE which is equivalent to buffer.putInt0xCAFEBABE buffer.putCharc buffer.putFloat 0.25 buffer.putLong0xDEADBEEFCAFEBABE Do note that the method operating on byte s is not named specially. Additionally note that its also valid to": "input.pdf", "pass both a ByteBuffer and a byte to put. Other than that, all primitive types have specialized put-methods. An additional note The index given when using absolute put is always counted in byte s. GoalKicker.com Java Notes for Professionals 592Chapter 105 Applets Applets have been part of Java since its o\ufb03cial release and have been used to teach Java and programming for a number of years. Recent years have seen an active push to move away from Applets and other browser plugins, with some browsers blocking them or actively not supporting them. In 2016, Oracle announced their plans to deprecate the plugin, Moving to a Plugin-Free Web Newer and better APIs are now available Section 105.1 Minimal Applet A very simple applet draws a rectangle and prints a string something on the screen. public class MyApplet extends JApplet private String str StackOverflow Override public void init setBackground Color.gray Override public void destroy Override public void start Override public void stop Override public void paintGraphics g g. setColor Color.yellow g. fillRect 1,1,300,150 g. setColor Color.red g. setFontnew FontTimesRoman , Font.PLAIN, 48 g. drawString str, 10, 80 The main class of an applet extends from javax.swing.JApplet . Version Java SE 1.2": "input.pdf", "Before Java 1.2 and the introduction of the swing API applets had extended from java.applet.Applet . Applets dont require a main method. The entry point is controlled by the life cycle. To use them, they need to be embedded in a HTML document. This is also the point where their size is de\ufb01ned. html headhead body applet codeMyApplet.class width400 height200applet body html GoalKicker.com Java Notes for Professionals 593Section 105.2 Creating a GUI Applets could easily be used to create a GUI. They act like a Container and have an add method that takes any awt or swing component. public class MyGUIApplet extends JApplet private JPanel panel private JButton button private JComboBox String cmbBox private JTextField textField Override public void init panel new JPanel button new JButtonClickMe! button. addActionListener new ActionListener Override public void actionPerformed ActionEvent ae ifStringcmbBox.getSelectedItem .equalsgreet JOptionPane .showMessageDialog null,Hello textField. getText else JOptionPane .showMessageDialog null,textField. getText stinks! cmbBox new JComboBox new Stringgreet, offend textField new JTextField John Doe panel. addcmbBox panel. addtextField panel. addbutton add panel Section 105.3 Open links from within the applet You can use the method getAppletContext to get an AppletContext object that allows you to request the browser to open a link. For": "input.pdf", "this you use the method showDocument . Its second parameter tells the browser to use a new window blank or the one that shows the applet self . public class MyLinkApplet extends JApplet Override public void init JButton button new JButtonClickMe! button. addActionListener new ActionListener Override public void actionPerformed ActionEvent ae AppletContext a getAppletContext try URL url new URLhttpstackoverflow.com a. showDocument url,blank catch Exception e omitted for brevity add button GoalKicker.com Java Notes for Professionals 594Section 105.4 Loading images, audio and other resources Java applets are able to load di\ufb00erent resources. But since they are running in the web browser of the client you need to make sure that these resources are accessible. Applets are not able to access client resources as the local \ufb01le system. If you want to load resources from the same URL the Applet is stored you can use the method getCodeBase to retrieve the base URL. To load resources, applets o\ufb00er the methods getImage and getAudioClip to load images or audio \ufb01les. Load and show an image public class MyImgApplet extends JApplet private Image img Override public void init try img getImage new URLhttpcdn.sstatic.netstackexchangeimglogossoso- logo.png catch MalformedURLException e omitted for brevity Override public void": "input.pdf", "paintGraphics g g. drawImage img, 0, 0, this Load and play an audio \ufb01le public class MyAudioApplet extends JApplet private AudioClip audioClip Override public void init try audioClip getAudioClip new URLURLTOANAUDIOFILE.WAV catch MalformedURLException e omitted for brevity Override public void start audioClip. play Override public void stop audioClip. stop Load and display a text \ufb01le public class MyTextApplet extends JApplet Override public void init JTextArea textArea new JTextArea JScrollPane sp new JScrollPane textArea add sp GoalKicker.com Java Notes for Professionals 595 load text try URL url new URLhttpwww.textfiles.comfunquotes.txt InputStream in url.openStream BufferedReader bf new BufferedReader new InputStreamReader in String line whileline bf.readLine ! null textArea. appendline n catchException e omitted for brevity GoalKicker.com Java Notes for Professionals 596Chapter 106 Expressions Expressions in Java are the primary construct for doing calculations. Section 106.1 Operator Precedence When an expression contains multiple operators, it can potentially be read in di\ufb00erent ways. For example, the mathematical expression 1 2 x 3 could be read in two ways Add 1 and 2 and multiply the result by 3. This gives the answer 9. If we added parentheses, this would look 1. like 1 2 x 3. Add 1 to the result of multiplying 2": "input.pdf", "and 3. This gives the answer 7. If we added parentheses, this would look 2. like 1 2 x 3 . In mathematics, the convention is to read the expression the second way. The general rule is that multiplication and division are done before addition and subtraction. When more advanced mathematical notation is used, either the meaning is either self-evident to a trained mathematician!, or parentheses are added to disambiguate. In either case, the e\ufb00ectiveness of the notation to convey meaning depends on the intelligence and shared knowledge of the mathematicians. Java has the same clear rules on how to read an expression, based on the precedence of the operators that are used. In general, each operator is ascribed a precedence value see the table below. For example 1 2 3 The precedence of is lower than the precedence of , so the result of the expression is 7, not 9. Description Operators constructs primary Precedence Associativity Quali\ufb01er Parentheses Instance creation Field access Array access Method invocation Method referencename.name expr new primary.name primaryexpr primaryexpr, ... primaryname15 Left to right Post increment expr, expr-- 14 - Pre increment Unary Cast1expr, --expr, expr, -expr, expr, !expr, typeexpr13- Right to left Right": "input.pdf", "to left Multiplicative 12 Left to right Additive - 11 Left to right Shift 10 Left to right Relational instanceof 9 Left to right Equality ! 8 Left to right Bitwise AND 7 Left to right Bitwise exclusive OR 6 Left to right Bitwise inclusive OR 5 Left to right Logical AND 4 Left to right GoalKicker.com Java Notes for Professionals 597Logical OR 3 Left to right Conditional1 ? 2 Right to left Assignment Lambda1 - -1 Right to left 1 Lambda expression precedence is complex, as it can also occur after a cast, or as the third part of the conditional ternary operator. Section 106.2 Expression Basics Expressions in Java are the primary construct for doing calculations. Here are some examples 1 A simple literal is an expression 1 2 A simple expression that adds two numbers i j k An expression with multiple operations flag ? c d An expression using the conditional operator String s A type-cast is an expression obj.test A method call is an expression new Object Creation of an object is an expression new int Creation of an object is an expression In general, an expression consists of the following forms Expression names": "input.pdf", "which consist of Simple identi\ufb01ers e.g. someIdentifier Quali\ufb01ed identi\ufb01ers e.g. MyClass. someField Primaries which consist of Literals e.g. 1, 1.0, X, hello , false and null Class literal expressions e.g. MyClass. class this and TypeName . this Parenthesized expressions e.g. a b Class instance creation expressions e.g. new MyClass 1, 2, 3 Array instance creation expressions e.g. new int3 Field access expressions e.g. obj.someField or this.someField Array access expressions e.g. vector21 Method invocations e.g. obj.doIt1, 2, 3 Method references Java 8 and later e.g. MyClassdoIt Unary operator expressions e.g. !a or i Binary operator expressions e.g. a b or obj null Ternary operator expressions e.g. obj null ? 1 obj.getCount Lambda expressions Java 8 and later e.g. obj - obj.getCount The details of the di\ufb00erent forms of expressions may be found in other Topics. The Operators topic covers unary, binary and ternary operator expressions. The Lambda expressions topic covers lambda expressions and method reference expressions. The Classes and Objects topic covers class instance creation expressions. The Arrays topic covers array access expressions and array instance creation expressions. The Literals topic covers the di\ufb00erent kinds of literals expressions. The Type of an Expression In most cases, an expression has a": "input.pdf", "static type that can be determined at compile time by examining and its subexpressions. These are referred to as stand-alone expressions. GoalKicker.com Java Notes for Professionals 598However, in Java 8 and later the following kinds of expressions may be poly expressions Parenthesized expressions Class instance creation expressions Method invocation expressions Method reference expressions Conditional expressions Lambda expressions When an expression is a poly expression, its type may be in\ufb02uenced by the expressions target type i.e. what it is being used for. The value of an Expression The value of an expression is assignment compatible with its type. The exception to this is when heap pollution has occurred e.g. because unsafe conversion warnings have been inappropriately suppressed or ignored. Expression Statements Unlike many other languages, Java does not generally allow expressions to be used as statements. For example public void compute int i, int j i j ERROR Since the result of evaluating an expression like cannot be use, and since it cannot a\ufb00ect the execution of the program in any other way, the Java designers took the position that such usage is either a mistake, or misguided. However, this does not apply to all expressions. A subset of expressions": "input.pdf", "are in fact legal as statements. The set comprises Assignment expression, including operation-and-becomes assignments. Pre and post increment and decrement expressions. Method calls void or non-void . Class instance creation expressions. Section 106.3 Expression evaluation order Java expressions are evaluated following the following rules Operands are evaluated from left to right. The operands of an operator are evaluated before the operator. Operators are evaluated according to operator precedence Argument lists are evaluated from left to right. Simple Example In the following example int i method1 method2 the order of evaluation is The left operand of operator is evaluated to the address of i. 1. The left operand of the operator method1 is evaluated. 2. GoalKicker.com Java Notes for Professionals 599The right operand of the operator method2 is evaluated. 3. The operation is evaluated. 4. The operation is evaluated, assigning the result of the addition to i. 5. Note that if the e\ufb00ects of the calls are observable, you will be able to observe that the call to method1 occurs before the call to method2 . Example with an operator which has a side-e\ufb00ect In the following example int i 1 intArray i i 1 the order of evaluation is": "input.pdf", "The left operand of operator is evaluated. This gives the address of intArray 1. 1. The pre-increment is evaluated. This adds 1 to i, and evaluates to 2. 2. The right hand operand of the is evaluated. 3. The operation is evaluated to 2 1 - 3. 4. The operation is evaluated, assigning 3 to intArray 1. 5. Note that since the left-hand operand of the is evaluated \ufb01rst, it is not in\ufb02uenced by the side-e\ufb00ect of the i subexpression. Reference JLS 15.7 - Evaluation Order Section 106.4 Constant Expressions A constant expression is an expression that yields a primitive type or a String, and whose value can be evaluated at compile time to a literal. The expression must evaluate without throwing an exception, and it must be composed of only the following Primitive and String literals. Type casts to primitive types or String . The following unary operators , -, and !. The following binary operators , , , , -, , , , , , , , , !, , , , and . The ternary conditional operator ? . Parenthesized constant expressions. Simple names that refer to constant variables. A constant variable is a variable declared": "input.pdf", "as final where the initializer expression is itself a constant expression. Quali\ufb01ed names of the form TypeName . Identifier that refer to constant variables. Note that the above list excludes and --, the assignment operators, class and instanceof , method calls and references to general variables or \ufb01elds. Constant expressions of type String result in an interned String , and \ufb02oating point operations in constant expressions are evaluated with FP-strict semantics. GoalKicker.com Java Notes for Professionals 600Uses for Constant Expressions Constant expressions can be used just about anywhere that a normal expression can be used. However, they have a special signi\ufb01cance in the following contexts. Constant expressions are required for case labels in switch statements. For example switch someValue case 1 1 OK case Math.min2, 3 Error - not a constant expression doSomething When the expression on the right hand side of an assignment is a constant expression, then the assignment can perform a primitive narrowing conversion. This is allowed provided that the value of the constant expression is within the range of the type on the left hand side. See JLS 5.1.3 and 5.2 For example byte b1 1 1 OK - primitive narrowing conversion. byte b2 127": "input.pdf", "1 Error - out of range byte b3 b1 1 Error - not a constant expession byte b4 byte b1 1 OK When a constant expression is used as the condition in a do, while or for, then it a\ufb00ects the readability analysis. For example while false doSomething Error - statenent not reachable boolean flag false while flag doSomething OK Note that this does not apply if statements. The Java compiler allows the then or else block of an if statement to be unreachable. This is the Java analog of conditional compilation in C and C. Finally, static final \ufb01elds in an class or interface with constant expression initializers are initialized eagerly. Thus, it is guaranteed that these constants will be observed in the initialized state, even when there is a cycle in the class initialization dependency graph. For more information, refer to JLS 15.28. Constant Expressions . GoalKicker.com Java Notes for Professionals 601Chapter 107 JSON in Java JSON JavaScript Object Notation is a lightweight, text-based, language-independent data exchange format that is easy for humans and machines to read and write. JSON can represent two structured types objects and arrays. JSON is often used in Ajax applications, con\ufb01gurations, databases,": "input.pdf", "and RESTful web services. The Java API for JSON Processing provides portable APIs to parse, generate, transform, and query JSON. Section 107.1 Using Jackson Object Mapper Pojo Model public class Model private String firstName private String lastName private int age Getters and setters not shown for brevity Example String to Object Model outputObject objectMapper. readValue firstName John,lastName Doe,age23, Model. class System.out.printlnoutputObject. getFirstName result John Example Object to String String jsonString objectMapper. writeValueAsString inputObject result firstNameJohn,lastNameDoe,age23 Details Import statement needed import com.fasterxml.jackson.databind.ObjectMapper Maven dependency jackson-databind ObjectMapper instance creating one ObjectMapper objectMapper new ObjectMapper ObjectMapper is threadsafe recommended have a shared, static instance Deserialization T T readValueString content, Class T valueType valueType needs to be speci\ufb01ed -- the return will be of this type Throws IOException - in case of a low-level IO problem JsonParseException - if underlying input contains invalid content JsonMappingException - if the input JSON structure does not match object structure GoalKicker.com Java Notes for Professionals 602Usage example jsonString is the input string Model fromJson objectMapper. readValue jsonString, Model. class Method for serialization String writeValueAsStringObject value Throws JsonProcessingException in case of an error Note prior to version 2.1, throws clause included IOException 2.1 removed it. Section 107.2 JSON": "input.pdf", "To Object Gson Library Lets assume you have a class called Person with just name private class Person public String name public PersonString name this.name name Code Gson gson new Gson String json name John Person person gson.fromJson json, Person. class System.out.printlnperson.name John You must have gson library in your classpath. Section 107.3 JSONObject.NULL If you need to add a property with a null value, you should use the prede\ufb01ned static \ufb01nal JSONObject. NULL and not the standard Java null reference. JSONObject. NULL is a sentinel value used to explicitly de\ufb01ne a property with an empty value. JSONObject obj new JSONObject obj.putsome, JSONObject. NULL Creates somenull System.out.printlnobj.getsomeprints null Note JSONObject. NULL.equalsnull returns true Which is a clear violation of Java.equals contract For any non-null reference value x, x.equalsnull should return false GoalKicker.com Java Notes for Professionals 603Section 107.4 JSON Builder - chaining methods You can use method chaining while working with JSONObject and JSONArray . JSONObject example JSONObject obj new JSONObject Initialize an empty JSON object Before obj.putname,Nikita .putage,30.putisMarried ,true After nameNikita,age30,isMarriedtrue JSONArray JSONArray arr new JSONArray Initialize an empty array Before arr.putStack.putOver.putFlow After Stack,Over,Flow Section 107.5 Object To JSON Gson Library Lets assume you have a class called": "input.pdf", "Person with just name private class Person public String name public PersonString name this.name name Code Gson g new Gson Person person new PersonJohn System.out.printlng.toJsonperson nameJohn Of course the Gson jar must be on the classpath. Section 107.6 JSON Iteration Iterate over JSONObject properties JSONObject obj new JSONObject isMarried true, nameNikita, age30 Iterator String keys obj.keysall keys isMarried, name age while keys.hasNext as long as there is another key String key keys.next get next key Object value obj.getkey get next value by key System.out.printlnkey valueprint key value Iterate over JSONArray values JSONArray arr new JSONArray Initialize an empty array push append some values in arr.putStack GoalKicker.com Java Notes for Professionals 604arr.putOver arr.putFlow for int i 0 i arr.length i iterate over all values Object value arr.geti get value System.out.printlnvalue print each value Section 107.7 optXXX vs getXXX methods JSONObject and JSONArray have a few methods that are very useful while dealing with a possibility that a value your are trying to get does not exist or is of another type. JSONObject obj new JSONObject obj.putString foo, bar For existing properties of the correct type, there is no difference obj.getString foo returns bar obj.optString foo returns bar obj.optString foo, tux": "input.pdf", "returns bar However, if a value cannot be coerced to the required type, the behavior differs obj.getIntfoo throws JSONException obj.optIntfoo returns 0 obj.optIntfoo, 123 returns 123 Same if a property does not exist obj.getString undefined throws JSONException obj.optString undefined returns obj.optString undefined , tux returns tux The same rules apply to the getXXX optXXX methods of JSONArray . Section 107.8 Extract single element from JSON String json name John, age21 JsonObject jsonObject new JsonParser .parsejson.getAsJsonObject System.out.printlnjsonObject. getname.getAsString John System.out.printlnjsonObject. getage.getAsInt 21 Section 107.9 JsonArray to Java List Gson Library Here is a simple JsonArray which you would like to convert to a Java ArrayList list TestString1 , TestString2 Now pass the JsonArray list to the following method which returns a corresponding Java ArrayList public ArrayList String getListString String jsonList Type listType new TypeToken ListString .getType make sure the name list matches the name of JsonArray in your Json. ArrayList String list new Gson.fromJson jsonList, listType GoalKicker.com Java Notes for Professionals 605 return list You should add the following maven dependency to your POM.xml \ufb01le !-- httpsmvnrepository.comartifactcom.google.code.gsongson -- dependency groupId com.google.code.gson groupId artifactId gsonartifactId version 2.7version dependency Or you should have the jar com.google.code.gsongsonjarversion in your classpath. Section 107.10 Encoding": "input.pdf", "data as JSON If you need to create a JSONObject and put data in it, consider the following example Create a new javax.json.JSONObject instance. JSONObject first new JSONObject first.putfoo, bar first.puttemperature , 21.5 first.putyear, 2016 Add a second object. JSONObject second new JSONObject second.putHello, world first.putmessage , second Create a new JSONArray with some values JSONArray someMonths new JSONArray new String January , February someMonths. putMarch Add another month as the fifth element, leaving the 4th element unset. someMonths. put4, May Add the array to our object object.putmonths , someMonths Encode String json object. toString An exercise for the reader Add pretty-printing! foobar, temperature21.5, year2016, messageHelloworld, monthsJanuary,February,March,null,May Section 107.11 Decoding JSON data If you need to get data from a JSONObject , consider the following example String json foobar,temperature 21.5,year2016,messageHelloworld,months January,February ,March,null,May GoalKicker.com Java Notes for Professionals 606 Decode the JSON-encoded string JSONObject object new JSONObject json Retrieve some values String foo object. getString foo double temperature object. getDouble temperature int year object. getIntyear Retrieve another object JSONObject secondary object. getJSONObject message String world secondary. getString Hello Retrieve an array JSONArray someMonths object. getJSONArray months Get some values from the array int nMonths someMonths. length String february someMonths. getString": "input.pdf", "1 GoalKicker.com Java Notes for Professionals 607Chapter 108 XML Parsing using the JAXP APIs Section 108.1 Parsing a document using the StAX API Considering the following document ?xml version1.0 encoding UTF-8 ? library book id1Effective Java book book id2Java Concurrency In Practice book notABook id3This is not a book element notABook library One can use the following code to parse it and build a map of book titles by book id. import javax.xml.stream.XMLInputFactory import javax.xml.stream.XMLStreamConstants import javax.xml.stream.XMLStreamReader import java.io.StringReader import java.util.HashMap import java.util.Map public class StaxDemo public static void mainString args throws Exception String xmlDocument ?xml version1.0 encodingUTF-8 ? library book id1Effective Javabook book id2Java Concurrency In Practicebook notABook id3This is not a book element notABook library XMLInputFactory xmlInputFactory XMLInputFactory. newFactory Various flavors are possible, e.g. from an InputStream, a Source, ... XMLStreamReader xmlStreamReader xmlInputFactory. createXMLStreamReader new StringReader xmlDocument MapInteger, String bookTitlesById new HashMap We go through each event using a loop while xmlStreamReader. hasNext switch xmlStreamReader. getEventType case XMLStreamConstants. STARTELEMENT System.out.printlnFound start of element xmlStreamReader. getLocalName Check if we are at the start of a book element if book.equalsxmlStreamReader. getLocalName int bookId Integer.parseInt xmlStreamReader. getAttributeValue , id String bookTitle xmlStreamReader. getElementText bookTitlesById. putbookId, bookTitle break A bunch of": "input.pdf", "other things are possible comments, processing instructions, Whitespace... default break xmlStreamReader. next GoalKicker.com Java Notes for Professionals 608 System.out.printlnbookTitlesById This outputs Found start of element library Found start of element book Found start of element book Found start of element notABook 1Effective Java, 2Java Concurrency In Practice In this sample, one must be carreful of a few things The use of xmlStreamReader. getAttributeValue works because we have checked \ufb01rst that the parser is in 1. the STARTELEMENT state. In evey other states except ATTRIBUTES , the parser is mandated to throw IllegalStateException , because attributes can only appear at the beginning of elements. same goes for xmlStreamReader. getTextContent , it works because we are at a STARTELEMENT and we 2. know in this document that the book element has no non-text child nodes. For more complex documents parsing deeper, nested elements, ..., it is a good practice to delegate the parser to sub-methods or other objets, e.g. have a BookParser class or method, and have it deal with every element from the STARTELEMENT to the ENDELEMENT of the book XML tag. One can also use a Stack object to keep around important datas up and down the tree. Section": "input.pdf", "108.2 Parsing and navigating a document using the DOM API Considering the following document ?xml version1.0 encoding UTF-8 ? library book id1Effective Java book book id2Java Concurrency In Practice book library One can use the following code to build a DOM tree out of a String import org.w3c.dom.Document import org.w3c.dom.Node import org.w3c.dom.NodeList import org.xml.sax.InputSource import javax.xml.parsers.DocumentBuilder import javax.xml.parsers.DocumentBuilderFactory import java.io.StringReader public class DOMDemo public static void mainString args throws Exception String xmlDocument ?xml version1.0 encodingUTF-8 ? library book id1Effective Javabook GoalKicker.com Java Notes for Professionals 609 book id2Java Concurrency In Practicebook library DocumentBuilderFactory documentBuilderFactory DocumentBuilderFactory. newInstance This is useless here, because the XML does not have namespaces, but this option is usefull to know in cas documentBuilderFactory. setNamespaceAware true DocumentBuilder documentBuilder documentBuilderFactory. newDocumentBuilder There are various options here, to read from an InputStream, from a file, ... Document document documentBuilder. parsenew InputSource new StringReader xmlDocument Root of the document System.out.printlnRoot of the XML Document document. getDocumentElement .getLocalName Iterate the contents NodeList firstLevelChildren document. getDocumentElement .getChildNodes for int i 0 i firstLevelChildren. getLength i Node item firstLevelChildren. itemi System.out.printlnFirst level child found, XML tag name is item.getLocalName System.out.printlntid attribute of this tag is item.getAttributes .getNamedItem id.getTextContent Another way would have": "input.pdf", "been NodeList allBooks document. getDocumentElement .getElementsByTagName book The code yields the following Root of the XML Document library First level child found, XML tag name is book id attribute of this tag is 1 First level child found, XML tag name is book id attribute of this tag is 2 GoalKicker.com Java Notes for Professionals 610Chapter 109 XML XPath Evaluation Section 109.1 Parsing multiple XPath Expressions in a single XML Using the same example as Evaluating a NodeList in an XML document , here is how you would make multiple XPath calls e\ufb03ciently Given the following XML document documentation tags tag nameJava topic nameRegular expressions example Matching groups example example Escaping metacharacters example topic topic nameArrays example Looping over arrays example example Converting an array to a list example topic tag tag nameAndroid topic nameBuilding Android projects example Building an Android application using Gradle example example Building an Android application using Maven example topic topic nameLayout resources example Including layout resources example example Supporting multiple device screens example topic tag tags documentation This is how you would use XPath to evaluate multiple expressions in one document XPath xPath XPathFactory. newInstance .newXPath Make new XPath DocumentBuilder builder DocumentBuilderFactory. newInstance Document": "input.pdf", "doc builder. parsenew Filepathtoxml.xml Specify XML file path NodeList javaExampleNodes NodeList xPath.evaluate documentationtagstagnameJavaexample , doc, XPathConstants. NODESET Evaluate the XPath xPath.reset Resets the xPath so it can be used again NodeList androidExampleNodes NodeList xPath.evaluate documentationtagstagnameAndroidexample , doc, XPathConstants. NODESET Evaluate the XPath ... Section 109.2 Parsing single XPath Expression multiple times in an XML In this case, you want to have the expression compiled before the evaluations, so that each call to evaluate does not compile the same expression. The simple syntax would be GoalKicker.com Java Notes for Professionals 611XPath xPath XPathFactory. newInstance .newXPath Make new XPath XPathExpression exp xPath.compiledocumentationtagstagnameJavaexample DocumentBuilder builder DocumentBuilderFactory. newInstance Document doc builder. parsenew Filepathtoxml.xml Specify XML file path NodeList javaExampleNodes NodeList exp.evaluate doc, XPathConstants. NODESET Evaluate the XPath from the already-compiled expression NodeList javaExampleNodes2 NodeList exp.evaluate doc, XPathConstants. NODESET Do it again Overall, two calls to XPathExpression. evaluate will be much more e\ufb03cient than two calls to XPath.evaluate . Section 109.3 Evaluating a NodeList in an XML document Given the following XML document documentation tags tag nameJava topic nameRegular expressions example Matching groups example example Escaping metacharacters example topic topic nameArrays example Looping over arrays example example Converting an array to a list example": "input.pdf", "topic tag tag nameAndroid topic nameBuilding Android projects example Building an Android application using Gradle example example Building an Android application using Maven example topic topic nameLayout resources example Including layout resources example example Supporting multiple device screens example topic tag tags documentation The following retrieves all example nodes for the Java tag Use this method if only evaluating XPath in the XML once. See other example for when multiple XPath calls are evaluated in the same XML \ufb01le. XPathFactory xPathFactory XPathFactory. newInstance XPath xPath xPathFactory. newXPath Make new XPath InputSource inputSource new InputSource pathtoxml.xml Specify XML file path NodeList javaExampleNodes NodeList xPath.evaluate documentationtagstagnameJavaexample , inputSource, XPathConstants. NODESET Evaluate the XPath ... GoalKicker.com Java Notes for Professionals 612Chapter 110 XOM - XML Object Model Section 110.1 Reading a XML \ufb01le In order to load the XML data with XOM you will need to make a Builder from which you can build it into a Document . Builder builder new Builder Document doc builder. buildfile To get the root element, the highest parent in the xml \ufb01le, you need to use the getRootElement on the Document instance. Element root doc.getRootElement Now the Element class has a lot of handy methods": "input.pdf", "that make reading xml really easy. Some of the most useful are listed below getChildElements String name - returns an Elements instance that acts as an array of elements getFirstChildElement String name - returns the \ufb01rst child element with that tag. getValue - returns the value inside the element. getAttributeValue String name - returns the value of an attribute with the speci\ufb01ed name. When you call the getChildElements you get a Elements instance. From this you can loop through and call the getint index method on it to retrieve all the elements inside. Elements colors root.getChildElements color for int q 0 q colors. size q Element color colors. getq Example Here is an example of reading an XML File XML File Code for reading and printing it GoalKicker.com Java Notes for Professionals 613import java.io.File import java.io.IOException import nu.xom.Builder import nu.xom.Document import nu.xom.Element import nu.xom.Elements import nu.xom.ParsingException public class XMLReader public static void mainString args throws ParsingException, IOException File file new Fileinsert path here builder builds xml data Builder builder new Builder Document doc builder. buildfile get the root element example Element root doc.getRootElement gets all element with tag person Elements people root.getChildElements person for int q 0 q people.": "input.pdf", "size q get the current person element Element person people. getq get the name element and its children first and last Element nameElement person. getFirstChildElement name Element firstNameElement nameElement. getFirstChildElement first Element lastNameElement nameElement. getFirstChildElement last get the age element Element ageElement person. getFirstChildElement age get the favorite color element Element favColorElement person. getFirstChildElement favcolor String fName, lName, ageUnit, favColor int age try fName firstNameElement. getValue lName lastNameElement. getValue age Integer.parseInt ageElement. getValue ageUnit ageElement. getAttributeValue unit favColor favColorElement. getValue System.out.printlnName lName , fName System.out.printlnAge age ageUnit System.out.printlnFavorite Color favColor System.out.println---------------- catch NullPointerException ex ex. printStackTrace catch NumberFormatException ex ex. printStackTrace GoalKicker.com Java Notes for Professionals 614This will print out in the console Name Smith, Dan Age 23 years Favorite Color green ---------------- Name Autry, Bob Age 3 months Favorite Color NA ---------------- Section 110.2 Writing to a XML File Writing to a XML File using XOM is very similar to reading it except in this case we are making the instances instead of retrieving them o\ufb00 the root. To make a new Element use the constructor ElementString name. You will want to make a root element so that you can easily add it to a Document . Element": "input.pdf", "root new Elementroot The Element class has some handy methods for editing elements. They are listed below appendChild String name - this will basically set the value of the element to name. appendChild Node node - this will make node the elements parent. Elements are nodes so you can parse elements. addAttribute Attribute attribute - will add an attribute to the element. The Attribute class has a couple of di\ufb00erent constructors. The simplest one is Attribute String name, String value. Once you have all of your elements add to your root element you can turn it into a Document . Document will take a Element as an argument in its constructor. You can use a Serializer to write your XML to a \ufb01le. You will need to make a new output stream to parse in the constructor of Serializer . FileOutputStream fileOutputStream new FileOutputStream file Serializer serializer new Serializer fileOutputStream, UTF-8 serializer. setIndent 4 serializer. writedoc Example Code import java.io.File import java.io.FileOutputStream import java.io.IOException import java.io.UnsupportedEncodingException import nu.xom.Attribute import nu.xom.Builder import nu.xom.Document import nu.xom.Element import nu.xom.Elements import nu.xom.ParsingException import nu.xom.Serializer GoalKicker.com Java Notes for Professionals 615public class XMLWriter public static void mainString args throws UnsupportedEncodingException , IOException root element": "input.pdf", "example Element root new Elementexample make a array of people to store Person people new PersonSmith, Dan, years, green, 23, new PersonAutry, Bob, months , NA, 3 add all the people for Person person people make the main person element person Element personElement new Elementperson make the name element and its children first and last Element nameElement new Elementname Element firstNameElement new Elementfirst Element lastNameElement new Elementlast make age element Element ageElement new Elementage make favorite color element Element favColorElement new Elementfavcolor add value to names firstNameElement. appendChild person.getFirstName lastNameElement. appendChild person.getLastName add names to name nameElement. appendChild firstNameElement nameElement. appendChild lastNameElement add value to age ageElement. appendChild String.valueOfperson.getAge add unit attribute to age ageElement. addAttribute new Attribute unit, person. getAgeUnit add value to favColor favColorElement. appendChild person.getFavoriteColor add all contents to person personElement. appendChild nameElement personElement. appendChild ageElement personElement. appendChild favColorElement add person to root root. appendChild personElement create doc off of root Document doc new Document root the file it will be stored in File file new Fileout.xml if !file.exists file. createNewFile GoalKicker.com Java Notes for Professionals 616 get a file output stream ready FileOutputStream fileOutputStream new FileOutputStream file use the serializer class to write it all": "input.pdf", "Serializer serializer new Serializer fileOutputStream, UTF-8 serializer. setIndent 4 serializer. writedoc private static class Person private String lName, fName, ageUnit, favColor private int age public PersonString lName, String fName, String ageUnit, String favColor, int age this.lName lName this.fName fName this.age age this.ageUnit ageUnit this.favColor favColor public String getLastName return lName public String getFirstName return fName public String getAgeUnit return ageUnit public String getFavoriteColor return favColor public int getAge return age This will be the contents of out.xml GoalKicker.com Java Notes for Professionals 617Chapter 111 Polymorphism Polymorphism is one of main OOPobject oriented programming concepts. Polymorphism word was derived from the greek words poly and morphs. Poly means many and morphs means forms many forms. There are two ways to perform polymorphism. Method Overloading and Method Overriding . Section 111.1 Method Overriding Method overriding is the ability of subtypes to rede\ufb01ne override the behavior of their supertypes. In Java, this translates to subclasses overriding the methods de\ufb01ned in the super class. In Java, all non-primitive variables are actually references , which are akin to pointers to the location of the actual object in memory. The references only have one type, which is the type they were declared with. However, they": "input.pdf", "can point to an object of either their declared type or any of its subtypes. When a method is called on a reference , the corresponding method of the actual object being pointed to is invoked . class SuperType public void sayHello System.out.printlnHello from SuperType public void sayBye System.out.printlnBye from SuperType class SubType extends SuperType override the superclass method public void sayHello System.out.printlnHello from SubType class Test public static void mainString... args SuperType superType new SuperType superType. sayHello - Hello from SuperType make the reference point to an object of the subclass superType new SubType behaviour is governed by the object, not by the reference superType. sayHello - Hello from SubType non-overridden method is simply inherited superType. sayBye - Bye from SuperType Rules to keep in mind To override a method in the subclass, the overriding method i.e. the one in the subclass MUST HAVE same name same return type in case of primitives a subclass is allowed for classes, this is also known as covariant return GoalKicker.com Java Notes for Professionals 618types. same type and order of parameters it may throw only those exceptions that are declared in the throws clause of the superclasss method or exceptions that": "input.pdf", "are subclasses of the declared exceptions. It may also choose NOT to throw any exception. The names of the parameter types do not matter. For example, void methodXint i is same as void methodXint k We are unable to Override \ufb01nal or Static methods. Only thing that we can do change only method body. Section 111.2 Method Overloading Method overloading , also known as function overloading , is the ability of a class to have multiple methods with the same name, granted that they di\ufb00er in either number or type of arguments. Compiler checks method signature for method overloading. Method signature consists of three things - Method name1. Number of parameters2. Types of parameters3. If these three are same for any two methods in a class, then compiler throws duplicate method error . This type of polymorphism is called static or compile time polymorphism because the appropriate method to be called is decided by the compiler during the compile time based on the argument list. class Polymorph public int addint a, int b return a b public int addint a, int b, int c return a b c public float addfloat a, float b return a b public static": "input.pdf", "void mainString... args Polymorph poly new Polymorph int a 1, b 2, c 3 float d 1.5, e 2.5 System.out.printlnpoly.adda, b System.out.printlnpoly.adda, b, c System.out.printlnpoly.addd, e This will result in 2 6 4.000000 GoalKicker.com Java Notes for Professionals 619Overloaded methods may be static or non-static. This also does not e\ufb00ect method overloading. public class Polymorph private static void methodOverloaded No argument, private static method private int methodOverloaded int i One argument private non-static method return i static int methodOverloaded double d static Method return 0 public void methodOverloaded int i, double d Public non-static Method Also if you change the return type of method, we are unable to get it as method overloading. public class Polymorph void methodOverloaded No argument and No return type int methodOverloaded No argument and int return type return 0 Section 111.3 Polymorphism and dierent types of overriding From java tutorial The dictionary de\ufb01nition of polymorphism refers to a principle in biology in which an organism or species can have many di\ufb00erent forms or stages. This principle can also be applied to object-oriented programming and languages like the Java language. Subclasses of a class can de\ufb01ne their own unique behaviors and yet share some of": "input.pdf", "the same functionality of the parent class. Have a look at this example to understand di\ufb00erent types of overriding. Base class provides no implementation and sub-class has to override complete method - abstract1. Base class provides default implementation and sub-class can change the behaviour2. Sub-class adds extension to base class implementation by calling super.methodName as \ufb01rst statement 3. Base class de\ufb01nes structure of the algorithm Template method and sub-class will override a part of4. algorithm GoalKicker.com Java Notes for Professionals 620code snippet import java.util.HashMap abstract class Game implements Runnable protected boolean runGame true protected Player player1 null protected Player player2 null protected Player currentPlayer null public Game player1 new PlayerPlayer 1 player2 new PlayerPlayer 2 currentPlayer player1 initializeGame Type 1 Let subclass define own implementation. Base class defines abstract method to force sub-classes to define implementation protected abstract void initializeGame Type 2 Sub-class can change the behaviour. If not, base class behaviour is applicable protected void logTimeBetweenMoves Player player System.out.printlnBase class Move Duration player.PlayerActTime - player.MoveShownTime Type 3 Base class provides implementation. Sub-class can enhance base class implementation by calling super.methodName in first line of the child class method and specific implementation later protected void logGameStatistics System.out.printlnBase class logGameStatistics": "input.pdf", "Type 4 Template method Structure of base class cant be changed but sub-class can some part of behaviour protected void runGame throws Exception System.out.printlnBase class Defining the flow for Game while runGame 1. Set current player 2. Get Player Move validatePlayerMove currentPlayer logTimeBetweenMoves currentPlayer Thread.sleep500 setNextPlayer logGameStatistics sub-part of the template method, which define child class behaviour protected abstract void validatePlayerMove Player p protected void setRunGame boolean status this.runGame status public void setCurrentPlayer Player p this.currentPlayer p GoalKicker.com Java Notes for Professionals 621 public void setNextPlayer if currentPlayer player1 currentPlayer player2 else currentPlayer player1 public void run try runGame catchException err err. printStackTrace class Player String name Player String name this.name name public String getName return name Concrete Game implementation class Chess extends Game public Chess super public void initializeGame System.out.printlnChild class Initialized Chess game protected void validatePlayerMove Player p System.out.printlnChild class Validate Chess move p.getName protected void logGameStatistics super.logGameStatistics System.out.printlnChild class Add Chess specific logGameStatistics class TicTacToe extends Game public TicTacToe super public void initializeGame System.out.printlnChild class Initialized TicTacToe game protected void validatePlayerMove Player p System.out.printlnChild class Validate TicTacToe move p.getName public class Polymorphism public static void mainString args try Game game new Chess Thread t1 new Threadgame": "input.pdf", "t1. start Thread.sleep1000 GoalKicker.com Java Notes for Professionals 622 game. setRunGame false Thread.sleep1000 game new TicTacToe Thread t2 new Threadgame t2. start Thread.sleep1000 game. setRunGame false catchException err err. printStackTrace Output Child class Initialized Chess game Base class Defining the flow for Game Child class Validate Chess movePlayer 1 Base class Move Duration player.PlayerActTime - player.MoveShownTime Child class Validate Chess movePlayer 2 Base class Move Duration player.PlayerActTime - player.MoveShownTime Base class logGameStatistics Child class Add Chess specific logGameStatistics Child class Initialized TicTacToe game Base class Defining the flow for Game Child class Validate TicTacToe movePlayer 1 Base class Move Duration player.PlayerActTime - player.MoveShownTime Child class Validate TicTacToe movePlayer 2 Base class Move Duration player.PlayerActTime - player.MoveShownTime Base class logGameStatistics Section 111.4 Virtual functions Virtual Methods are methods in Java that are non-static and without the keyword Final in front. All methods by default are virtual in Java. Virtual Methods play important roles in Polymorphism because children classes in Java can override their parent classes methods if the function being overridden is non-static and has the same method signature. There are, however, some methods that are not virtual. For example, if the method is declared private or with the keyword": "input.pdf", "\ufb01nal, then the method is not Virtual. Consider the following modi\ufb01ed example of inheritance with Virtual Methods from this StackOver\ufb02ow post How do virtual functions work in C and Java? public class A public void hello System.out.printlnHello public void boo System.out.printlnSay boo GoalKicker.com Java Notes for Professionals 623public class B extends A public void hello System.out.printlnNo public void boo System.out.printlnSay haha If we invoke class B and call hello and boo, we would get No and Say haha as the resulting output because B overrides the same methods from A. Even though the example above is almost exactly the same as method overriding, it is important to understand that the methods in class A are all, by default, Virtual. Additionally, we can implement Virtual methods using the abstract keyword. Methods declared with the keyword abstract does not have a method de\ufb01nition, meaning the methods body is not yet implemented. Consider the example from above again, except the boo method is declared abstract public class A public void hello System.out.printlnHello abstract void boo public class B extends A public void hello System.out.printlnNo public void boo System.out.printlnSay haha If we invoke boo from B, the output will still be Say haha": "input.pdf", "since B inherits the abstract method boo and makes boo output Say haha. Sources used and further readings How do virtual functions work in C and Java? Check out this great answer that gives a much more complete information about Virtual functions Can you write virtual functions methods in Java? Section 111.5 Adding behaviour by adding classes without touching existing code import java.util.ArrayList import java.util.List import static java.lang.System.out public class PolymorphismDemo GoalKicker.com Java Notes for Professionals 624 public static void mainString args List FlyingMachine machines new ArrayList FlyingMachine machines. addnew FlyingMachine machines. addnew Jet machines. addnew Helicopter machines. addnew Jet new MakeThingsFly .letTheMachinesFly machines class MakeThingsFly public void letTheMachinesFly ListFlyingMachine flyingMachines for FlyingMachine flyingMachine flyingMachines flyingMachine. fly class FlyingMachine public void fly out. printlnNo implementation class Jet extends FlyingMachine Override public void fly out. printlnStart, taxi, fly public void bombardment out. printlnFire missile class Helicopter extends FlyingMachine Override public void fly out. printlnStart vertically, hover, fly Explanation a The MakeThingsFly class can work with everything that is of type FlyingMachine . b The method letTheMachinesFly also works without any change ! when you add a new class, for example PropellerPlane public void letTheMachinesFly ListFlyingMachine flyingMachines for FlyingMachine flyingMachine flyingMachines": "input.pdf", "flyingMachine. fly Thats the power of polymorphism. You can implement the open-closed-principle with it. GoalKicker.com Java Notes for Professionals 625Chapter 112 Encapsulation Imagine you had a class with some pretty important variables and they were set by other programmers from their code to unacceptable values.Their code brought errors in your code. As a solution, In OOP, you allow the state of an object stored in its variables to be modi\ufb01ed only through methods. Hiding the state of an object and providing all interaction through an objects methods is known as Data Encapsulation. Section 112.1 Encapsulation to maintain invariants There are two parts of a class the interface and the implementation. The interface is the exposed functionality of the class. Its public methods and variables are part of the interface. The implementation is the internal workings of a class. Other classes shouldnt need to know about the implementation of a class. Encapsulation refers to the practice of hiding the implementation of a class from any users of that class. This allows the class to make assumptions about its internal state. For example, take this class representing an Angle public class Angle private double angleInDegrees private double angleInRadians public static Angle": "input.pdf", "angleFromDegrees double degrees Angle a new Angle a. angleInDegrees degrees a. angleInRadians Math.PIdegrees180 return a public static Angle angleFromRadians double radians Angle a new Angle a. angleInRadians radians a. angleInDegrees radians 180Math.PI return a public double getDegrees return angleInDegrees public double getRadians return angleInRadians public void setDegrees double degrees this.angleInDegrees degrees this.angleInRadians Math.PIdegrees180 public void setRadians double radians this.angleInRadians radians this.angleInDegrees radians 180Math.PI private Angle GoalKicker.com Java Notes for Professionals 626 This class relies on a basic assumption or invariant angleInDegrees and angleInRadians are always in sync . If the class members were public, there would be no guarantees that the two representations of angles are correlated. Section 112.2 Encapsulation to reduce coupling Encapsulation allows you to make internal changes to a class without a\ufb00ecting any code that calls the class. This reduces coupling , or how much any given class relies on the implementation of another class. For example, lets change the implementation of the Angle class from the previous example public class Angle private double angleInDegrees public static Angle angleFromDegrees double degrees Angle a new Angle a. angleInDegrees degrees return a public static Angle angleFromRadians double radians Angle a new Angle a. angleInDegrees radians 180Math.PI return a": "input.pdf", "public double getDegrees return angleInDegrees public double getRadians return angleInDegrees Math.PI 180 public void setDegrees double degrees this.angleInDegrees degrees public void setRadians double radians this.angleInDegrees radians 180Math.PI private Angle The implementation of this class has changed so that it only stores one representation of the angle and calculates the other angle when needed. However, the implementation changed, but the interface didnt . If a calling class relied on accessing the angleInRadians method, it would need to be changed to use the new version of Angle . Calling classes shouldnt care about the internal representation of a class. GoalKicker.com Java Notes for Professionals 627Chapter 113 Java Agents Section 113.1 Modifying classes with agents Firstly, make sure that the agent being used has the following attributes in the Manifest.mf Can-Redefine -Classes true Can-Retransform -Classes true Starting a java agent will let the agent access the class Instrumentation. With Instrumentation you can call addTransformerClassFileTransformer transformer . ClassFileTransformers will let you rewrite the bytes of classes. The class has only a single method which supplies the ClassLoader that loads the class, the classs name, a java.lang.Class instance of it, its ProtectionDomain, and lastly the bytes of the class itself. It looks like this": "input.pdf", "byte transform ClassLoader loader, String className, Class ? classBeingRedefined, ProtectionDomain protectionDomain, byte classfileBuffer Modifying a class purely from bytes can take ages. To remedy this there are libraries that can be used to convert the class bytes into something more usable. In this example Ill be using ASM, but other alternatives like Javassist and BCEL have similar features. ClassNode getNode byte bytes Create a ClassReader that will parse the byte array into a ClassNode ClassReader cr new ClassReader bytes ClassNode cn new ClassNode try This populates the ClassNode cr. acceptcn, ClassReader. EXPANDFRAMES cr null catch Exception e e. printStackTrace return cn From here changes can be made to the ClassNode object. This makes changing \ufb01eldmethod access incredibly easy. Plus with ASMs Tree API modifying the bytecode of methods is a breeze. Once the edits are \ufb01nished you can convert the ClassNode back into bytes with the following method and return them in the transform method public static byte getNodeBytes ClassNode cn, boolean useMaxs ClassWriter cw new ClassWriter useMaxs ? ClassWriter. COMPUTEMAXS ClassWriter. COMPUTEFRAMES cn.acceptcw byte b cw.toByteArray return b Section 113.2 Adding an agent at runtime Agents can be added to a JVM at runtime. To load an agent": "input.pdf", "you will need to use the Attach APIs GoalKicker.com Java Notes for Professionals 628VirtualMachine.attatchString id . You can then load a compiled agent jar with the following method public static void loadAgent String agentPath String vmName ManagementFactory. getRuntimeMXBean .getName int index vmName. indexOf String pid vmName. substring 0, index try File agentFile new FileagentPath VirtualMachine vm VirtualMachine. attachpid vm. loadAgent agentFile. getAbsolutePath , VirtualMachine. attachvm.id catch Exception e throw new RuntimeException e This will not call premainString agentArgs, Instrumentation inst in the loaded agent, but instead will call agentmainString agentArgs, Instrumentation inst . This requires Agent-Class to be set in the agent Manifest.mf. Section 113.3 Setting up a basic agent The Premain class will contain the method premainString agentArgs Instrumentation inst Here is an example import java.lang.instrument.Instrumentation public class PremainExample public static void premain String agentArgs, Instrumentation inst System.out.printlnagentArgs When compiled into a jar \ufb01le open the Manifest and ensure that it has the Premain-Class attribute. Here is an example Premain-Class PremainExample To use the agent with another java program myProgram you must de\ufb01ne the agent in the JVM arguments java -javaagent PremainAgent. jar -jar myProgram. jar GoalKicker.com Java Notes for Professionals 629Chapter 114 Varargs Variable Argument Section 114.1": "input.pdf", "Working with Varargs parameters Using varargs as a parameter for a method de\ufb01nition, it is possible to pass either an array or a sequence of arguments. If a sequence of arguments are passed, they are converted into an array automatically. This example shows both an array and a sequence of arguments being passed into the printVarArgArray method, and how they are treated identically in the code inside the method public class VarArgs this method will print the entire contents of the parameter passed in void printVarArgArray int... x for int i 0 i x.length i System.out.printxi , public static void mainString args VarArgs obj new VarArgs Using an array int testArray new int10, 20 obj. printVarArgArray testArray System.out.println Using a sequence of arguments obj. printVarArgArray 5, 6, 5, 8, 6, 31 Output 10,20, 5,6,5,8,6,31 If you de\ufb01ne the method like this, it will give compile-time errors. void methodString... a, int... b , int c Compile time error multiple varargs void methodint... a, String b Compile time error varargs must be the last argument Section 114.2 Specifying a varargs parameter void doSomething String... strings for String s strings System.out.printlns The three periods after the \ufb01nal parameters type indicate that the": "input.pdf", "\ufb01nal argument may be passed as an array or as a sequence of arguments. Varargs can be used only in the \ufb01nal argument position. GoalKicker.com Java Notes for Professionals 630Chapter 115 Logging java.util.logging Section 115.1 Logging complex messages eciently Lets look at a sample of logging which you can see in many programs public class LoggingComplex private static final Logger logger Logger. getLogger LoggingComplex. class.getName private int total 50, orders 20 private String username Bob public void takeOrder ... making some stuff logger. fineString.formatUser s ordered d things d in total , username, orders, total ... some other stuff some other methods and calculations The above example looks perfectly \ufb01ne, but many programmers forgets that Java VM is stack machine. This means that all methods parameters are calculated before executing the method. This fact is crucial for logging in Java, especially for logging something in low levels like FINE , FINER , FINEST which are disabled by default. Lets look at Java bytecode for the takeOrder method. The result for javap -c LoggingComplex. class is something like this public void takeOrder Code 0 getstatic 27 Field loggerLjavautilloggingLogger 3 ldc 45 String User s ordered d things d in total": "input.pdf", "5 iconst3 6 anewarray 3 class javalangObject 9 dup 10 iconst0 11 aload0 12 getfield 40 Field usernameLjavalangString 15 aastore 16 dup 17 iconst1 18 aload0 19 getfield 36 Field ordersI 22 invokestatic 47 Method javalangInteger.valueOfILjavalangInteger 25 aastore 26 dup 27 iconst2 28 aload0 29 getfield 34 Field totalI 32 invokestatic 47 Method javalangInteger.valueOfILjavalangInteger 35 aastore 36 invokestatic 53 Method javalangString.formatLjavalangStringLjavalangObjectLjavalangString 39 invokevirtual 59 Method javautilloggingLogger.fineLjavalangStringV GoalKicker.com Java Notes for Professionals 631 42 return Line 39 runs the actual logging. All of the previous work loading variables, creating new objects, concatenating Strings in format method can be for nothing if logging level is set higher then FINE and by default it is. Such logging can be very ine\ufb03cient, consuming unnecessary memory and processor resources. Thats why you should ask if the level you want to use is enabled. The right way should be public void takeOrder making some stuff if logger.isLoggable Level.FINE no action taken when theres no need for it logger. fineString.formatUser s ordered d things d in total , username, orders, total some other stuff Since Java 8 The Logger class has additional methods that take a Supplier String as parameter, which can simply be provided by": "input.pdf", "a lambda public void takeOrder making some stuff logger. fine - String.formatUser s ordered d things d in total , username, orders, total some other stuff The Suppliers getmethod - in this case the lambda - is only called when the corresponding level is enabled and so the ifconstruction is not needed anymore. Section 115.2 Using the default logger This example shows how to use the default logging api. import java.util.logging.Level import java.util.logging.Logger public class MyClass retrieve the logger for the current class private static final Logger LOG Logger. getLogger MyClass. class.getName public void foo LOG. infoA log message LOG. logLevel.INFO, Another log message LOG. fineA fine message logging an exception try code might throw an exception catch SomeException ex log a warning printing Something went wrong GoalKicker.com Java Notes for Professionals 632 together with the exception message and stacktrace LOG. logLevel.WARNING, Something went wrong , ex String s Hello World! logging an object LOG. logLevel.FINER, String s 0 , s logging several objects LOG. logLevel.FINEST, String s 0 has length 1 , new Objects, s.length Section 115.3 Logging levels Java Logging Api has 7 levels . The levels in descending order are SEVERE highest value WARNING INFO CONFIG": "input.pdf", "FINE FINER FINEST lowest value The default level is INFO but this depends on the system and used a virtual machine. Note There are also levels OFF can be used to turn logging o\ufb00 and ALL the opposite of OFF. Code example for this import java.util.logging.Logger public class Levels private static final Logger logger Logger. getLogger Levels.class.getName public static void mainString args logger. severeMessage logged by SEVERE logger. warningMessage logged by WARNING logger. infoMessage logged by INFO logger. configMessage logged by CONFIG logger. fineMessage logged by FINE logger. finerMessage logged by FINER logger. finestMessage logged by FINEST All of above methods are really just shortcut for public void logLevel level, String msg logger. logLevel.FINEST, Message logged by FINEST By default running this class will output only messages with level higher then CONFIG Jul 23, 2016 91611 PM LevelsExample main SEVERE Message logged by SEVERE GoalKicker.com Java Notes for Professionals 633Jul 23, 2016 91611 PM LevelsExample main WARNING Message logged by WARNING Jul 23, 2016 91611 PM LevelsExample main INFO Message logged by INFO GoalKicker.com Java Notes for Professionals 634Chapter 116 log4j log4j2 Apache Log4j is a Java-based logging utility, it is one of several Java logging frameworks. This topic": "input.pdf", "is to show how to setup and con\ufb01gure Log4j in Java with detailed examples on all of its possible aspects of usage. Section 116.1 Properties-File to log to DB For this example to work youll need a JDBC driver compatible to the system the database is running on. An opensource one that allows you to connect to DB2 databases on an IBM System i can be found here JT400 Even though this example is DB2 speci\ufb01c, it works for almost every other system if you exchange the driver and adapt the JDBC URL. Root logger option log4j.rootLogger ERROR, DB Redirect log messages to a DB2 Define the DB appender log4j.appender .DBorg.apache.log4j.jdbc.JDBCAppender Set JDBC URL !!! adapt to your target system !!! log4j.appender .DB.URLjdbcas40010.10.10.1446DATABASENAMEnamingsystemerrorsfull Set Database Driver !!! adapt to your target system !!! log4j.appender .DB.drivercom.ibm.as400.access.AS400JDBCDriver Set database user name and password log4j.appender .DB.userUSER log4j.appender .DB.password PASSWORD Set the SQL statement to be executed. log4j.appender .DB.sqlINSERT INTO DB. TABLENAME VALUESdyyyy-MM- dd,dHHmmss ,C,p,m Define the layout for file appender log4j.appender .DB.layoutorg.apache.log4j.PatternLayout Section 116.2 How to get Log4j Current version log4j2 Using Maven Add the following dependency to your POM.xml \ufb01le dependencies dependency groupId org.apache.logging.log4j groupId artifactId log4j-api artifactId version 2.6.2version dependency": "input.pdf", "dependency groupId org.apache.logging.log4j groupId artifactId log4j-core artifactId version 2.6.2version dependency dependencies GoalKicker.com Java Notes for Professionals 635Using Ivy dependencies dependency orgorg.apache.logging.log4j namelog4j-api rev2.6.2 dependency orgorg.apache.logging.log4j namelog4j-core rev2.6.2 dependencies Using Gradle dependencies compile group org.apache.logging.log4j , name log4j-api , version 2.6.2 compile group org.apache.logging.log4j , name log4j-core , version 2.6.2 Getting log4j 1.x Note Log4j 1.x has reached End-of-Life EOL see Remarks. Using Maven Declare this dependency in the POM.xml \ufb01le dependency groupId log4jgroupId artifactId log4jartifactId version 1.2.17version dependency Using Ivy dependency orglog4j namelog4j rev1.2.17 Usign Gradle compile group log4j, name log4j, version 1.2.17 Using Buildr log4jlog4jjar1.2.17 Adding manually in path build Download from Log4j website project Section 116.3 Setting up property \ufb01le Log4j gives you posibility to log data into console and \ufb01le at same time. Create a log4j.properties \ufb01le and put inside this basic con\ufb01guration Root logger option log4j.rootLogger DEBUG, stdout, file Redirect log messages to console log4j.appender .stdoutorg.apache.log4j.ConsoleAppender log4j.appender .stdout.TargetSystem.out log4j.appender .stdout.layoutorg.apache.log4j.PatternLayout GoalKicker.com Java Notes for Professionals 636log4j.appender .stdout.layout.ConversionPattern dyyyy-MM-dd HHmmss -5p c1L - mn Redirect log messages to a log file, support file rolling. log4j.appender .fileorg.apache.log4j.RollingFileAppender log4j.appender .file.FileClog4j-application. log log4j.appender .file.MaxFileSize 5MB log4j.appender .file.MaxBackupIndex 10 log4j.appender .file.layoutorg.apache.log4j.PatternLayout log4j.appender .file.layout.ConversionPattern dyyyy-MM-dd HHmmss -5p c1L - mn If": "input.pdf", "you are using maven, put this propertie \ufb01le in path ProjectFolder srcjavaresources Section 116.4 Basic log4j2.xml con\ufb01guration \ufb01le ?xml version1.0 encoding UTF-8? Configuration Appenders Console nameSTDOUT targetSYSTEMOUT PatternLayout patternd -5p t C2 mn Console Appenders Loggers Root leveldebug AppenderRef refSTDOUT Root Loggers Configuration This is a basic log4j2.xml con\ufb01guration which has a console appender and a root logger. The pattern layout speci\ufb01es which pattern should be used for logging the statements. In order to debug the loading of log4j2.xml you can add the attribute status WARN DEBUG ERROR FATAL TRACE INFO in the con\ufb01guration tag of your log4j2.xml. You can also add a monitor interval so that it loads the con\ufb01guration again after the speci\ufb01ed interval period. The monitor interval can be added to the con\ufb01guration tag as follows monitorInterval 30. It means that the con\ufb01g will be loaded every 30 seconds. Section 116.5 How to use Log4j in Java code First need to create a final static logger object final static Logger logger Logger. getLogger classname. class Then, call logging methods logs an error message logger.infoInformation about some param parameter Note that this line could throw a NullPointerException! in order to improve performance, it is advised to use": "input.pdf", "the isXXXEnabled Methods if logger. isInfoEnabled logger. infoInformation about some param parameter In log4j2 parameter substitution is preferable due to readability and performance The parameter substitution only takes place if info level is active which obsoletes the use of GoalKicker.com Java Notes for Professionals 637isXXXEnabled. logger.infoInformation about some param , parameter logs an exception logger.errorInformation about some error , exception Section 116.6 Migrating from log4j 1.x to 2.x If you want to migrate from existing log4j 1.x in your project to log4j 2.x then remove all existing log4j 1.x dependencies and add the following dependency Log4j 1.x API Bridge Maven Build dependencies dependency groupId org.apache.logging.log4j groupId artifactId log4j-1.2-api artifactId version 2.6.2version dependency dependencies Ivy Build dependencies dependency orgorg.apache.logging.log4j namelog4j-1.2-api rev2.6.2 dependencies Gradle Build dependencies compile group org.apache.logging.log4j , name log4j-1.2-api , version 2.6.2 Apache Commons Logging Bridge If your project is using Apache Commons Logging which use log4j 1.x and you want to migrate it to log4j 2.x then add the following dependencies Maven Build dependencies dependency groupId org.apache.logging.log4j groupId artifactId log4j-jcl artifactId version 2.6.2version dependency dependencies Ivy Build dependencies dependency orgorg.apache.logging.log4j namelog4j-jcl rev2.6.2 dependencies Gradle Build GoalKicker.com Java Notes for Professionals 638dependencies compile group org.apache.logging.log4j , name log4j-jcl": "input.pdf", ", version 2.6.2 Note Do not remove any existing dependencies of Apache commons logging Reference httpslogging.apache.orglog4j2.xmaven-artifacts.html Section 116.7 Filter Logoutput by level log4j 1.x You can use a \ufb01lter to log only messages lower than e.g. ERROR level. But the \ufb01lter is not supported by PropertyCon\ufb01gurator. So you must change to XML con\ufb01g to use it . See log4j-Wiki about \ufb01lters . Example speci\ufb01c level appender nameinfo-out classorg.apache.log4j.FileAppender param nameFile valueinfo.log layout classorg.apache.log4j.PatternLayout param nameConversionPattern valuemn layout filter classorg.apache.log4j.varia.LevelMatchFilter param nameLevelToMatch valueinfo param nameAcceptOnMatch valuetrue filter filter classorg.apache.log4j.varia.DenyAllFilter appender Or Level range appender nameinfo-out classorg.apache.log4j.FileAppender param nameFile valueinfo.log layout classorg.apache.log4j.PatternLayout param nameConversionPattern valuemn layout filter classorg.apache.log4j.varia.LevelRangeFilter param nameLevelMax valueinfo param nameLevelMin valueinfo param nameAcceptOnMatch valuetrue filter appender GoalKicker.com Java Notes for Professionals 639Chapter 117 Oracle Ocial Code Standard Oracle o\ufb03cial style guide for the Java Programming Language is a standard followed by developers at Oracle and recommended to be followed by any other Java developer. It covers \ufb01lenames, \ufb01le organization, indentation, comments, declarations, statements, white space, naming conventions, programming practices and includes a code example. Section 117.1 Naming Conventions Package names Package names should be all lower case without underscores or other special characters. Package names begin with the": "input.pdf", "reversed authority part of the web address of the company of the developer. This part can be followed a by projectprogram structure dependent package substructure. Dont use plural form. Follow the convention of the standard API which uses for instance java.lang.annotation and not java.lang.annotations . Examples com.yourcompany .widget.button , com.yourcompany .core.api Class, Interface and Enum Names Class and enum names should typically be nouns. Interface names should typically be nouns or adjectives ending with able. Use mixed case with the \ufb01rst letter in each word in upper case i.e. CamelCase . Match the regular expression A-Za-zA-Z0-9. Use whole words and avoid using abbreviations unless the abbreviation is more widely used than the long form. Format an abbreviation as a word if the it is part of a longer class name. Examples ArrayList , BigInteger , ArrayIndexOutOfBoundsException , Iterable . Method Names Method names should typically be verbs or other descriptions of actions They should match the regular expression a-za-zA-Z0-9. Use mixed case with the \ufb01rst letter in lower case. Examples toString , hashCode Variables Variable names should be in mixed case with the \ufb01rst letter in lower case Match the regular expression a-za-zA-Z0-9 Further recommendation Variables Examples elements ,": "input.pdf", "currentIndex Type Variables For simple cases where there are few type variables involved use a single upper case letter. Match the regular expression A-Z0-9? If one letter is more descriptive than another such as K and V for keys and values in maps or R for a function return type use that, otherwise use T. For complex cases where single letter type variables become confusing, use longer names written in all capital letters and use underscore to separate words. GoalKicker.com Java Notes for Professionals 640Examples T, V, SRCVERTEX Constants Constants static final \ufb01elds whose content is immutable, by language rules or by convention should be named with all capital letters and underscore to separate words. Match the regular expression A-ZA-Z0-9A-Z0-9 Examples BUFFERSIZE , MAXLEVEL Other guidelines on naming Avoid hidingshadowing methods, variables and type variables in outer scopes. Let the verbosity of the name correlate to the size of the scope. For instance, use descriptive names for \ufb01elds of large classes and brief names for local short-lived variables. When naming public static members, let the identi\ufb01er be self descriptive if you believe they will be statically imported. Further reading Naming Section in the o\ufb03cial Java Style Guide Source Java": "input.pdf", "Style Guidelines from Oracle Section 117.2 Class Structure Order of class members Class members should be ordered as follows Fields in order of public, protected and private1. Constructors2. Factory methods3. Other Methods in order of public, protected and private4. Ordering \ufb01elds and methods primarily by their access modi\ufb01ers or identi\ufb01er is not required. Here is an example of this order class Example private int i Example int i this.i i static Example getExample int i return new Example i Override public String toString return An example i Grouping of class members GoalKicker.com Java Notes for Professionals 641Related \ufb01elds should be grouped together. A nested type may be declared right before its \ufb01rst use otherwise it should be declared before the \ufb01elds. Constructors and overloaded methods should be grouped together by functionality and ordered with increasing arity. This implies that delegation among these constructs \ufb02ow downward in the code. Constructors should be grouped together without other members between. Overloaded variants of a method should be grouped together without other members between. Section 117.3 Annotations Declaration annotations should be put on a separate line from the declaration being annotated. SuppressWarnings unchecked public T toArray T typeHolder ... However, few or short": "input.pdf", "annotations annotating a single-line method may be put on the same line as the method if it improves readability. For example, one may write Nullable String getName return name For a matter of consistency and readability, either all annotations should be put on the same line or each annotation should be put on a separate line. Bad. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Even worse. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Good. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Good. Deprecated SafeVarargs CustomAnnotation public final TupleT extendT... elements ... Section 117.4 Import statements First javajavax packages import java.util.ArrayList import javax.tools.JavaCompiler GoalKicker.com Java Notes for Professionals 642 Then third party libraries import com.fasterxml.jackson.annotation.JsonProperty Then project imports import com.example.my.package.ClassA import com.example.my.package.ClassB Then static imports in the same order as above import static java.util.stream.Collectors .toList Import statements should be sorted primarily by non-static static with non-static imports \ufb01rst. secondarily by package origin according to the following order java packages javax packages external packages e.g. org.xml internal packages e.g. com.sun tertiary by package and class identi\ufb01er in lexicographical order Import statements should not be line wrapped, regardless of whether it exceeds the recommended maximum length": "input.pdf", "of a line. No unused imports should be present. Wildcard imports Wildcard imports should in general not be used. When importing a large number of closely-related classes such as implementing a visitor over a tree with dozens of distinct node classes, a wildcard import may be used. In any case, no more than one wildcard import per \ufb01le should be used. Section 117.5 Braces class Example void methodboolean error if error Log. errorError occurred! System.out.printlnError! else Use braces since the other block uses braces. System.out.printlnNo error Opening braces should be put on the end of the current line rather than on a line by its own. There should be a new line in front of a closing brace unless the block is empty see Short Forms below Braces are recommended even where the language makes them optional, such as single-line if and loop bodies. If a block spans more than one line including comments it must have braces. If one of the blocks in a if else statement has braces, the other block must too. If the block comes last in an enclosing block, it must have braces. The else , catch and the while keyword in dowhile loops": "input.pdf", "go on the same line as the closing brace of the GoalKicker.com Java Notes for Professionals 643preceding block. Short forms enum Response YES, NO, MAYBE public boolean isReference return true The above recommendations are intended to improve uniformity and thus increase familiarity readability. In some cases short forms that deviate from the above guidelines are just as readable and may be used instead. These cases include for instance simple enum declarations and trivial methods and lambda expressions. Section 117.6 Redundant Parentheses return flag ? yes no String cmp flag1 ! flag2 ? not equal equal Dont do this return flag ? yes no Redundant grouping parentheses i.e. parentheses that does not a\ufb00ect evaluation may be used if they improve readability. Redundant grouping parentheses should typically be left out in shorter expressions involving common operators but included in longer expressions or expressions involving operators whose precedence and associativity is unclear without parentheses. Ternary expressions with non-trivial conditions belong to the latter. The entire expression following a return keyword must not be surrounded by parentheses. Section 117.7 Modi\ufb01ers class ExampleClass Access modifiers first dont do for instance static public public static void mainString args System.out.printlnHello World interface ExampleInterface Avoid public and": "input.pdf", "abstract since they are implicit void sayHello Modi\ufb01ers should go in the following order Access modi\ufb01er public private protected abstract static final transient volatile default synchronized native strictfp GoalKicker.com Java Notes for Professionals 644Modi\ufb01ers should not be written out when they are implicit. For example, interface methods should neither be declared public nor abstract , and nested enums and interfaces should not be declared static. Method parameters and local variables should not be declared final unless it improves readability or documents an actual design decision. Fields should be declared final unless there is a compelling reason to make them mutable. Section 117.8 Indentation Indentation level is four spaces . Only space characters may be used for indentation. No tabs. Empty lines must not be indented. This is implied by the no trailing white space rule. case lines should be indented with four spaces, and statements within the case should be indented with another four spaces. switch var case TWO setChoice two break case THREE setChoice three break default throw new IllegalArgumentException Refer to Wrapping statements for guidelines on how to indent continuation lines. Section 117.9 Literals long l 5432L int i 0x123 0xABC byte b 0b1010 float f1 1": "input.pdf", "5432f float f2 0.123e4f double d1 1 5432d or 1 5432.0 double d2 0x1.3p2 long literals should use the upper case letter L su\ufb03x. Hexadecimal literals should use upper case letters A-F. All other numerical pre\ufb01xes, in\ufb01xes, and su\ufb03xes should use lowercase letters. Section 117.10 Package declaration package com.example.my.package The package declaration should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line. Section 117.11 Lambda Expressions Runnable r - System.out.printlnHello World Supplier String c - Hello World GoalKicker.com Java Notes for Professionals 645 Collectioncontains is a simple unary method and its behavior is clear from the context. A method reference is preferred here. appendFilter goodStrings contains A lambda expression is easier to understand than just tempMapput in this case trackTemperature time, temp - tempMap. puttime, temp Expression lambdas are preferred over single-line block lambdas. Method references should generally be preferred over lambda expressions. For bound instance method references, or methods with arity greater than one, a lambda expression may be easier to understand and therefore preferred. Especially if the behavior of the method is not clear from the context. The parameter types should be omitted unless they improve readability. If a lambda": "input.pdf", "expression stretches over more than a few lines, consider creating a method. Section 117.12 Java Source Files All lines must be terminated with a line feed character LF, ASCII value 10 and not for instance CR or CRLF. There may be no trailing white space at the end of a line. The name of a source \ufb01le must equal the name of the class it contains followed by the .java extension, even for \ufb01les that only contain a package private class. This does not apply to \ufb01les that do not contain any class declarations, such as package-info.java . Section 117.13 Wrapping statements Source code and comments should generally not exceed 80 characters per line and rarely if ever exceed 100 characters per line, including indentation. The character limit must be judged on a case by case basis. What really matters is the semantical density and readability of the line. Making lines gratuitously long makes them hard to read similarly, making heroic attempts to \ufb01t them into 80 columns can also make them hard to read. The \ufb02exibility outlined here aims to enable developers to avoid these extremes, not to maximize use of monitor real-estate. URLs or example commands should": "input.pdf", "not be wrapped. Ok even though it might exceed max line width when indented. Error e isTypeParam ? Errors. InvalidRepeatableAnnotationNotApplicable targetContainerType, on Errors. InvalidRepeatableAnnotationNotApplicableInContext targetContainerType Wrapping preferable String pretty Stream. ofargs . mapArgument prettyPrint . collectors joining, Too strict interpretation of max line width. Readability suffers. Error e isTypeParam ? Errors. InvalidRepeatableAnnotationNotApplicable targetContainerType, on Errors. InvalidRepeatableAnnotationNotApplicableInContext targetContainerType Should be wrapped even though it fits within the character limit GoalKicker.com Java Notes for Professionals 646String pretty Stream. ofargs.mapArgument prettyPrint .collectors joining, Wrapping at a higher syntactical level is preferred over wrapping at a lower syntactical level. There should be at most 1 statement per line. A continuation line should be indented in one of the following four ways Variant 1 With 8 extra spaces relative to the indentation of the previous line. Variant 2 With 8 extra spaces relative to the starting column of the wrapped expression. Variant 3 Aligned with previous sibling expression as long as it is clear that it s a continuation line Variant 4 Aligned with previous method call in a chained expression. Section 117.14 Wrapping Method Declarations int someMethod String aString, List Integer aList, Map String, String aMap, int anInt, long aLong, Set Number aSet,": "input.pdf", "double aDouble int someMethod String aString, List Integer aList, Map String, String aMap, int anInt, long aLong, double aDouble, long aLong int someMethod String aString, List MapInteger, StringBuffer aListOfMaps, Map String, String aMap throws IllegalArgumentException int someMethod String aString, List Integer aList, Map String, String aMap, int anInt throws IllegalArgumentException Method declarations can be formatted by listing the arguments vertically, or by a new line and 8 extra spaces If a throws clause needs to be wrapped, put the line break in front of the throws clause and make sure it stands out from the argument list, either by indenting 8 relative to the function declaration, or 8 relative to the previous line. Section 117.15 Wrapping Expressions If a line approaches the maximum character limit, always consider breaking it down into multiple statements expressions instead of wrapping the line. Break before operators. Break before the . in chained method calls. GoalKicker.com Java Notes for Professionals 647popupMsg Inbox notification You have newMsgs new messages Dont! Looks like two arguments popupMsg Inbox notification You have newMsgs new messages Section 117.16 Whitespace Vertical Whitespace A single blank line should be used to separate Package declaration Class declarations Constructors Methods Static initializers Instance": "input.pdf", "initializers and may be used to separate logical groups of import statements \ufb01elds statements Multiple consecutive blank lines should only be used to separate groups of related members and not as the standard inter-member spacing. Horizontal Whitespace A single space should be used To separate keywords from neighboring opening or closing brackets and braces Before and after all binary operators and operator like symbols such as arrows in lambda expressions and the colon in enhanced for loops but not before the colon of a label After that starts a comment. After commas separating arguments and semicolons separating the parts of a for loop. After the closing parenthesis of a cast. In variable declarations it is not recommended to align types and variables. Section 117.17 Special Characters Apart from LF the only allowed white space character is Space ASCII value 32. Note that this implies that other white space characters in, for instance, string and character literals must be written in escaped form. , , , t, b, r, f, and n should be preferred over corresponding octal e.g. 047 or Unicode e.g. u0027 escaped characters. Should there be a need to go against the above rules for the sake": "input.pdf", "of testing, the test should generate the required input programmatically. GoalKicker.com Java Notes for Professionals 648Section 117.18 Variable Declarations One variable per declaration and at most one declaration per line Square brackets of arrays should be at the type String args and not on the variable String args. Declare a local variable right before it is \ufb01rst used, and initialize it as close to the declaration as possible. GoalKicker.com Java Notes for Professionals 649Chapter 118 Character encoding Section 118.1 Reading text from a \ufb01le encoded in UTF-8 import java.io.BufferedReader import java.io.BufferedWriter import java.io.IOException import java.nio.charset.StandardCharsets import java.nio.file.Files import java.nio.file.Paths public class ReadingUTF8TextFile public static void mainString args throws IOException StandardCharsets is available since Java 1.7 for ealier version use Charset.forNameUTF-8 try BufferedWriter wr Files.newBufferedWriter Paths.gettest.txt , StandardCharsets. UTF8 wr. writeStrange cyrillic symbol \u042b First Way. For big files try BufferedReader reader Files.newBufferedReader Paths.gettest.txt , StandardCharsets. UTF8 String line while line reader. readLine ! null System.out.printline System.out.println just separating output Second way. For small files String s new StringFiles.readAllBytes Paths.gettest.txt , StandardCharsets. UTF8 System.out.prints Section 118.2 Writing text to a \ufb01le in UTF-8 import java.io.BufferedWriter import java.io.IOException import java.nio.charset.StandardCharsets import java.nio.file.Files import java.nio.file.Paths public class WritingUTF8TextFile public static void mainString": "input.pdf", "args throws IOException StandardCharsets is available since Java 1.7 for ealier version use Charset.forNameUTF-8 try BufferedWriter wr Files.newBufferedWriter Paths.gettest2.txt , StandardCharsets. UTF8 wr. writeCyrillic symbol \u042b GoalKicker.com Java Notes for Professionals 650Section 118.3 Getting byte representation of a string in UTF-8 import java.nio.charset.StandardCharsets import java.util.Arrays public class GetUtf8BytesFromString public static void mainString args String str Cyrillic symbol \u042b StandardCharsets is available since Java 1.7 for ealier version use Charset.forNameUTF-8 byte textInUtf8 str.getBytes StandardCharsets. UTF8 System.out.printlnArrays.toString textInUtf8 GoalKicker.com Java Notes for Professionals 651Chapter 119 Apache Commons Lang Section 119.1 Implement equals method To implement the equals method of an object easily you could use the EqualsBuilder class. Selecting the \ufb01elds Override public boolean equalsObject obj if!obj instanceof MyClass return false MyClass theOther MyClass obj EqualsBuilder builder new EqualsBuilder builder. appendfield1, theOther. field1 builder. appendfield2, theOther. field2 builder. appendfield3, theOther. field3 return builder. isEquals Using re\ufb02ection Override public boolean equalsObject obj return EqualsBuilder. reflectionEquals this, obj, false the boolean parameter is to indicates if the equals should check transient \ufb01elds. Using re\ufb02ection avoiding some \ufb01elds Override public boolean equalsObject obj return EqualsBuilder. reflectionEquals this, obj, field1 , field2 Section 119.2 Implement hashCode method To implement the hashCode method of an object": "input.pdf", "easily you could use the HashCodeBuilder class. Selecting the \ufb01elds Override public int hashCode HashCodeBuilder builder new HashCodeBuilder builder. appendfield1 builder. appendfield2 builder. appendfield3 return builder. hashCode GoalKicker.com Java Notes for Professionals 652Using re\ufb02ection Override public int hashCode return HashCodeBuilder. reflectionHashCode this, false the boolean parameter indicates if it should use transient \ufb01elds. Using re\ufb02ection avoiding some \ufb01elds Override public int hashCode return HashCodeBuilder. reflectionHashCode this, field1 , field2 Section 119.3 Implement toString method To implement the toString method of an object easily you could use the ToStringBuilder class. Selecting the \ufb01elds Override public String toString ToStringBuilder builder new ToStringBuilder this builder. appendfield1 builder. appendfield2 builder. appendfield3 return builder. toString Example result ar.com.jonat.lang.MyClassdd7123null,0,false Explicitly giving names to the \ufb01elds Override public String toString ToStringBuilder builder new ToStringBuilder this builder. appendfield1 ,field1 builder. appendfield2 ,field2 builder. appendfield3 ,field3 return builder. toString Example result ar.com.jonat.lang.MyClassdd7404field1null,field20,field3false You could change the style via parameter Override GoalKicker.com Java Notes for Professionals 653public String toString ToStringBuilder builder new ToStringBuilder this, ToStringStyle. MULTILINESTYLE builder. appendfield1 , field1 builder. appendfield2 , field2 builder. appendfield3 , field3 return builder. toString Example result ar.com.bna.lang.MyClassebbf5c field1 null field2 0 field3 false There are some styles, for example JSON, no Classname,": "input.pdf", "short, etc ... Via re\ufb02ection Override public String toString return ToStringBuilder. reflectionToString this You could also indicate the style Override public String toString return ToStringBuilder. reflectionToString this, ToStringStyle. JSONSTYLE GoalKicker.com Java Notes for Professionals 654Chapter 120 Localization and Internationalization Section 120.1 Locale The java.util.Locale class is used to represent a geographical, political or cultural region to localize a given text, number, date or operation to. A Locale object may thus contain a country, region, language, and also a variant of a language, for instance a dialect spoken in a certain region of a country, or spoken in a di\ufb00erent country than the country from which the language originates. The Locale instance is handed to components that need to localize their actions, whether it is converting the input, output, or just need it for internal operations. The Locale class cannot do any internationalization or localization by itself Language The language must be an ISO 639 2 or 3 character language code, or a registered language subtag of up to 8 characters. In case a language has both a 2 and 3 character language code, use the 2 character code. A full list of language codes can be found in the": "input.pdf", "IANA Language Subtag Registry. Language codes are case insensitive, but the Locale class always use lowercase versions of the language codes Creating a Locale Creating a java.util.Locale instance can be done in four di\ufb00erent ways Locale constants Locale constructors Locale.Builder class Locale.forLanguageTag factory method Java ResourceBundle You create a ResourceBundle instance like this Locale locale new Localeen, US ResourceBundle labels ResourceBundle .getBundle i18n.properties System.out.printlnlabels.getString message Consider I have a property \ufb01le i18n.properties messageThis is locale Output This is locale Setting Locale If you want to reproduce the state using other languages, you can use setDefault method. Its usage setDefault Locale.JAPANESE Set Japanese GoalKicker.com Java Notes for Professionals 655Section 120.2 Automatically formatted Dates using locale SimpleDateFormatter is great in a pinch, but like the name suggests it doesnt scale well. If you hard-code MMddyyyy all over your application your international users wont be happy. Let Java do the work for you Use the static methods in DateFormat to retrieve the right formatting for your user. For a desktop application where youll rely on the default locale , simply call String localizedDate DateFormat .getDateInstance style.formatdate Where style is one of the formatting constants FULL , LONG , MEDIUM , SHORT ,": "input.pdf", "etc. speci\ufb01ed in DateFormat . For a server-side application where the user speci\ufb01es their locale as part of the request, you should pass it explicitly to getDateInstance instead String localizedDate DateFormat .getDateInstance style, request. getLocale .formatdate Section 120.3 String Comparison Compare two Strings ignoring case School .equalsIgnoreCase school true Dont use text1.toLowerCase .equalstext2.toLowerCase Languages have di\ufb00erent rules for converting upper and lower case. A I would be converted to i in English. But in Turkish a I becomes a \u0131. If you have to use toLowerCase use the overload which expects a Locale String.toLowerCase Locale. Comparing two Strings ignoring minor di\ufb00erences Collator collator Collator .getInstance Locale.GERMAN collator. setStrength Collator .PRIMARY collator. equalsG\u00e4rten, gaerten returns true Sort Strings respecting natural language order, ignoring case use collation key to String texts new String Birne, \u00e4ther, Apfel Collator collator Collator .getInstance Locale.GERMAN collator. setStrength Collator .SECONDARY ignore case Arrays.sorttexts, collator compare will return Apfel, \u00e4ther, Birne GoalKicker.com Java Notes for Professionals 656Chapter 121 Parallel programming with ForkJoin framework Section 121.1 ForkJoin Tasks in Java The forkjoin framework in Java is ideal for a problem that can be divided into smaller pieces and solved in parallel. The fundamental steps of a forkjoin problem": "input.pdf", "are Divide the problem into multiple pieces Solve each of the pieces in parallel to each other Combine each of the sub-solutions into one overall solution A ForkJoinTask is the interface that de\ufb01nes such a problem. It is generally expected that you will subclass one of its abstract implementations usually the RecursiveTask rather than implement the interface directly. In this example, we are going to sum a collection of integers, dividing until we get to batch sizes of no more than ten. import java.util.List import java.util.concurrent.RecursiveTask public class SummingTask extends RecursiveTask Integer private static final int MAXBATCHSIZE 10 private final ListInteger numbers private final int minInclusive, maxExclusive public SummingTask ListInteger numbers thisnumbers, 0, numbers. size This constructor is only used internally as part of the dividing process private SummingTask ListInteger numbers, int minInclusive, int maxExclusive this.numbers numbers this.minInclusive minInclusive this.maxExclusive maxExclusive Override public Integer compute if maxExclusive - minInclusive MAXBATCHSIZE This is too big for a single batch, so we shall divide into two tasks int mid minInclusive maxExclusive 2 SummingTask leftTask new SummingTask numbers, minInclusive, mid SummingTask rightTask new SummingTask numbers, mid, maxExclusive Submit the left hand task as a new task to the same ForkJoinPool leftTask. fork": "input.pdf", "Run the right hand task on the same thread and get the result int rightResult rightTask. compute Wait for the left hand task to complete and get its result int leftResult leftTask. join And combine the result return leftResult rightResult else GoalKicker.com Java Notes for Professionals 657 This is fine for a single batch, so we will run it here and now int sum 0 for int i minInclusive i maxExclusive i sum numbers. geti return sum An instance of this task can now be passed to an instance of ForkJoinPool . Because I am not specifying the number of threads it will create a thread for each available processor ForkJoinPool pool new ForkJoinPool Submit the task to the pool, and get what is effectively the Future ForkJoinTask Integer task pool.submitnew SummingTask numbers Wait for the result int result task.join GoalKicker.com Java Notes for Professionals 658Chapter 122 Non-Access Modi\ufb01ers Non-Access Modi\ufb01ers do not change the accessibility of variables and methods, but they do provide them special properties . Section 122.1 \ufb01nal final in Java can refer to variables, methods and classes. There are three simple rules \ufb01nal variable cannot be reassigned \ufb01nal method cannot be overridden \ufb01nal class cannot": "input.pdf", "be extended Usages Good Programming Practice Some developer consider it good practice to mark a variable \ufb01nal when you can. If you have a variable that should not be changed, you should mark it \ufb01nal. An important use of final keyword if for method parameters. If you want to emphasize that a method doesnt change its input parameters, mark the properties as \ufb01nal. public int sumupfinal ListInteger ints This emphasizes that the sumup method is not going to change the ints . Inner class Access If your anonymous inner class wants to access a variable, the variable should be marked final public IPrintName printName String name return new IPrintName Override public void printName System.out.printlnname This class doesnt compile, as the variable name , is not \ufb01nal. Version Java SE 8 E\ufb00ectively \ufb01nal variables are an exception. These are local variables that are written to only once and could therefore be made \ufb01nal. E\ufb00ectively \ufb01nal variables can be accessed from anonymus classes too. final static variable Even though the code below is completely legal when final variable foo is not static , in case of static it will not compile class TestFinal private final static List foo GoalKicker.com Java Notes": "input.pdf", "for Professionals 659 public Test foo new ArrayList The reason is, lets repeat again, \ufb01nal variable cannot be reassigned . Since foo is static, it is shared among all instances of class TestFinal . When a new instance of a class TestFinal is created, its constructor is invoked and therefore foo gets reassigned which compiler does not allow. A correct way to initialize variable foo in this case is either class TestFinal private static final List foo new ArrayList .. or by using a static initializer class TestFinal private static final List foo static foo new ArrayList .. final methods are useful when base class implements some important functionality that derived class is not supposed to change it. They are also faster than non-\ufb01nal methods, because there is no concept of virtual table involved. All wrapper classes in Java are \ufb01nal, such as Integer , Long etc. Creators of these classes didnt want that anyone can e.g. extend Integer into his own class and change the basic behavior of Integer class. One of the requirements to make a class immutable is that subclasses may not override methods. The simplest way to do this is to declare the class as": "input.pdf", "final . Section 122.2 static The static keyword is used on a class, method, or \ufb01eld to make them work independently of any instance of the class. Static \ufb01elds are common to all instances of a class. They do not need an instance to access them. Static methods can be run without an instance of the class they are in. However, they can only access static \ufb01elds of that class. Static classes can be declared inside of other classes. They do not need an instance of the class they are in to be instantiated. public class TestStatic static int staticVariable static This block of code is run when the class first loads staticVariable 11 int nonStaticVariable 5 static void doSomething GoalKicker.com Java Notes for Professionals 660 We can access static variables from static methods staticVariable 10 void add We can access both static and non-static variables from non-static methods nonStaticVariable staticVariable static class StaticInnerClass int number public StaticInnerClass int number number number void doSomething We can access number and staticVariable, but not nonStaticVariable number staticVariable int getNumber return number Static fields and methods TestStatic object1 new TestStatic System.out.printlnobject1. staticVariable 11 System.out.printlnTestStatic. staticVariable 11 TestStatic. doSomething TestStatic object2 new TestStatic": "input.pdf", "System.out.printlnobject1. staticVariable 10 System.out.printlnobject2. staticVariable 10 System.out.printlnTestStatic. staticVariable 10 object1. add System.out.printlnobject1. nonStaticVariable 15 System.out.printlnobject2. nonStaticVariable 10 Static inner classes StaticInnerClass object3 new TestStatic. StaticInnerClass 100 StaticInnerClass object4 new TestStatic. StaticInnerClass 200 System.out.printlnobject3. getNumber 100 System.out.printlnobject4. getNumber 200 object3. doSomething System.out.printlnobject3. getNumber 110 System.out.printlnobject4. getNumber 200 Section 122.3 abstract Abstraction is a process of hiding the implementation details and showing only functionality to the user. An abstract GoalKicker.com Java Notes for Professionals 661class can never be instantiated. If a class is declared as abstract then the sole purpose is for the class to be extended. abstract class Car abstract void tagLine class Honda extends Car void tagLine System.out.printlnStart Something Special class Toyota extends Car void tagLine System.out.printlnDrive Your Dreams Section 122.4 strictfp Version Java SE 1.2 strictfp modi\ufb01er is used for \ufb02oating-point calculations. This modi\ufb01er makes \ufb02oating point variable more consistent across multiple platforms and ensure all the \ufb02oating point calculations are done according to IEEE 754 standards to avoid errors of calculation round-o\ufb00 errors, over\ufb02ows and under\ufb02ows on both 32bit and 64bit architecture. This cannot be applied on abstract methods, variables or constructors. strictfp keyword can be applied on methods, classes and interfaces. strictfp class A strictfp interface": "input.pdf", "M class A strictfp void m Section 122.5 volatile The volatile modi\ufb01er is used in multi threaded programming. If you declare a \ufb01eld as volatile it is a signal to threads that they must read the most recent value, not a locally cached one. Furthermore, volatile reads and writes are guaranteed to be atomic access to a non- volatile long or double is not atomic, thus avoiding certain readwrite errors between multiple threads. public class MyRunnable implements Runnable private volatile boolean active public void run run is called in one thread active true while active some code here GoalKicker.com Java Notes for Professionals 662 public void stop stop is called from another thread active false Section 122.6 synchronized Synchronized modi\ufb01er is used to control the access of a particular method or a block by multiple threads. Only one thread can enter into a method or a block which is declared as synchronized. synchronized keyword works on intrinsic lock of an object, in case of a synchronized method current objects lock and static method uses class object. Any thread trying to execute a synchronized block must acquire the object lock \ufb01rst. class Shared int i synchronized void SharedMethod Thread t": "input.pdf", "Thread.currentThread forint i 0 i 1000 i System.out.printlnt.getName i void SharedMethod2 synchronized this System.out.printlnThais access to currect object is synchronize this public class ThreadsInJava public static void mainString args final Shared s1 new Shared Thread t1 new ThreadThread - 1 Override public void run s1. SharedMethod Thread t2 new ThreadThread - 2 Override public void run s1. SharedMethod GoalKicker.com Java Notes for Professionals 663 t1. start t2. start Section 122.7 transient A variable which is declared as transient will not be serialized during object serialization. public transient int limit 55 will not persist public int b will persist GoalKicker.com Java Notes for Professionals 664Chapter 123 Process Section 123.1 Pitfall Runtime.exec, Process and ProcessBuilder dont understand shell syntax The Runtime.execString ... and Runtime.execString methods allow you to execute a command as an external process1. In the \ufb01rst version, you supply the command name and the command arguments as separate elements of the string array, and the Java runtime requests the OS runtime system to start the external command. The second version is deceptively easy to use, but it has some pitfalls. First of all, here is an example of using execString being used safely Process p Runtime.execmkdir tmptestDir p.waitFor if": "input.pdf", "p.exitValue 0 System.out.printlncreated the directory Spaces in pathnames Suppose that we generalize the example above so that we can create an arbitrary directory Process p Runtime.execmkdir dirPath ... This will typically work, but it will fail if dirPath is for example homeuserMy Documents. The problem is that execString splits the string into a command and arguments by simply looking for whitespace. The command string mkdir homeuserMy Documents will be split into mkdir, homeuserMy , Documents and this will cause the mkdir command to fail because it expects one argument, not two. Faced with this, some programmers try to add quotes around the pathname. This doesnt work either mkdir homeuserMy Documents will be split into mkdir, homeuserMy , Documents The extra double-quote characters that were added in attempt to quote the spaces are treated like any other non- whitespace characters. Indeed, anything we do quote or escape the spaces is going to fail. The way to deal with this particular problems is to use the execString ... overload. Process p Runtime.execmkdir, dirPath ... GoalKicker.com Java Notes for Professionals 665This will work if dirpath includes whitespace characters because this overload of exec does not attempt to split the arguments. The strings": "input.pdf", "are passed through to the OS exec system call as-is. Redirection, pipelines and other shell syntax Suppose that we want to redirect an external commands input or output, or run a pipeline. For example Process p Runtime.execfind -name .java -print 2devnull or Process p Runtime.execfind source -name .java xargs grep package The \ufb01rst example lists the names of all Java \ufb01les in the \ufb01le system, and the second one prints the package statements2 in the Java \ufb01les in the source tree. These are not going to work as expected. In the \ufb01rst case, the \ufb01nd command will be run with 2devnull as a command argument. It will not be interpreted as a redirection. In the second example, the pipe character and the works following it will be given to the \ufb01nd command. The problem here is that the exec methods and ProcessBuilder do not understand any shell syntax. This includes redirections, pipelines, variable expansion, globbing, and so on. In a few cases for example, simple redirection you can easily achieve the desired e\ufb00ect using ProcessBuilder . However, this is not true in general. An alternative approach is to run the command line in a shell for example Process p": "input.pdf", "Runtime.execbash, -c, find -name .java -print 2devnull or Process p Runtime.execbash, -c, find source -name .java xargs grep package But note that in the second example, we needed to escape the wildcard character because we want the wildcard to be interpreted by \ufb01nd rather than the shell. Shell builtin commands dont work Suppose the following examples wont work on a system with a UNIX-like shell Process p Runtime.execcd, tmp Change java apps home directory or Process p Runtime.execexport , NAMEvalue Export NAME to the java apps environment There are a couple of reasons why this wont work On cd and export commands are shell builtin commands. They dont exist as distinct executables.1. For shell builtins to do what they are supposed to do e.g. change the working directory, update the2. environment, they need to change the place where that state resides. For a normal application including a Java application the state is associated with the application process. So for example, the child process that would run the cd command could not change the working directory of its parent java process. Similarly, GoalKicker.com Java Notes for Professionals 666one exec d process cannot change the working directory for a process that": "input.pdf", "follows it. This reasoning applies to all shell builtin commands. 1 - You can use ProcessBuilder as well, but that is not relevant to the point of this example. 2 - This is a bit rough and ready ... but once again, the failings of this approach are not relevant to the example. Section 123.2 Simple example Java version 1.5 This example will call the windows calculator. Its important to notice that the exit code will vary accordingly to the programscript that is being called. package process.example import java.io.IOException public class App public static void mainString args try Executes windows calculator Process p Runtime.getRuntime .execcalc.exe Wait for process until it terminates int exitCode p.waitFor System.out.printlnexitCode catch IOException e e. printStackTrace catch InterruptedException e e. printStackTrace GoalKicker.com Java Notes for Professionals 667Chapter 124 Java Native Access Section 124.1 Introduction to JNA What is JNA? Java Native Access JNA is a community-developed library providing Java programs an easy access to native shared libraries .dll \ufb01les on windows, .so \ufb01les on Unix ... How can I use it? Firstly, download the latest release of JNA and reference its jna.jar in your projects CLASSPATH. Secondly, copy, compile and run the Java code below": "input.pdf", "For the purpose of this introduction, we suppose the native platform in use is Windows. If youre running on another platform simply replace the string msvcrt with the string c in the code below. The small Java program below will print a message on the console by calling the C printf function. CRuntimeLibrary.java package jna.introduction import com.sun.jna.Library import com.sun.jna.Native We declare the printf function we need and the library containing it msvcrt... public interface CRuntimeLibrary extends Library CRuntimeLibrary INSTANCE CRuntimeLibrary Native.loadLibrary msvcrt , CRuntimeLibrary. class void printfString format, Object... args MyFirstJNAProgram.java package jna.introduction Now we call the printf function... public class MyFirstJNAProgram public static void mainString args CRuntimeLibrary. INSTANCE .printfHello World from JNA ! Where to go now? Jump into another topic here or jump to the o\ufb03cial site . GoalKicker.com Java Notes for Professionals 668Chapter 125 Modules Section 125.1 De\ufb01ning a basic module Modules are de\ufb01ned in a \ufb01le named module-info.java , named a module descriptor. It should be placed in the source-code root -- module-info.java -- com -- example -- foo -- Foo.java -- bar -- Bar.java Here is a simple module descriptor module com. example requires java. httpclient exports com. example.foo The module name should be": "input.pdf", "unique and it is recommended that you use the same Reverse-DNS naming notation as used by packages to help ensure this. The module java.base , which contains Javas basic classes, is implicitly visible to any module and does not need to be included. The requires declaration allows us to use other modules, in the example the module java.httpclient is imported. A module can also specify which packages it exports and therefore makes it visible to other modules. The package com.example.foo declared in the exports clause will be visible to other modules. Any sub-packages of com.example.foo will not be exported, they need their own export declarations. Conversely, com.example.bar which is not listed in exports clauses will not be visible to other modules. GoalKicker.com Java Notes for Professionals 669Chapter 126 Concurrent Programming Threads Concurrent computing is a form of computing in which several computations are executed concurrently instead of sequentially. Java language is designed to support concurrent programming through the usage of threads. Objects and resources can be accessed by multiple threads each thread can potentially access any object in the program and the programmer must ensure read and write access to objects is properly synchronized between threads. Section 126.1 Callable": "input.pdf", "and Future While Runnable provides a means to wrap code to be executed in a di\ufb00erent thread, it has a limitation in that it cannot return a result from the execution. The only way to get some return value from the execution of a Runnable is to assign the result to a variable accessible in a scope outside of the Runnable . Callable was introduced in Java 5 as a peer to Runnable . Callable is essentially the same except it has a call method instead of run. The call method has the additional capability to return a result and is also allowed to throw checked exceptions. The result from a Callable task submission is available to be tapped via a Future Future can be considered a container of sorts that houses the result of the Callable computation. Computation of the callable can carry on in another thread, and any attempt to tap the result of a Future will block and will only return the result once it is available. Callable Interface public interface Callable V V call throws Exception Future interface FutureV V get V get long timeout, TimeUnit unit boolean cancelboolean mayInterruptIfRunning boolean isCancelled boolean isDone Using": "input.pdf", "Callable and Future example public static void mainString args throws Exception ExecutorService es Executors. newSingleThreadExecutor System.out.printlnTime At Task Submission new Date Future String result es.submitnew ComplexCalculator the call to Future.get blocks until the result is available.So we are in for about a 10 sec wait now System.out.printlnResult of Complex Calculation is result. get System.out.printlnTime At the Point of Printing the Result new Date Our Callable that does a lengthy computation GoalKicker.com Java Notes for Professionals 670public class ComplexCalculator implements Callable String Override public String call throws Exception just sleep for 10 secs to simulate a lengthy computation Thread.sleep10000 System.out.printlnResult after a lengthy 10sec calculation return Complex Result the result Output Time At Task Submission Thu Aug 04 150515 EDT 2016 Result after a lengthy 10sec calculation Result of Complex Calculation is Complex Result Time At the Point of Printing the Result Thu Aug 04 150525 EDT 2016 Other operations permitted on Future While get is the method to extract the actual result Future has provision getlong timeout, TimeUnit unit de\ufb01nes maximum time period during current thread will wait for a result To cancel the task call cancelmayInterruptIfRunning . The \ufb02ag mayInterrupt indicates that task should be interrupted if it": "input.pdf", "was started and is running right now To check if task is completed\ufb01nished by calling isDone To check if the lengthy task were cancelled isCancelled . Section 126.2 CountDownLatch CountDownLatch A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. A CountDownLatch is initialized with a given count. 1. The await methods block until the current count reaches zero due to invocations of the countDown method, 2. after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon the count cannot be reset. If you need a version that resets the count, 3. consider using a CyclicBarrier . Key Methods public void await throws InterruptedException Causes the current thread to wait until the latch has counted down to zero, unless the thread is interrupted. public void countDown GoalKicker.com Java Notes for Professionals 671Decrements the count of the latch, releasing all waiting threads if the count reaches zero. Example import java.util.concurrent. class DoSomethingInAThread implements Runnable CountDownLatch latch public DoSomethingInAThread CountDownLatch latch this.latch latch public void run try System.out.printlnDo some thing latch. countDown catchException err err. printStackTrace public class CountDownLatchDemo": "input.pdf", "public static void mainString args try int numberOfThreads 5 if args.length 1 System.out.printlnUsage java CountDownLatchDemo numberOfThreads return try numberOfThreads Integer.parseInt args0 catchNumberFormatException ne CountDownLatch latch new CountDownLatch numberOfThreads for int n 0 n numberOfThreads n Thread t new Threadnew DoSomethingInAThread latch t. start latch. await System.out.printlnIn Main thread after completion of numberOfThreads threads catchException err err. printStackTrace output java CountDownLatchDemo 5 Do some thing Do some thing Do some thing Do some thing Do some thing In Main thread after completion of 5 threads Explanation GoalKicker.com Java Notes for Professionals 672CountDownLatch is initialized with a counter of 5 in Main thread 1. Main thread is waiting by using await method. 2. Five instances of DoSomethingInAThread have been created. Each instance decremented the counter with 3. countDown method. Once the counter becomes zero, Main thread will resume4. Section 126.3 Basic Multithreading If you have many tasks to execute, and all these tasks are not dependent of the result of the precedent ones, you can use Multithreading for your computer to do all this tasks at the same time using more processors if your computer can. This can make your program execution faster if you have some big independent tasks. class": "input.pdf", "CountAndPrint implements Runnable private final String name CountAndPrint String name this.name name This is what a CountAndPrint will do Override public void run for int i 0 i 10000 i System.out.printlnthis.name i public static void mainString args Launching 4 parallel threads for int i 1 i 4 i start method will call the run method of CountAndPrint in another thread new Threadnew CountAndPrint Instance i.start Doing some others tasks in the main Thread for int i 0 i 10000 i System.out.printlnMain i The code of the run method of the various CountAndPrint instances will execute in non predictable order. A snippet of a sample execution might look like this Instance 4 1 Instance 2 1 Instance 4 2 Instance 1 1 Instance 1 2 Main 1 Instance 4 3 Main 2 Instance 3 1 Instance 4 4 ... GoalKicker.com Java Notes for Professionals 673Section 126.4 Locks as Synchronisation aids Prior to Java 5s concurrent package introduction threading was more low level.The introduction of this package provided several higher level concurrent programming aidsconstructs. Locks are thread synchronisation mechanisms that essentially serve the same purpose as synchronized blocks or key words. Intrinsic Locking int count 0 shared among multiple threads public": "input.pdf", "void doSomething synchronized this count a non-atomic operation Synchronisation using Locks int count 0 shared among multiple threads Lock lockObj new ReentrantLock public void doSomething try lockObj. lock count a non-atomic operation finally lockObj. unlock sure to release the lock without fail Locks also have functionality available that intrinsic locking does not o\ufb00er, such as locking but remaining responsive to interruption, or trying to lock, and not block when unable to. Locking, responsive to interruption class Locky int count 0 shared among multiple threads Lock lockObj new ReentrantLock public void doSomething try try lockObj. lockInterruptibly count a non-atomic operation catch InterruptedException e Thread.currentThread .interrupt stopping finally if !Thread.currentThread .isInterrupted lockObj. unlock sure to release the lock without fail GoalKicker.com Java Notes for Professionals 674Only do something when able to lock public class Locky2 int count 0 shared among multiple threads Lock lockObj new ReentrantLock public void doSomething boolean locked lockObj. tryLock returns true upon successful lock if locked try count a non-atomic operation finally lockObj. unlock sure to release the lock without fail There are several variants of lock available.For more details refer the api docs here Section 126.5 Semaphore A Semaphore is a high-level synchronizer that maintains a": "input.pdf", "set of permits that can be acquired and released by threads. A Semaphore can be imagined as a counter of permits that will be decremented when a thread acquires, and incremented when a thread releases. If the amount of permits is 0 when a thread attempts to acquire, then the thread will block until a permit is made available or until the thread is interrupted. A semaphore is initialized as Semaphore semaphore new Semaphore 1 The int value being the number of permits The Semaphore constructor accepts an additional boolean parameter for fairness. When set false, this class makes no guarantees about the order in which threads acquire permits. When fairness is set true, the semaphore guarantees that threads invoking any of the acquire methods are selected to obtain permits in the order in which their invocation of those methods was processed. It is declared in the following manner Semaphore semaphore new Semaphore 1, true Now lets look at an example from javadocs, where Semaphore is used to control access to a pool of items. A Semaphore is used in this example to provide blocking functionality in order to ensure that there are always items to be obtained when": "input.pdf", "getItem is called. class Pool Note that this DOES NOT bound the amount that may be released! This is only a starting value for the Semaphore and has no other significant meaning UNLESS you enforce this inside of the getNextAvailableItem and markAsUnused methods private static final int MAXAVAILABLE 100 private final Semaphore available new Semaphore MAXAVAILABLE, true Obtains the next available item and reduces the permit count by 1. If there are no items available, block. public Object getItem throws InterruptedException GoalKicker.com Java Notes for Professionals 675 available. acquire return getNextAvailableItem Puts the item into the pool and add 1 permit. public void putItem Object x if markAsUnused x available. release private Object getNextAvailableItem Implementation private boolean markAsUnused Object o Implementation Section 126.6 Synchronization In Java, there is a built-in language-level locking mechanism the synchronized block, which can use any Java object as an intrinsic lock i.e. every Java object may have a monitor associated with it. Intrinsic locks provide atomicity to groups of statements. To understand what that means for us, lets have a look at an example where synchronized is useful private static int t 0 private static Object mutex new Object public static void mainString args": "input.pdf", "ExecutorService executorService Executors. newFixedThreadPool 400 The high thread count is for demonstration purposes. for int i 0 i 100 i executorService. execute - synchronized mutex t System.out.printlnMessageFormat .formatt 0 , t executorService. shutdown In this case, if it werent for the synchronized block, there would have been multiple concurrency issues involved. The \ufb01rst one would be with the post increment operator it isnt atomic in itself, and the second would be that we would be observing the value of t after an arbitrary amount of other threads has had the chance to modify it. However, since we acquired an intrinsic lock, there will be no race conditions here and the output will contain numbers from 1 to 100 in their normal order. Intrinsic locks in Java are mutexes i.e. mutual execution locks. Mutual execution means that if one thread has acquired the lock, the second will be forced to wait for the \ufb01rst one to release it before it can acquire the lock for itself. Note An operation that may put the thread into the wait sleep state is called a blocking operation . Thus, acquiring a lock is a blocking operation. Intrinsic locks in Java are reentrant .": "input.pdf", "This means that if a thread attempts to acquire a lock it already owns, it will not GoalKicker.com Java Notes for Professionals 676block and it will successfully acquire it. For instance, the following code will not block when called public void bar synchronized this ... public void foo synchronized this bar Beside synchronized blocks, there are also synchronized methods. The following blocks of code are practically equivalent even though the bytecode seems to be di\ufb00erent synchronized block on this 1. public void foo synchronized this doStuff synchronized method 2. public synchronized void foo doStuff Likewise for static methods, this class MyClass ... public static void bar synchronized MyClass. class doSomeOtherStuff has the same e\ufb00ect as this class MyClass ... public static synchronized void bar doSomeOtherStuff Section 126.7 Runnable Object The Runnable interface de\ufb01nes a single method, run, meant to contain the code executed in the thread. The Runnable object is passed to the Thread constructor. And Threads start method is called. GoalKicker.com Java Notes for Professionals 677Example public class HelloRunnable implements Runnable Override public void run System.out.printlnHello from a thread public static void mainString args new Threadnew HelloRunnable .start Example in Java8 public static void mainString args Runnable r": "input.pdf", "- System.out.printlnHello world new Threadr.start Runnable vs Thread subclass A Runnable object employment is more general, because the Runnable object can subclass a class other than Thread . Thread subclassing is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of Thread . A Runnable object is applicable to the high-level thread management APIs. Section 126.8 Creating basic deadlocked system A deadlock occurs when two competing actions wait for the other to \ufb01nish, and thus neither ever does. In java there is one lock associated with each object. To avoid concurrent modi\ufb01cation done by multiple threads on single object we can use synchronized keyword, but everything comes at a cost. Using synchronized keyword wrongly can lead to stuck systems called as deadlocked system. Consider there are 2 threads working on 1 instance, Lets call threads as First and Second, and lets say we have 2 resources R1 and R2. First acquires R1 and also needs R2 for its completion while Second acquires R2 and needs R1 for completion. so say at time t0, First has R1 and Second has R2. now First is waiting for R2 while Second": "input.pdf", "is waiting for R1. this wait is inde\ufb01nite and this leads to deadlock. public class Example2 public static void mainString args throws InterruptedException final DeadLock dl new DeadLock Thread t1 new Threadnew Runnable Override public void run TODO Auto-generated method stub dl. methodA GoalKicker.com Java Notes for Professionals 678 Thread t2 new Threadnew Runnable Override public void run TODO Auto-generated method stub try dl. method2 catch InterruptedException e TODO Auto-generated catch block e. printStackTrace t1. setNameFirst t2. setNameSecond t1. start t2. start class DeadLock Object mLock1 new Object Object mLock2 new Object public void methodA System.out.printlnmethodA wait for mLock1 Thread.currentThread .getName synchronized mLock1 System.out.printlnmethodA mLock1 acquired Thread.currentThread .getName try Thread.sleep100 method2 catch InterruptedException e TODO Auto-generated catch block e. printStackTrace public void method2 throws InterruptedException System.out.printlnmethod2 wait for mLock2 Thread.currentThread .getName synchronized mLock2 System.out.printlnmethod2 mLock2 acquired Thread.currentThread .getName Thread.sleep100 method3 public void method3 throws InterruptedException System.out.printlnmethod3 mLock1 Thread.currentThread .getName synchronized mLock1 System.out.printlnmethod3 mLock1 acquired Thread.currentThread .getName Output of this program methodA wait for mLock1 First GoalKicker.com Java Notes for Professionals 679method2 wait for mLock2 Second method2 mLock2 acquired Second methodA mLock1 acquired First method3 mLock1 Second method2 wait for mLock2 First Section 126.9 Creating a java.lang.Thread instance There are": "input.pdf", "two main approaches to creating a thread in Java. In essence, creating a thread is as easy as writing the code that will be executed in it. The two approaches di\ufb00er in where you de\ufb01ne that code. In Java, a thread is represented by an object - an instance of java.lang.Thread or its subclass. So the \ufb01rst approach is to create that subclass and override the run method. Note Ill use Thread to refer to the java.lang.Thread class and thread to refer to the logical concept of threads. class MyThread extends Thread Override public void run for int i 0 i 10 i System.out.printlnThread running! Now since weve already de\ufb01ned the code to be executed, the thread can be created simply as MyThread t new MyThread The Thread class also contains a constructor accepting a string, which will be used as the threads name. This can be particulary useful when debugging a multi thread program. class MyThread extends Thread public MyThread String name supername Override public void run for int i 0 i 10 i System.out.printlnThread running! MyThread t new MyThread Greeting Producer The second approach is to de\ufb01ne the code using java.lang.Runnable and its only method run .": "input.pdf", "The Thread class then allows you to execute that method in a separated thread. To achieve this, create the thread using a constructor accepting an instance of the Runnable interface. Thread t new ThreadaRunnable This can be very powerful when combined with lambdas or methods references Java 8 only Thread t new Threadoperator hardWork GoalKicker.com Java Notes for Professionals 680You can specify the threads name, too. Thread t new Threadoperator hardWork, Pi operator Practicaly speaking, you can use both approaches without worries. However the general wisdom says to use the latter. For every of the four mentioned constructors, there is also an alternative accepting an instance of java.lang.ThreadGroup as the \ufb01rst parameter. ThreadGroup tg new ThreadGroup Operators Thread t new Threadtg, operator hardWork, PI operator The ThreadGroup represents a set of threads. You can only add a Thread to a ThreadGroup using a Thread s constructor. The ThreadGroup can then be used to manage all its Thread s together, as well as the Thread can gain information from its ThreadGroup . So to sumarize, the Thread can be created with one of these public constructors Thread ThreadString name ThreadRunnable target ThreadRunnable target, String name ThreadThreadGroup group, String name ThreadThreadGroup": "input.pdf", "group, Runnable target ThreadThreadGroup group, Runnable target, String name ThreadThreadGroup group, Runnable target, String name, long stackSize The last one allows us to de\ufb01ne desired stack size for the new thread. Often the code readability su\ufb00ers when creating and con\ufb01guring many Threads with same properties or from the same pattern. Thats when java.util.concurrent.ThreadFactory can be used. This interface allows you to encapsulate the procedure of creating the thread through the factory pattern and its only method newThreadRunnable . class WorkerFactory implements ThreadFactory private int id 0 Override public Thread newThread Runnable r return new Threadr, Worker id Section 126.10 Atomic operations An atomic operation is an operation that is executed all at once, without any chance of other threads observing or modifying state during the atomic operations execution. Lets consider a BAD EXAMPLE . private static int t 0 public static void mainString args ExecutorService executorService Executors. newFixedThreadPool 400 The high thread count is for demonstration purposes. for int i 0 i 100 i GoalKicker.com Java Notes for Professionals 681 executorService. execute - t System.out.printlnMessageFormat .formatt 0 , t executorService. shutdown In this case, there are two issues. The \ufb01rst issue is that the post increment operator is not": "input.pdf", "atomic. It is comprised of multiple operations get the value, add 1 to the value, set the value. Thats why if we run the example, it is likely that we wont see t 100 in the output - two threads may concurrently get the value, increment it, and set it lets say the value of t is 10, and two threads are incrementing t. Both threads will set the value of t to 11, since the second thread observes the value of t before the \ufb01rst thread had \ufb01nished incrementing it. The second issue is with how we are observing t. When we are printing the value of t, the value may have already been changed by a di\ufb00erent thread after this threads increment operation. To \ufb01x those issues, well use the java.util.concurrent .atomic.AtomicInteger , which has many atomic operations for us to use. private static AtomicInteger t new AtomicInteger 0 public static void mainString args ExecutorService executorService Executors. newFixedThreadPool 400 The high thread count is for demonstration purposes. for int i 0 i 100 i executorService. execute - int currentT t.incrementAndGet System.out.printlnMessageFormat .formatt 0 , currentT executorService. shutdown The incrementAndGet method of AtomicInteger atomically increments and returns the": "input.pdf", "new value, thus eliminating the previous race condition. Please note that in this example the lines will still be out of order because we make no e\ufb00ort to sequence the println calls and that this falls outside the scope of this example, since it would require synchronization and the goal of this example is to show how to use AtomicInteger to eliminate race conditions concerning state. Section 126.11 Exclusive write Concurrent read access It is sometimes required for a process to concurrently write and read the same data. The ReadWriteLock interface, and its ReentrantReadWriteLock implementation allows for an access pattern that can be described as follow There can be any number of concurrent readers of the data. If there is at least one reader access granted,1. then no writer access is possible. There can be at most one single writer to the data. If there is a writer access granted, then no reader can2. access the data. An implementation could look like import java.util.concurrent.locks.ReadWriteLock import java.util.concurrent.locks.ReentrantReadWriteLock GoalKicker.com Java Notes for Professionals 682public class Sample Our lock. The constructor allows a fairness setting, which guarantees the chronology of lock attributions. protected static final ReadWriteLock RWLOCK new ReentrantReadWriteLock This is a": "input.pdf", "typical data that needs to be protected for concurrent access protected static int data 0 This will write to the data, in an exclusive access public static void writeToData RWLOCK. writeLock .lock try data finally RWLOCK. writeLock .unlock public static int readData RWLOCK. readLock .lock try return data finally RWLOCK. readLock .unlock NOTE 1 This precise use case has a cleaner solution using AtomicInteger , but what is described here is an access pattern, that works regardless of the fact that data here is an integer that as an Atomic variant. NOTE 2 The lock on the reading part is really needed, although it might not look so to the casual reader. Indeed, if you do not lock on the reader side, any number of things can go wrong, amongst which The writes of primitive values are not guaranteed to be atomic on all JVMs, so the reader could see e.g. only1. 32bits of a 64bits write if data were a 64bits long type The visibility of the write from a thread that did not perform it is guaranteed by the JVM only if we establish2. Happen Before relationship between the writes and the reads. This relationship is established": "input.pdf", "when both readers and writers use their respective locks, but not otherwise Version Java SE 8 In case higher performance is required, an under certain types of usage, there is a faster lock type available, called the StampedLock , that amongst other things implements an optimistic lock mode. This lock works very di\ufb00erently from the ReadWriteLock , and this sample is not transposable. Section 126.12 Producer-Consumer A simple example of producer-consumer problem solution. Notice that JDK classes AtomicBoolean and BlockingQueue are used for synchronization, which reduces the chance of creating an invalid solution. Consult Javadoc for various types of BlockingQueue choosing di\ufb00erent implementation may drastically change the behavior of this example like DelayQueue or Priority Queue . public class Producer implements Runnable GoalKicker.com Java Notes for Professionals 683 private final BlockingQueue ProducedData queue public Producer BlockingQueue ProducedData queue this.queue queue public void run int producedCount 0 try while true producedCount put throws an InterruptedException when the thread is interrupted queue. putnew ProducedData catch InterruptedException e the thread has been interrupted cleanup and exit producedCount -- re-interrupt the thread in case the interrupt flag is needeed higher up Thread.currentThread .interrupt System.out.printlnProduced producedCount objects public class Consumer implements Runnable private final": "input.pdf", "BlockingQueue ProducedData queue public Consumer BlockingQueue ProducedData queue this.queue queue public void run int consumedCount 0 try while true put throws an InterruptedException when the thread is interrupted ProducedData data queue.poll10, TimeUnit. MILLISECONDS process data consumedCount catch InterruptedException e the thread has been interrupted cleanup and exit consumedCount -- re-interrupt the thread in case the interrupt flag is needeed higher up Thread.currentThread .interrupt System.out.printlnConsumed consumedCount objects public class ProducerConsumerExample static class ProducedData empty data object public static void mainString args throws InterruptedException BlockingQueue ProducedData queue new ArrayBlockingQueue ProducedData 1000 choice of queue determines the actual behavior see various BlockingQueue implementations Thread producer new Threadnew Producer queue GoalKicker.com Java Notes for Professionals 684 Thread consumer new Threadnew Consumer queue producer. start consumer. start Thread.sleep1000 producer. interrupt Thread.sleep10 consumer. interrupt Section 126.13 Visualizing readwrite barriers while using synchronized volatile As we know that we should use synchronized keyword to make execution of a method or block exclusive. But few of us may not be aware of one more important aspect of using synchronized and volatile keyword apart from making a unit of code atomic, it also provides read write barrier . What is this read write barrier? Lets discuss this using": "input.pdf", "an example class Counter private Integer count 10 public synchronized void incrementCount count public Integer getCount return count Lets suppose a thread A calls incrementCount \ufb01rst then another thread B calls getCount . In this scenario there is no guarantee that B will see updated value of count . It may still see count as 10, even it is also possible that it never sees updated value of count ever. To understand this behavior we need to understand how Java memory model integrates with hardware architecture. In Java, each thread has its own thread stack. This stack contains method call stack and local variable created in that thread. In a multi core system, it is quite possible that two threads are running concurrently in separate cores. In such scenario it is possible that part of a threads stack lies inside register cache of a core. If inside a thread, an object is accessed using synchronized or volatile keyword, after synchronized block that thread syncs its local copy of that variable with the main memory. This creates a read write barrier and makes sure that the thread is seeing the latest value of that object. But in our case, since": "input.pdf", "thread B has not used synchronized access to count , it might be refering value of count stored in register and may never see updates from thread A. To make sure that B sees latest value of count we need to make getCount synchronized as well. public synchronized Integer getCount return count Now when thread A is done with updating count it unlocks Counter instance, at the same time creates write barrier and \ufb02ushes all changes done inside that block to the main memory. Similarly when thread B acquires lock on the same instance of Counter , it enters into read barrier and reads value of count from main memory and sees all GoalKicker.com Java Notes for Professionals 685updates. Same visibility e\ufb00ect goes for volatile read writes as well. All variables updated prior to write to volatile will be \ufb02ushed to main memory and all reads after volatile variable read will be from main memory. Section 126.14 Get status of all threads started by your program excluding system threads Code snippet import java.util.Set public class ThreadStatus public static void mainString args throws Exception for int i 0 i 5 i Thread t new Threadnew MyThread t. setNameMyThread i t.": "input.pdf", "start int threadCount 0 Set Thread threadSet Thread.getAllStackTraces .keySet for Thread t threadSet if t.getThreadGroup Thread.currentThread .getThreadGroup System.out.printlnThread t state t.getState threadCount System.out.printlnThread count started by Main thread threadCount class MyThread implements Runnable public void run try Thread.sleep2000 catchException err GoalKicker.com Java Notes for Professionals 686 err. printStackTrace Output Thread ThreadMyThread1,5,mainstateTIMEDWAITING Thread ThreadMyThread3,5,mainstateTIMEDWAITING Thread Threadmain,5,mainstateRUNNABLE Thread ThreadMyThread4,5,mainstateTIMEDWAITING Thread ThreadMyThread0,5,mainstateTIMEDWAITING Thread ThreadMyThread2,5,mainstateTIMEDWAITING Thread count started by Main thread6 Explanation Thread.getAllStackTraces .keySet returns all Thread s including application threads and system threads. If you are interested only in status of Threads, started by your application, iterate the Thread set by checking Thread Group of a particular thread against your main program thread. In absence of above ThreadGroup condition, the program returns status of below System Threads Reference Handler Signal Dispatcher Attach Listener Finalizer Section 126.15 Using ThreadLocal A useful tool in Java Concurrency is ThreadLocal this allows you to have a variable that will be unique to a given thread. Thus, if the same code runs in di\ufb00erent threads, these executions will not share the value, but instead each thread has its own variable that is local to the thread . For example, this is frequently used to establish the context": "input.pdf", "such as authorization information of handling a request in a servlet. You might do something like this private static final ThreadLocal MyUserContext contexts new ThreadLocal public static MyUserContext getContext return contexts. get get returns the variable unique to this thread public void doGet... MyUserContext context magicGetContextFromRequest request contexts. putcontext save that context to our thread-local - other threads making this call dont overwrite ours try business logic finally contexts. remove ensure removal of thread-local variable Now, instead of passing MyUserContext into every single method, you can instead use MyServlet. getContext where you need it. Now of course, this does introduce a variable that needs to be documented, but it s thread-safe, GoalKicker.com Java Notes for Professionals 687which eliminates a lot of the downsides to using such a highly scoped variable. The key advantage here is that every thread has its own thread local variable in that contexts container. As long as you use it from a de\ufb01ned entry point like demanding that each servlet maintains its context, or perhaps by adding a servlet \ufb01lter you can rely on this context being there when you need it. Section 126.16 Multiple producerconsumer example with shared global queue Below code showcases multiple": "input.pdf", "ProducerConsumer program. Both Producer and Consumer threads share same global queue. import java.util.concurrent. import java.util.Random public class ProducerConsumerWithES public static void mainString args BlockingQueue Integer sharedQueue new LinkedBlockingQueue Integer ExecutorService pes Executors. newFixedThreadPool 2 ExecutorService ces Executors. newFixedThreadPool 2 pes. submitnew Producer sharedQueue, 1 pes. submitnew Producer sharedQueue, 2 ces. submitnew Consumer sharedQueue, 1 ces. submitnew Consumer sharedQueue, 2 pes. shutdown ces. shutdown Different producers produces a stream of integers continuously to a shared queue, which is shared between all Producers and consumers class Producer implements Runnable private final BlockingQueue Integer sharedQueue private int threadNo private Random random new Random public Producer BlockingQueue Integer sharedQueue, int threadNo this.threadNo threadNo this.sharedQueue sharedQueue Override public void run Producer produces a continuous stream of numbers for every 200 milli seconds while true try int number random. nextInt1000 System.out.printlnProduced number by thread threadNo sharedQueue. putnumber Thread.sleep200 catch Exception err err. printStackTrace Different consumers consume data from shared queue, which is shared by both producer and consumer threads GoalKicker.com Java Notes for Professionals 688class Consumer implements Runnable private final BlockingQueue Integer sharedQueue private int threadNo public Consumer BlockingQueue Integer sharedQueue, int threadNo this.sharedQueue sharedQueue this.threadNo threadNo Override public void run Consumer consumes numbers generated": "input.pdf", "from Producer threads continuously whiletrue try int num sharedQueue. take System.out.printlnConsumed num by thread threadNo catch Exception err err. printStackTrace output Produced69by thread2 Produced553by thread1 Consumed 69by thread1 Consumed 553by thread2 Produced41by thread2 Produced796by thread1 Consumed 41by thread1 Consumed 796by thread2 Produced728by thread2 Consumed 728by thread1 and so on ................ Explanation sharedQueue , which is a LinkedBlockingQueue is shared among all Producer and Consumer threads. 1. Producer threads produces one integer for every 200 milli seconds continuously and append it to2. sharedQueue Consumer thread consumes integer from sharedQueue continuously. 3. This program is implemented with-out explicit synchronized or Lock constructs. BlockingQueue is the key to 4. achieve it. BlockingQueue implementations are designed to be used primarily for producer-consumer queues. BlockingQueue implementations are thread-safe. All queuing methods achieve their e\ufb00ects atomically using internal locks or other forms of concurrency control. Section 126.17 Add two int arrays using a Threadpool A Threadpool has a Queue of tasks, of which each will be executed on one these Threads. GoalKicker.com Java Notes for Professionals 689The following example shows how to add two int arrays using a Threadpool. Version Java SE 8 int firstArray 2, 4, 6, 8 int secondArray 1, 3, 5, 7": "input.pdf", "int result 0, 0, 0, 0 ExecutorService pool Executors. newCachedThreadPool Setup the ThreadPool for each element in the array, submit a worker to the pool that adds elements for int i 0 i result. length i final int worker i pool. submit - resultworker firstArray worker secondArray worker Wait for all Workers to finish try execute all submitted tasks pool. shutdown waits until all workers finish, or the timeout ends pool. awaitTermination 12, TimeUnit. SECONDS catch InterruptedException e pool. shutdownNow kill thread System.out.printlnArrays.toString result Notes This example is purely illustrative. In practice, there wont be any speedup by using threads for a task this1. small. A slowdown is likely, since the overheads of task creation and scheduling will swamp the time taken to run a task. If you were using Java 7 and earlier, you would use anonymous classes instead of lambdas to implement the2. tasks. Section 126.18 Pausing Execution Thread.sleep causes the current thread to suspend execution for a speci\ufb01ed period. This is an e\ufb03cient means of making processor time available to the other threads of an application or other applications that might be running on a computer system. There are two overloaded sleep methods in the Thread": "input.pdf", "class. One that speci\ufb01es the sleep time to the millisecond public static void sleeplong millis throws InterruptedException One that speci\ufb01es the sleep time to the nanosecond public static void sleeplong millis, int nanos Pausing Execution for 1 second Thread.sleep1000 It is important to note that this is a hint to the operating systems kernels scheduler. This may not necessarily be GoalKicker.com Java Notes for Professionals 690precise, and some implementations do not even consider the nanosecond parameter possibly rounding to the nearest millisecond. It is recommended to enclose a call to Thread.sleep in trycatch and catch InterruptedException . Section 126.19 Thread Interruption Stopping Threads Each Java Thread has an interrupt \ufb02ag, which is initially false. Interrupting a thread, is essentially nothing more than setting that \ufb02ag to true. The code running on that thread can check the \ufb02ag on occasion and act upon it. The code can also ignore it completely. But why would each Thread have such a \ufb02ag? After all, having a boolean \ufb02ag on a thread is something we can just organize ourselves, if and when we need it. Well, there are methods that behave in a special way when the thread theyre running on is interrupted.": "input.pdf", "These methods are called blocking methods. These are methods that put the thread in the WAITING or TIMEDWAITING state. When a thread is in this state, interrupting it, will cause an InterruptedException to be thrown on the interrupted thread, rather than the interrupt \ufb02ag being set to true, and the thread becomes RUNNABLE again. Code that invokes a blocking method is forced to deal with the InterruptedException, since it is a checked exception. So, and hence its name, an interrupt can have the e\ufb00ect of interrupting a WAIT, e\ufb00ectively ending it. Note that not all methods that are somehow waiting e.g. blocking IO respond to interruption in that way, as they dont put the thread in a waiting state. Lastly a thread that has its interrupt \ufb02ag set, that enters a blocking method i.e. tries to get into a waiting state, will immediately throw an InterruptedException and the interrupt \ufb02ag will be cleared. Other than these mechanics, Java does not assign any special semantic meaning to interruption. Code is free to interpret an interrupt any way it likes. But most often interruption is used to signal to a thread it should stop running at its earliest convenience. But, as": "input.pdf", "should be clear from the above, it is up to the code on that thread to react to that interruption appropriately in order to stop running. Stopping a thread is a collaboration. When a thread is interrupted its running code can be several levels deep into the stacktrace. Most code doesnt call a blocking method, and \ufb01nishes timely enough to not delay the stopping of the thread unduly. The code that should mostly be concerned with being responsive to interruption, is code that is in a loop handling tasks until there are none left, or until a \ufb02ag is set signalling it to stop that loop. Loops that handle possibly in\ufb01nite tasks i.e. they keep running in principle should check the interrupt \ufb02ag in order to exit the loop. For \ufb01nite loops the semantics may dictate that all tasks must be \ufb01nished before ending, or it may be appropriate to leave some tasks unhandled. Code that calls blocking methods will be forced to deal with the InterruptedException. If at all semantically possible, it can simply propagate the InterruptedException and declare to throw it. As such it becomes a blocking method itself in regard to its callers. If it cannot": "input.pdf", "propagate the exception, it should at the very least set the interrupted \ufb02ag, so callers higher up the stack also know the thread was interrupted. In some cases the method needs to continue waiting regardless of the InterruptedException, in which case it must delay setting the interrupted \ufb02ag until after it is done waiting, this may involve setting a local variable, which is to be checked prior to exiting the method to then interrupt its thread. Examples Example of code that stops handling tasks upon interruption class TaskHandler implements Runnable private final BlockingQueue Task queue TaskHandler BlockingQueue Task queue this.queue queue Override public void run while !Thread.currentThread .isInterrupted check for interrupt flag, exit loop GoalKicker.com Java Notes for Professionals 691when interrupted try Task task queue.take blocking call, responsive to interruption handle task catch InterruptedException e Thread.currentThread .interrupt cannot throw InterruptedException due to Runnable interface restriction so indicating interruption by setting the flag private void handleTask task actual handling Example of code that delays setting the interrupt \ufb02ag until completely done class MustFinishHandler implements Runnable private final BlockingQueue Task queue MustFinishHandler BlockingQueue Task queue this.queue queue Override public void run boolean shouldInterrupt false while true try Task task queue.take if": "input.pdf", "task.isEndOfTasks if shouldInterrupt Thread.currentThread .interrupt return handle task catch InterruptedException e shouldInterrupt true must finish, remember to set interrupt flag when were done private void handleTask task actual handling Example of code that has a \ufb01xed list of tasks but may quit early when interrupted class GetAsFarAsPossible implements Runnable private final ListTask tasks new ArrayList Override public void run for Task task tasks GoalKicker.com Java Notes for Professionals 692 if Thread.currentThread .isInterrupted return handle task private void handleTask task actual handling GoalKicker.com Java Notes for Professionals 693Chapter 127 Executor, ExecutorService and Thread pools The Executor interface in Java provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. With Executors, developers wont have to signi\ufb01cantly rewrite their code to be able to easily tune their programs task-execution policy. Section 127.1 ThreadPoolExecutor A common Executor used is the ThreadPoolExecutor , which takes care of Thread handling. You can con\ufb01gure the minimal amount of Threads the executor always has to maintain when theres not much to do its called core size and a maximal Thread size to": "input.pdf", "which the Pool can grow, if there is more work to do. Once the workload declines, the Pool slowly reduces the Thread count again until it reaches min size. ThreadPoolExecutor pool new ThreadPoolExecutor 1, keep at least one thread ready, even if no Runnables are executed 5, at most five RunnablesThreads executed in parallel 1, TimeUnit. MINUTES, idle Threads terminated after one minute, when min Pool size exceeded new ArrayBlockingQueue Runnable 10 outstanding Runnables are kept here pool.executenew Runnable Override public void run code to run Note If you con\ufb01gure the ThreadPoolExecutor with an unbounded queue, then the thread count will not exceed corePoolSize since new threads are only created if the queue is full ThreadPoolExecutor with all parameters ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler from JavaDoc If there are more than corePoolSize but less than maximumPoolSize threads running, a new thread will be created only if the queue is full. Advantages BlockingQueue size can be controlled and out-of-memory scenarios can be avoided. Application1. performance wont be degraded with limited bounded queue size. You can use existing or create new Rejection Handler policies.2. In the default ThreadPoolExecutor.AbortPolicy, the handler": "input.pdf", "throws a runtime1. GoalKicker.com Java Notes for Professionals 694RejectedExecutionException upon rejection. In ThreadPoolExecutor. CallerRunsPolicy , the thread that invokes execute itself runs the task. This 2. provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted. In ThreadPoolExecutor. DiscardPolicy , a task that cannot be executed is simply dropped. 3. In ThreadPoolExecutor. DiscardOldestPolicy , if the executor is not shut down, the task at the head 4. of the work queue is dropped, and then execution is retried which can fail again, causing this to be repeated. Custom ThreadFactory can be con\ufb01gured, which is useful 3. To set a more descriptive thread name1. To set thread daemon status2. To set thread priority3. Here is a example of how to use ThreadPoolExecutor Section 127.2 Retrieving value from computation - Callable If your computation produces some return value which later is required, a simple Runnable task isnt su\ufb03cient. For such cases you can use ExecutorService. submitCallable T which returns a value after execution completes. The Service will return a Future which you can use to retrieve the result of the task execution. Submit a callable for execution ExecutorService pool anExecutorService FutureInteger future pool.submitnew Callable": "input.pdf", "Integer Override public Integer call do some computation return new Random.nextInt ... perform other tasks while future is executed in a different thread When you need to get the result of the future, call future.get Wait inde\ufb01nitely for future to \ufb01nish with a result. try Blocks current thread until future is completed Integer result future. get catch InterruptedException ExecutionException e handle appropriately Wait for future to \ufb01nish, but no longer than speci\ufb01ed time. try Blocks current thread for a maximum of 500 milliseconds. If the future finishes before that, result is returned, otherwise TimeoutException is thrown. Integer result future. get500, TimeUnit. MILLISECONDS catch InterruptedException ExecutionException TimeoutException e GoalKicker.com Java Notes for Professionals 695 handle appropriately If the result of a scheduled or running task is no longer required, you can call Future.cancelboolean to cancel it. Calling cancelfalse will just remove the task from the queue of tasks to be run. Calling canceltrue will also interrupt the task if it is currently running. Section 127.3 submit vs execute exception handling dierences Generally execute command is used for \ufb01re and forget calls without need of analyzing the result and submit command is used for analyzing the result of Future object. We": "input.pdf", "should be aware of key di\ufb00erence of Exception Handling mechanisms between these two commands. Exceptions from submit are swallowed by framework if you did not catch them. Code example to understand the di\ufb00erence Case 1 submit the Runnable with execute command, which reports the Exception. import java.util.concurrent. import java.util. public class ExecuteSubmitDemo public ExecuteSubmitDemo System.out.printlncreating service ExecutorService service Executors. newFixedThreadPool 2 ExtendedExecutor service new ExtendedExecutor for int i 0 i 2 i service. executenew Runnable public void run int a 4, b 0 System.out.printlna and b a b System.out.printlnab a b System.out.printlnThread Name in Runnable after divide by zeroThread.currentThread .getName service. shutdown public static void mainString args ExecuteSubmitDemo demo new ExecuteSubmitDemo class ExtendedExecutor extends ThreadPoolExecutor public ExtendedExecutor super1, 1, 60, TimeUnit. SECONDS, new ArrayBlockingQueue Runnable 100 ... protected void afterExecute Runnable r, Throwable t super.afterExecute r, t if t null r instanceof Future? try Object result Future? r.get GoalKicker.com Java Notes for Professionals 696 catch CancellationException ce t ce catch ExecutionException ee t ee.getCause catch InterruptedException ie Thread.currentThread .interrupt ignorereset if t ! null System.out.printlnt output creating service a and b40 a and b40 Exception in thread pool-1-thread-1 Exception in thread pool-1-thread-2 java.lang.ArithmeticException by zero at ExecuteSubmitDemo1.runExecuteSubmitDemo.java15 at java.util.concurrent.ThreadPoolExecutor.runWorkerThreadPoolExecutor.java1145": "input.pdf", "at java.util.concurrent.ThreadPoolExecutorWorker.runThreadPoolExecutor.java615 at java.lang.Thread.runThread.java744 java.lang.ArithmeticException by zero at ExecuteSubmitDemo1.runExecuteSubmitDemo.java15 at java.util.concurrent.ThreadPoolExecutor.runWorkerThreadPoolExecutor.java1145 at java.util.concurrent.ThreadPoolExecutorWorker.runThreadPoolExecutor.java615 at java.lang.Thread.runThread.java744 Case 2 Replace execute with submit service. submitnew Runnable In this case, Exceptions are swallowed by framework since run method did not catch them explicitly. output creating service a and b40 a and b40 Case 3 Change the newFixedThreadPool to ExtendedExecutor ExecutorService service Executors.newFixedThreadPool2 ExtendedExecutor service new ExtendedExecutor output creating service a and b40 java.lang.ArithmeticException by zero a and b40 java.lang.ArithmeticException by zero I have demonstrated this example to cover two topics Use your custom ThreadPoolExecutor and handle Exectpion with custom ThreadPoolExecutor. GoalKicker.com Java Notes for Professionals 697Other simple solution to above problem When you are using normal ExecutorService submit command, get the Future object from submit command call get API on Future. Catch the three exceptions, which have been quoted in afterExecute method implementation. Advantage of custom ThreadPoolExecutor over this approach You have to handle Exception handling mechanism in only one place - Custom ThreadPoolExecutor. Section 127.4 Handle Rejected Execution If you try to submit tasks to a shutdown Executor or1. the queue is saturated only possible with bounded ones and maximum number of Threads has been2. reached, RejectedExecutionHandler. rejectedExecution Runnable , ThreadPoolExecutor": "input.pdf", "will be called. The default behavior is that youll get a RejectedExecutionException thrown at the caller. But there are more prede\ufb01ned behaviors available ThreadPoolExecutor.AbortPolicy default, will throw REE ThreadPoolExecutor.CallerRunsPolicy executes task on callers thread - blocking it ThreadPoolExecutor.DiscardPolicy silently discard task ThreadPoolExecutor.DiscardOldestPolicy silently discard oldest task in queue and retry execution of the new task You can set them using one of the ThreadPool constructors public ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, RejectedExecutionHandler handler -- public ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler -- You can as well implement your own behavior by extending RejectedExecutionHandler interface void rejectedExecution Runnable r, ThreadPoolExecutor executor Section 127.5 Fire and Forget - Runnable Tasks Executors accept a java.lang.Runnable which contains potentially computationally or otherwise long-running or heavy code to be run in another Thread. Usage would be Executor exec anExecutor exec.executenew Runnable Override public void run offloaded work, no need to get result back GoalKicker.com Java Notes for Professionals 698 Note that with this executor, you have no means to get any computed value back. With Java 8, one can utilize lambdas to shorten the code example. Version": "input.pdf", "Java SE 8 Executor exec anExecutor exec.execute - offloaded work, no need to get result back Section 127.6 Use cases for dierent types of concurrency constructs ExecutorService1. ExecutorService executor Executors. newFixedThreadPool 50 It is simple and easy to use. It hides low level details of ThreadPoolExecutor . I prefer this one when number of Callable Runnable tasks are small in number and piling of tasks in unbounded queue does not increase memory degrade the performance of the system. If you have CPUMemory constraints, I prefer to use ThreadPoolExecutor with capacity constraints RejectedExecutionHandler to handle rejection of tasks. CountDownLatch2. CountDownLatch will be initialized with a given count. This count is decremented by calls to the countDown method. Threads waiting for this count to reach zero can call one of the await methods. Calling await blocks the thread until the count reaches zero. This class enables a java thread to wait until other set of threads completes their tasks. Use cases Achieving Maximum Parallelism Sometimes we want to start a number of threads at the same time to1. achieve maximum parallelism Wait N threads to completes before start execution2. Deadlock detection.3. ThreadPoolExecutor It provides more control. If application is constrained by": "input.pdf", "number of pending 3. RunnableCallable tasks, you can use bounded queue by setting the max capacity. Once the queue reaches maximum capacity, you can de\ufb01ne RejectionHandler. Java provides four types of RejectedExecutionHandler policies . ThreadPoolExecutor. AbortPolicy , the handler throws a runtime RejectedExecutionException upon 1. rejection. ThreadPoolExecutor.CallerRunsPolicy, the thread that invokes execute itself runs the task. This2. provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted. GoalKicker.com Java Notes for Professionals 699In ThreadPoolExecutor. DiscardPolicy , a task that cannot be executed is simply dropped. 3. ThreadPoolExecutor. DiscardOldestPolicy , if the executor is not shut down, the task at the head of 4. the work queue is dropped, and then execution is retried which can fail again, causing this to be repeated. If you want to simulate CountDownLatch behaviour, you can use invokeAll method. One more mechanism you did not quote is ForkJoinPool 4. The ForkJoinPool was added to Java in Java 7. The ForkJoinPool is similar to the Java ExecutorService but with one di\ufb00erence. The ForkJoinPool makes it easy for tasks to split their work up into smaller tasks which are then submitted to the ForkJoinPool too. Task stealing happens in": "input.pdf", "ForkJoinPool when free worker threads steal tasks from busy worker thread queue. Java 8 has introduced one more API in ExecutorService to create work stealing pool. You dont have to create RecursiveTask and RecursiveAction but still can use ForkJoinPool . public static ExecutorService newWorkStealingPool Creates a work-stealing thread pool using all available processors as its target parallelism level. By default, it will take number of CPU cores as parameter. All these four mechanism are complimentary to each other. Depending on level of granularity you want to control, you have to chose right ones. Section 127.7 Wait for completion of all tasks in ExecutorService Lets have a look at various options to wait for completion of tasks submitted to Executor ExecutorService invokeAll 1. Executes the given tasks, returning a list of Futures holding their status and results when everything is completed. Example import java.util.concurrent. import java.util. public class InvokeAllDemo public InvokeAllDemo System.out.printlncreating service ExecutorService service Executors. newFixedThreadPool Runtime.getRuntime .availableProcessors List MyCallable futureList new ArrayList MyCallable GoalKicker.com Java Notes for Professionals 700 for int i 0 i 10 i MyCallable myCallable new MyCallable longi futureList. addmyCallable System.out.printlnStart try List FutureLong futures service. invokeAll futureList catchException err err. printStackTrace System.out.printlnCompleted service. shutdown": "input.pdf", "public static void mainString args InvokeAllDemo demo new InvokeAllDemo class MyCallable implements Callable Long Long id 0L public MyCallable Long val this.id val public Long call Add your business logic return id CountDownLatch2. A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier . ForkJoinPool or newWorkStealingPool in Executors 3. Iterate through all Future objects created after submitting to ExecutorService 4. Recommended way of shutdown from oracle documentation page of ExecutorService 5. void shutdownAndAwaitTermination ExecutorService pool pool. shutdown Disable new tasks from being submitted try Wait a while for existing tasks to terminate if !pool.awaitTermination 60, TimeUnit. SECONDS pool. shutdownNow Cancel currently executing tasks Wait a while for tasks to respond to being cancelled if !pool.awaitTermination 60, TimeUnit. SECONDS System.err.printlnPool did not terminate": "input.pdf", "GoalKicker.com Java Notes for Professionals 701 catch InterruptedException ie Re-Cancel if current thread also interrupted pool. shutdownNow Preserve interrupt status Thread.currentThread .interrupt shutdown Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. shutdownNow Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. In above example, if your tasks are taking more time to complete, you can change if condition to while condition Replace if !pool.awaitTermination 60, TimeUnit. SECONDS with while!pool.awaitTermination 60, TimeUnit. SECONDS Thread.sleep60000 Section 127.8 Use cases for dierent types of ExecutorService Executors returns di\ufb00erent type of ThreadPools catering to speci\ufb01c need. public static ExecutorService newSingleThreadExecutor 1. Creates an Executor that uses a single worker thread operating o\ufb00 an unbounded queue There is a di\ufb00erence between newFixedThreadPool 1 and newSingleThreadExecutor as the java doc says for the latter Unlike the otherwise equivalent newFixedThreadPool1 the returned executor is guaranteed not to be recon\ufb01gurable to use additional threads. Which means that a newFixedThreadPool can be recon\ufb01gured later in the program by ThreadPoolExecutor fixedThreadPool .setMaximumPoolSize 10 This is not possible for newSingleThreadExecutor Use cases You want to": "input.pdf", "execute the submitted tasks in a sequence.1. You need only one Thread to handle all your request2. GoalKicker.com Java Notes for Professionals 702Cons Unbounded queue is harmful1. public static ExecutorService newFixedThreadPool int nThreads 2. Creates a thread pool that reuses a \ufb01xed number of threads operating o\ufb00 a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available Use cases E\ufb00ective use of available cores. Con\ufb01gure nThreads as 1. Runtime.getRuntime .availableProcessors When you decide that number of thread should not exceed a number in the thread pool2. Cons Unbounded queue is harmful.1. public static ExecutorService newCachedThreadPool 3. Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available Use cases For short-lived asynchronous tasks1. Cons Unbounded queue is harmful.1. Each new task will create a new thread if all existing threads are busy. If the task is taking long2. duration, more number of threads will be created,which will degrade the performance of the system. Alternative in this case newFixedThreadPool public static ScheduledExecutorService newScheduledThreadPool int": "input.pdf", "corePoolSize 4. Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically. Use cases Handling recurring events with delays, which will happen in future at certain interval of times1. Cons Unbounded queue is harmful.1. 5.public static ExecutorService newWorkStealingPool GoalKicker.com Java Notes for Professionals 703Creates a work-stealing thread pool using all available processors as its target parallelism level Use cases For divide and conquer type of problems.1. E\ufb00ective use of idle threads. Idle threads steals tasks from busy threads.2. Cons Unbounded queue size is harmful.1. You can see one common drawbacks in all these ExecutorService unbounded queue. This will be addressed with ThreadPoolExecutor ThreadPoolExecutor int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue Runnable workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler With ThreadPoolExecutor , you can Control Thread pool size dynamically1. Set the capacity for BlockingQueue 2. De\ufb01ne RejectionExecutionHander when queue is full 3. CustomThreadFactory to add some additional functionality during Thread creation public Thread 4. newThread Runnable r Section 127.9 Scheduling tasks to run at a \ufb01xed time, after a delay or repeatedly The ScheduledExecutorService class provides a methods for scheduling single or repeated tasks in a number of ways. The following code": "input.pdf", "sample assume that pool has been declared and initialized as follows ScheduledExecutorService pool Executors. newScheduledThreadPool 2 In addition to the normal ExecutorService methods, the ScheduledExecutorService API adds 4 methods that schedule tasks and return ScheduledFuture objects. The latter can be used to retrieve results in some cases and cancel tasks. Starting a task after a \ufb01xed delay The following example schedules a task to start after ten minutes. ScheduledFuture Integer future pool.schedule new Callable Override public Integer call do something return 42 , 10, TimeUnit. MINUTES Starting tasks at a \ufb01xed rate The following example schedules a task to start after ten minutes, and then repeatedly at a rate of once every one minute. GoalKicker.com Java Notes for Professionals 704ScheduledFuture ? future pool.scheduleAtFixedRate new Runnable Override public void run do something , 10, 1, TimeUnit. MINUTES Task execution will continue according to the schedule until the pool is shut down, the future is canceled, or one of the tasks encounters an exception. It is guaranteed that the tasks scheduled by a given scheduledAtFixedRate call will not overlap in time. If a task takes longer than the prescribed period, then the next and subsequent task executions may start late. Starting": "input.pdf", "tasks with a \ufb01xed delay The following example schedules a task to start after ten minutes, and then repeatedly with a delay of one minute between one task ending and the next one starting. ScheduledFuture ? future pool.scheduleWithFixedDelay new Runnable Override public void run do something , 10, 1, TimeUnit. MINUTES Task execution will continue according to the schedule until the pool is shut down, the future is canceled, or one of the tasks encounters an exception. Section 127.10 Using Thread Pools Thread Pools are used mostly calling methods in ExecutorService . The following methods can be used to submit work for execution Method Description submit Executes a the submitted work and return a future which can be used to get the result execute Execute the task sometime in the future without getting any return value invokeAll Execute a list of tasks and return a list of Futures invokeAny Executes all the but return only the result of one that has been successful without exceptions Once you are done with the Thread Pool you can call shutdown to terminate the Thread Pool. This executes all pending tasks. To wait for all tasks to execute you can can loop around": "input.pdf", "awaitTermination or isShutdown . GoalKicker.com Java Notes for Professionals 705Chapter 128 ThreadLocal Section 128.1 Basic ThreadLocal usage Java ThreadLocal is used to create thread local variables. It is known that threads of an Object share it s variables, so the variable is not thread safe. We can use synchronization for thread safety but if we want to avoid synchronization,ThreadLocal allows us to create variables which are local to the thread, i.e. only that thread can read or write to those variables, so the other threads executing the same piece of code will not be able to access each others ThreadLocal variables. This can be usedwe can use ThreadLocal variables. in situations where you have a thread pool like for example in a web service. For example, Creating a SimpleDateFormat object every time for every request is time consuming and a Static one cannot be created as SimpleDateFormat is not thread safe, so we can create a ThreadLocal so that we can perform thread safe operations without the overhead of creating SimpleDateFormat every time. The below piece of code shows how it can be used Every thread has it s own ThreadLocal variable and they can use it s get": "input.pdf", "and set methods to get the default value or change it s value local to Thread. ThreadLocal instances are typically private static \ufb01elds in classes that wish to associate state with a thread. Here is a small example showing use of ThreadLocal in java program and proving that every thread has it s own copy of ThreadLocal variable. package com.examples.threads import java.text.SimpleDateFormat import java.util.Random public class ThreadLocalExample implements Runnable SimpleDateFormat is not thread-safe, so give one to each thread SimpleDateFormat is not thread-safe, so give one to each thread private static final ThreadLocal SimpleDateFormat formatter new ThreadLocal SimpleDateFormat Override protected SimpleDateFormat initialValue return new SimpleDateFormat yyyyMMdd HHmm public static void mainString args throws InterruptedException ThreadLocalExample obj new ThreadLocalExample forint i0 i10 i Thread t new Threadobj, i Thread.sleepnew Random.nextInt1000 t. start Override public void run System.out.printlnThread Name Thread.currentThread .getName default Formatter formatter. get.toPattern try GoalKicker.com Java Notes for Professionals 706 Thread.sleepnew Random.nextInt1000 catch InterruptedException e e. printStackTrace formatter. setnew SimpleDateFormat System.out.printlnThread Name Thread.currentThread .getName formatter formatter. get.toPattern Output Thread Name 0 default Formatter yyyyMMdd HHmm Thread Name 1 default Formatter yyyyMMdd HHmm Thread Name 0 formatter Mdyy hmm a Thread Name 2 default Formatter yyyyMMdd HHmm Thread Name 1": "input.pdf", "formatter Mdyy hmm a Thread Name 3 default Formatter yyyyMMdd HHmm Thread Name 4 default Formatter yyyyMMdd HHmm Thread Name 4 formatter Mdyy hmm a Thread Name 5 default Formatter yyyyMMdd HHmm Thread Name 2 formatter Mdyy hmm a Thread Name 3 formatter Mdyy hmm a Thread Name 6 default Formatter yyyyMMdd HHmm Thread Name 5 formatter Mdyy hmm a Thread Name 6 formatter Mdyy hmm a Thread Name 7 default Formatter yyyyMMdd HHmm Thread Name 8 default Formatter yyyyMMdd HHmm Thread Name 8 formatter Mdyy hmm a Thread Name 7 formatter Mdyy hmm a Thread Name 9 default Formatter yyyyMMdd HHmm Thread Name 9 formatter Mdyy hmm a As we can see from the output that Thread-0 has changed the value of formatter but still thread-2 default formatter is same as the initialized value. Section 128.2 ThreadLocal Java 8 functional initialization public static class ThreadLocalExample GoalKicker.com Java Notes for Professionals 707 private static final ThreadLocal SimpleDateFormat format ThreadLocal .withInitial - new SimpleDateFormat yyyyMMddHHmm public String formatDate Date date return format. get.formatdate Section 128.3 Multiple threads with one shared object In this example we have only one object but it is shared betweenexecuted on di\ufb00erent threads. Ordinary usage of": "input.pdf", "\ufb01elds to save state would not be possible because the other thread would see that too or probably not see. public class Test public static void mainString args Foo foo new Foo new Threadfoo, Thread 1 .start new Threadfoo, Thread 2 .start In Foo we count starting from zero. Instead of saving the state to a \ufb01eld we store our current number in the ThreadLocal object which is statically accessible. Note that the synchronization in this example is not related to the usage of ThreadLocal but rather ensures a better console output. public class Foo implements Runnable private static final int ITERATIONS 10 private static final ThreadLocal Integer threadLocal new ThreadLocal Integer Override protected Integer initialValue return 0 Override public void run for int i 0 i ITERATIONS i synchronized threadLocal Although accessing a static field, we get our own previously saved value. int value threadLocal. get System.out.printlnThread.currentThread .getName value Update our own variable threadLocal. setvalue 1 try threadLocal. notifyAll if i ITERATIONS - 1 threadLocal. wait catch InterruptedException ex From the output we can see that each thread counts for itself and does not use the value of the other one GoalKicker.com Java Notes for Professionals 708Thread 1": "input.pdf", "0 Thread 2 0 Thread 1 1 Thread 2 1 Thread 1 2 Thread 2 2 Thread 1 3 Thread 2 3 Thread 1 4 Thread 2 4 Thread 1 5 Thread 2 5 Thread 1 6 Thread 2 6 Thread 1 7 Thread 2 7 Thread 1 8 Thread 2 8 Thread 1 9 Thread 2 9 GoalKicker.com Java Notes for Professionals 709Chapter 129 Using ThreadPoolExecutor in MultiThreaded applications. When creating a performant and data-driven application, it can be very helpful to complete time-intensive tasks in an asynchronous manner and to have multiple tasks running concurrently. This topic will introduce the concept of using ThreadPoolExecutors to complete multiple ansynchronous tasks concurrently. Section 129.1 Performing Asynchronous Tasks Where No Return Value Is Needed Using a Runnable Class Instance Some applications may want to create so-called Fire Forget tasks which can be periodically triggered and do not need to return any type of value returned upon completion of the assigned task for example, purging old temp \ufb01les, rotating logs, autosaving state. In this example, we will create two classes One which implements the Runnable interface, and one which contains a main method. AsyncMaintenanceTaskCompleter.java import lombok.extern.java.Log import java.util.concurrent.ThreadLocalRandom import java.util.concurrent.TimeUnit Log": "input.pdf", "public class AsyncMaintenanceTaskCompleter implements Runnable private int taskNumber public AsyncMaintenanceTaskCompleter int taskNumber this.taskNumber taskNumber public void run int timeout ThreadLocalRandom. current.nextInt1, 20 try log. infoString.formatTask d is sleeping for d seconds , taskNumber, timeout TimeUnit. SECONDS.sleeptimeout log. infoString.formatTask d is done sleeping , taskNumber catch InterruptedException e log. warninge.getMessage AsyncExample1 import java.util.concurrent.ExecutorService import java.util.concurrent.Executors public class AsyncExample1 public static void mainString args ExecutorService executorService Executors. newCachedThreadPool forint i 0 i 10 i executorService. executenew AsyncMaintenanceTaskCompleter i GoalKicker.com Java Notes for Professionals 710 executorService. shutdown Running AsyncExample1.main resulted in the following output Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 8 is sleeping for 18 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 6 is sleeping for 4 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 2 is sleeping for 6 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 3 is sleeping for 4 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 9 is sleeping for 14 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 4 is sleeping for 9 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 5 is sleeping for 10 seconds Dec 28, 2016": "input.pdf", "22103 PM AsyncMaintenanceTaskCompleter run INFO Task 0 is sleeping for 7 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 1 is sleeping for 9 seconds Dec 28, 2016 22103 PM AsyncMaintenanceTaskCompleter run INFO Task 7 is sleeping for 8 seconds Dec 28, 2016 22107 PM AsyncMaintenanceTaskCompleter run INFO Task 6 is done sleeping Dec 28, 2016 22107 PM AsyncMaintenanceTaskCompleter run INFO Task 3 is done sleeping Dec 28, 2016 22109 PM AsyncMaintenanceTaskCompleter run INFO Task 2 is done sleeping Dec 28, 2016 22110 PM AsyncMaintenanceTaskCompleter run INFO Task 0 is done sleeping Dec 28, 2016 22111 PM AsyncMaintenanceTaskCompleter run INFO Task 7 is done sleeping Dec 28, 2016 22112 PM AsyncMaintenanceTaskCompleter run INFO Task 4 is done sleeping Dec 28, 2016 22112 PM AsyncMaintenanceTaskCompleter run INFO Task 1 is done sleeping Dec 28, 2016 22113 PM AsyncMaintenanceTaskCompleter run INFO Task 5 is done sleeping Dec 28, 2016 22117 PM AsyncMaintenanceTaskCompleter run INFO Task 9 is done sleeping Dec 28, 2016 22121 PM AsyncMaintenanceTaskCompleter run INFO Task 8 is done sleeping Process finished with exit code 0 Observations of Note There are several things to note in the output above, The tasks did not execute in a predictable": "input.pdf", "order.1. Since each task was sleeping for a pseudorandom amount of time, they did not necessarily complete in the2. order in which they were invoked. Section 129.2 Performing Asynchronous Tasks Where a Return Value Is Needed Using a Callable Class Instance It is often necessary to execute a long-running task and use the result of that task once it has completed. GoalKicker.com Java Notes for Professionals 711In this example, we will create two classes One which implements the CallableT interface where T is the type we wish to return, and one which contains a main method. AsyncValueTypeTaskCompleter.java import lombok.extern.java.Log import java.util.concurrent.Callable import java.util.concurrent.ThreadLocalRandom import java.util.concurrent.TimeUnit Log public class AsyncValueTypeTaskCompleter implements Callable Integer private int taskNumber public AsyncValueTypeTaskCompleter int taskNumber this.taskNumber taskNumber Override public Integer call throws Exception int timeout ThreadLocalRandom. current.nextInt1, 20 try log. infoString.formatTask d is sleeping , taskNumber TimeUnit. SECONDS.sleeptimeout log. infoString.formatTask d is done sleeping , taskNumber catch InterruptedException e log. warninge.getMessage return timeout AsyncExample2.java import lombok.extern.java.Log import java.util.ArrayList import java.util.List import java.util.concurrent.ExecutionException import java.util.concurrent.ExecutorService import java.util.concurrent.Executors import java.util.concurrent.Future Log public class AsyncExample2 public static void mainString args ExecutorService executorService Executors. newCachedThreadPool List FutureInteger futures new ArrayList for int i 0 i 10 i Future Integer": "input.pdf", "submittedFuture executorService. submitnew AsyncValueTypeTaskCompleter i futures. addsubmittedFuture executorService. shutdown while!futures. isEmpty forint j 0 j futures. size j Future Integer f futures. getj iff.isDone try GoalKicker.com Java Notes for Professionals 712 int timeout f.get log. infoString.formatA task just completed after sleeping for d seconds , timeout futures. removef catch InterruptedException ExecutionException e log. warninge.getMessage Running AsyncExample2.main resulted in the following output Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 7 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 8 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 2 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 1 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 4 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 9 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 0 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 6 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 5 is sleeping Dec 28, 2016 30715 PM AsyncValueTypeTaskCompleter call INFO Task 3 is sleeping Dec 28, 2016 30716 PM AsyncValueTypeTaskCompleter call INFO Task 8 is done sleeping Dec 28, 2016 30716 PM": "input.pdf", "AsyncExample2 main INFO A task just completed after sleeping for 1 seconds Dec 28, 2016 30717 PM AsyncValueTypeTaskCompleter call INFO Task 2 is done sleeping Dec 28, 2016 30717 PM AsyncExample2 main INFO A task just completed after sleeping for 2 seconds Dec 28, 2016 30717 PM AsyncValueTypeTaskCompleter call INFO Task 9 is done sleeping Dec 28, 2016 30717 PM AsyncExample2 main INFO A task just completed after sleeping for 2 seconds Dec 28, 2016 30719 PM AsyncValueTypeTaskCompleter call INFO Task 3 is done sleeping Dec 28, 2016 30719 PM AsyncExample2 main INFO A task just completed after sleeping for 4 seconds Dec 28, 2016 30720 PM AsyncValueTypeTaskCompleter call INFO Task 0 is done sleeping Dec 28, 2016 30720 PM AsyncExample2 main INFO A task just completed after sleeping for 5 seconds Dec 28, 2016 30721 PM AsyncValueTypeTaskCompleter call INFO Task 5 is done sleeping Dec 28, 2016 30721 PM AsyncExample2 main INFO A task just completed after sleeping for 6 seconds Dec 28, 2016 30725 PM AsyncValueTypeTaskCompleter call INFO Task 1 is done sleeping Dec 28, 2016 30725 PM AsyncExample2 main GoalKicker.com Java Notes for Professionals 713INFO A task just completed after sleeping for 10 seconds Dec 28,": "input.pdf", "2016 30727 PM AsyncValueTypeTaskCompleter call INFO Task 6 is done sleeping Dec 28, 2016 30727 PM AsyncExample2 main INFO A task just completed after sleeping for 12 seconds Dec 28, 2016 30729 PM AsyncValueTypeTaskCompleter call INFO Task 7 is done sleeping Dec 28, 2016 30729 PM AsyncExample2 main INFO A task just completed after sleeping for 14 seconds Dec 28, 2016 30731 PM AsyncValueTypeTaskCompleter call INFO Task 4 is done sleeping Dec 28, 2016 30731 PM AsyncExample2 main INFO A task just completed after sleeping for 16 seconds Observations of Note There are several things to note in the output above, Each call to ExecutorService.submit returned an instance of Future, which was stored in a list for later use1. Future contains a method called isDone which can be used to check whether our task has been completed2. before attempting to check its return value. Calling the Future.get method on a Future that is not yet done will block the current thread until the task is complete, potentially negating many bene\ufb01ts gained from performing the task Asynchronously. The executorService.shutdown method was called prior to checking the return values of the Future objects.3. This is not required, but was done in": "input.pdf", "this way to show that it is possible. The executorService.shutdown method does not prevent the completion of tasks which have already been submitted to the ExecutorService, but rather prevents new tasks from being added to the Queue. Section 129.3 De\ufb01ning Asynchronous Tasks Inline using Lambdas While good software design often maximizes code reusability, sometimes it can be useful to de\ufb01ne asynchronous tasks inline in your code via Lambda expressions to maximize code readability. In this example, we will create a single class which contains a main method. Inside this method, we will use Lambda expressions to create and execute instances of Callable and RunnableT. AsyncExample3.java import lombok.extern.java.Log import java.util.ArrayList import java.util.List import java.util.concurrent. Log public class AsyncExample3 public static void mainString args ExecutorService executorService Executors. newCachedThreadPool List FutureInteger futures new ArrayList forint i 0 i 5 i final int index i executorService. execute - int timeout getTimeout log. infoString.formatRunnable d has been submitted and will sleep for d seconds , index, timeout try GoalKicker.com Java Notes for Professionals 714 TimeUnit. SECONDS.sleeptimeout catch InterruptedException e log. warninge.getMessage log. infoString.formatRunnable d has finished sleeping , index Future Integer submittedFuture executorService. submit - int timeout getTimeout log. infoString.formatCallable d will begin sleeping": "input.pdf", ", index try TimeUnit. SECONDS.sleeptimeout catch InterruptedException e log. warninge.getMessage log. infoString.formatCallable d is done sleeping , index return timeout futures. addsubmittedFuture executorService. shutdown while!futures. isEmpty forint j 0 j futures. size j Future Integer f futures. getj iff.isDone try int timeout f.get log. infoString.formatA task just completed after sleeping for d seconds , timeout futures. removef catch InterruptedException ExecutionException e log. warninge.getMessage public static int getTimeout return ThreadLocalRandom. current.nextInt1, 20 Observations of Note There are several things to note in the output above, Lambda expressions have access to variables and methods which are available to the scope in which they are1. de\ufb01ned, but all variables must be \ufb01nal or e\ufb00ectively \ufb01nal for use inside a lambda expression. We do not have to specify whether our Lambda expression is a Callable or a RunnableT explicitly, the2. return type is inferred automatically by the return type. GoalKicker.com Java Notes for Professionals 715Chapter 130 Common Java Pitfalls This topic outlines some of the common mistakes made by beginners in Java. This includes any common mistakes in use of the Java language or understanding of the run-time environment. Mistakes associated with speci\ufb01c APIs can be described in topics speci\ufb01c to those APIs.": "input.pdf", "Strings are a special case theyre covered in the Java Language Speci\ufb01cation. Details other than common mistakes can be described in this topic on Strings. Section 130.1 Pitfall using to compare primitive wrappers objects such as Integer This pitfall applies equally to all primitive wrapper types, but we will illustrate it for Integer and int. When working with Integer objects, it is tempting to use to compare values, because that is what you would do with int values. And in some cases this will seem to work Integer int11 Integer.valueOf1 Integer int12 Integer.valueOf1 System.out.printlnint11 int12 int11 int12 true System.out.printlnint11 equals int12 int11. equalsint12 true Here we created two Integer objects with the value 1 and compare them In this case we created one from a String and one from an int literal. There are other alternatives. Also, we observe that the two comparison methods and equals both yield true . This behavior changes when we choose di\ufb00erent values Integer int21 Integer.valueOf1000 Integer int22 Integer.valueOf1000 System.out.printlnint21 int22 int21 int22 false System.out.printlnint21 equals int22 int21. equalsint22 true In this case, only the equals comparison yields the correct result. The reason for this di\ufb00erence in behavior is, that the JVM maintains a": "input.pdf", "cache of Integer objects for the range -128 to 127. The upper value can be overridden with the system property java.lang.Integer.IntegerCache.high or the JVM argument -XXAutoBoxCacheMaxsize. For values in this range, the Integer.valueOf will return the cached value rather than creating a new one. Thus, in the \ufb01rst example the Integer.valueOf1 and Integer.valueOf1 calls returned the same cached Integer instance. By contrast, in the second example the Integer.valueOf1000 and Integer.valueOf1000 both created and returned new Integer objects. The operator for reference types tests for reference equality i.e. the same object. Therefore, in the \ufb01rst example int11 int12 is true because the references are the same. In the second example int21 int22 is false because the references are di\ufb00erent. Section 130.2 Pitfall using to compare strings A common mistake for Java beginners is to use the operator to test if two strings are equal. For example GoalKicker.com Java Notes for Professionals 716public class Hello public static void mainString args if args.length 0 if args0 hello System.out.printlnHello back to you else System.out.printlnAre you feeling grumpy today? The above program is supposed to test the \ufb01rst command line argument and print di\ufb00erent messages when it and isnt the word hello. But the": "input.pdf", "problem is that it wont work. That program will output Are you feeling grumpy today? no matter what the \ufb01rst command line argument is. In this particular case the String hello is put in the string pool while the String args0 resides on the heap. This means there are two objects representing the same literal, each with its reference. Since tests for references, not actual equality, the comparison will yield a false most of the times. This doesnt mean that it will always do so. When you use to test strings, what you are actually testing is if two String objects are the same Java object. Unfortunately, that is not what string equality means in Java. In fact, the correct way to test strings is to use the equalsObject method. For a pair of strings, we usually want to test if they consist of the same characters in the same order. public class Hello2 public static void mainString args if args.length 0 if args0.equalshello System.out.printlnHello back to you else System.out.printlnAre you feeling grumpy today? But it actually gets worse. The problem is that will give the expected answer in some circumstances. For example public class Test1 public static void": "input.pdf", "mainString args String s1 hello String s2 hello if s1 s2 System.out.printlnsame else System.out.printlndifferent Interestingly, this will print same, even though we are testing the strings the wrong way. Why is that? Because the Java Language Speci\ufb01cation Section 3.10.5 String Literals stipulates that any two string literals consisting of the same characters will actually be represented by the same Java object. Hence, the test will give true for equal literals. The string literals are interned and added to a shared string pool when your code is loaded, but that is actually an implementation detail. GoalKicker.com Java Notes for Professionals 717To add to the confusion, the Java Language Speci\ufb01cation also stipulates that when you have a compile-time constant expression that concatenates two string literals, that is equivalent to a single literal. Thus public class Test1 public static void mainString args String s1 hello String s2 hel lo String s3 mum if s1 s2 System.out.println1. same else System.out.println1. different if s1 s3 hello mum System.out.println2. same else System.out.println2. different This will output 1. same and 2. di\ufb00erent. In the \ufb01rst case, the expression is evaluated at compile time and we compare one String object with itself. In the second case, it": "input.pdf", "is evaluated at run time and we compare two di\ufb00erent String objects In summary, using to test strings in Java is almost always incorrect, but it is not guaranteed to give the wrong answer. Section 130.3 Pitfall forgetting to free resources Every time a program opens a resource, such as a \ufb01le or network connection, it is important to free the resource once you are done using it. Similar caution should be taken if any exception were to be thrown during operations on such resources. One could argue that the FileInputStream has a \ufb01nalizer that invokes the close method on a garbage collection event however, since we can t be sure when a garbage collection cycle will start, the input stream can consume computer resources for an inde\ufb01nite period of time. The resource must be closed in a finally section of a try-catch block Version Java SE 7 private static void printFileJava6 throws IOException FileInputStream input try input new FileInputStream file.txt int data input.read while data ! -1 System.out.printchar data data input.read finally if input ! null input. close Since Java 7 there is a really useful and neat statement introduced in Java 7 particularly for this case, called": "input.pdf", "try-with- resources Version Java SE 7 GoalKicker.com Java Notes for Professionals 718private static void printFileJava7 throws IOException try FileInputStream input new FileInputStream file.txt int data input.read while data ! -1 System.out.printchar data data input.read The try-with-resources statement can be used with any object that implements the Closeable or AutoCloseable interface. It ensures that each resource is closed by the end of the statement. The di\ufb00erence between the two interfaces is, that the close method of Closeable throws an IOException which has to be handled in some way. In cases where the resource has already been opened but should be safely closed after use, one can assign it to a local variable inside the try-with-resources Version Java SE 7 private static void printFileJava7 InputStream extResource throws IOException try InputStream input extResource ... access resource The local resource variable created in the try-with-resources constructor is e\ufb00ectively \ufb01nal. Section 130.4 Pitfall testing a \ufb01le before attempting to open it Some people recommend that you should apply various tests to a \ufb01le before attempting to open it either to provide better diagnostics or avoid dealing with exceptions. For example, this method attempts to check if path corresponds to a readable \ufb01le public static": "input.pdf", "File getValidatedFile String path throws IOException File f new Filepath if !f.exists throw new IOException Error not found path if !f.isFile throw new IOException Error Is a directory path if !f.canRead throw new IOException Error cannot read file path return f You might use the above method like this File f null try f getValidatedFile somefile catch IOException ex System.err.printlnex.getMessage return try InputStream is new FileInputStream file Read data etc. The \ufb01rst problem is in the signature for FileInputStream File because the compiler will still insist we catch IOException here, or further up the stack. GoalKicker.com Java Notes for Professionals 719The second problem is that checks performed by getValidatedFile do not guarantee that the FileInputStream will succeed. Race conditions another thread or a separate process could rename the \ufb01le, delete the \ufb01le, or remove read access after the getValidatedFile returns. That would lead to a plain IOException without the custom message. There are edge cases not covered by those tests. For example, on a system with SELinux in enforcing mode, an attempt to read a \ufb01le can fail despite canRead returning true . The third problem is that the tests are ine\ufb03cient. For example, the exists , isFile and": "input.pdf", "canRead calls will each make a syscall to perform the required check. Another syscall is then made to open the \ufb01le, which repeats the same checks behind the scenes. In short, methods like getValidatedFile are misguided. It is better to simply attempt to open the \ufb01le and handle the exception try InputStream is new FileInputStream somefile Read data etc. catch IOException ex System.err.printlnIO Error processing somefile ex.getMessage return If you wanted to distinguish IO errors thrown while opening and reading, you could use a nested try catch. If you wanted to produce better diagnostics for open failures, you could perform the exists , isFile and canRead checks in the handler. Section 130.5 Pitfall thinking of variables as objects No Java variable represents an object. String foo NOT AN OBJECT Neither does any Java array contain objects. String bar new String100 No member is an object. If you mistakenly think of variables as objects, the actual behavior of the Java language will surprise you. For Java variables which have a primitive type such as int or float the variable holds a copy of the value. All copies of a primitive value are indistinguishable i.e. there is only one int value": "input.pdf", "for the number one. Primitive values are not objects and they do not behave like objects. For Java variables which have a reference type either a class or an array type the variable holds a reference. All copies of a reference are indistinguishable. References may point to objects, or they may be null which means that they point to no object. However, they are not objects and they dont behave like objects. Variables are not objects in either case, and they dont contain objects in either case. They may contain references to objects , but that is saying something di\ufb00erent. Example class The examples that follow use this class, which represents a point in 2D space. GoalKicker.com Java Notes for Professionals 720public final class MutableLocation public int x public int y public MutableLocation int x, int y this.x x this.y y public boolean equalsObject other if !other instanceof MutableLocation return false MutableLocation that MutableLocation other return this.x that.x this.y that.y An instance of this class is an object that has two \ufb01elds x and y which have the type int. We can have many instances of the MutableLocation class. Some will represent the same locations in 2D space i.e.": "input.pdf", "the respective values of x and y will match. Others will represent di\ufb00erent locations. Multiple variables can point to the same object MutableLocation here new MutableLocation 1, 2 MutableLocation there here MutableLocation elsewhere new MutableLocation 1, 2 In the above, we have declared three variables here , there and elsewhere that can hold references to MutableLocation objects. If you incorrectly think of these variables as being objects, then you are likely to misread the statements as saying Copy the location 1, 2 to here 1. Copy the location 1, 2 to there 2. Copy the location 1, 2 to elsewhere 3. From that, you are likely to infer we have three independent objects in the three variables. In fact there are only two objects created by the above. The variables here and there actually refer to the same object. We can demonstrate this. Assuming the variable declarations as above System.out.printlnBEFORE here.x is here.x , there.x is there.x elsewhere.x is elsewhere. x here.x 42 System.out.printlnAFTER here.x is here.x , there.x is there.x elsewhere.x is elsewhere. x This will output the following BEFORE here.x is 1, there.x is 1, elsewhere.x is 1 AFTER here.x is 42, there.x is 42, elsewhere.x is": "input.pdf", "1 We assigned a new value to here.x and it changed the value that we see via there.x. They are referring to the same object. But the value that we see via elsewhere. x has not changed, so elsewhere must refer to a di\ufb00erent GoalKicker.com Java Notes for Professionals 721object. If a variable was an object, then the assignment here.x 42 would not change there.x. The equality operator does NOT test that two objects are equal Applying the equality operator to reference values tests if the values refer to the same object. It does not test whether two di\ufb00erent objects are equal in the intuitive sense. MutableLocation here new MutableLocation 1, 2 MutableLocation there here MutableLocation elsewhere new MutableLocation 1, 2 if here there System.out.printlnhere is there if here elsewhere System.out.printlnhere is elsewhere This will print here is there, but it wont print here is elsewhere. The references in here and elsewhere are for two distinct objects. By contrast, if we call the equalsObject method that we implemented above, we are going to test if two MutableLocation instances have an equal location. if here.equalsthere System.out.printlnhere equals there if here.equalselsewhere System.out.printlnhere equals elsewhere This will print both messages. In particular,": "input.pdf", "here.equalselsewhere returns true because the semantic criteria we chose for equality of two MutableLocation objects has been satis\ufb01ed. Method calls do NOT pass objects at all Java method calls use pass by value 1 to pass arguments and return a result. When you pass a reference value to a method, youre actually passing a reference to an object by value , which means that it is creating a copy of the object reference. As long as both object references are still pointing to the same object, you can modify that object from either reference, and this is what causes confusion for some. However, you are not passing an object by reference2. The distinction is that if the object reference copy is modi\ufb01ed to point to another object, the original object reference will still point to the original object. void fMutableLocation foo foo new MutableLocation 3, 4 Point local foo at a different object. void g MutableLocation foo MutableLocation 1, 2 ffoo System.out.printlnfoo.x is foo.x Prints foo.x is 1. GoalKicker.com Java Notes for Professionals 722 Neither are you passing a copy of the object. void fMutableLocation foo foo. x 42 void g MutableLocation foo new MutableLocation 0, 0 ffoo System.out.printlnfoo.x": "input.pdf", "is foo.x Prints foo.x is 42 1 - In languages like Python and Ruby, the term pass by sharing is preferred for pass by value of an object reference. 2 - The term pass by reference or call by reference has a very speci\ufb01c meaning in programming language terminology. In e\ufb00ect, it means that you pass the address of a variable or an array element , so that when the called method assigns a new value to the formal argument, it changes the value in the original variable. Java does not support this. For a more fulsome description of di\ufb00erent mechanisms for passing parameters, please refer to httpsen.wikipedia.orgwikiEvaluationstrategy . Section 130.6 Pitfall memory leaks Java manages memory automatically. You are not required to free memory manually. An objects memory on the heap may be freed by a garbage collector when the object is no longer reachable by a live thread. However, you can prevent memory from being freed, by allowing objects to be reachable that are no longer needed. Whether you call this a memory leak or memory packratting, the result is the same -- an unnecessary increase in allocated memory. Memory leaks in Java can happen in various": "input.pdf", "ways, but the most common reason is everlasting object references, because the garbage collector can t remove objects from the heap while there are still references to them. Static \ufb01elds One can create such a reference by de\ufb01ning class with a static \ufb01eld containing some collection of objects, and forgetting to set that static \ufb01eld to null after the collection is no longer needed. static \ufb01elds are considered GC roots and are never collected. Another issue is leaks in non-heap memory when JNI is used. Classloader leak By far, though, the most insidious type of memory leak is the classloader leak . A classloader holds a reference to every class it has loaded, and every class holds a reference to its classloader. Every object holds a reference to its class as well. Therefore, if even a single object of a class loaded by a classloader is not garbage, not a single class that that classloader has loaded can be collected. Since each class also refers to its static \ufb01elds, they cannot be collected either. Accumulation leak The accumulation leak example could look like the following final ScheduledExecutorService scheduledExecutorService Executors. newScheduledThreadPool 1 final DequeBigDecimal numbers new LinkedBlockingDeque final BigDecimal divisor": "input.pdf", "new BigDecimal 51 scheduledExecutorService. scheduleAtFixedRate - GoalKicker.com Java Notes for Professionals 723 BigDecimal number numbers. peekLast if number ! null number. remainder divisor.byteValue 0 System.out.printlnNumber number System.out.printlnDeque size numbers. size , 10, 10, TimeUnit. MILLISECONDS scheduledExecutorService. scheduleAtFixedRate - numbers. addnew BigDecimal System.currentTimeMillis , 10, 10, TimeUnit. MILLISECONDS try scheduledExecutorService. awaitTermination 1, TimeUnit. DAYS catch InterruptedException e e.printStackTrace This example creates two scheduled tasks. The \ufb01rst task takes the last number from a deque called numbers , and, if the number is divisible by 51, it prints the number and the deques size. The second task puts numbers into the deque. Both tasks are scheduled at a \ufb01xed rate, and they run every 10 ms. If the code is executed, you ll see that the size of the deque is permanently increasing. This will eventually cause the deque to be \ufb01lled with objects that consume all available heap memory. To prevent this while preserving the semantics of this program, we can use a di\ufb00erent method for taking numbers from the deque pollLast . Contrary to the method peekLast , pollLast returns the element and removes it from the deque while peekLast only returns the last element. Section 130.7 Pitfall Not": "input.pdf", "understanding that String is an immutable class New Java programmers often forget, or fail to fully comprehend, that the Java String class is immutable. This leads to problems like the one in the following example public class Shout public static void mainString args for String s args s. toUpperCase System.out.prints System.out.print System.out.println The above code is supposed to print command line arguments in upper case. Unfortunately, it does not work, the case of the arguments is not changed. The problem is this statement s.toUpperCase You might think that calling toUpperCase is going to change s to an uppercase string. It doesnt. It cant! String objects are immutable. They cannot be changed. In reality, the toUpperCase method returns a String object which is an uppercase version of the String that you call it on. This will probably be a new String object, but if s was already all uppercase, the result could be the existing string. GoalKicker.com Java Notes for Professionals 724So in order to use this method e\ufb00ectively, you need to use the object returned by the method call for example s s.toUpperCase In fact, the strings never change rule applies to all String methods. If you remember that,": "input.pdf", "then you can avoid a whole category of beginners mistakes. Section 130.8 Pitfall combining assignment and side-eects Occasionally we see StackOver\ufb02ow Java questions and C or C questions that ask what something like this i ai bi-- evaluates to ... for some known initial states of i, a and b. Generally speaking for Java the answer is always speci\ufb01ed1, but non-obvious, and often di\ufb03cult to \ufb01gure out for C and C the answer is often unspeci\ufb01ed. Such examples are often used in exams or job interviews as an attempt to see if the student or interviewee understands how expression evaluation really works in the Java programming language. This is arguably legitimate as a test of knowledge, but that does not mean that you should ever do this in a real program. To illustrate, the following seemingly simple example has appeared a few times in StackOver\ufb02ow questions like this one. In some cases, it appears as a genuine mistake in someones code. int a 1 a a System.out.printlna What does this print. Most programmers including Java experts reading those statements quickly would say that it outputs 2. In fact, it outputs 1. For a detailed explanation of why, please read": "input.pdf", "this Answer . However the real takeaway from this and similar examples is that any Java statement that both assigns to and side- e\ufb00ects the same variable is going to be at best hard to understand, and at worst downright misleading. You should avoid writing code like this. 1 - modulo potential issues with the Java Memory Model if the variables or objects are visible to other threads. GoalKicker.com Java Notes for Professionals 725Chapter 131 Java Pitfalls - Exception usage Several Java programming language misusage might conduct a program to generate incorrect results despite being compiled correctly. This topic main purpose is to list common pitfalls related to exception handling , and to propose the correct way to avoid having such pitfalls. Section 131.1 Pitfall - Catching Throwable, Exception, Error or RuntimeException A common thought pattern for inexperienced Java programmers is that exceptions are a problem or a burden and the best way to deal with this is catch them all1 as soon as possible. This leads to code like this .... try InputStream is new FileInputStream fileName process the input catch Exception ex System.out.printlnCould not open file fileName The above code has a signi\ufb01cant \ufb02aw. The catch is": "input.pdf", "actually going to catch more exceptions than the programmer is expecting. Suppose that the value of the fileName is null , due to a bug elsewhere in the application. This will cause the FileInputStream constructor to throw a NullPointerException . The handler will catch this, and report to the user Could not open file null which is unhelpful and confusing. Worse still, suppose that the it was the process the input code that threw the unexpected exception checked or unchecked!. Now the user will get the misleading message for a problem that didnt occur while opening the \ufb01le, and may not be related to IO at all. The root of the problem is that the programmer has coded a handler for Exception . This is almost always a mistake Catching Exception will catch all checked exceptions, and most unchecked exceptions as well. Catching RuntimeException will catch most unchecked exceptions. Catching Error will catch unchecked exceptions that signal JVM internal errors. These errors are generally not recoverable, and should not be caught. Catching Throwable will catch all possible exceptions. The problem with catching too broad a set of exceptions is that the handler typically cannot handle all of them appropriately.": "input.pdf", "In the case of the Exception and so on, it is di\ufb03cult for the programmer to predict what could be caught i.e. what to expect. In general, the correct solution is to deal with the exceptions that are thrown. For example, you can catch them and handle them in situ try InputStream is new FileInputStream fileName process the input catch FileNotFoundException ex System.out.printlnCould not open file fileName GoalKicker.com Java Notes for Professionals 726or you can declare them as thrown by the enclosing method. There are very few situations where catching Exception is appropriate. The only one that arises commonly is something like this public static void mainString args try do stuff catch Exception ex System.err.printlnUnfortunately an error has occurred. Please report this to X Y Z Write stacktrace to a log file. System.exit1 Here we genuinely want to deal with all exceptions, so catching Exception or even Throwable is correct. 1 - Also known as Pokemon Exception Handling . Section 131.2 Pitfall - Ignoring or squashing exceptions This example is about deliberately ignoring or squashing exceptions. Or to be more precise, it is about how to catch and handle an exception in a way that ignores it. However, before": "input.pdf", "we describe how to do this, we should \ufb01rst point out that squashing exceptions is generally not the correct way to deal with them. Exceptions are usually thrown by something to notify other parts of the program that some signi\ufb01cant i.e. exceptional event has occurred. Generally though not always an exception means that something has gone wrong. If you code your program to squash the exception, there is a fair chance that the problem will reappear in another form. To make things worse, when you squash the exception, you are throwing away the information in the exception object and its associated stack trace. That is likely to make it harder to \ufb01gure out what the original source of the problem was. In practice, exception squashing frequently happens when you use an IDEs auto-correction feature to \ufb01x a compilation error caused by an unhandled exception. For example, you might see code like this try inputStream new FileInputStream someFile catch IOException e add exception handling code here Clearly, the programmer has accepted the IDEs suggestion to make the compilation error go away, but the suggestion was inappropriate. If the \ufb01le open has failed, the program should most likely do something about": "input.pdf", "it. With the above correction, the program is liable to fail later e.g. with a NullPointerException because inputStream is now null . Having said that, here is an example of deliberately squashing an exception. For the purposes of argument, assume that we have determined that an interrupt while showing the sel\ufb01e is harmless. The comment tells the reader that we squashed the exception deliberately, and why we did that. try selfie. show catch InterruptedException e It doesnt matter if showing the selfie is interrupted. GoalKicker.com Java Notes for Professionals 727 Another conventional way to highlight that we are deliberately squashing an exception without saying why is to indicate this with the exception variables name, like this try selfie. show catch InterruptedException ignored Some IDEs like IntelliJ IDEA wont display a warning about the empty catch block if the variable name is set to ignored . Section 131.3 Pitfall - Throwing Throwable, Exception, Error or RuntimeException While catching the Throwable , Exception , Error and RuntimeException exceptions is bad, throwing them is even worse. The basic problem is that when your application needs to handle exceptions, the presence of the top level exceptions make it hard to discriminate between di\ufb00erent": "input.pdf", "error conditions. For example try InputStream is new FileInputStream someFile could throw IOException ... if somethingBad throw new Exception WRONG catch IOException ex System.err.printlncannot open ... catch Exception ex System.err.printlnsomething bad happened WRONG The problem is that because we threw an Exception instance, we are forced to catch it. However as described in another example, catching Exception is bad. In this situation, it becomes di\ufb03cult to discriminate between the expected case of an Exception that gets thrown if somethingBad is true , and the unexpected case where we actually catch an unchecked exception such as NullPointerException . If the top-level exception is allowed to propagate, we run into other problems We now have to remember all of the di\ufb00erent reasons that we threw the top-level, and discriminate handle them. In the case of Exception and Throwable we also need to add these exceptions to the throws clause of methods if we want the exception to propagate. This is problematic, as described below. In short, dont throw these exceptions. Throw a more speci\ufb01c exception that more closely describes the exceptional event that has happened. If you need to, de\ufb01ne and use a custom exception class. Declaring Throwable or Exception in": "input.pdf", "a methods throws is problematic. It is tempting to replace a long list of thrown exceptions in a methods throws clause with Exception or even Throwable. This is a bad idea It forces the caller to handle or propagate Exception . 1. We can no longer rely on the compiler to tell us about speci\ufb01c checked exceptions that need to be handled.2. GoalKicker.com Java Notes for Professionals 728Handling Exception properly is di\ufb03cult. It is hard to know what actual exceptions may be caught, and if you 3. dont know what could be caught, it is hard to know what recovery strategy is appropriate. Handling Throwable is even harder, since now you also have to cope with potential failures that should never 4. be recovered from. This advice means that certain other patterns should be avoided. For example try doSomething catch Exception ex report ex throw ex The above attempts to log all exceptions as they pass, without de\ufb01nitively handling them. Unfortunately, prior to Java 7, the throw ex statement caused the compiler to think that any Exception could be thrown. That could force you to declare the enclosing method as throws Exception . From Java 7 onwards, the compiler": "input.pdf", "knows that the set of exceptions that could be re-thrown there is smaller. Section 131.4 Pitfall - Using exceptions for normal \ufb02owcontrol There is a mantra that some Java experts are wont to recite Exceptions should only be used for exceptional cases. For example httpprogrammers.stackexchange.comquestions184654 The essence of this is that is it is a bad idea in Java to use exceptions and exception handling to implement normal \ufb02ow control. For example, compare these two ways of dealing with a parameter that could be null. public String truncateWordOrNull String word, int maxLength if word null return else return word.substring 0, Math.minword.length, maxLength public String truncateWordOrNull String word, int maxLength try return word.substring 0, Math.minword.length, maxLength catch NullPointerException ex return In this example, we are by design treating the case where word is null as if it is an empty word. The two versions deal with null either using conventional if ... else and or try ... catch . How should we decide which version is better? The \ufb01rst criterion is readability. While readability is hard to quantify objectively, most programmers would agree that the essential meaning of the \ufb01rst version is easier to discern. Indeed, in order to truly": "input.pdf", "understand the second form, you need to understand that a NullPointerException cannot be thrown by the Math.min or String.substring methods. The second criterion is e\ufb03ciency. In releases of Java prior to Java 8, the second version is signi\ufb01cantly orders of GoalKicker.com Java Notes for Professionals 729magnitude slower than the \ufb01rst version. In particular, the construction of an exception object entails capturing and recording the stackframes, just in case the stacktrace is required. On the other hand, there are many situations where using exceptions is more readable, more e\ufb03cient and sometimes more correct than using conditional code to deal with exceptional events. Indeed, there are rare situations where it is necessary to use them for non-exceptional events i.e. events that occur relatively frequently. For the latter, it is worth looking at ways to reduce the overheads of creating exception objects. Section 131.5 Pitfall - Directly subclassing Throwable Throwable has two direct subclasses, Exception and Error . While its possible to create a new class that extends Throwable directly, this is inadvisable as many applications assume only Exception and Error exist. More to the point there is no practical bene\ufb01t to directly subclassing Throwable , as the resulting class is, in": "input.pdf", "e\ufb00ect, simply a checked exception. Subclassing Exception instead will result in the same behavior, but will more clearly convey your intent. Section 131.6 Pitfall - Catching InterruptedException As already pointed out in other pitfalls, catching all exceptions by using try Some code catch Exception Some error handling Comes with a lot of di\ufb00erent problems. But one perticular problem is that it can lead to deadlocks as it breaks the interrupt system when writing multi-threaded applications. If you start a thread you usually also need to be able to stop it abruptly for various reasons. Thread t new Threadnew Runnable public void run while true Do something indefinetely t.start Do something else The thread should be canceld if it is still active. A Better way to solve this is with a shared variable that is tested regularily by the thread for a clean exit, but for this example we try to forcibly interrupt this thread. if t.isAlive t.interrupt t.join Continue with program The t.interrupt will raise an InterruptedException in that thread, than is intended to shut down the thread. But what if the Thread needs to clean up some resources before its completely stopped? For this it can catch the": "input.pdf", "GoalKicker.com Java Notes for Professionals 730InterruptedException and do some cleanup. Thread t new Threadnew Runnable public void run try while true Do something indefinetely catch InterruptedException ex Do some quick cleanup In this case a simple return would do. But if you are not 100 sure that the thread ends after catching the InterruptedException you will need to raise another one for the layers surrounding this code. Thread.currentThread .interrupt But if you have a catch-all expression in your code, the InterruptedException will be caught by it as well and the interruption will not continue. Which in this case could lead to a deadlock as the parent thread waits inde\ufb01nitely for this thead to stop with t.join. Thread t new Threadnew Runnable public void run try while true try Do something indefinetely catch Exception ex ex. printStackTrace catch InterruptedException ex Dead code as the interrupt exception was already caught in the inner try-catch Thread.currentThread .interrupt So it is better to catch Exceptions individually, but if you insist on using a catch-all, at least catch the InterruptedException individually beforehand. Thread t new Threadnew Runnable public void run try while true try Do something indefinetely catch InterruptedException ex throw ex Send it": "input.pdf", "up in the chain catch Exception ex ex. printStackTrace catch InterruptedException ex Some quick cleanup code GoalKicker.com Java Notes for Professionals 731 Thread.currentThread .interrupt Section 131.7 Pitfall - Excessive or inappropriate stacktraces One of the more annoying things that programmers can do is to scatter calls to printStackTrace throughout their code. The problem is that the printStackTrace is going to write the stacktrace to standard output. For an application that is intended for end-users who are not Java programmers, a stacktrace is uninformative at best, and alarming at worst. For a server-side application, the chances are that nobody will look at the standard output. A better idea is to not call printStackTrace directly, or if you do call it, do it in a way that the stack trace is written to a log \ufb01le or error \ufb01le rather than to the end-users console. One way to do this is to use a logging framework, and pass the exception object as a parameter of the log event. However, even logging the exception can be harmful if done injudiciously. Consider the following public void method1 throws SomeException try method2 Do something catch SomeException ex Logger. getLogger .warnSomething bad in method1 ,": "input.pdf", "ex throw ex public void method2 throws SomeException try Do something else catch SomeException ex Logger. getLogger .warnSomething bad in method2 , ex throw ex If the exception is thrown in method2 , you are likely to see two copies of the same stacktrace in the log\ufb01le, corresponding to the same failure. In short, either log the exception or re-throw it further possibly wrapped with another exception. Dont do both. GoalKicker.com Java Notes for Professionals 732Chapter 132 Java Pitfalls - Language syntax Several Java programming language misusage might conduct a program to generate incorrect results despite being compiled correctly. This topic main purpose is to list common pitfalls with their causes, and to propose the correct way to avoid falling in such problems. Section 132.1 Pitfall - Missing a break in a switch case These Java issues can be very embarrassing, and sometimes remain undiscovered until run in production. Fallthrough behavior in switch statements is often useful however, missing a break keyword when such behavior is not desired can lead to disastrous results. If you have forgotten to put a break in case 0 in the code example below, the program will write Zero followed by One, since the": "input.pdf", "control \ufb02ow inside here will go through the entire switch statement until it reaches a break . For example public static void switchCasePrimer int caseIndex 0 switch caseIndex case 0 System.out.printlnZero case 1 System.out.printlnOne break case 2 System.out.printlnTwo break default System.out.printlnDefault In most cases, the cleaner solution would be to use interfaces and move code with speci\ufb01c behaviour into separate implementations composition over inheritance If a switch-statement is unavoidable it is recommended to document expected fallthroughs if they occur. That way you show fellow developers that you are aware of the missing break, and that this is expected behaviour. switchcaseIndex ... case 2 System.out.printlnTwo fallthrough default System.out.printlnDefault Section 132.2 Pitfall - Declaring classes with the same names as standard classes Sometimes, programmers who are new to Java make the mistake of de\ufb01ning a class with a name that is the same as a widely used class. For example package com.example GoalKicker.com Java Notes for Professionals 733 My string utilities public class String .... Then they wonder why they get unexpected errors. For example package com.example public class Test public static void mainString args System.out.printlnHello world! If you compile and then attempt to run the above classes you will get": "input.pdf", "an error javac com example.java java com.example.Test Error Main method not found in class test.Test, please define the main method as public static void mainString args or a JavaFX application class must extend javafx.application.Application Someone looking at the code for the Test class would see the declaration of main and look at its signature and wonder what the java command is complaining about. But in fact, the java command is telling the truth. When we declare a version of String in the same package as Test , this version takes precedence over the automatic import of java.lang.String . Thus, the signature of the Test.main method is actually void maincom.example.String args instead of void mainjava.lang.String args and the java command will not recognize that as an entrypoint method. Lesson Do not de\ufb01ne classes that have the same name as existing classes in java.lang , or other commonly used classes in the Java SE library. If you do that, you are setting yourself open for all sorts of obscure errors. Section 132.3 Pitfall - Leaving out braces the dangling if and dangling else problems The latest version of the Oracle Java style guide mandates that the then and else statements in": "input.pdf", "an if statement should always be enclosed in braces or curly brackets. Similar rules apply to the bodies of various loop statements. if a - open brace doSomething doSomeMore - close brace This is not actually required by Java language syntax. Indeed, if the then part of an if statement is a single statement, it is legal to leave out the braces GoalKicker.com Java Notes for Professionals 734if a doSomething or even if a doSomething However there are dangers in ignoring Java style rules and leaving out the braces. Speci\ufb01cally, you signi\ufb01cantly increase the risk that code with faulty indentation will be misread. The dangling if problem Consider the example code from above, rewritten without braces. if a doSomething doSomeMore This code seems to say that the calls to doSomething and doSomeMore will both occur if and only if a is true . In fact, the code is incorrectly indented. The Java Language Speci\ufb01cation that the doSomeMore call is a separate statement following the if statement. The correct indentation is as follows if a doSomething doSomeMore The dangling else problem A second problem appears when we add else to the mix. Consider the following example with missing braces. if": "input.pdf", "a if b doX else if c doY else doZ The code above seems to say that doZ will be called when a is false . In fact, the indentation is incorrect once again. The correct indentation for the code is if a if b doX else if c doY else doZ If the code was written according to the Java style rules, it would actually look like this if a if b doX else if c doY else GoalKicker.com Java Notes for Professionals 735 doZ To illustrate why that is better, suppose that you had accidentally mis-indented the code. You might end up with something like this if a if a if b if b doX doX else if c else if c doY doY else else doZ doZ But in both cases, the mis-indented code looks wrong to the eye of an experienced Java programmer. Section 132.4 Pitfall - Octal literals Consider the following code snippet Print the sum of the numbers 1 to 10 int count 0 for int i 1 i 010 i Mistake here .... count count i System.out.printlnThe sum of 1 to 10 is count A Java beginner might be surprised to know": "input.pdf", "that the above program prints the wrong answer. It actually prints the sum of the numbers 1 to 8. The reason is that an integer literal that starts with the digit zero 0 is interpreted by the Java compiler as an octal literal, not a decimal literal as you might expect. Thus, 010 is the octal number 10, which is 8 in decimal. Section 132.5 Pitfall - Using to test a boolean Sometimes a new Java programmer will write code like this public void checkboolean ok if ok true Note ok true System.out.printlnIt is OK An experienced programmer would spot that as being clumsy and want to rewrite it as public void checkboolean ok if ok System.out.printlnIt is OK However, there is more wrong with ok true than simple clumsiness. Consider this variation public void checkboolean ok GoalKicker.com Java Notes for Professionals 736 if ok true Oooops! System.out.printlnIt is OK Here the programmer has mistyped as ... and now the code has a subtle bug. The expression x true unconditionally assigns true to x and then evaluates to true . In other words, the check method will now print It is OK no matter what the parameter was. The": "input.pdf", "lesson here is to get out of the habit of using false and true . In addition to being verbose, they make your coding more error prone. Note A possible alternative to ok true that avoids the pitfall is to use Yoda conditions i.e. put the literal on the left side of the relational operator, as in true ok. This works, but most programmers would probably agree that Yoda conditions look odd. Certainly ok or !ok is more concise and more natural. Section 132.6 Pitfall - Ignoring method visibility Even experienced Java developers tend to think that Java has only three protection modi\ufb01ers. The language actually has four! The package private a.k.a. default level of visibility is often forgotten. You should pay attention to what methods you make public. The public methods in an application are the application s visible API. This should be as small and compact as possible, especially if you are writing a reusable library see also the SOLID principle. It is important to similarly consider the visibility of all methods, and to only use protected or package private access where appropriate. When you declare methods that should be private as public, you expose the internal": "input.pdf", "implementation details of the class. A corollary to this is that you only unit test the public methods of your class - in fact you can only test public methods. It is bad practice to increase the visibility of private methods just to be able to run unit tests against those methods. Testing public methods that call the methods with more restrictive visibility should be su\ufb03cient to test an entire API. You should never expand your API with more public methods only to allow unit testing. Section 132.7 Pitfall Using assert for argument or user input validation A question that occasionally on StackOver\ufb02ow is whether it is appropriate to use assert to validate arguments supplied to a method, or even inputs provided by the user. The simple answer is that it is not appropriate. Better alternatives include Throwing an IllegalArgumentException using custom code. Using the Preconditions methods available in Google Guava library. Using the Validate methods available in Apache Commons Lang3 library. This is what the Java Language Speci\ufb01cation JLS 14.10, for Java 8 advises on this matter Typically, assertion checking is enabled during program development and testing, and disabled for deployment, to improve performance. Because assertions may be": "input.pdf", "disabled, programs must not assume that the expressions contained in GoalKicker.com Java Notes for Professionals 737assertions will be evaluated. Thus, these boolean expressions should generally be free of side e\ufb00ects. Evaluating such a boolean expression should not a\ufb00ect any state that is visible after the evaluation is complete. It is not illegal for a boolean expression contained in an assertion to have a side e\ufb00ect, but it is generally inappropriate, as it could cause program behavior to vary depending on whether assertions were enabled or disabled. In light of this, assertions should not be used for argument checking in public methods. Argument checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled. A secondary problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception such as IllegalArgumentException , ArrayIndexOutOfBoundsException , or NullPointerException . An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate. It is intended that AssertionError never be caught, but it is possible to do so, thus the rules": "input.pdf", "for try statements should treat assertions appearing in a try block similarly to the current treatment of throw statements. Section 132.8 Pitfall - Wildcard imports can make your code fragile Consider the following partial example import com.example.somelib. import com.acme.otherlib. public class Test private Context x new Context from com.example.somelib ... Suppose that when when you \ufb01rst developed the code against version 1.0 of somelib and version 1.0 of otherlib . Then at some later point, you need to upgrade your dependencies to a later versions, and you decide to use otherlib version 2.0. Also suppose that one of the changes that they made to otherlib between 1.0 and 2.0 was to add a Context class. Now when you recompile Test , you will get a compilation error telling you that Context is an ambiguous import. If you are familiar with the codebase, this probably is just a minor inconvenience. If not, then you have some work to do to address this problem, here and potentially elsewhere. The problem here is the wildcard imports. On the one hand, using wildcards can make your classes a few lines shorter. On the other hand Upwards compatible changes to other parts of your": "input.pdf", "codebase, to Java standard libraries or to 3rd party libraries can lead to compilation errors. Readability su\ufb00ers. Unless you are using an IDE, \ufb01guring out which of the wildcard imports is pulling in a named class can be di\ufb03cult. The lesson is that it is a bad idea to use wildcard imports in code that needs to be long lived. Speci\ufb01c non-wildcard imports are not much e\ufb00ort to maintain if you use an IDE, and the e\ufb00ort is worthwhile. GoalKicker.com Java Notes for Professionals 738Section 132.9 Pitfall - Misplaced semicolons and missing braces This is a mistake that causes real confusion for Java beginners, at least the \ufb01rst time that they do it. Instead of writing this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown they accidentally write this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown and are puzzled when the Java compiler tells them that the else is misplaced. The Java compiler with interpret the above as follows if feeling HAPPY empty statement System.out.printlnSmile This is unconditional else This is misplaced. A statement cannot start with else System.out.printlnFrown In other cases, there will be no be compilation errors, but the code wont do what the programmer intends. For example for int": "input.pdf", "i 0 i 5 i System.out.printlnHello only prints Hello once. Once again, the spurious semicolon means that the body of the for loop is an empty statement. That means that the println call that follows is unconditional. Another variation for int i 0 i 5 i System.out.printlnThe number is i This will give a Cannot \ufb01nd symbol error for i. The presence of the spurious semicolon means that the println call is attempting to use i outside of its scope. In those examples, there is a straight-forward solution simply delete the spurious semicolon. However, there are some deeper lessons to be drawn from these examples The semicolon in Java is not syntactic noise. The presence or absence of a semicolon can change the1. meaning of your program. Dont just add them at the end of every line. Dont trust your codes indentation. In the Java language, extra whitespace at the beginning of a line is2. ignored by the compiler. Use an automatic indenter. All IDEs and many simple text editors understand how to correctly indent Java3. GoalKicker.com Java Notes for Professionals 739code. This is the most important lesson. Follow the latest Java style guidelines, and put braces around the": "input.pdf", "then4. and else statements and the body statement of a loop. The open brace should not be on a new line. If the programmer followed the style rules then the if example with a misplaced semicolons would look like this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown That looks odd to an experienced eye. If you auto-indented that code, it would probably look like this if feeling HAPPY System.out.printlnSmile else System.out.printlnFrown which should stand out as wrong to even a beginner. Section 132.10 Pitfall - Overloading instead of overriding Consider the following example public final class Person private final String firstName private final String lastName public PersonString firstName, String lastName this.firstName firstName null ? firstName this.lastName lastName null ? lastName public boolean equalsString other if !other instanceof Person return false Person p Person other return firstName. equalsp.firstName lastName. equalsp.lastName public int hashcode return firstName. hashCode 31 lastName. hashCode This code is not going to behave as expected. The problem is that the equals and hashcode methods for Person do not override the standard methods de\ufb01ned by Object . The equals method has the wrong signature. It should be declared as equalsObject not equalsString. The hashcode method has the wrong name.": "input.pdf", "It should be hashCode note the capital C. These mistakes mean that we have declared accidental overloads, and these wont be used if Person is used in a GoalKicker.com Java Notes for Professionals 740polymorphic context. However, there is a simple way to deal with this from Java 5 onwards. Use the Override annotation whenever you intend your method to be an override Version Java SE 5 public final class Person ... Override public boolean equalsString other .... Override public hashcode .... When we add an Override annotation to a method declaration, the compiler will check that the method does override or implement a method declared in a superclass or interface. So in the example above, the compiler will give us two compilation errors, which should be enough to alert us to the mistake. Section 132.11 Pitfall of Auto-Unboxing Null Objects into Primitives public class Foobar public static void mainString args example Boolean ignore null if ignore false System.out.printlnDo not ignore! The pitfall here is that null is compared to false . Since were comparing a primitive boolean against a Boolean , Java attempts to unbox the the Boolean Object into a primitive equivalent, ready for comparison. However, since that": "input.pdf", "value is null , a NullPointerException is thrown. Java is incapable of comparing primitive types against null values, which causes a NullPointerException at runtime. Consider the primitive case of the condition false null this would generate a compile time error incomparable types int and null. GoalKicker.com Java Notes for Professionals 741Chapter 133 Java Pitfalls - Threads and Concurrency Section 133.1 Pitfall - Extending java.lang.Thread The javadoc for the Thread class shows two ways to de\ufb01ne and use a thread Using a custom thread class class PrimeThread extends Thread long minPrime PrimeThread long minPrime this.minPrime minPrime public void run compute primes larger than minPrime . . . PrimeThread p new PrimeThread 143 p.start Using a Runnable class PrimeRun implements Runnable long minPrime PrimeRun long minPrime this.minPrime minPrime public void run compute primes larger than minPrime . . . PrimeRun p new PrimeRun 143 new Threadp.start Source java.lang.Thread javadoc . The custom thread class approach works, but it has a few problems It is awkward to use PrimeThread in a context that uses a classic thread pool, an executor, or the ForkJoin 1. framework. It is not impossible, because PrimeThread indirectly implements Runnable , but using a custom Thread class as": "input.pdf", "a Runnable is certainly clumsy, and may not be viable ... depending on other aspects of the class. There is more opportunity for mistakes in other methods. For example, if you declared a2. PrimeThread. start without delegating to Thread.start, you would end up with a thread that ran on the current thread. The approach of putting the thread logic into a Runnable avoids these problems. Indeed, if you use an anonymous class Java 1.1 onwards to implement the Runnable the result is more succinct, and more readable than the GoalKicker.com Java Notes for Professionals 742examples above. final long minPrime ... new Threadnew Runnable public void run compute primes larger than minPrime . . . .start With a lambda expression Java 8 onwards, the above example would become even more elegant final long minPrime ... new Thread - compute primes larger than minPrime . . . .start Section 133.2 Pitfall - Too many threads makes an application slower A lot of people who are new to multi-threading think that using threads automatically make an application go faster. In fact, it is a lot more complicated than that. But one thing that we can state with certainty is that for any": "input.pdf", "computer there is a limit on the number of threads that can be run at the same time A computer has a \ufb01xed number of cores or hyperthreads . A Java thread has to be scheduled to a core or hyperthread in order to run. If there are more runnable Java threads than available cores hyperthreads, some of them must wait. This tells us that simply creating more and more Java threads cannot make the application go faster and faster. But there are other considerations as well Each thread requires an o\ufb00-heap memory region for its thread stack. The typical default thread stack size is 512Kbytes or 1Mbytes. If you have a signi\ufb01cant number of threads, the memory usage can be signi\ufb01cant. Each active thread will refer to a number of objects in the heap. That increases the working set of reachable objects, which impacts on garbage collection and on physical memory usage. The overheads of switching between threads is non-trivial. It typically entails a switch into the OS kernel space to make a thread scheduling decision. The overheads of thread synchronization and inter-thread signaling e.g. wait, notify notifyAll can be signi\ufb01cant. Depending on the details of your application,": "input.pdf", "these factors generally mean that there is a sweet spot for the number of threads. Beyond that, adding more threads gives minimal performance improvement, and can make performance worse. If your application create for each new task, then an unexpected increase in the workload e.g. a high request rate can lead to catastrophic behavior. A better way to deal with this is to use bounded thread pool whose size you can control statically or dynamically. When there is too much work to do, the application needs to queue the requests. If you use an ExecutorService , it will take care of the thread pool management and task queuing. GoalKicker.com Java Notes for Professionals 743Section 133.3 Pitfall incorrect use of wait notify The methods object.wait, object.notify and object.notifyAll are meant to be used in a very speci\ufb01c way. see httpstackover\ufb02ow.comdocumentationjava5409wait-notifyt20160811161648303307 The Lost Noti\ufb01cation problem One common beginner mistake is to unconditionally call object.wait private final Object lock new Object public void myConsumer synchronized lock lock. wait DONT DO THIS!! doSomething The reason this is wrong is that it depends on some other thread to call lock.notify or lock.notifyAll , but nothing guarantees that the other thread did not make that": "input.pdf", "call before the consumer thread called lock.wait. lock.notify and lock.notifyAll do not do anything at all if some other thread is not already waiting for the noti\ufb01cation. The thread that calls myConsumer in this example will hang forever if it is too late to catch the noti\ufb01cation. The Illegal Monitor State bug If you call wait or notify on an object without holding the lock, then the JVM will throw IllegalMonitorStateException . public void myConsumer lock. wait throws exception consume public void myProducer produce lock. notify throws exception The design for wait notify requires that the lock is held because this is necessary to avoid systemic race conditions. If it was possible to call wait or notify without locking, then it would be impossible to implement the primary use-case for these primitives waiting for a condition to occur. Wait notify is too low-level The best way to avoid problems with wait and notify is to not use them. Most synchronization problems can be solved by using the higher-level synchronization objects queues, barriers, semaphores, etc. that are available in the java.utils.concurrent package. Section 133.4 Pitfall Shared variables require proper synchronization Consider this example public class ThreadTest implements Runnable GoalKicker.com Java": "input.pdf", "Notes for Professionals 744 private boolean stop false public void run long counter 0 while !stop counter counter 1 System.out.printlnCounted counter public static void mainString args ThreadTest tt new ThreadTest new Threadtt.start Create and start child thread Thread.sleep1000 tt. stop true Tell child thread to stop. The intent of this program is intended to start a thread, let it run for 1000 milliseconds, and then cause it to stop by setting the stop \ufb02ag. Will it work as intended? Maybe yes, may be no. An application does not necessarily stop when the main method returns. If another thread has been created, and that thread has not been marked as a daemon thread, then the application will continue to run after the main thread has ended. In this example, that means that the application will keep running until child thread ends. That should happens when tt.stop is set to true . But that is actually not strictly true. In fact, the child thread will stop after it has observed stop with the value true . Will that happen? Maybe yes, maybe no. The Java Language Speci\ufb01cation guarantees that memory reads and writes made in a thread are visible to that": "input.pdf", "thread, as per the order of the statements in the source code. However, in general, this is NOT guaranteed when one thread writes and another thread subsequently reads. To get guaranteed visibility, there needs to be a chain of happens-before relations between a write and a subsequent read. In the example above, there is no such chain for the update to the stop \ufb02ag, and therefore it is not guaranteed that the child thread will see stop change to true . Note to authors There should be a separate Topic on the Java Memory Model to go into the deep technical details. How do we \ufb01x the problem? In this case, there are two simple ways to ensure that the stop update is visible Declare stop to be volatile i.e. 1. private volatile boolean stop false For a volatile variable, the JLS speci\ufb01es that there is a happens-before relation between a write by one thread and a later read by a second thread. Use a mutex to synchronize as follows2. public class ThreadTest implements Runnable GoalKicker.com Java Notes for Professionals 745 private boolean stop false public void run long counter 0 while true synchronize this if stop break counter": "input.pdf", "counter 1 System.out.printlnCounted counter public static void mainString args ThreadTest tt new ThreadTest new Threadtt.start Create and start child thread Thread.sleep1000 synchronize tt tt. stop true Tell child thread to stop. In addition to ensuring that there is mutual exclusion, the JLS speci\ufb01es that there is a happens-before relation between the releasing a mutex in one thread and gaining the same mutex in a second thread. But isnt assignment atomic? Yes it is! However, that fact does not mean that the e\ufb00ects of update will be visible simultaneously to all threads. Only a proper chain of happens-before relations will guarantee that. Why did they do this? Programmers doing multi-threaded programming in Java for the \ufb01rst time \ufb01nd the Memory Model is challenging. Programs behave in an unintuitive way because the natural expectation is that writes are visible uniformly. So why the Java designers design the Memory Model this way. It actually comes down to a compromise between performance and ease of use for the programmer. A modern computer architecture consists of multiple processors cores with individual register sets. Main memory is accessible either to all processors or to groups of processors. Another property of modern computer hardware is that": "input.pdf", "access to registers is typically orders of magnitude faster to access than access to main memory. As the number of cores scales up, it is easy to see that reading and writing to main memory can become a systems main performance bottleneck. This mismatch is addressed by implementing one or more levels of memory caching between the processor cores and main memory. Each core access memory cells via its cache. Normally, a main memory read only happens when there is a cache miss, and a main memory write only happens when a cache line needs to be \ufb02ushed. For an application where each cores working set of memory locations will \ufb01t into its cache, the core speed is no longer limited by main memory speed bandwidth. But that gives us a new problem when multiple cores are reading and writing shared variables. The latest version of a variable may sit in one cores cache. Unless the that core \ufb02ushes the cache line to main memory, AND other cores GoalKicker.com Java Notes for Professionals 746invalidate their cached copy of older versions, some of them are liable to see stale versions of the variable. But if the caches were \ufb02ushed to": "input.pdf", "memory each time there is a cache write just in case there was a read by another core that would consume main memory bandwidth unnecessarily. The standard solution used at the hardware instruction set level is to provide instructions for cache invalidation and a cache write-through, and leave it to the compiler to decide when to use them. Returning to Java. the Memory Model is designed so that the Java compilers are not required to issue cache invalidation and write-through instructions where they are not really needed. The assumption is that the programmer will use an appropriate synchronization mechanism e.g. primitive mutexes, volatile , higher-level concurrency classes and so on to indicate that it needs memory visibility. In the absence of a happens-before relation, the Java compilers are free to assume that no cache operations or similar are required. This has signi\ufb01cant performance advantages for multi-threaded applications, but the downside is that writing correct multi-threaded applications is not a simple matter. The programmer does have to understand what he or she is doing. Why cant I reproduce this? There are a number of reasons why problems like this are di\ufb03cult to reproduce As explained above, the consequence of not": "input.pdf", "dealing with memory visibility issues problems properly is1. typically that your compiled application does not handle the memory caches correctly. However, as we alluded to above, memory caches often get \ufb02ushed anyway. When you change the hardware platform, the characteristics of the memory caches may change. This can2. lead to di\ufb00erent behavior if your application does not synchronize correctly. You may be observing the e\ufb00ects of serendipitous synchronization. For example, if you add traceprints, their 3. is typically some synchronization happening behind the scenes in the IO streams that causes cache \ufb02ushes. So adding traceprints often causes the application to behave di\ufb00erently. Running an application under a debugger causes it to be compiled di\ufb00erently by the JIT compiler.4. Breakpoints and single stepping exacerbate this. These e\ufb00ects will often change the way an application behaves. These things make bugs that are due to inadequate synchronization particularly di\ufb03cult to solve. Section 133.5 Pitfall - Thread creation is relatively expensive Consider these two micro-benchmarks The \ufb01rst benchmark simply creates, starts and joins threads. The threads Runnable does no work. public class ThreadTest public static void mainString args throws Exception while true long start System.nanoTime for int i 0 i 100000 i Thread": "input.pdf", "t new Threadnew Runnable public void run t. start t. join long end System.nanoTime GoalKicker.com Java Notes for Professionals 747 System.out.printlnend - start 100000.0 java ThreadTest 34627.91355 33596.66021 33661.19084 33699.44895 33603.097 33759.3928 33671.5719 33619.46809 33679.92508 33500.32862 33409.70188 33475.70541 33925.87848 33672.89529 C On a typical modern PC running Linux with 64bit Java 8 u101, this benchmark shows an average time taken to create, start and join thread of between 33.6 and 33.9 microseconds. The second benchmark does the equivalent to the \ufb01rst but using an ExecutorService to submit tasks and a Future to rendezvous with the end of the task. import java.util.concurrent. public class ExecutorTest public static void mainString args throws Exception ExecutorService exec Executors. newCachedThreadPool while true long start System.nanoTime for int i 0 i 100000 i Future ? future exec.submitnew Runnable public void run future. get long end System.nanoTime System.out.printlnend - start 100000.0 java ExecutorTest 6714.66053 5418.24901 5571.65213 5307.83651 5294.44132 5370.69978 5291.83493 5386.23932 5384.06842 5293.14126 5445.17405 5389.70685 GoalKicker.com Java Notes for Professionals 748C As you can see, the averages are between 5.3 and 5.6 microseconds. While the actual times will depend on a variety of factors, the di\ufb00erence between these two results is signi\ufb01cant. It is clearly faster": "input.pdf", "to use a thread pool to recycle threads than it is to create new threads. GoalKicker.com Java Notes for Professionals 749Chapter 134 Java Pitfalls - Nulls and NullPointerException Section 134.1 Pitfall - Making good unexpected nulls On StackOver\ufb02ow, we often see code like this in Answers public String joinStrings String a, String b if a null a if b null b return a b Often, this is accompanied with an assertion that is best practice to test for null like this to avoid NullPointerException . Is it best practice? In short No. There are some underlying assumptions that need to be questioned before we can say if it is a good idea to do this in our joinStrings What does it mean for a or b to be null? A String value can be zero or more characters, so we already have a way of representing an empty string. Does null mean something di\ufb00erent to ? If no, then it is problematic to have two ways to represent an empty string. Did the null come from an uninitialized variable? A null can come from an uninitialized \ufb01eld, or an uninitialized array element. The value could be uninitialized by design,": "input.pdf", "or by accident. If it was by accident then this is a bug. Does the null represent a dont know or missing value? Sometimes a null can have a genuine meaning e.g. that the real value of a variable is unknown or unavailable or optional. In Java 8, the Optional class provides a better way of expressing that. If this is a bug or a design error should we make good? One interpretation of the code is that we are making good an unexpected null by using an empty string in its place. Is the correct strategy? Would it be better to let the NullPointerException happen, and then catch the exception further up the stack and log it as a bug? The problem with making good is that it is liable to either hide the problem, or make it harder to diagnose. Is this e\ufb03cient good for code quality? If the make good approach is used consistently, your code is going to contain a lot of defensive null tests. This is going to make it longer and harder to read. Furthermore, all of this testing and making good is liable to impact on the performance of your application. In": "input.pdf", "summary GoalKicker.com Java Notes for Professionals 750If null is a meaningful value, then testing for the null case is the correct approach. The corollary is that if a null value is meaningful, then this should be clearly documented in the javadocs of any methods that accept the null value or return it. Otherwise, it is a better idea to treat an unexpected null as a programming error, and let the NullPointerException happen so that the developer gets to know there is a problem in the code. Section 134.2 Pitfall - Using null to represent an empty array or collection Some programmers think that it is a good idea to save space by using a null to represent an empty array or collection. While it is true that you can save a small amount of space, the \ufb02ipside is that it makes your code more complicated, and more fragile. Compare these two versions of a method for summing an array The \ufb01rst version is how you would normally code the method Sum the values in an array of integers. arg values the array to be summed return the sum public int sumint values int sum 0 for int value values": "input.pdf", "sum value return sum The second version is how you need to code the method if you are in the habit of using null to represent an empty array. Sum the values in an array of integers. arg values the array to be summed, or null. return the sum, or zero if the array is null. public int sumint values int sum 0 if values ! null for int value values sum value return sum As you can see, the code is a bit more complicated. This is directly attributable to the decision to use null in this way. Now consider if this array that might be a null is used in lots of places. At each place where you use it, you need to consider whether you need to test for null . If you miss a null test that needs to be there, you risk a NullPointerException . Hence, the strategy of using null in this way leads to your application being more fragile i.e. more vulnerable to the consequences of programmer errors. The lesson here is to use empty arrays and empty lists when that is what you mean. GoalKicker.com Java Notes for Professionals 751int values": "input.pdf", "new int0 always empty ListInteger list new ArrayList initially empty ListInteger list Collections .emptyList always empty The space overhead is small, and there are other ways to minimize it if this this is a worthwhile thing to do. Section 134.3 Pitfall - Not checking if an IO stream isnt even initialized when closing it To prevent memory leaks, one should not forget to close an input stream or an output stream whose job is done. This is usually done with a try-catch -finally statement without the catch part void writeNullBytesToAFile int count, String filename throws IOException FileOutputStream out null try out new FileOutputStream filename for count 0 count-- out. write0 finally out. close While the above code might look innocent, it has a \ufb02aw that can make debugging impossible. If the line where out is initialized out new FileOutputStream filename throws an exception, then out will be null when out.close is executed, resulting in a nasty NullPointerException ! To prevent this, simply make sure the stream isnt null before trying to close it. void writeNullBytesToAFile int count, String filename throws IOException FileOutputStream out null try out new FileOutputStream filename for count 0 count-- out. write0 finally if out !": "input.pdf", "null out. close An even better approach is to try-with-resources, since itll automatically close the stream with a probability of 0 to throw an NPE without the need of a finally block. void writeNullBytesToAFile int count, String filename throws IOException try FileOutputStream out new FileOutputStream filename for count 0 count-- out. write0 Section 134.4 Pitfall - Returning null instead of throwing an exception Some Java programmers have a general aversion to throwing or propagating exceptions. This leads to code like the following GoalKicker.com Java Notes for Professionals 752public Reader getReader String pathname try return new BufferedReader FileReader pathname catch IOException ex System.out.printlnOpen failed ex.getMessage return null So what is the problem with that? The problem is that the getReader is returning a null as a special value to indicate that the Reader could not be opened. Now the returned value needs to be tested to see if it is null before it is used. If the test is left out, the result will be a NullPointerException . There are actually three problems here The IOException was caught too soon. 1. The structure of this code means that there is a risk of leaking a resource.2. A null was used": "input.pdf", "then returned because no real Reader was available to return. 3. In fact, assuming that the exception did need to be caught early like this, there were a couple of alternatives to returning null It would be possible to implement a NullReader class e.g. one where APIs operations behaves as if the 1. reader was already at the end of \ufb01le position. With Java 8, it would be possible to declare getReader as returning an Optional Reader. 2. Section 134.5 Pitfall - Unnecessary use of Primitive Wrappers can lead to NullPointerExceptions Sometimes, programmers who are new Java will use primitive types and wrappers interchangeably. This can lead to problems. Consider this example public class MyRecord public int a, b public Integer c, d ... MyRecord record new MyRecord record.a 1 OK record.b record. b 1 OK record.c 1 OK record.d record. d 1 throws a NullPointerException Our MyRecord class1 relies on default initialization to initialize the values on its \ufb01elds. Thus, when we new a record, the a and b \ufb01elds will be set to zero, and the c and d \ufb01elds will be set to null . When we try to use the default initialized \ufb01elds, we see": "input.pdf", "that the int \ufb01elds works all of the time, but the Integer \ufb01elds work in some cases and not others. Speci\ufb01cally, in the case that fails with d, what happens is that the expression on the right-hand side attempts to unbox a null reference, and that is what causes the NullPointerException to be thrown. There are a couple of ways to look at this GoalKicker.com Java Notes for Professionals 753If the \ufb01elds c and d need to be primitive wrappers, then either we should not be relying on default initialization, or we should be testing for null . For former is the correct approach unless there is a de\ufb01nite meaning for the \ufb01elds in the null state. If the \ufb01elds dont need to be primitive wrappers, then it is a mistake to make them primitive wrappers. In addition to this problem, the primitive wrappers have extra overheads relative to primitive types. The lesson here is to not use primitive wrapper types unless you really need to. 1 - This class is not an example of good coding practice. For instance, a well-designed class would not have public \ufb01elds. However, that is not the point of this example. Section 134.6": "input.pdf", "Pitfall - Using Yoda notation to avoid NullPointerException A lot of example code posted on StackOver\ufb02ow includes snippets like this if A.equalssomeString do something This does prevent or avoid a possible NullPointerException in the case that someString is null . Furthermore, it is arguable that A.equalssomeString is better than someString ! null someString. equalsA It is more concise, and in some circumstances it might be more e\ufb03cient. However, as we argue below, conciseness could be a negative. However, the real pitfall is using the Yoda test to avoid NullPointerExceptions as a matter of habit. When you write A.equalssomeString you are actually making good the case where someString happens to be null . But as another example Pitfall - Making good unexpected nulls explains, making good null values can be harmful for a variety of reasons. This means that Yoda conditions are not best practice1. Unless the null is expected, it is better to let the NullPointerException happen so that you can get a unit test failure or a bug report. That allows you to \ufb01nd and \ufb01x the bug that caused the unexpected unwanted null to appear. Yoda conditions should only be used in cases where the null is": "input.pdf", "expected because the object you are testing has come from an API that is documented as returning a null . And arguably, it could be better to use one of the less pretty ways expressing the test because that helps to highlight the null test to someone who is reviewing your code. 1 - According to Wikipedia Best coding practices are a set of informal rules that the software development community has learned over time which can help improve the quality of software. . Using Yoda notation does not achieve this. In a lot of situations, it makes the code worse. GoalKicker.com Java Notes for Professionals 754Chapter 135 Java Pitfalls - Performance Issues This topic describes a number of pitfalls i.e. mistakes that novice java programmers make that relate to Java application performance. Section 135.1 Pitfall - String concatenation in a loop does not scale Consider the following code as an illustration public String joinWords ListString words String message for String word words message message word return message Unfortunate this code is ine\ufb03cient if the words list is long. The root of the problem is this statement message message word For each loop iteration, this statement creates a new": "input.pdf", "message string containing a copy of all characters in the original message string with extra characters appended to it. This generates a lot of temporary strings, and does a lot of copying. When we analyse joinWords , assuming that there are N words with an average length of M, we \ufb01nd that ON temporary strings are created and OM.N2 characters will be copied in the process. The N2 component is particularly troubling. The recommended approach for this kind of problem1 is to use a StringBuilder instead of string concatenation as follows public String joinWords2 ListString words StringBuilder message new StringBuilder for String word words message. append .appendword return message. toString The analysis of joinWords2 needs to take account of the overheads of growing the StringBuilder backing array that holds the builders characters. However, it turns out that the number of new objects created is OlogN and that the number of characters copied is OM.N characters. The latter includes characters copied in the \ufb01nal toString call. It may be possible to tune this further, by creating the StringBuilder with the correct capacity to start with. However, the overall complexity remains the same. Returning to the original joinWords method, it turns": "input.pdf", "out that the critical statement will be optimized by a typical Java compiler to something like this StringBuilder tmp new StringBuilder GoalKicker.com Java Notes for Professionals 755 tmp.appendmessage.append .appendword message tmp.toString However, the Java compiler will not hoist the StringBuilder out of the loop, as we did by hand in the code for joinWords2 . Reference Is Javas String operator in a loop slow? 1 - In Java 8 and later, the Joiner class can be used to solve this particular problem. However, that is not what this example is really supposed to be about . Section 135.2 Pitfall - Using size to test if a collection is empty is inecient The Java Collections Framework provides two related methods for all Collection objects size returns the number of entries in a Collection , and isEmpty method returns true if and only if the Collection is empty. Both methods can be used to test for collection emptiness. For example Collection String strings new ArrayList boolean isEmptywrong strings. size 0 Avoid this boolean isEmpty strings. isEmpty Best While these approaches look the same, some collection implementations do not store the size. For such a collection, the implementation of size needs to": "input.pdf", "calculate the size each time it is called. For instance A simple linked list class but not the java.util.LinkedList might need to traverse the list to count the elements. The ConcurrentHashMap class needs to sum the entries in all of the maps segments. A lazy implementation of a collection might need to realize the entire collection in memory in order to count the elements. By contrast, an isEmpty method only needs to test if there is at least one element in the collection. This does not entail counting the elements. While size 0 is not always less e\ufb03cient that isEmpty, it is inconceivable for a properly implemented isEmpty to be less e\ufb03cient than size 0. Hence isEmpty is preferred. Section 135.3 Pitfall - Interning strings so that you can use is a bad idea When some programmers see this advice Testing strings using is incorrect unless the strings are interned their initial reaction is to intern strings so that they can use . After all is faster than calling String.equals..., isnt it. This is the wrong approach, from a number of perspectives GoalKicker.com Java Notes for Professionals 756Fragility First of all, you can only safely use if you know": "input.pdf", "that all of the String objects you are testing have been interned. The JLS guarantees that String literals in your source code will have been interned. However, none of the standard Java SE APIs guarantee to return interned strings, apart from String.internString itself. If you miss just one source of String objects that havent been interned, your application will be unreliable. That unreliability will manifest itself as false negatives rather than exceptions which is liable to make it harder to detect. Costs of using intern Under the hood, interning works by maintaining a hash table that contains previously interned String objects. Some kind of weak reference mechanism is used so that the interning hash table does not become a storage leak. While the hash table is implemented in native code unlike HashMap , HashTable and so on, the intern calls are still relatively costly in terms of CPU and memory used. This cost has to be compared with the saving of we are going to get by using instead of equals . In fact, we are not going to break even unless each interned string is compared with other strings a few times. Aside the few situations where interning": "input.pdf", "is worthwhile tend to be about reducing the memory foot print of an application where the same strings recur many times, and those strings have a long lifetime. The impact on garbage collection In addition to the direct CPU and memory costs described above, interned Strings impact on the garbage collector performance. For versions of Java prior to Java 7, interned strings are held in the PermGen space which is collected infrequently. If PermGen needs to be collected, this typically triggers a full garbage collection. If the PermGen space \ufb01lls completely, the JVM crashes, even if there was free space in the regular heap spaces. In Java 7, the string pool was moved out of PermGen into the normal heap. However, the hash table is still going to be a long-lived data structure, which is going to cause any interned strings to be long-lived. Even if the interned string objects were allocated in Eden space they would most likely be promoted before they were collected. Thus in all cases, interning a string is going to prolong its lifetime relative to an ordinary string. That will increase the garbage collection overheads over the lifetime of the JVM. The second issue": "input.pdf", "is that the hash table needs to use a weak reference mechanism of some kind to prevent string interning leaking memory. But such a mechanism is more work for the garbage collector. These garbage collection overheads are di\ufb03cult to quantify, but there is little doubt that they do exist. If you use intern extensively, they could be signi\ufb01cant. The string pool hashtable size According to this source , from Java 6 onwards, the string pool is implemented as \ufb01xed sized hash table with chains to deal with strings that hash to the same bucket. In early releases of Java 6, the hash table had a hard-wired constant size. A tuning parameter -XXStringTableSize was added as a mid-life update to Java 6. Then in a mid- life update to Java 7, the default size of the pool was changed from 1009 to 60013 . The bottom line is that if you do intend to use intern intensively in your code, it is advisable to pick a version of Java where the hashtable size is tunable and make sure that you tune the size it appropriately. Otherwise, the performance of intern is liable to degrade as the pool gets larger. Interning": "input.pdf", "as a potential denial of service vector GoalKicker.com Java Notes for Professionals 757The hashcode algorithm for strings is well-known. If you intern strings supplied by malicious users or applications, this could be used as part of a denial of service DoS attack. If the malicious agent arranges that all of the strings it provides have the same hash code, this could lead to an unbalanced hash table and ON performance for intern ... where N is the number of collided strings. There are simpler more e\ufb00ective ways to launch a DoS attack against a service. However, this vector could be used if the goal of the DoS attack is to break security, or to evade \ufb01rst-line DoS defences. Section 135.4 Pitfall - Using new to create primitive wrapper instances is inecient The Java language allows you to use new to create instances Integer , Boolean and so on, but it is generally a bad idea. It is better to either use autoboxing Java 5 and later or the valueOf method. Integer i1 new Integer1 BAD Integer i2 2 BEST autoboxing Integer i3 Integer.valueOf3 OK The reason that using new Integerint explicitly is a bad idea is that it creates": "input.pdf", "a new object unless optimized out by JIT compiler. By contrast, when autoboxing or an explicit valueOf call are used, the Java runtime will try to reuse an Integer object from a cache of pre-existing objects. Each time the runtime has a cache hit, it avoids creating an object. This also saves heap memory and reduces GC overheads caused by object churn. Notes In recent Java implementations, autoboxing is implemented by calling valueOf , and there are caches for 1. Boolean , Byte , Short , Integer , Long and Character . The caching behavior for the integral types is mandated by the Java Language Speci\ufb01cation.2. Section 135.5 Pitfall - Eciency concerns with regular expressions Regular expression matching is a powerful tool in Java, and in other contexts but it does have some drawbacks. One of these that regular expressions tends to be rather expensive. Pattern and Matcher instances should be reused Consider the following example Test if all strings in a list consist of English letters and numbers. param strings the list to be checked return true if an only if all strings satisfy the criteria throws NullPointerException if strings is null or a null element. public boolean": "input.pdf", "allAlphanumeric ListString strings for String s strings if !s.matchesA-Za-z0-9 return false return true This code is correct, but it is ine\ufb03cient. The problem is in the matches... call. Under the hood, s.matchesA- GoalKicker.com Java Notes for Professionals 758Za-z0-9 is equivalent to this Pattern. matchess, A-Za-z0-9 which is in turn equivalent to Pattern. compileA-Za-z0-9 .matchers.matches The Pattern. compileA-Za-z0-9 call parses the regular expression, analyze it, and construct a Pattern object that holds the data structure that will be used by the regex engine. This is a non-trivial computation. Then a Matcher object is created to wrap the s argument. Finally we call match to do the actual pattern matching. The problem is that this work is all repeated for each loop iteration. The solution is to restructure the code as follows private static Pattern ALPHANUMERIC Pattern. compileA-Za-z0-9 public boolean allAlphanumeric ListString strings Matcher matcher ALPHANUMERIC. matcher for String s strings matcher. resets if !matcher. matches return false return true Note that the javadoc for Pattern states Instances of this class are immutable and are safe for use by multiple concurrent threads. Instances of the Matcher class are not safe for such use. Dont use match when you should use \ufb01nd": "input.pdf", "Suppose you want to test if a string s contains three or more digits in a row. You cn express this in various ways including if s.matches.0-93. System.out.printlnmatches or if Pattern. compile0-93 .matchers.find System.out.printlnmatches The \ufb01rst one is more concise, but it is also likely to be less e\ufb03cient. On the face of it, the \ufb01rst version is going to try to match the entire string against the pattern. Furthermore, since . is a greedy pattern, the pattern matcher is likely to advance eagerly try to the end of the string, and backtrack until it \ufb01nds a match. By contrast, the second version will search from left to right and will stop searching as soon as it \ufb01nds the 3 digits in a row. GoalKicker.com Java Notes for Professionals 759Use more e\ufb03cient alternatives to regular expressions Regular expressions are a powerful tool, but they should not be your only tool. A lot of tasks can be done more e\ufb03ciently in other ways. For example Pattern. compileABC.matchers.find does the same thing as s.contains ABC except that the latter is a lot more e\ufb03cient. Even if you can amortize the cost of compiling the regular expression. Often, the non-regex form is": "input.pdf", "more complicated. For example, the test performed by the matches call the earlier allAlplanumeric method can be rewritten as public boolean matches String s for char c s if c A c Z c a c z c 0 c 9 return false return true Now that is more code than using a Matcher , but it is also going to be signi\ufb01cantly faster. Catastrophic Backtracking This is potentially a problem with all implementations of regular expressions, but we will mention it here because it is a pitfall for Pattern usage. Consider this contrived example Pattern pat Pattern. compileAB System.out.printlnpat.matcherAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB .matches System.out.printlnpat.matcherAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC .matches The \ufb01rst println call will quickly print true . The second one will print false . Eventually. Indeed, if you experiment with the code above, you will see that each time you add an A before the C, the time take will double. This is behavior is an example of catastrophic backtracking . The pattern matching engine that implements the regex matching is fruitlessly trying all of the possible ways that the pattern might match. Let us look at what AB actually means. Super\ufb01cially, it seems to say one or more A characters followed by a": "input.pdf", "B value, but in reality it says one or more groups, each of which consists of one or more A characters. So, for example AB matches one way only AB AAB matches two ways AAB or AAB AAAB matches four ways AAAB or AAAB or AAAB or AAAB and so on In other words, the number of possible matches is 2N where N is the number of A characters. GoalKicker.com Java Notes for Professionals 760The above example is clearly contrived, but patterns that exhibit this kind of performance characteristics i.e. O2N or ONK for a large K arise frequently when ill-considered regular expressions are used. There are some standard remedies Avoid nesting repeating patterns within other repeating patterns. Avoid using too many repeating patterns. Use non-backtracking repetition as appropriate. Dont use regexes for complicated parsing tasks. Write a proper parser instead. Finally, beware of situations where a user or an API client can supply a regex string with pathological characteristics. That can lead to accidental or deliberate denial of service. References The Regular Expressions tag, particularly httpstackover\ufb02ow.comdocumentationregex977backtrackingt201610010339131361163 and httpstackover\ufb02ow.comdocumentationregex4527when-you-should-not-use-regular-expressionst2016 10010339593564913 Regex Performance by Je\ufb00 Atwood. How to kill Java with a Regular Expression by Andreas Hau\ufb02er. Section 135.6 Pitfall": "input.pdf", "- Small reads writes on unbuered streams are inecient Consider the following code to copy one \ufb01le to another import java.io. public class FileCopy public static void mainString args throws Exception try InputStream is new FileInputStream args0 OutputStream os new FileOutputStream args1 int octet while octet is.read ! -1 os. writeoctet We have deliberated omitted normal argument checking, error reporting and so on because they are not relevant to point of this example. If you compile the above code and use it to copy a huge \ufb01le, you will notice that it is very slow. In fact, it will be at least a couple of orders of magnitude slower than the standard OS \ufb01le copy utilities. Add actual performance measurements here! The primary reason that the example above is slow in the large \ufb01le case is that it is performing one-byte reads and one-byte writes on unbu\ufb00ered byte streams. The simple way to improve performance is to wrap the streams with bu\ufb00ered streams. For example import java.io. public class FileCopy GoalKicker.com Java Notes for Professionals 761 public static void mainString args throws Exception try InputStream is new BufferedInputStream new FileInputStream args0 OutputStream os new BufferedOutputStream new FileOutputStream args1 int": "input.pdf", "octet while octet is.read ! -1 os. writeoctet These small changes will improve data copy rate by at least a couple of orders of magnitude, depending on various platform-related factors. The bu\ufb00ered stream wrappers cause the data to be read and written in larger chunks. The instances both have bu\ufb00ers implemented as byte arrays. With is, data is read from the \ufb01le into the bu\ufb00er a few kilobytes at a time. When read is called, the implementation will typically return a byte from the bu\ufb00er. It will only read from the underlying input stream if the bu\ufb00er has been emptied. The behavior for os is analogous. Calls to os.writeint write single bytes into the bu\ufb00er. Data is only written to the output stream when the bu\ufb00er is full, or when os is \ufb02ushed or closed. What about character-based streams? As you should be aware, Java IO provides di\ufb00erent APIs for reading and writing binary and text data. InputStream and OutputStream are the base APIs for stream-based binary IO Reader and Writer are the base APIs for stream-based text IO. For text IO, BufferedReader and BufferedWriter are the equivalents for BufferedInputStream and BufferedOutputStream . Why do bu\ufb00ered streams make this": "input.pdf", "much di\ufb00erence? The real reason that bu\ufb00ered streams help performance is to do with the way that an application talks to the operating system Java method in a Java application, or native procedure calls in the JVMs native runtime libraries are fast. They typically take a couple of machine instructions and have minimal performance impact. By contrast, JVM runtime calls to the operating system are not fast. They involve something known as a syscall. The typical pattern for a syscall is as follows Put the syscall arguments into registers.1. Execute a SYSENTER trap instruction.2. The trap handler switched to privileged state and changes the virtual memory mappings. Then it3. dispatches to the code to handle the speci\ufb01c syscall. The syscall handler checks the arguments, taking care that it isnt being told to access memory that the4. user process should not see. The syscall speci\ufb01c work is performed. In the case of a read syscall, this may involve 5. checking that there is data to be read at the \ufb01le descriptors current position1. calling the \ufb01le system handler to fetch the required data from disk or wherever it is stored into2. the bu\ufb00er cache, copying data from the bu\ufb00er cache": "input.pdf", "to the JVM-supplied address3. GoalKicker.com Java Notes for Professionals 762adjusting thstream pointerse \ufb01le descriptor position4. Return from the syscall. This entails changing VM mappings again and switching out of privileged state.6. As you can imagine, performing a single syscall can thousands of machine instructions. Conservatively, at least two orders of magnitude longer than a regular method call. Probably three or more. Given this, the reason that bu\ufb00ered streams make a big di\ufb00erence is that they drastically reduce the number of syscalls. Instead of doing a syscall for each read call, the bu\ufb00ered input stream reads a large amount of data into a bu\ufb00er as required. Most read calls on the bu\ufb00ered stream do some simple bounds checking and return a byte that was read previously. Similar reasoning applies in the output stream case, and also the character stream cases. Some people think that bu\ufb00ered IO performance comes from the mismatch between the read request size and the size of a disk block, disk rotational latency and things like that. In fact, a modern OS uses a number of strategies to ensure that the application typically doesnt need to wait for the disk. This is not the real explanation. Are": "input.pdf", "bu\ufb00ered streams always a win? Not always. Bu\ufb00ered streams are de\ufb01nitely a win if your application is going to do lots of small reads or writes. However, if your application only needs to perform large reads or writes to from a large byte or char, then bu\ufb00ered streams will give you no real bene\ufb01ts. Indeed there might even be a tiny performance penalty. Is this the fastest way to copy a \ufb01le in Java? No it isnt. When you use Javas stream-based APIs to copy a \ufb01le, you incur the cost of at least one extra memory-to- memory copy of the data. It is possible to avoid this if your use the NIO ByteBuffer and Channel APIs. Add a link to a separate example here. Section 135.7 Pitfall - Over-use of primitive wrapper types is inecient Consider these two pieces of code int a 1000 int b a 1 and Integer a 1000 Integer b a 1 Question Which version is more e\ufb03cient? Answer The two versions look almost the identical, but the \ufb01rst version is a lot more e\ufb03cient than the second one. The second version is using a representation for the numbers that uses more space, and": "input.pdf", "is relying on auto-boxing and auto-unboxing behind the scenes. In fact the second version is directly equivalent to the following code Integer a Integer.valueOf1000 box 1000 Integer b Integer.valueOfa.intValue 1 unbox 1000, add 1, box 1001 Comparing this to the other version that uses int, there are clearly three extra method calls when Integer is used. In the case of valueOf , the calls are each going to create and initialize a new Integer object. All of this extra boxing and unboxing work is likely to make the second version an order of magnitude slower than the \ufb01rst one. GoalKicker.com Java Notes for Professionals 763In addition to that, the second version is allocating objects on the heap in each valueOf call. While the space utilization is platform speci\ufb01c, it is likely to be in the region of 16 bytes for each Integer object. By contrast, the int version needs zero extra heap space, assuming that a and b are local variables. Another big reason why primitives are faster then their boxed equivalent is how their respective array types are laid out in memory. If you take int and Integer as an example, in the case of an int the": "input.pdf", "int values are contiguously laid out in memory. But in the case of an Integer its not the values that are laid out, but references pointers to Integer objects, which in turn contain the actual int values. Besides being an extra level of indirection, this can be a big tank when it comes to cache locality when iterating over the values. In the case of an int the CPU could fetch all the values in the array, into its cache at once, because they are contiguous in memory. But in the case of an Integer the CPU potentially has to do an additional memory fetch for each element, since the array only contains references to the actual values. In short, using primitive wrapper types is relatively expensive in both CPU and memory resources. Using them unnecessarily is in e\ufb03cient. Section 135.8 Pitfall - The overheads of creating log messages TRACE and DEBUG log levels are there to be able to convey high detail about the operation of the given code at runtime. Setting the log level above these is usually recommended, however some care must be taken for these statements to not a\ufb00ect performance even when seemingly turned o\ufb00.": "input.pdf", "Consider this log statement Processing a request of some kind, logging the parameters LOG.debugRequest coming from myInetAddress. toString parameters Arrays.toString veryLongParamArray Even when the log level is set to INFO , arguments passed to debug will be evaluated on each execution of the line. This makes it unnecessarily consuming on several counts String concatenation multiple String instances will be created InetAddress might even do a DNS lookup. the veryLongParamArray might be very long - creating a String out of it consumes memory, takes time Solution Most logging framework provide means to create log messages using \ufb01x strings and object references. The log message will be evaluated only if the message is actually logged. Example No toString evaluation, no string concatenation if debug is disabled LOG.debugRequest coming from parameters , myInetAddress, parameters This works very well as long as all parameters can be converted to strings using String.valueOfObject . If the log message compuation is more complex, the log level can be checked before logging if LOG.isDebugEnabled Argument expression evaluated only when DEBUG is enabled LOG. debugRequest coming from , parameters , myInetAddress, Arrays.toString veryLongParamArray GoalKicker.com Java Notes for Professionals 764 Here, LOG.debug with the costly Arrays.toString Obect computation is": "input.pdf", "processed only when DEBUG is actually enabled. Section 135.9 Pitfall - Iterating a Maps keys can be inecient The following example code is slower than it needs to be MapString, String map new HashMap for String key map.keySet String value map.getkey Do something with key and value That is because it requires a map lookup the get method for each key in the map. This lookup may not be e\ufb03cient in a HashMap, it entails calling hashCode on the key, then looking up the correct bucket in internal data structures, and sometimes even calling equals . On a large map, this may not be a trivial overhead. The correct way of avoiding this is to iterate on the maps entries, which is detailed in the Collections topic Section 135.10 Pitfall - Calling System.gc is inecient It is almost always a bad idea to call System.gc. The javadoc for the gc method speci\ufb01es the following Calling the gc method suggests that the Java Virtual Machine expend e\ufb00ort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the Java Virtual Machine has made a best e\ufb00ort": "input.pdf", "to reclaim space from all discarded objects. There are a couple of important points that can be drawn from this The use of the word suggests rather than say tells means that the JVM is free to ignore the suggestion.1. The default JVM behavior recent releases is to follow the suggestion, but this can be overridden by setting - XXDisableExplicitGC when when launching the JVM. The phrase a best e\ufb00ort to reclaim space from all discarded objects implies that calling gc will trigger a 2. full garbage collection. So why is calling System.gc a bad idea? First, running a full garbage collection is expensive. A full GC involves visiting and marking every object that is still reachable i.e. every object that is not garbage. If you trigger this when there isnt much garbage to be collected, then the GC does a lot of work for relatively little bene\ufb01t. Second, a full garbage collection is liable to disturb the locality properties of the objects that are not collected. Objects that are allocated by the same thread at roughly the same time tend to be allocated close together in memory. This is good. Objects that are allocated at the same time": "input.pdf", "are likely to be related i.e. reference each other. If your application uses those references, then the chances are that memory access will be faster because of various memory and page caching e\ufb00ects. Unfortunately, a full garbage collection tend to move objects around so that objects that were once close are now further apart. GoalKicker.com Java Notes for Professionals 765Third, running a full garbage collection is liable to make your application pause until the collection is complete. While this is happening, your application will be non-responsive. In fact, the best strategy is to let the JVM decide when to run the GC, and what kind of collection to run. If you dont interfere, the JVM will choose a time and collection type that optimizes throughput or minimizes GC pause times. At the beginning we said ... almost always a bad idea .... In fact there are a couple of scenarios where it might be a good idea If you are implementing a unit test for some code that is garbage collection sensitive e.g. something1. involving \ufb01nalizers or weak soft phantom references then calling System.gc may be necessary. In some interactive applications, there can be particular points in time where": "input.pdf", "the user wont care if there is a2. garbage collection pause. One example is a game where there are natural pauses in the play e.g. when loading a new level. Section 135.11 Pitfall - Calling new StringString is inecient Using new StringString to duplicate a string is ine\ufb03cient and almost always unnecessary. String objects are immutable, so there is no need to copy them to protect against changes. In some older versions of Java, String objects can share backing arrays with other String objects. In those versions, it is possible to leak memory by creating a small substring of a large string and retaining it. However, from Java 7 onwards, String backing arrays are not shared. In the absence of any tangible bene\ufb01t, calling new StringString is simply wasteful Making the copy takes CPU time. The copy uses more memory which increases the applications memoru footprint and or increases GC overheads. Operations like equalsObject and hashCode can be slower if String objects are copied. GoalKicker.com Java Notes for Professionals 766Chapter 136 ServiceLoader Section 136.1 Simple ServiceLoader Example The ServiceLoader is a simple and easy to use built-in mechanism for dynamic loading of interface implementations. With the service loader -": "input.pdf", "providing means for instantation but not the wiring - a simple dependency injection mechanism can be built in Java SE. With the ServiceLoader interface and implementation separation becomes natural and programs can be conveniently extended. Actually a lot of Java API are implented based on the ServiceLoader The basic concepts are Operating on interfaces of services Obtaining implementations of the service via ServiceLoader Providing implementation of servics Lets start with the interface and put it in a jar, named for example accounting -api.jar package example public interface AccountingService long getBalance Now we provide an implementation of that service in a jar named accounting -impl.jar, containing an implementation of the service package example.impl import example.AccountingService public interface DefaultAccountingService implements AccouningService public long getBalance return balanceFromDB private long balanceFromDB ... further, the accounting -impl.jar contains a \ufb01le declaring that this jar provides an implementation of AccountingService . The \ufb01le has to have a path starting with META-INFservices and must have the same name as the fully-quali\ufb01ed name of the interface META-INFservices example. AccountingService The content of the \ufb01le is the fully-qual\ufb01\ufb01ed name of the implementation example. impl.DefaultAccountingService Given both jars are in the classpath of the program, that consumes the AccountingService": "input.pdf", ", an instance of the Service can be obtained by using the ServiceLauncher GoalKicker.com Java Notes for Professionals 767ServiceLoader AccountingService loader ServiceLoader. loadAccountingService. class AccountingService service loader. next long balance service. getBalance As the ServiceLoader is an Iterable , it supports multiple implementation providers, where the program may choose from ServiceLoader AccountingService loader ServiceLoader. loadAccountingService. class forAccountingService service loader ... Note that when invoking next a new instance will allways be created. If you want to re-use an instance, you have to use the iterator method of the ServiceLoader or the for-each loop as shown above. Section 136.2 Logger Service The following example shows how to instantiate a class for logging via the ServiceLoader . Service package servicetest import java.io.IOException public interface Logger extends AutoCloseable void logString message throws IOException Implementations of the service The following implementation simply writes the message to System.err package servicetest.logger import servicetest.Logger public class ConsoleLogger implements Logger Override public void logString message System.err.printlnmessage Override public void close The following implementation writes the messages to a text \ufb01le package servicetest.logger import java.io.BufferedWriter import java.io.FileWriter import java.io.IOException GoalKicker.com Java Notes for Professionals 768import servicetest.Logger public class FileLogger implements Logger private final BufferedWriter writer public FileLogger throws": "input.pdf", "IOException writer new BufferedWriter new FileWriter log.txt Override public void logString message throws IOException writer. appendmessage writer. newLine Override public void close throws IOException writer. close META-INFservicesservicetest.Logger The META-INFservices servicetest. Logger \ufb01le lists the names of the Logger implementations. servicetest. logger.ConsoleLogger servicetest. logger.FileLogger Usage The following main method writes a message to all available loggers. The loggers are instantiated using ServiceLoader . public static void mainString args throws Exception final String message Hello World! get ServiceLoader for Logger ServiceLoader Logger loader ServiceLoader. loadservicetest. Logger.class iterate through instances of available loggers, writing the message to each one Iterator Logger iterator loader. iterator while iterator. hasNext try Logger logger iterator. next logger. logmessage GoalKicker.com Java Notes for Professionals 769Chapter 137 Classloaders Section 137.1 Implementing a custom classLoader Every custom loader must directly or indirectly extend the java.lang.ClassLoader class. The main extension points are the following methods findClass String - overload this method if your classloader follows the standard delegation model for class loading. loadClass String, boolean - overload this method to implement an alternative delegation model. findResource and findResources - overload these methods to customize resource loading. The defineClass methods which are responsible for actually loading the class from a byte": "input.pdf", "array are final to prevent overloading. Any custom behavior needs to be performed prior to calling defineClass . Here is a simple that loads a speci\ufb01c class from a byte array public class ByteArrayClassLoader extends ClassLoader private String classname private byte classfile public ByteArrayClassLoader String classname, byte classfile this.classname classname this.classfile classfile. clone Override protected Class findClass String classname throws ClassNotFoundException if classname. equalsthis.classname return defineClass classname, classfile, 0, classfile. length else throw new ClassNotFoundException classname Since we have only overridden the findClass method, this custom class loader is going to behave as follows when loadClass is called. The classloaders loadClass method calls findLoadedClass to see if a class with this name has already been 1. loaded by this classloader. If that succeeds, the resulting Class object is returned to the requestor. The loadClass method then delegates to the parent classloader by calling its loadClass call. If the parent can 2. deal with the request, it will return a Class object which is then returned to the requestor. If the parent classloader cannot load the class, findClass then calls our override findClass method, passing 3. the name of the class to be loaded. If the requested name matches this.classname": "input.pdf", ", we call defineClass to load the actual class from the 4. this.classfile byte array. The resulting Class object is then returned. If the name did not match, we throw ClassNotFoundException . 5. Section 137.2 Loading an external .class \ufb01le To load a class we \ufb01rst need to de\ufb01ne it. The class is de\ufb01ned by the ClassLoader . Theres just one problem, Oracle didnt write the ClassLoader s code with this feature available. To de\ufb01ne the class we will need to access a method named defineClass which is a private method of the ClassLoader . GoalKicker.com Java Notes for Professionals 770To access it, what we will do is create a new class, ByteClassLoader , and extend it to ClassLoader . Now that we have extended our class to ClassLoader , we can access the ClassLoader s private methods. To make defineClass available, we will create a new method that will act like a mirror for the private defineClass method. To call the private method we will need the class name, name , the class bytes, classBytes , the \ufb01rst bytes o\ufb00set, which will be 0 because classBytes data starts at classBytes 0, and the last bytes o\ufb00set, which will": "input.pdf", "be classBytes. lenght because it represents the size of the data, which will be the last o\ufb00set. public class ByteClassLoader extends ClassLoader public Class? defineClass String name, byte classBytes return defineClass name, classBytes, 0, classBytes. length Now, we have a public defineClass method. It can be called by passing the name of the class and the class bytes as arguments. Lets say we have class named MyClass in the package stackoverflow ... To call the method we need the class bytes so we create a Path object representing our class path by using the Paths.get method and passing the path of the binary class as an argument. Now, we can get the class bytes with Files.readAllBytes path. So we create a ByteClassLoader instance and use the method we created, defineClass . We already have the class bytes but to call our method we also need the class name which is given by the package name dot the class canonical name, in this case stackoverflow. MyClass . Path path Paths.getMyClass.class ByteClassLoader loader new ByteClassLoader loader.defineClass stackoverflow.MyClass , Files. readAllBytes path Note The defineClass method returns a Class? object. You can save it if you want. To load the class, we": "input.pdf", "just call loadClass and pass the class name. This method can throw an ClassNotFoundException so we need to use a try cath block try loader. loadClass stackoverflow.MyClass catchClassNotFoundException e e.printStackTrace Section 137.3 Instantiating and using a classloader This basic example shows how an application can instantiate a classloader and use it to dynamically load a class. URL urls new URL new URLfilehomemeextras.jar Classloader loader new URLClassLoader urls Class? myObjectClass loader. findClass com.example.MyObject The classloader created in this example will have the default classloader as its parent, and will \ufb01rst try to \ufb01nd any class in the parent classloader before looking in extra.jar. If the requested class has already been loaded, the findClass call will return the reference to the previously loaded class. The findClass call can fail in a variety of ways. The most common are GoalKicker.com Java Notes for Professionals 771If the named class cannot be found, the call with throw ClassNotFoundException . If the named class depends on some other class that cannot be found, the call will throw NoClassDefFoundError . GoalKicker.com Java Notes for Professionals 772Chapter 138 Creating Images Programmatically Section 138.1 Creating a simple image programmatically and displaying it class ImageCreationExample static Image createSampleImage instantiate": "input.pdf", "a new BufferedImage subclass of Image instance BufferedImage img new BufferedImage 640, 480, BufferedImage .TYPEINTARGB draw something on the image paintOnImage img return img static void paintOnImage BufferedImage img get a drawable Graphics2D subclass of Graphics object Graphics2D g2d Graphics2D img.getGraphics some sample drawing g2d. setColor Color.BLACK g2d. fillRect 0, 0, 640, 480 g2d. setColor Color.WHITE g2d. drawLine 0, 0, 640, 480 g2d. drawLine 0, 480, 640, 0 g2d. setColor Color.YELLOW g2d. drawOval 200, 100, 240, 280 g2d. setColor Color.RED g2d. drawRect 150, 70, 340, 340 drawing on images can be very memory-consuming so its better to free resources early its not necessary, though g2d. dispose public static void mainString args JFrame frame new JFrame frame. setDefaultCloseOperation JFrame.EXITONCLOSE Image img createSampleImage ImageIcon icon new ImageIcon img frame. addnew JLabelicon frame. pack frame. setVisible true GoalKicker.com Java Notes for Professionals 773 Section 138.2 Save an Image to disk public static void saveImage String destination throws IOException method implemented in Creating a simple image Programmatically and displaying it example BufferedImage img createSampleImage ImageIO provides several write methods with different outputs ImageIO. writeimg, png, new Filedestination Section 138.3 Setting individual pixels color in BueredImage BufferedImage image new BufferedImage 256, 256, BufferedImage .TYPEINTARGB": "input.pdf", "you dont have to use the Graphics object, you can read and set pixel color individually for int i 0 i 256 i for int j 0 j 256 j int alpha 255 dont forget this, or use BufferedImage.TYPEINTRGB instead int red i or any formula you like int green j or any formula you like int blue 50 or any formula you like int color alpha 24 red 16 green 8 blue image. setRGBi, j, color ImageIO. writeimage, png, new Filecomputed.png GoalKicker.com Java Notes for Professionals 774Output Section 138.4 Specifying image rendering quality static void setupQualityHigh Graphics2D g2d g2d. setRenderingHint RenderingHints .KEYANTIALIASING , RenderingHints .VALUEANTIALIASON g2d. setRenderingHint RenderingHints .KEYRENDERING , RenderingHints .VALUERENDERQUALITY many other RenderingHints KEYVALUE pairs to specify static void setupQualityLow Graphics2D g2d g2d. setRenderingHint RenderingHints .KEYANTIALIASING , RenderingHints .VALUEANTIALIASOFF g2d. setRenderingHint RenderingHints .KEYRENDERING , RenderingHints .VALUERENDERSPEED A comparison of QUALITY and SPEED rendering of the sample image GoalKicker.com Java Notes for Professionals 775 GoalKicker.com Java Notes for Professionals 776 Section 138.5 Creating an image with BueredImage class int width 256 in pixels int height 256 in pixels BufferedImage image new BufferedImage width, height, BufferedImage .TYPE4BYTEABGR BufferedImage.TYPE4BYTEABGR - store RGB color and visibility alpha, see javadoc for": "input.pdf", "more info Graphics g image.createGraphics draw whatever you like, like you would in a drawComponentGraphics g method in an UI application g.setColor Color.RED g.fillRect 20, 30, 50, 50 g.setColor Color.BLUE g.drawOval 120, 120, 80, 40 g.dispose dispose graphics objects when they are no longer needed now image has programmatically generated content, you can use it in graphics.drawImage to draw it somewhere else or just simply save it to a file ImageIO. writeimage, png, new Filemyimage.png Output GoalKicker.com Java Notes for Professionals 777 Section 138.6 Editing and re-using image with BueredImage BufferedImage cat ImageIO. readnew Filecat.jpg read existing file modify it Graphics g cat.createGraphics g.setColor Color.RED g.drawString Cat, 10, 10 g.dispose now create a new image BufferedImage cats new BufferedImage 256, 256, BufferedImage .TYPE4BYTEABGR and draw the old one on it, 16 times g cats.createGraphics for int i 0 i 4 i for int j 0 j 4 j g. drawImage cat, i 64, j 64, null g.setColor Color.BLUE g.drawRect 0, 0, 255, 255 add some nice border g.dispose and done ImageIO. writecats, png, new Filecats.png Original cat \ufb01le Produced \ufb01le GoalKicker.com Java Notes for Professionals 778 Section 138.7 How to scale a BueredImage Resizes an image using a Graphics2D": "input.pdf", "object backed by a BufferedImage. param srcImg - source image to scale param w - desired width param h - desired height return - the new resized image private BufferedImage getScaledImage Image srcImg, int w, int h Create a new image with good size that contains or might contain arbitrary alpha values between and including 0.0 and 1.0. BufferedImage resizedImg new BufferedImage w, h, BufferedImage .TRANSLUCENT Create a device-independant object to draw the resized image Graphics2D g2 resizedImg. createGraphics This could be changed, Cf. httpstackoverflow.comdocumentationjava5482creating-images-programmatically19498specifying-im age-rendering-quality g2.setRenderingHint RenderingHints .KEYINTERPOLATION , RenderingHints .VALUEINTERPOLATIONBILINEAR Finally draw the source image in the Graphics2D with the desired size. g2.drawImage srcImg, 0, 0, w, h, null Disposes of this graphics context and releases any system resources that it is using g2.dispose Return the image used to create the Graphics2D return resizedImg GoalKicker.com Java Notes for Professionals 779Chapter 139 Atomic Types Parameter Description set Volatile set of the \ufb01eld get Volatile read of the \ufb01eld lazySet This is a store ordered operation of the \ufb01eld compareAndSet If the value is the expeed value then sent it to the new value getAndSet get the current value and update Java Atomic Types are simple mutable types that": "input.pdf", "provide basic operations that are thread-safe and atomic without resorting to locking. They are intended for use in cases where locking would be a concurrency bottleneck, or where there is risk of deadlock or livelock. Section 139.1 Creating Atomic Types For simple multi-threaded code, using synchronization is acceptable. However, using synchronization does have a liveness impact, and as a codebase becomes more complex, the likelihood goes up that you will end up with Deadlock , Starvation, or Livelock . In cases of more complex concurrency, using Atomic Variables is often a better alternative, as it allows an individual variable to be accessed in a thread-safe manner without the overhead of using synchronized methods or code blocks. Creating an AtomicInteger type AtomicInteger aInt new AtomicInteger Create with default value 0 AtomicInteger aInt new AtomicInteger 1 Create with initial value 1 Similarly for other instance types. AtomicIntegerArray aIntArray new AtomicIntegerArray 10 Create array of specific length AtomicIntegerArray aIntArray new AtomicIntegerArray new int 1, 2, 3 Initialize array with another array Similarly for other atomic types. There is a notable exception that there is no float and double types. These can be simulated through the use of Float.floatToIntBits float and Float.intBitsToFloat int": "input.pdf", "for float as well as Double.doubleToLongBits double and Double.longBitsToDouble long for doubles. If you are willing to use sun.misc.Unsafe you can use any primitive variable as atomic by using the atomic operation in sun.misc.Unsafe . All primitive types should be converted or encoded in int or longs to so use it in this way. For more on this see sun.misc.Unsafe. Section 139.2 Motivation for Atomic Types The simple way to implement multi-threaded applications is to use Javas built-in synchronization and locking primitives e.g. the synchronized keyword. The following example shows how we might use synchronized to accumulate counts. public class Counters private final int counters GoalKicker.com Java Notes for Professionals 780 public Counters int nosCounters counters new intnosCounters Increments the integer at the given index public synchronized void countint number if number 0 number counters. length counters number Obtains the current count of the number at the given index, or if there is no number at that index, returns 0. public synchronized int getCount int number return number 0 number counters. length ? counters number 0 This implementation will work correctly. However, if you have a large number of threads making lots of simultaneous calls on the same Counters": "input.pdf", "object, the synchronization is liable to be a bottleneck. Speci\ufb01cally Each synchronized method call will start with the current thread acquiring the lock for the Counters 1. instance. The thread will hold the lock while it checks number value and updates the counter. 2. Finally, the it will release the lock, allowing other threads access.3. If one thread attempts to acquire the lock while another one holds it, the attempting thread will be blocked stopped at step 1 until the lock is released. If multiple threads are waiting, one of them will get it, and the others will continue to be blocked. This can lead to a couple of problems If there is a lot of contention for the lock i.e. lots of thread try to acquire it, then some threads can be blocked for a long time. When a thread is blocked waiting for the lock, the operating system will typically try switch execution to a di\ufb00erent thread. This context switching incurs a relatively large performance impact on the processor. When there are multiple threads blocked on the same lock, there are no guarantees that any one of them will be treated fairly i.e. each thread is guaranteed": "input.pdf", "to be scheduled to run. This can lead to thread starvation . How does one implement Atomic Types? Let us start by rewriting the example above using AtomicInteger counters public class Counters private final AtomicInteger counters public Counters int nosCounters counters new AtomicInteger nosCounters for int i 0 i nosCounters i counters i new AtomicInteger GoalKicker.com Java Notes for Professionals 781 Increments the integer at the given index public void countint number if number 0 number counters. length counters number.incrementAndGet Obtains the current count of the object at the given index, or if there is no number at that index, returns 0. public int getCount int number return number 0 number counters. length ? counters number.get 0 We have replaced the int with an AtomicInteger , and initialized it with an instance in each element. We have also added calls to incrementAndGet and get in place of operations on int values. But the most important thing is that we can remove the synchronized keyword because locking is no longer required. This works because the incrementAndGet and get operations are atomic and thread-safe . In this context, it means that Each counter in the array will only be observable in": "input.pdf", "the either the before state for an operation like an increment or in the after state. Assuming that the operation occurs at time T, no thread will be able to see the before state after time T. Furthermore, while two threads might actually attempt to update the same AtomicInteger instance at the same time, the implementations of the operations ensure that only one increment happens at a time on the given instance. This is done without locking, often resulting in better performance. How do Atomic Types work? Atomic types typically rely on specialized hardware instructions in the instruction set of the target machine. For example, Intel-based instruction sets provide a CAS Compare and Swap instruction that will perform a speci\ufb01c sequence of memory operations atomically. These low-level instructions are are used to implement higher-level operations in the APIs of the respective AtomicXxx classes. For example, again, in C-like pseudocode private volatile num int increment while TRUE int old num int new old 1 if old compareandswap num, old, new return new GoalKicker.com Java Notes for Professionals 782If there is no contention on the AtomicXxxx , the if test will succeed and the loop will end immediately. If there is": "input.pdf", "contention, then the if will fail for all but one of the threads, and they will spin in the loop for a small number of cycles of the loop. In practice, the spinning is orders of magnitude faster except at unrealistically high levels of contention, where synchronized performs better than atomic classes because when the CAS operation fails, then the retry will only add more contention than suspending the thread and switching to another one. Incidentally, CAS instructions are typically used by the JVM to implement uncontended locking . If the JVM can see that a lock is not currently locked, it will attempt to use a CAS to acquire the lock. If the CAS succeeds, then there is no need to do the expensive thread scheduling, context switching and so on. For more information on the techniques used, see Biased Locking in HotSpot . GoalKicker.com Java Notes for Professionals 783Chapter 140 RSA Encryption Section 140.1 An example using a hybrid cryptosystem consisting of OAEP and GCM The following example encrypts data by using a hybrid cryptosystem consisting of AES GCM and OAEP, using their default parameter sizes and an AES key size of 128 bits. OAEP is less": "input.pdf", "vulnerable to padding oracle attacks than PKCS1 v1.5 padding. GCM is also protected against padding oracle attacks. Decryption can be performed by \ufb01rst retrieving the length of the encapsulated key and then by retrieving the encapsulated key. The encapsulated key can then be decrypted using the RSA private key that forms a key pair with the public key. After that the AESGCM encrypted ciphertext can be decrypted to the original plaintext. The protocol consists of a length \ufb01eld for the wrapped key RSAPrivateKey misses a getKeySize method 1. the wrappedencapsulated key, of the same size as the RSA key size in bytes2. the GCM ciphertext and 128 bit authentication tag automatically added by Java.3. Notes To correctly use this code you should supply an RSA key of at least 2048 bits, bigger is better but slower, especially during decryption To use AES-256 you should install the unlimited cryptography policy \ufb01les \ufb01rst Instead creating your own protocol you might want to use a container format such as the Cryptographic Message Syntax CMS PKCS7 or PGP instead. So heres the example Encrypts the data using a hybrid crypto-system which uses GCM to encrypt the data and OAEP to encrypt the AES": "input.pdf", "key. The key size of the AES encryption will be 128 bit. All the default parameter choices are used for OAEP and GCM. param publicKey the RSA public key used to wrap the AES key param plaintext the plaintext to be encrypted, not altered return the ciphertext throws InvalidKeyException if the key is not an RSA public key throws NullPointerException if the plaintext is null public static byte encryptData PublicKey publicKey, byte plaintext throws InvalidKeyException , NullPointerException --- create the RSA OAEP cipher --- Cipher oaep try SHA-1 is the default and not vulnerable in this setting use OAEPParameterSpec to configure more than just the hash oaep Cipher. getInstance RSAECBOAEPwithSHA1andMGF1Padding catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for RSA cipher mandatory algorithm for runtimes , e GoalKicker.com Java Notes for Professionals 784 catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for OAEP padding present in the standard Java runtime sinze XX , e oaep. initCipher.WRAPMODE , publicKey --- wrap the plaintext in a buffer will throw NullPointerException if plaintext is null ByteBuffer plaintextBuffer ByteBuffer. wrapplaintext --- generate a new AES secret key --- KeyGenerator aesKeyGenerator try aesKeyGenerator KeyGenerator. getInstance AES catch NoSuchAlgorithmException e throw": "input.pdf", "new RuntimeException Runtime doesnt have support for AES key generator mandatory algorithm for runtimes , e for AES-192 and 256 make sure youve got the rights install the Unlimited Crypto Policy files aesKeyGenerator. init128 SecretKey aesKey aesKeyGenerator. generateKey --- wrap the new AES secret key --- byte wrappedKey try wrappedKey oaep.wrapaesKey catch IllegalBlockSizeException e throw new RuntimeException AES key should always fit OAEP with normal sized RSA key , e --- setup the AES GCM cipher mode --- Cipher aesGCM try aesGCM Cipher. getInstance AESGCMNopadding we can get away with a zero nonce since the key is randomly generated 128 bits is the recommended maximum value for the tag size 12 bytes 96 bits is the default nonce size for GCM mode encryption GCMParameterSpec staticParameterSpec new GCMParameterSpec 128, new byte12 aesGCM. initCipher.ENCRYPTMODE , aesKey, staticParameterSpec catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for AES cipher mandatory algorithm for runtimes , e catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for GCM present in the standard Java runtime sinze XX, e catch InvalidAlgorithmParameterException e throw new RuntimeException IvParameterSpec not accepted by this implementation of GCM , e --- create a buffer of the right size": "input.pdf", "for our own protocol --- GoalKicker.com Java Notes for Professionals 785 ByteBuffer ciphertextBuffer ByteBuffer. allocate Short.BYTES oaep.getOutputSize 128 Byte.SIZE aesGCM. getOutputSize plaintext. length - element 1 make sure that we know the size of the wrapped key ciphertextBuffer. putShort short wrappedKey. length - element 2 put in the wrapped key ciphertextBuffer. putwrappedKey - element 3 GCM encrypt into buffer try aesGCM. doFinalplaintextBuffer, ciphertextBuffer catch ShortBufferException IllegalBlockSizeException BadPaddingException e throw new RuntimeException Cryptographic exception, AESGCM encryption should not fail here, e return ciphertextBuffer. array Of course, encryption is not very useful without decryption. Note that this will return minimal information if decryption fails. Decrypts the data using a hybrid crypto-system which uses GCM to encrypt the data and OAEP to encrypt the AES key. All the default parameter choices are used for OAEP and GCM. param privateKey the RSA private key used to unwrap the AES key param ciphertext the ciphertext to be encrypted, not altered return the plaintext throws InvalidKeyException if the key is not an RSA private key throws NullPointerException if the ciphertext is null throws IllegalArgumentException with the message Invalid ciphertext if the ciphertext is invalid minimize information leakage public static byte decryptData PrivateKey privateKey, byte ciphertext": "input.pdf", "throws InvalidKeyException , NullPointerException --- create the RSA OAEP cipher --- Cipher oaep try SHA-1 is the default and not vulnerable in this setting use OAEPParameterSpec to configure more than just the hash oaep Cipher. getInstance RSAECBOAEPwithSHA1andMGF1Padding catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for RSA cipher mandatory algorithm for runtimes , e catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for OAEP padding present in the standard Java runtime sinze XX , GoalKicker.com Java Notes for Professionals 786 e oaep. initCipher.UNWRAPMODE , privateKey --- wrap the ciphertext in a buffer will throw NullPointerException if ciphertext is null ByteBuffer ciphertextBuffer ByteBuffer. wrapciphertext sanity check 1 if ciphertextBuffer. remaining 2 throw new IllegalArgumentException Invalid ciphertext - element 1 the length of the encapsulated key int wrappedKeySize ciphertextBuffer. getShort 0xFFFF sanity check 2 if ciphertextBuffer. remaining wrappedKeySize 128 Byte.SIZE throw new IllegalArgumentException Invalid ciphertext --- unwrap the AES secret key --- byte wrappedKey new bytewrappedKeySize - element 2 the encapsulated key ciphertextBuffer. getwrappedKey SecretKey aesKey try aesKey SecretKey oaep.unwrapwrappedKey, AES, Cipher. SECRETKEY catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for AES cipher mandatory algorithm for runtimes , e catch InvalidKeyException e throw new": "input.pdf", "RuntimeException Invalid ciphertext --- setup the AES GCM cipher mode --- Cipher aesGCM try aesGCM Cipher. getInstance AESGCMNopadding we can get away with a zero nonce since the key is randomly generated 128 bits is the recommended maximum value for the tag size 12 bytes 96 bits is the default nonce size for GCM mode encryption GCMParameterSpec staticParameterSpec new GCMParameterSpec 128, new byte12 aesGCM. initCipher.DECRYPTMODE , aesKey, staticParameterSpec catch NoSuchAlgorithmException e throw new RuntimeException Runtime doesnt have support for AES cipher mandatory algorithm for runtimes , e catch NoSuchPaddingException e throw new RuntimeException Runtime doesnt have support for GCM present in the standard Java runtime sinze XX, e catch InvalidAlgorithmParameterException e throw new RuntimeException GoalKicker.com Java Notes for Professionals 787 IvParameterSpec not accepted by this implementation of GCM , e --- create a buffer of the right size for our own protocol --- ByteBuffer plaintextBuffer ByteBuffer. allocate aesGCM . getOutputSize ciphertextBuffer. remaining - element 3 GCM ciphertext try aesGCM. doFinalciphertextBuffer, plaintextBuffer catch ShortBufferException IllegalBlockSizeException BadPaddingException e throw new RuntimeException Invalid ciphertext return plaintextBuffer. array GoalKicker.com Java Notes for Professionals 788Chapter 141 Secure objects Section 141.1 SealedObject javax.crypto.SealedObject This class enables a programmer to create an object and protect its": "input.pdf", "con\ufb01dentiality with a cryptographic algorithm. Given any Serializable object, one can create a SealedObject that encapsulates the original object, in serialized format i.e., a deep copy, and seals encrypts its serialized contents, using a cryptographic algorithm such as AES, DES, to protect its con\ufb01dentiality. The encrypted content can later be decrypted with the corresponding algorithm using the correct decryption key and de-serialized, yielding the original object. Serializable obj new StringJohn Generate key KeyGenerator kgen KeyGenerator. getInstance AES kgen.init128 SecretKey aesKey kgen.generateKey Cipher cipher Cipher. getInstance AES cipher.initCipher.ENCRYPTMODE , aesKey SealedObject sealedObject new SealedObject obj, cipher System.out.printlnsealedObject- sealedObject System.out.printlnsealedObject Data- sealedObject. getObject aesKey Section 141.2 SignedObject java.security.SignedObject SignedObject is a class for the purpose of creating authentic runtime objects whose integrity cannot be compromised without being detected. More speci\ufb01cally, a SignedObject contains another Serializable object, the to-be-signed object and its signature. GoalKicker.com Java Notes for Professionals 789 Create a key KeyPairGenerator keyGen KeyPairGenerator .getInstance DSA, SUN SecureRandom random SecureRandom .getInstance SHA1PRNG , SUN keyGen.initialize 1024, random create a private key PrivateKey signingKey keyGen. generateKeyPair .getPrivate create a Signature Signature signingEngine Signature .getInstance DSA signingEngine. initSign signingKey create a simple object Serializable obj new StringJohn sign our object SignedObject signedObject new": "input.pdf", "SignedObject obj, signingKey, signingEngine System.out.printlnsignedObject- signedObject System.out.printlnsignedObject Data- signedObject. getObject GoalKicker.com Java Notes for Professionals 790Chapter 142 Security Cryptography Section 142.1 Compute Cryptographic Hashes To compute the hashes of relatively small blocks of data using di\ufb00erent algorithms final MessageDigest md5 MessageDigest .getInstance MD5 final MessageDigest sha1 MessageDigest .getInstance SHA-1 final MessageDigest sha256 MessageDigest .getInstance SHA-256 final byte data FOO BAR .getBytes System.out.printlnMD5 hash DatatypeConverter. printHexBinary md5.digestdata System.out.printlnSHA1 hash DatatypeConverter. printHexBinary sha1.digestdata System.out.printlnSHA256 hash DatatypeConverter. printHexBinary sha256.digestdata Produces this output MD5 hash E99E768582F6DD5A3BA2D9C849DF736E SHA1 hash 0135FAA6323685BA8A8FF8D3F955F0C36949D8FB SHA256 hash 8D35C97BCD902B96D1B551741BBE8A7F50BB5A690B4D0225482EAA63DBFB9DED Additional algorithms may be available depending on your implementation of the Java platform. Section 142.2 Encrypt and Decrypt Data with Public Private Keys To encrypt data with a public key final Cipher rsa Cipher. getInstance RSA rsa.initCipher.ENCRYPTMODE , keyPair. getPublic rsa.updatemessage. getBytes final byte result rsa.doFinal System.out.printlnMessage message System.out.printlnEncrypted DatatypeConverter. printHexBinary result Produces output similar to Message Hello Encrypted 5641FBB9558ECFA9ED... Note that when creating the Cipher object, you have to specify a transformation that is compatible with the type of key being used. See JCA Standard Algorithm Names for a list of supported transformations.. For RSA encryption data message. getBytes length must be smaller than the key size. See this SO": "input.pdf", "Answer for detail. To decrypt the data final Cipher rsa Cipher. getInstance RSA rsa.initCipher.DECRYPTMODE , keyPair. getPrivate rsa.updatecipherText final String result new Stringrsa.doFinal GoalKicker.com Java Notes for Professionals 791System.out.printlnDecrypted result Produces the following output Decrypted Hello Section 142.3 Generate Cryptographically Random Data To generate samples of cryptographically random data final byte sample new byte16 new SecureRandom .nextBytes sample System.out.printlnSample DatatypeConverter. printHexBinary sample Produces output similar to Sample E4F14CEA2384F70B706B53A6DF8C5EFE Note that the call to nextBytes may block while entropy is gathered depending on the algorithm being used. To specify the algorithm and provider final byte sample new byte16 final SecureRandom randomness SecureRandom .getInstance SHA1PRNG , SUN randomness. nextBytes sample System.out.printlnProvider randomness. getProvider System.out.printlnAlgorithm randomness. getAlgorithm System.out.printlnSample DatatypeConverter. printHexBinary sample Produces output similar to Provider SUN version 1.8 Algorithm SHA1PRNG Sample C80C44BAEB352FD29FBBE20489E4C0B9 Section 142.4 Generate Public Private Key Pairs To generate key pairs using di\ufb00erent algorithms and key sizes final KeyPairGenerator dhGenerator KeyPairGenerator .getInstance DiffieHellman final KeyPairGenerator dsaGenerator KeyPairGenerator .getInstance DSA final KeyPairGenerator rsaGenerator KeyPairGenerator .getInstance RSA dhGenerator. initialize 1024 dsaGenerator. initialize 1024 rsaGenerator. initialize 2048 final KeyPair dhPair dhGenerator. generateKeyPair final KeyPair dsaPair dsaGenerator. generateKeyPair final KeyPair rsaPair rsaGenerator. generateKeyPair GoalKicker.com Java Notes for Professionals 792Additional algorithms and key sizes": "input.pdf", "may be available on your implementation of the Java platform. To specify a source of randomness to use when generating the keys final KeyPairGenerator generator KeyPairGenerator .getInstance RSA generator. initialize 2048, SecureRandom .getInstance SHA1PRNG , SUN final KeyPair pair generator. generateKeyPair Section 142.5 Compute and Verify Digital Signatures To compute a signature final PrivateKey privateKey keyPair. getPrivate final byte data FOO BAR .getBytes final Signature signer Signature .getInstance SHA1withRSA signer.initSign privateKey signer.updatedata final byte signature signer. sign Note that the signature algorithm must be compatible with the algorithm used to generate the key pair. To verify a signature final PublicKey publicKey keyPair. getPublic final Signature verifier Signature .getInstance SHA1withRSA verifier. initVerify publicKey verifier. updatedata System.out.printlnSignature verifier. verifysignature Produces this output Signature true GoalKicker.com Java Notes for Professionals 793Chapter 143 Security Cryptography Security practices in Java can be separated into two broad, vaguely de\ufb01ned categories Java platform security, and secure Java programming. Java platform security practices deal with managing the security and integrity of the JVM. It includes such topics as managing JCE providers and security policies. Secure Java programming practices concern the best ways to write secure Java programs. It includes such topics as using random numbers and cryptography,": "input.pdf", "and preventing vulnerabilities. Section 143.1 The JCE The Java Cryptography Extension JCE is a framework built into the JVM to allow developers to easily and securely use cryptography in their programs. It does this by providing a simple, portable interface to programmers, while using a system of JCE Providers to securely implement the underlying cryptographic operations. Section 143.2 Keys and Key Management While the JCE secures cryptographic operations and key generation, it is up to the developer to actually manage their keys. More information needs to be provided here. One commonly-accepted best practice for handling keys at runtime is to store them only as byte arrays, and never as strings. This is because Java strings are immutable, and cannot be manually cleared or zeroed out in memory while a reference to a string can be removed, the exact string will remain in memory until its segment of memory is garbage-collected and reused. An attacker would have a large window in which they could dump the programs memory and easily \ufb01nd the key. Contrarily, byte arrays are mutable, and can have their contents overwritten in place it is a good idea to zero-out your keys as soon as you no": "input.pdf", "longer need them. Section 143.3 Common Java vulnerabilities Section 143.4 Networking Concerns Section 143.5 Randomness and You For most applications, the java.utils.Random class is a perfectly \ufb01ne source of random data. If you need to choose a random element from an array, or generate a random string, or create a temporary unique identi\ufb01er, you should probably use Random . However, many cryptographic systems rely on randomness for their security, and the randomness provided by Random simply isnt of high enough quality. For any cryptographic operation that requires a random input, you should use SecureRandom instead. Section 143.6 Hashing and Validation A cryptographic hash function is a member of a class of functions with three vital properties consistency, uniqueness, and irreversibility. Consistency Given the same data, a hash function will always return the same value. That is, if X Y, fx will always equal fy for hash function f. Uniqueness No two inputs to a hash function will ever result in the same output. That is, if X ! Y, fx ! fy, for any GoalKicker.com Java Notes for Professionals 794values of X and Y. Irreversibility It is impractically di\ufb03cult, if not impossible, to reverse a hash function. That is,": "input.pdf", "given only fX, there should be no way of \ufb01nding the original X short of putting every possible value of X through the function f brute-force. There should be no function f1 such that f1fX X. Many functions lack at least one of these attributes. For example, MD5 and SHA1 are known to have collisions, i.e. two inputs that have the same output, so they lack uniqueness. Some functions that are currently believed to be secure are SHA-256 and SHA-512. GoalKicker.com Java Notes for Professionals 795Chapter 144 SecurityManager Section 144.1 Sandboxing classes loaded by a ClassLoader The ClassLoader needs to provide a ProtectionDomain identifying the source of the code public class PluginClassLoader extends ClassLoader private final ClassProvider provider private final ProtectionDomain pd public PluginClassLoader ClassProvider provider this.provider provider Permissions permissions new Permissions this.pd new ProtectionDomain provider. getCodeSource , permissions, this, null Override protected Class? findClass String name throws ClassNotFoundException byte classDef provider. getClass name Class ? clazz defineClass name, classDef, 0, classDef. length, pd return clazz By overriding findClass rather than loadClass the delegational model is preserved, and the PluginClassLoader will \ufb01rst query the system and parent classloader for class de\ufb01nitions. Create a Policy public class PluginSecurityPolicy extends Policy": "input.pdf", "private final Permissions appPermissions new Permissions private final Permissions pluginPermissions new Permissions public PluginSecurityPolicy amend this as appropriate appPermissions. addnew AllPermission add any permissions plugins should have to pluginPermissions Override public Provider getProvider return super.getProvider Override public String getType return super.getType Override public Parameters getParameters return super.getParameters Override GoalKicker.com Java Notes for Professionals 796 public PermissionCollection getPermissions CodeSource codesource return new Permissions Override public PermissionCollection getPermissions ProtectionDomain domain return isPlugin domain?pluginPermissions appPermissions private boolean isPlugin ProtectionDomain pd return pd.getClassLoader instanceof PluginClassLoader Finally, set the policy and a SecurityManager default implementation is \ufb01ne Policy.setPolicy new PluginSecurityPolicy System.setSecurityManager new SecurityManager Section 144.2 Enabling the SecurityManager Java Virtual Machines JVMs can be run with a SecurityManager installed. The SecurityManager governs what the code running in the JVM is allowed to do, based on factors such as where the code was loaded from and what certi\ufb01cates were used to sign the code. The SecurityManager can be installed by setting the java.security.manager system property on the command line when starting the JVM java -Djava.security .manager main class name or programmatically from within Java code System.setSecurityManager new SecurityManager The standard Java SecurityManager grants permissions on the basis of a Policy, which is de\ufb01ned in a": "input.pdf", "policy \ufb01le. If no policy \ufb01le is speci\ufb01ed, the default policy \ufb01le under JAVAHOME libsecurity java.policy will be used. Section 144.3 Implementing policy deny rules It is occasionally desirable to deny a certain Permission to some ProtectionDomain , regardless of any other permissions that domain accrues. This example demonstrates just one of all the possible approaches for satisfying this kind of requirement. It introduces a negative permission class, along with a wrapper that enables the default Policy to be reused as a repository of such permissions. Notes The standard policy \ufb01le syntax and mechanism for permission assignment in general remain una\ufb00ected. This means that deny rules within policy \ufb01les are still expressed as grants . The policy wrapper is meant to speci\ufb01cally encapsulate the default \ufb01le-backed Policy assumed to be com.sun.security .provider .PolicyFile . Denied permissions are only processed as such at the policy level. If statically assigned to a domain, they will by default be treated by that domain as ordinary positive permissions. The DeniedPermission class package com.example GoalKicker.com Java Notes for Professionals 797import java.lang.reflect.Constructor import java.lang.reflect.InvocationTargetException import java.lang.reflect.Modifier import java.security.BasicPermission import java.security.Permission import java.security.UnresolvedPermission import java.text.MessageFormat A representation of a negative privilege. p A codeDeniedPermissioncode, when granted": "input.pdf", "to some codeProtectionDomaincode andor codePrincipalcode, represents a privilege which emcannotem be exercised, regardless of any positive permissions codeAllPermissioncode included possessed. In other words, if a set of granted permissions, emPem, contains a permission of this class, emDem, then the set of effectively granted permissions isbr br nbspnbspnbspnbspem Psubimpliedsub - Dsubimpliedsub em. p p Each instance of this class encapsulates a emtarget permissionem, representing the positive permission being denied. p Denied permissions employ the following naming schemebr br nbspnbspnbspnbspemlttargetclassnamegtlttargetnamegtlttargetactionsgte mbr br where ul liemtargetclassnameem is the name of the target permissions class,li liemtargetnameem is the name of the target permission, andli liemtargetactionsem is, optionally, the actions string of the target permission.li ul A denied permission, having a target permission emtem, is said to emimplyem another permission empem, if ul lip emis notem itself a denied permission, and codet.impliesp truecode, orli lip emisem a denied permission, with a target emt1em, and codet.impliest1 truecode. ul p It is the responsibility of the policy decision point e.g., the codePolicycode provider to take denied permission semantics into account when issuing authorization statements. p public final class DeniedPermission extends BasicPermission private final Permission target private static final long serialVersionUID 473625163869800679L Instantiates a codeDeniedPermissioncode that encapsulates": "input.pdf", "a target permission of the indicated class, specified name and, optionally, actions. throws IllegalArgumentException if ul licodetargetClassNamecode is codenullcode, the empty string, does not refer to a concrete codePermissioncode descendant, or refers to GoalKicker.com Java Notes for Professionals 798 codeDeniedPermission.classcode or codeUnresolvedPermission.classcode.li licodetargetNamecode is codenullcode.li licodetargetClassNamecode cannot be instantiated, and its the callers fault e.g., because codetargetNamecode andor codetargetActionscode do not adhere to the naming constraints of the target class or due to the target class not exposing a codeString namecode, or codeString name, String actionscode constructor, depending on whether codetargetActionscode is codenullcode or not.li ul public static DeniedPermission newDeniedPermission String targetClassName, String targetName, String targetActions if targetClassName null targetClassName. trim.isEmpty targetName null throw new IllegalArgumentException Null or empty targetClassName, or null targetName argument was supplied. StringBuilder sb new StringBuilder targetClassName .append.appendtargetName if targetName ! null sb. append.appendtargetName return new DeniedPermission sb.toString Instantiates a codeDeniedPermissioncode that encapsulates a target permission of the class, name and, optionally, actions, collectively provided as the codenamecode argument. throws IllegalArgumentException if ul licodenamecodes target permission class name component is empty, does not refer to a concrete codePermissioncode descendant, or refers to codeDeniedPermission.classcode or codeUnresolvedPermission.classcode.li licodenamecodes target name component is codeemptycodeli lithe target permission class": "input.pdf", "cannot be instantiated, and its the callers fault e.g., because codenamecodes target name andor target actions components do not adhere to the naming constraints of the target class or due to the target class not exposing a codeString namecode, or codeString name, String actionscode constructor, depending on whether the target actions component is empty or not.li ul public DeniedPermission String name supername String comps name.split if comps.length 2 throw new IllegalArgumentException MessageFormat .formatMalformed name 0 argument. , name this.target initTarget comps0, comps1, comps.length 3 ? null comps2 GoalKicker.com Java Notes for Professionals 799 Instantiates a codeDeniedPermissioncode that encapsulates the given target permission. throws IllegalArgumentException if codetargetcode is codenullcode, a codeDeniedPermissioncode, or an codeUnresolvedPermissioncode. public static DeniedPermission newDeniedPermission Permission target if target null throw new IllegalArgumentException Null target argument. if target instanceof DeniedPermission target instanceof UnresolvedPermission throw new IllegalArgumentException target must not be a DeniedPermission or an UnresolvedPermission. StringBuilder sb new StringBuilder target.getClass .getName.append.appendtarget.getName String targetActions target. getActions if targetActions ! null sb. append.appendtargetActions return new DeniedPermission sb.toString , target private DeniedPermission String name, Permission target supername this.target target private Permission initTarget String targetClassName, String targetName, String targetActions Class ? targetClass try targetClass Class.forNametargetClassName catch ClassNotFoundException cnfe if targetClassName. trim.isEmpty": "input.pdf", "targetClassName empty throw new IllegalArgumentException MessageFormat .formatTarget Permission class 0 not found. , targetClassName if !Permission .class.isAssignableFrom targetClass Modifier .isAbstract targetClass. getModifiers throw new IllegalArgumentException MessageFormat . formatTarget Permission class 0 is not a concrete Permission. , targetClassName if targetClass DeniedPermission. class targetClass UnresolvedPermission .class throw new IllegalArgumentException Target Permission class cannot be a DeniedPermission itself. Constructor ? targetCtor try if targetActions null targetCtor targetClass. getConstructor String.class else targetCtor targetClass. getConstructor String.class, String.class GoalKicker.com Java Notes for Professionals 800 catch NoSuchMethodException nsme throw new IllegalArgumentException MessageFormat .format Target Permission class 0 does not provide or expose a String name or String name, String actions constructor. , targetClassName try return Permission targetCtor . newInstance targetCtor. getParameterCount 1 ? new Object targetName new Object targetName, targetActions catch ReflectiveOperationException roe if roe instanceof InvocationTargetException if targetName null targetName null else if targetName. trim.isEmpty targetName empty if targetActions null targetActions null else if targetActions. trim.isEmpty targetActions empty throw new IllegalArgumentException MessageFormat .format Could not instantiate target Permission class 0 provided target name 1 andor target actions 2 potentially erroneous. , targetClassName, targetName, targetActions , roe throw new RuntimeException Could not instantiate target Permission class 0 an unforeseen error occurred - see attached cause": "input.pdf", "for details , roe Checks whether the given permission is implied by this one, as per the link DeniedPermission overview. Override public boolean implies Permission p if p instanceof DeniedPermission return target. impliesDeniedPermission p.target return target. impliesp Returns this denied permissions target permission the actual positive permission which is not to be granted. public Permission getTargetPermission return target The DenyingPolicy class GoalKicker.com Java Notes for Professionals 801package com.example import java.security.CodeSource import java.security.NoSuchAlgorithmException import java.security.Permission import java.security.PermissionCollection import java.security.Policy import java.security.ProtectionDomain import java.security.UnresolvedPermission import java.util.Enumeration Wrapper that adds rudimentary link DeniedPermission processing capabilities to the standard file-backed codePolicycode. public final class DenyingPolicy extends Policy try defaultPolicy Policy.getInstance javaPolicy , null catch NoSuchAlgorithmException nsae throw new RuntimeException Could not acquire default Policy. , nsae private final Policy defaultPolicy Override public PermissionCollection getPermissions CodeSource codesource return defaultPolicy. getPermissions codesource Override public PermissionCollection getPermissions ProtectionDomain domain return defaultPolicy. getPermissions domain return ul licodetruecode ifli ul licodepermissioncode emis notem an instance of codeDeniedPermissioncode,li lian codeimpliesdomain, permissioncode invocation on the system-default codePolicycode yields codetruecode, andli licodepermissioncode emis notem implied by any codeDeniedPermissioncodes having potentially been assigned to codedomaincode.li ul licodefalsecode, otherwise. ul Override public boolean implies ProtectionDomain domain, Permission permission if permission instanceof DeniedPermission At": "input.pdf", "the policy decision level, DeniedPermissions can only themselves imply, not be implied as they take away, rather than grant, privileges. Furthermore, clients arent supposed to use this GoalKicker.com Java Notes for Professionals 802 method for checking whether some domain does not have a permission which is what DeniedPermissions express after all. return false if !defaultPolicy. impliesdomain, permission permission not granted, so no need to check whether denied return false Permission granted--now check whether theres an overriding DeniedPermission. The following assumes that previousPolicy is a sun.security.provider.PolicyFile different implementations might not support getPermissionsProtectionDomain andor handle UnresolvedPermissions differently. Enumeration Permission perms defaultPolicy. getPermissions domain.elements while perms.hasMoreElements Permission p perms.nextElement DeniedPermissions will generally remain unresolved, as no code is expected to check whether other code has been granted such a permission. if p instanceof UnresolvedPermission UnresolvedPermission up UnresolvedPermission p if up.getUnresolvedType .equalsDeniedPermission. class.getName force resolution defaultPolicy. impliesdomain, up evaluate right away, to avoid reiterating over the collection p new DeniedPermission up.getUnresolvedName if p instanceof DeniedPermission p.impliespermission permission denied return false permission granted return true Override public void refresh defaultPolicy. refresh Demo package com.example import java.security.Policy public class Main public static void mainString... args Policy.setPolicy new DenyingPolicy GoalKicker.com Java Notes for Professionals 803 System.setSecurityManager": "input.pdf", "new SecurityManager should fail System.getProperty foo.bar Assign some permissions grant codeBase filepathtoclassesbin- permission java. util.PropertyPermission , read,write permission com. example.DeniedPermission java.util.PropertyPermissionfoo.barread Lastly, run the Main and watch it fail, due to the deny rule the DeniedPermission overriding the grant its PropertyPermission . Note that a setProperty foo.baz , xyz invocation would instead have succeeded, since the denied permission only covers the read action, and solely for the foo.bar property. GoalKicker.com Java Notes for Professionals 804Chapter 145 JNDI Section 145.1 RMI through JNDI This example shows how JNDI works in RMI. It has two roles to provide the server with a bindunbindrebind API to the RMI Registry to provide the client with a lookuplist API to the RMI Registry. The RMI Registry is part of RMI, not JNDI. To make this simple, we will use java.rmi.registry .CreateRegistry to create the RMI Registry. Server.javathe JNDI server1. package com.neohope.jndi.test import javax.naming.Context import javax.naming.InitialContext import javax.naming.NamingException import java.io.IOException import java.rmi.RemoteException import java.rmi.registry.LocateRegistry import java.util.Hashtable JNDI Server 1.create a registry on port 1234 2.bind JNDI 3.wait for connection 4.clean up and end public class Server private static Registry registry private static InitialContext ctx public static void initJNDI try registry LocateRegistry .createRegistry 1234 final Hashtable": "input.pdf", "jndiProperties new Hashtable jndiProperties. putContext.INITIALCONTEXTFACTORY , com.sun.jndi.rmi.registry.RegistryContextFactory jndiProperties. putContext.PROVIDERURL , rmilocalhost1234 ctx new InitialContext jndiProperties catch NamingException e e. printStackTrace catch RemoteException e e. printStackTrace public static void bindJNDI String name, Object obj throws NamingException ctx. bindname, obj public static void unbindJNDI String name throws NamingException ctx. unbindname GoalKicker.com Java Notes for Professionals 805 public static void unInitJNDI throws NamingException ctx. close public static void mainString args throws NamingException , IOException initJNDI NMessage msg new NMessage Just A Message bindJNDI neohopejnditest01 , msg System.in.read unbindJNDI neohopejnditest01 unInitJNDI Client.javathe JNDI client2. package com.neohope.jndi.test import javax.naming.Context import javax.naming.InitialContext import javax.naming.NamingException import java.util.Hashtable 1.init context 2.lookup registry for the service 3.use the service 4.end public class Client public static void mainString args throws NamingException final Hashtable jndiProperties new Hashtable jndiProperties. putContext.INITIALCONTEXTFACTORY , com.sun.jndi.rmi.registry.RegistryContextFactory jndiProperties. putContext.PROVIDERURL , rmilocalhost1234 InitialContext ctx new InitialContext jndiProperties NMessage msg NeoMessage ctx.lookupneohopejnditest01 System.out.printlnmsg.message ctx. close NMessage.java RMI server class3. package com.neohope.jndi.test import java.io.Serializable import java.rmi.Remote NMessage RMI server class must implements Remote and Serializable public class NMessage implements Remote, Serializable public String message public NMessage String message this.message message GoalKicker.com Java Notes for Professionals 806 How to run the eaxmple build and start the server1. build and start": "input.pdf", "the client2. Introduce The Java Naming and Directory Interface JNDI is a Java API for a directory service that allows Java software clients to discover and look up data and objects via a name. It is designed to be independent of any speci\ufb01c naming or directory service implementation. The JNDI architecture consists of an API Application Programming Interface and an SPI Service Provider Interface. Java applications use this API to access a variety of naming and directory services. The SPI enables a variety of naming and directory services to be plugged in transparently, allowing the Java application using the API of the JNDI technology to access their services. As you can see form the picture above, JNDI supports LDAP, DNS, NIS, NDS, RMI and CORBA. Of course, you can extend it. How it works In this example, the Java RMI use the JNDI API to look up objects in a network. If you want to look up a object, you need at least two pieces of information Where to \ufb01nd the object The RMI Registry manages the name bindings, it tells you where to \ufb01nd the object. The name of the object What is a objects name? It is": "input.pdf", "usually a string, it can also be a object that implements the Name interface. GoalKicker.com Java Notes for Professionals 807Step by step First you need a registry, which manage the name binding. In this example, we use1. java.rmi.registry .LocateRegistry . This will start a registry on localhost, port 1234 registry LocateRegistry .createRegistry 1234 Both client and server need a Context. Server use the Context to bind the name and object. Client use the2. Context to lookup the name and get the object. We use com.sun.jndi.rmi.registry.RegistryContextFactory as the InitialContextFactory final Hashtable jndiProperties new Hashtable jndiProperties. putContext.INITIALCONTEXTFACTORY , com.sun.jndi.rmi.registry.RegistryContextFactory the registry usrl is rmilocalhost1234 jndiProperties. putContext.PROVIDERURL , rmilocalhost1234 InitialContext ctx new InitialContext jndiProperties The server bind the name and object3. The jndi name is neohopejnditest01 bindJNDI neohopejnditest01 , msg The client look up the object by the name neohopejnditest014. look up the object by name javacomneohopejnditest01 NeoMessage msg NeoMessage ctx.lookupneohopejnditest01 Now the client can use the object5. When the server is ending, need to clean up.6. ctx.unbindneohopejnditest01 ctx.close GoalKicker.com Java Notes for Professionals 808Chapter 146 sun.misc.Unsafe Section 146.1 Instantiating sun.misc.Unsafe via re\ufb02ection public static Unsafe getUnsafe try Field unsafe Unsafe. class.getDeclaredField theUnsafe unsafe. setAccessible true return Unsafe unsafe. getnull catch IllegalAccessException": "input.pdf", "e Handle catch IllegalArgumentException e Handle catch NoSuchFieldException e Handle catch SecurityException e Handle sun.misc.Unsafe has a Private constructor, and the static getUnsafe method is guarded with a check of the classloader to ensure that the code was loaded with the primary classloader. Therefore, one method of loading the instance is to use re\ufb02ection to get the static \ufb01eld. Section 146.2 Instantiating sun.misc.Unsafe via bootclasspath public class UnsafeLoader public static Unsafe loadUnsafe return Unsafe. getUnsafe While this example will compile, it is likely to fail at runtime unless the Unsafe class was loaded with the primary classloader. To ensure that happens the JVM should be loaded with the appropriate arguments, like java -Xbootclasspath JAVAHOME jrelibrt.jar.UnsafeLoader. jar foo.bar.MyApp The foo.bar.MyApp class can then use UnsafeLoader. loadUnsafe . Section 146.3 Getting Instance of Unsafe Unsafe is stored as a private \ufb01eld that cannot be accessed directly. The constructor is private and the only method to access public static Unsafe getUnsafe has privileged access. By use of re\ufb02ection, there is a work-around to make private \ufb01elds accessible public static final Unsafe UNSAFE static Unsafe unsafe null try final PrivilegedExceptionAction Unsafe action - final Field f Unsafe. class.getDeclaredField theUnsafe f. setAccessible true return": "input.pdf", "Unsafe f.getnull GoalKicker.com Java Notes for Professionals 809 unsafe AccessController .doPrivileged action catch final Throwable t throw new RuntimeException Exception accessing Unsafe , t UNSAFE unsafe Section 146.4 Uses of Unsafe Some uses of unsafe is s follows Use API O\ufb00 heap direct memory allocation, reallocation and deallocationallocateMemory bytes, reallocateMemory address, bytes and freeMemory address Memory fences loadFence , storeFence , fullFence Parking current thread parkisAbsolute, time , unparkthread Direct \ufb01eld and or memory access get and put family of methods Throwing unchecked exceptions throwException e CAS and Atomic Operations compareAndSwap family of methods Setting out memory setMemory Volatile or concurrent operations getVolatile , putVolatile , putOrdered The get and put family of methods are relative to a given object. If the object is null then it is treated as an absolute address. Putting a value to a field protected static long fieldOffset UNSAFE. objectFieldOffset getClass .getField theField UNSAFE.putLongthis, fieldOffset , newValue Puting an absolute value UNSAFE. putLongnull, address, newValue UNSAFE. putLongaddress, newValue Some methods are only de\ufb01ned for int and longs. You can use these methods on \ufb02oats and doubles using floatToRawIntBits , intBitsToFloat, doubleToRawLongBits ,longBitsToDouble GoalKicker.com Java Notes for Professionals 810Chapter 147 Java Memory Model Section 147.1": "input.pdf", "Motivation for the Memory Model Consider the following example public class Example public int a, b, c, d public void doIt a b 1 c d 1 If this class is used is a single-threaded application, then the observable behavior will be exactly as you would expect. For instance public class SingleThreaded public static void mainString args Example eg new Example System.out.printlneg.a , eg.c eg. doIt System.out.printlneg.a , eg.c will output 0, 0 1, 1 As far as the main thread can tell , the statements in the main method and the doIt method will be executed in the order that they are written in the source code. This is a clear requirement of the Java Language Speci\ufb01cation JLS. Now consider the same class used in a multi-threaded application. public class MultiThreaded public static void mainString args final Example eg new Example new Threadnew Runnable public void run while true eg. doIt .start while true System.out.printlneg.a , eg.c What will this print? GoalKicker.com Java Notes for Professionals 811In fact, according to the JLS it is not possible to predict that this will print You will probably see a few lines of 0, 0 to start with. Then you probably": "input.pdf", "see lines like N, N or N, N 1. You might see lines like N 1, N. In theory, you might even see that the 0, 0 lines continue forever1. 1 - In practice the presence of the println statements is liable to cause some serendipitous synchronization and memory cache \ufb02ushing. That is likely to hide some of the e\ufb00ects that would cause the above behavior. So how can we explain these? Reordering of assignments One possible explanation for unexpected results is that the JIT compiler has changed the order of the assignments in the doIt method. The JLS requires that statements appear to execute in order from the perspective of the current thread. In this case, nothing in the code of the doIt method can observe the e\ufb00ect of a hypothetical reordering of those two statement. This means that the JIT compiler would be permitted to do that. Why would it do that? On typical modern hardware, machine instructions are executed using a instruction pipeline which allows a sequence of instructions to be in di\ufb00erent stages. Some phases of instruction execution take longer than others, and memory operations tend to take a longer time. A smart compiler can": "input.pdf", "optimize the instruction throughput of the pipeline by ordering the instructions to maximize the amount of overlap. This may lead to executing parts of statements out of order. The JLS permits this provided that not a\ufb00ect the result of the computation from the perspective of the current thread . E\ufb00ects of memory caches A second possible explanation is e\ufb00ect of memory caching. In a classical computer architecture, each processor has a small set of registers, and a larger amount of memory. Access to registers is much faster than access to main memory. In modern architectures, there are memory caches that are slower than registers, but faster than main memory. A compiler will exploit this by trying to keep copies of variables in registers, or in the memory caches. If a variable does not need to be \ufb02ushed to main memory, or does not need to be read from memory, there are signi\ufb01cant performance bene\ufb01ts in not doing this. In cases where the JLS does not require memory operations to be visible to another thread, the Java JIT compiler is likely to not add the read barrier and write barrier instructions that will force main memory reads and writes. Once": "input.pdf", "again, the performance bene\ufb01ts of doing this are signi\ufb01cant. Proper synchronization So far, we have seen that the JLS allows the JIT compiler to generate code that makes single-threaded code faster by reordering or avoiding memory operations. But what happens when other threads can observe the state of the shared variables in main memory? The answer is, that the other threads are liable to observe variable states which would appear to be impossible ... based on the code order of the Java statements. The solution to this is to use appropriate synchronization. The three main approaches are Using primitive mutexes and the synchronized constructs. Using volatile variables. Using higher level concurrency support e.g. classes in the java.util.concurrent packages. GoalKicker.com Java Notes for Professionals 812But even with this, it is important to understand where synchronization is needed, and what e\ufb00ects that you can rely on. This is where the Java Memory Model comes in. The Memory Model The Java Memory Model is the section of the JLS that speci\ufb01es the conditions under which one thread is guaranteed to see the e\ufb00ects of memory writes made by another thread. The Memory Model is speci\ufb01ed with a fair degree of formal rigor": "input.pdf", ", and as a result requires detailed and careful reading to understand. But the basic principle is that certain constructs create a happens-before relation between write of a variable by one thread, and a subsequent read of the same variable by another thread. If the happens before relation exists, the JIT compiler is obliged to generate code that will ensure that the read operation sees the value written by the write. Armed with this, it is possible to reason about memory coherency in a Java program, and decide whether this will be predictable and consistent for all execution platforms. Section 147.2 Happens-before relationships The following is a simpli\ufb01ed version of what the Java Language Speci\ufb01cation says. For a deeper understanding, you need to read the speci\ufb01cation itself. Happens-before relationships are the part of the Memory Model that allow us to understand and reason about memory visibility. As the JLS says JLS 17.4.5 Two actions can be ordered by a happens-before relationship. If one action happens-before another, then the \ufb01rst is visible to and ordered before the second. What does this mean? Actions The actions that the above quote refers to are speci\ufb01ed in JLS 17.4.2 . There are 5": "input.pdf", "kinds of action listed de\ufb01ned by the spec Read Reading a non-volatile variable. Write Writing a non-volatile variable. Synchronization actions Volatile read Reading a volatile variable. Volatile write Writing a volatile variable. Lock. Locking a monitor Unlock. Unlocking a monitor. The synthetic \ufb01rst and last actions of a thread. Actions that start a thread or detect that a thread has terminated. External Actions. An action that has a result that depends on the environment in which the program. Thread divergence actions. These model the behavior of certain kinds of in\ufb01nite loop. GoalKicker.com Java Notes for Professionals 813Program Order and Synchronization Order These two orderings JLS 17.4.3 and JLS 17.4.4 govern the execution of statements in a Java Program order describes the order of statement execution within a single thread. Synchronization order describes the order of statement execution for two statements connected by a synchronization An unlock action on monitor synchronizes-with all subsequent lock actions on that monitor. A write to a volatile variable synchronizes-with all subsequent reads of the same variable by any thread. An action that starts a thread i.e. the call to Thread.start synchronizes-with the \ufb01rst action in the thread it starts i.e. the call to the": "input.pdf", "threads run method. The default initialization of \ufb01elds synchronizes-with the \ufb01rst action in every thread. See the JLS for an explanation of this. The \ufb01nal action in a thread synchronizes-with any action in another thread that detects the termination e.g. the return of a join call or isTerminated call that returns true . If one thread interrupts another thread, the interrupt call in the \ufb01rst thread synchronizes-with the point where another thread detects that the thread was interrupted. Happens-before Order This ordering JLS 17.4.5 is what determines whether a memory write is guaranteed to be visible to a subsequent memory read. More speci\ufb01cally, a read of a variable v is guaranteed to observe a write to v if and only if writev happens-before readv AND there is no intervening write to v. If there are intervening writes, then the readv may see the results of them rather than the earlier one. The rules that de\ufb01ne the happens-before ordering are as follows Happens-Before Rule 1 - If x and y are actions of the same thread and x comes before y in program order , then x happens-before y. Happens-Before Rule 2 - There is a happens-before edge from the": "input.pdf", "end of a constructor of an object to the start of a \ufb01nalizer for that object. Happens-Before Rule 3 - If an action x synchronizes-with a subsequent action y, then x happens-before y. Happens-Before Rule 4 - If x happens-before y and y happens-before z then x happens-before z. In addition, various classes in the Java standard libraries are speci\ufb01ed as de\ufb01ning happens-before relationships. You can interpret this as meaning that it happens somehow , without needing to know exactly how the guarantee is going to be met. Section 147.3 How to avoid needing to understand the Memory Model The Memory Model is di\ufb03cult to understand, and di\ufb03cult to apply. It is useful if you need to reason about the correctness of multi-threaded code, but you do not want to have to do this reasoning for every multi-threaded application that you write. GoalKicker.com Java Notes for Professionals 814If you adopt the following principals when writing concurrent code in Java, you can largely avoid the need to resort to happens-before reasoning. Use immutable data structures where possible. A properly implemented immutable class will be thread-safe, and will not introduce thread-safety issues when you use it with other classes. Understand and": "input.pdf", "avoid unsafe publication. Use primitive mutexes or Lock objects to synchronize access to state in mutable objects that need to be thread-safe1. Use Executor ExecutorService or the fork join framework rather than attempting to create manage threads directly. Use the java.util.concurrent classes that provide advanced locks, semaphores, latches and barriers, instead of using waitnotifynotifyAll directly. Use the java.util.concurrent versions of maps, sets, lists, queues and deques rather than external synchonization of non-concurrent collections. The general principle is to try to use Javas built-in concurrency libraries rather than rolling your own concurrency. You can rely on them working, if you use them properly. 1 - Not all objects need to be thread safe. For example, if an object or objects is thread-con\ufb01ned i.e. it is only accessible to one thread, then its thread-safety is not relevant. Section 147.4 Happens-before reasoning applied to some examples We will present some examples to show how to apply happens-before reasoning to check that writes are visible to subsequent reads. Single-threaded code As you would expect, writes are always visible to subsequent reads in a single-threaded program. public class SingleThreadExample public int a, b public int add a 1 writea b 2 writeb return a": "input.pdf", "b reada followed by readb By Happens-Before Rule 1 The writea action happens-before the writeb action. 1. The writeb action happens-before the reada action. 2. The reada action happens-before the reada action. 3. By Happens-Before Rule 4 writea happens-before writeb AND writeb happens-before reada IMPLIES writea happens-before 4. reada. GoalKicker.com Java Notes for Professionals 815writeb happens-before reada AND reada happens-before readb IMPLIES writeb happens-before 5. readb. Summing up The writea happens-before reada relation means that the a b statement is guaranteed to see the 6. correct value of a. The writeb happens-before readb relation means that the a b statement is guaranteed to see the 7. correct value of b. Behavior of volatile in an example with 2 threads We will use the following example code to explore some implications of the Memory Model for volatile. public class VolatileExample private volatile int a private int b NOT volatile public void updateint first, int second b first writeb a second write-volatilea public int observe return a b read-volatilea followed by readb First, consider the following sequence of statements involving 2 threads A single instance of VolatileExample is created call it ve, 1. ve.update1, 2 is called in one thread, and": "input.pdf", "2. ve.observe is called in another thread. 3. By Happens-Before Rule 1 The writea action happens-before the volatile -writea action. 1. The volatile -reada action happens-before the readb action. 2. By Happens-Before Rule 2 The volatile -writea action in the \ufb01rst thread happens-before the volatile -reada action in the second 3. thread. By Happens-Before Rule 4 The writeb action in the \ufb01rst thread happens-before the readb action in the second thread. 4. In other words, for this particular sequence, we are guaranteed that the 2nd thread will see the update to the non- volatile variable b made by the \ufb01rst thread. However, it is should also be clear that if the assignments in the update method were the other way around, or the observe method read the variable b before a, then the happens-before chain would be broken. The chain would also be broken if volatile -reada in the second thread was not subsequent to the volatile -writea in the \ufb01rst thread. When the chain is broken, there is no guarantee that observe will see the correct value of b. Volatile with three threads GoalKicker.com Java Notes for Professionals 816Suppose we to add a third thread into the previous": "input.pdf", "example A single instance of VolatileExample is created call it ve, 1. Two threads call update 2. ve.update1, 2 is called in one thread, ve.update3, 4 is called in the second thread, ve.observe is subsequently called in a third thread. 3. To analyse this completely, we need to consider all of the possible interleavings of the statements in thread one and thread two. Instead, we will consider just two of them. Scenario 1 - suppose that update1, 2 precedes update3,4 we get this sequence writeb, 1, write-volatile a, 2 first thread writeb, 3, write-volatile a, 4 second thread read-volatile a, readb third thread In this case, it is easy to see that there is an unbroken happens-before chain from writeb, 3 to readb. Furthermore there is no intervening write to b. So, for this scenario, the third thread is guaranteed to see b as having value 3. Scenario 2 - suppose that update1, 2 and update3,4 overlap and the ations are interleaved as follows writeb, 3 second thread writeb, 1 first thread write-volatile a, 2 first thread write-volatile a, 4 second thread read-volatile a, readb third thread Now, while there is a happens-before chain from writeb, 3 to readb,": "input.pdf", "there is an intervening writeb, 1 action performed by the other thread. This means we cannot be certain which value readb will see. Aside This demonstrates that we cannot rely on volatile for ensuring visibility of non-volatile variables, except in very limited situations. GoalKicker.com Java Notes for Professionals 817Chapter 148 Java deployment There are a variety of technologies for packaging Java applications, webapps and so forth, for deployment to the platform on which they will run. They range from simple library or executable JAR \ufb01les, WAR and EAR \ufb01les, through to installers and self-contained executables. Section 148.1 Making an executable JAR from the command line To make a jar, you need one or more class \ufb01les. This should have a main method if it is to be run by a double click. For this example, we will use import javax.swing. import java.awt.Container public class HelloWorld public static void mainString args JFrame f new JFrameHello, World JLabel label new JLabelHello, World Container cont f.getContentPane cont. addlabel f. setSize400,100 f. setVisible true f. setDefaultCloseOperation JFrame.EXITONCLOSE It has been named HelloWorld.java Next, we want to compile this program. You may use any program you want to do this. To run from the": "input.pdf", "command line, see the documentation on compiling and running your \ufb01rst java program. Once you have HelloWorld.class, make a new folder and call it whatever you want. Make another \ufb01le called manifest.txt and paste into it Main-Class HelloWorld Class-Path HelloWorld. jar Put it in the same folder with HelloWorld.class Use the command line to make your current directory cd CYourFolderPathHere on windows your folder. Use Terminal and change directory to the directory cd UsersuserDocuments Javajarfolder on Mac your folder When that is done, type in jar -cvfm HelloWorld. jar manifest. txt HelloWorld. class and press enter. This makes a jar \ufb01le in the folder with your manifest and HelloWorld.class using the .class \ufb01les speci\ufb01ed and named HelloWorld.jar. See the Syntax section for information about the options like -m and -v. After these steps, go to your directory with the manifest \ufb01le and you should \ufb01nd HelloWorld.jar Clicking on it should display Hello, World in a text box. GoalKicker.com Java Notes for Professionals 818Section 148.2 Creating an UberJAR for an application and its dependencies A common requirement for a Java application is that can be deployed by copying a single \ufb01le. For simple applications that depend only on the standard": "input.pdf", "Java SE class libraries, this requirement is satis\ufb01ed by creating a JAR \ufb01le containing all of the compiled application classes. Things are not so straightforward if the application depends on third-party libraries. If you simply put dependency JAR \ufb01les inside an application JAR, the standard Java class loader will not be able to \ufb01nd the library classes, and your application will not start. Instead, you need to create a single JAR \ufb01le that contains the application classes and associated resources together with the dependency classes and resources. These need to be organized as a single namespace for the classloader to search. The such a JAR \ufb01le is often referred to as an UberJAR. Creating an UberJAR using the jar command The procedure for creating an UberJAR is straight-forward. I will use Linux commands for simplicity. The commands should be identical for Mac OS, and similar for Windows. Create a temporary directory, and change directory to it.1. mkdir tempDir cd tempDir For each dependent JAR \ufb01le, in the reverse order that they need to appear on the applications classpath, used 2. the jar command to unpack the JAR into the temporary directory. jar -xf pathtofile.jar Doing this for multiple JAR": "input.pdf", "\ufb01les will overlay contents of the JARs. Copy the application classes from the build tree into the temporary directory3. cp -r pathtoclasses . Create the UberJAR from the contents of the temporary directory4. jar -cf ..myApplication. jar If you are creating an executable JAR \ufb01le, include an appropriate MANIFEST.MF as described here. Creating an UberJAR using Maven If your project is built using Maven, you can get it to create an UberJAR using either the maven-assembly or maven-shade plugins. See the Maven Assembly topic in the Maven documentation for details. The advantages and drawbacks of UberJARs Some of advantages of UberJARs are self-evident An UberJAR is easy to distribute. GoalKicker.com Java Notes for Professionals 819You cannot break the library dependencies for an UberJAR, since the libraries are self-contained. In addition, if you use an appropriate tooling to create the UberJAR, you will have the option of excluding library classes that are not used from the JAR \ufb01le. However, that this is typically done by static analysis of the classes. If your application uses re\ufb02ection, annotation processing and similar techniques, you need to be careful that classes are not excluded incorrectly. UberJARs also have some disadvantages If you have lots": "input.pdf", "of UberJARs with the same dependencies, then each one will contain a copy of the dependencies. Some open source libraries have licenses which may preclude 1 their use in an UberJAR. 1 - Some open source library licenses allow you to use the library only of the end-user is able to replace one version of the library with another. UberJARs can make replacement of version dependencies di\ufb03cult. Section 148.3 Creating JAR, WAR and EAR \ufb01les The JAR, WAR and EAR \ufb01les types are fundamentally ZIP \ufb01les with a manifest \ufb01le and for WAR and EAR \ufb01les a particular internal directory \ufb01le structure. The recommended way to create these \ufb01les is to use a Java-speci\ufb01c build tool which understands the requirements for the respective \ufb01le types. If you dont use a build tool, then IDE export is the next option to try. Editorial note the descriptions of how to create these \ufb01les are best placed in the documentation for the respective tools. Put them there. Please show some self-restraint and DONT shoe-horn them into this example! Creating JAR and WAR \ufb01les using Maven Creating a JAR or WAR using Maven is simply a matter of putting the correct packaging element": "input.pdf", "into the POM \ufb01le e,g, packaging jarpackaging or packaging warpackaging For more details. Maven can be con\ufb01gured to create executable JAR \ufb01les by adding the requisite information about the entry-point class and external dependencies as plugin properties for the maven jar plugin. There is even a plugin for creating uberJAR \ufb01les that combine an application and its dependencies into a single JAR \ufb01le. Please refer to the Maven documentation httpstackover\ufb02ow.comdocumentationmaventopics for more information. Creating JAR, WAR and EAR \ufb01les using Ant The Ant build tool has separate tasks for building JAR, WAR and EAR. Please refer to the Ant documentation httpstackover\ufb02ow.comdocumentationanttopics for more information. Creating JAR, WAR and EAR \ufb01les using an IDE The three most popular Java IDEs all have built-in support for creating deployment \ufb01les. The functionality is often described as exporting. GoalKicker.com Java Notes for Professionals 820Eclipse - httpstackover\ufb02ow.comdocumentationeclipsetopics NetBeans - httpstackover\ufb02ow.comdocumentationnetbeanstopics Intellij-IDEA - Exporting Creating JAR, WAR and EAR \ufb01les using the jar command. It is also possible to create these \ufb01les by hand using the jar command. It is simply a matter of assembling a \ufb01le tree with the correct component \ufb01les in the correct place, creating a manifest \ufb01le, and running jar to": "input.pdf", "create the JAR \ufb01le. Please refer to the jar command Topic Creating and modifying JAR \ufb01les for more information Section 148.4 Introduction to Java Web Start The Oracle Java Tutorials summarize Web Start as follows Java Web Start software provides the power to launch full-featured applications with a single click. Users can download and launch applications, such as a complete spreadsheet program or an Internet chat client, without going through lengthy installation procedures. Other advantages of Java Web Start are support for signed code and explicit declaration of platform dependencies, and support for code caching and deployment of application updates. Java Web Start is also referred to as JavaWS and JAWS. The primary sources of information are The Java Tutorials - Lesson Java Web Start Java Web Start Guide Java Web Start FAQ JNLP Speci\ufb01cation javax.jnlp API Documentation Java Web Start Developers Site Prerequisites At a high level, Web Start works by distributing Java applications packed as JAR \ufb01les from a remote webserver. The prerequisites are A pre-existing Java installation JRE or JDK on the target machine where the application is to run. Java 1.2.2 or higher is required From Java 5.0 onwards, Web Start support is included in": "input.pdf", "the JRE JDK. For earlier releases, Web Start support is installed separately. The Web Start infrastructure includes some Javascript that can be included in a web page to assist the user to install the necessary software. The webserver that hosts the software must be accessible to the target machine. If the user is going to launch a Web Start application using a link in a web page, then they need a compatible web browser, and for modern secure browsers, they need to be told how to tell the browser to allow Java to run ... without compromising web browser security. GoalKicker.com Java Notes for Professionals 821An example JNLP \ufb01le The following example is intended to illustrate the basic functionality of JNLP. ?xml version1.0 encoding UTF-8? jnlp spec1.0 codebase httpswww.example.comdemo hrefdemowebstart.jnlp information titleDemotitle vendorThe Example.com Team vendor information resources !-- Application Resources -- j2se version1.7 hrefhttpjava.sun.comproductsautodlj2se jar hrefDemo.jar maintrue resources application-desc nameDemo Application main-class com.example.jwsdemo.Main width300 height300 application-desc update checkbackground jnlp As you can see, a JNLP \ufb01le XML-based, and the information is all contained in the jnlp element. The spec attribute gives the version of the JNPL spec that this \ufb01le conforms to. The codebase attribute gives the base": "input.pdf", "URL for resolving relative href URLs in the rest of the \ufb01le. The href attribute gives the de\ufb01nitive URL for this JNLP \ufb01le. The information element contains metadata the application including its title, authors, description and help website. The resources element describes the dependencies for the application including the required Java version, OS platform and JAR \ufb01les. The application-desc or applet-desc element provides information needed to launch the application. Setting up the web server The webserver must be con\ufb01gured to use application x-java-jnlp-file as the MIMEtype for .jnlp \ufb01les. The JNLP \ufb01le and the applications JAR \ufb01les must be installed on the webserver so that they are available using the URLs indicated by the JNLP \ufb01le. Enabling launch via a web page If the application is to be launched via a web link, the page that contains the link must be created on the webserver. If you can assume that Java Web Start is already installed on the users machine, then the web page simply needs to contain a link for launching the application. For example. a hrefhttpswww.example.comdemowebstart.jnlp Launch the application a Otherwise, the page should also include some scripting to detect the kind of browser the user is": "input.pdf", "using and request to download and install the required version of Java. GoalKicker.com Java Notes for Professionals 822NOTE It is a bad idea to encourage users to encourage to install Java this way, or even to enable Java in their web browsers so that JNLP web page launch will work. Launching Web Start applications from the command line The instructions for launching an Web Start application from the command line are simple. Assuming that the user has a Java 5.0 JRE or JDK installed, the simply need to run this javaws url where url is the URL for the JNLP \ufb01le on the remote server. GoalKicker.com Java Notes for Professionals 823Chapter 149 Java plugin system implementations Section 149.1 Using URLClassLoader There are several ways to implement a plugin system for a Java application. One of the simplest is to use URLClassLoader . The following example will involve a bit of JavaFX code. Suppose we have a module of a main application. This module is supposed to load plugins in form of Jars from plugins folder. Initial code package main public class MainApplication extends Application Override public void startStage primaryStage throws Exception File pluginDirectory new Fileplugins arbitrary directory if!pluginDirectory. existspluginDirectory.": "input.pdf", "mkdir VBox loadedPlugins new VBox6 a container to show the visual info later Rectangle2D screenbounds Screen.getPrimary .getVisualBounds Scene scene new SceneloadedPlugins,screenbounds. getWidth 2,screenbounds. getHeight 2 primaryStage. setScene scene primaryStage. show public static void mainString a launch a Then, we create an interface which will represent a plugin. package main public interface Plugin default void initialize System.out.printlnInitialized this.getClass .getName default String namereturn getClass .getSimpleName We want to load classes which implement this interface, so \ufb01rst we need to \ufb01lter \ufb01les which have a .jar extension File filespluginDirectory. listFiles dir, name - name.endsWith .jar If there are any \ufb01les, we need to create collections of URLs and class names iffiles!null files.length0 ArrayList String classes new ArrayList ArrayList URL urlsnew ArrayList files.length forFile filefiles GoalKicker.com Java Notes for Professionals 824 JarFile jarnew JarFilefile jar. stream.forEachjarEntry - ifjarEntry. getName.endsWith .class classes. addjarEntry. getName URL urlfile.toURI.toURL urls. addurl Lets add a static HashSet to MainApplication which will hold loaded plugins static HashSet Plugin plugins new HashSet Next, we instantiate a URLClassLoader , and iterate over class names, instantiating classes which implement Plugin interface URLClassLoader urlClassLoader new URLClassLoader urls.toArraynew URLurls.size classes. forEachclassName - try Class clsurlClassLoader. loadClass className. replaceAll ,..replace.class , transforming to binary name": "input.pdf", "Class interfaces cls.getInterfaces forClass intface interfaces ifintface. equalsPlugin.class checking presence of Plugin interface Plugin plugin Plugin cls.newInstance instantiating the Plugin plugins. addplugin break catch Exception ee.printStackTrace Then, we can call plugins methods, for example, to initialize them if!plugins. isEmptyloadedPlugins. getChildren .addnew LabelLoaded plugins plugins. forEachplugin - plugin. initialize loadedPlugins. getChildren .addnew Labelplugin.name The \ufb01nal code of MainApplication package main public class MainApplication extends Application static HashSet Plugin plugins new HashSet Override public void startStage primaryStage throws Exception File pluginDirectory new Fileplugins if!pluginDirectory. existspluginDirectory. mkdir GoalKicker.com Java Notes for Professionals 825 File filespluginDirectory. listFiles dir, name - name.endsWith .jar VBox loadedPlugins new VBox6 loadedPlugins. setAlignment Pos.CENTER iffiles!null files.length0 ArrayList String classes new ArrayList ArrayList URL urlsnew ArrayList files.length forFile filefiles JarFile jarnew JarFilefile jar. stream.forEachjarEntry - ifjarEntry. getName.endsWith .class classes. addjarEntry. getName URL urlfile.toURI.toURL urls. addurl URLClassLoader urlClassLoader new URLClassLoader urls.toArraynew URLurls.size classes. forEachclassName - try Class clsurlClassLoader. loadClass className. replaceAll ,..replace.class , Class interfaces cls.getInterfaces forClass intface interfaces ifintface. equalsPlugin.class Plugin plugin Plugin cls.newInstance plugins. addplugin break catch Exception ee.printStackTrace if!plugins. isEmptyloadedPlugins. getChildren .addnew LabelLoaded plugins plugins. forEachplugin - plugin. initialize loadedPlugins. getChildren .addnew Labelplugin.name Rectangle2D screenbounds Screen.getPrimary .getVisualBounds Scene scene new SceneloadedPlugins,screenbounds. getWidth 2,screenbounds. getHeight 2 primaryStage. setScene": "input.pdf", "scene primaryStage. show public static void mainString a launch a Lets create two plugins. Obviously, the plugins source should be in a separate module. package plugins import main.Plugin GoalKicker.com Java Notes for Professionals 826public class FirstPlugin implements Plugin this plugin has default behaviour Second plugin package plugins import main.Plugin public class AnotherPlugin implements Plugin Override public void initialize overrided to show users home directory System.out.printlnUser home directory System.getProperty user.home These plugins have to be packaged into standard Jars - this process depends on your IDE or other tools. When Jars will be put into plugins directly, MainApplication will detect them and instantiate appropriate classes. GoalKicker.com Java Notes for Professionals 827Chapter 150 JavaBean JavaBeans TM is a pattern for designing Java class APIs that allows instances beans to be used in various contexts and using various tools without explicitly writing Java code. The patterns consists of conventions for de\ufb01ning getters and setters for properties , for de\ufb01ning constructors, and for de\ufb01ning event listener APIs. Section 150.1 Basic Java Bean public class BasicJavaBean implements java.io.Serializable private int value1 private String value2 private boolean value3 public BasicJavaBean public void setValue1 int value1 this.value1 value1 public int getValue1 return value1 public void setValue2": "input.pdf", "String value2 this.value2 value2 public String getValue2 return value2 public void setValue3 boolean value3 this.value3 value3 public boolean isValue3 return value3 GoalKicker.com Java Notes for Professionals 828Chapter 151 Java SE 7 Features In this topic youll \ufb01nd a summary of the new features added to the Java programming language in Java SE 7. There are many other new features in other \ufb01elds such as JDBC and Java Virtual Machine JVM that are not going to be covered in this topic. Section 151.1 New Java SE 7 programming language features Binary Literals The integral types byte, short, int, and long can also be expressed using the binary number system. To specify a binary literal, add the pre\ufb01x 0b or 0B to the number. Strings in switch Statements You can use a String object in the expression of a switch statement The try-with-resources Statement The try-with-resources statement is a try statement that declares one or more resources. A resource is as an object that must be closed after the program is \ufb01nished with it. The try- with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement": "input.pdf", "java.io.Closeable, can be used as a resource. Catching Multiple Exception Types and Rethrowing Exceptions with Improved Type Checking a single catch block can handle more than one type of exception. This feature can reduce code duplication and lessen the temptation to catch an overly broad exception. Underscores in Numeric Literals Any number of underscore characters can appear anywhere between digits in a numerical literal. This feature enables you, for example, to separate groups of digits in numeric literals, which can improve the readability of your code. Type Inference for Generic Instance Creation You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond. Improved Compiler Warnings and Errors When Using Non-Rei\ufb01able Formal Parameters with Varargs Methods Section 151.2 Binary Literals An 8-bit byte value byte aByte byte0b00100001 A 16-bit short value short aShort short0b1010000101000101 Some 32-bit int values int anInt1 0b10100001010001011010000101000101 int anInt2 0b101 int anInt3 0B101 The B can be upper or lower case. A 64-bit long value. Note the L suffix long aLong": "input.pdf", "0b1010000101000101101000010100010110100001010001011010000101000101L Section 151.3 The try-with-resources statement The example reads the \ufb01rst line from a \ufb01le. It uses an instance of BufferedReader to read data from the \ufb01le. BufferedReader is a resource that must be closed after the program is \ufb01nished with it static String readFirstLineFromFile String path throws IOException try BufferedReader br new BufferedReader new FileReader path return br.readLine GoalKicker.com Java Notes for Professionals 829 In this example, the resource declared in the try-with-resources statement is a BufferedReader . The declaration statement appears within parentheses immediately after the try keyword. The class BufferedReader , in Java SE 7 and later, implements the interface java.lang.AutoCloseable . Because the BufferedReader instance is declared in a try-with-resource statement, it will be closed regardless of whether the try statement completes normally or abruptly as a result of the method BufferedReader .readLine throwing an IOException . Section 151.4 Underscores in Numeric Literals The following example shows other ways you can use the underscore in numeric literals long creditCardNumber 1234567890123456L long socialSecurityNumber 999999999L float pi 3.1415F long hexBytes 0xFFECDE5E long hexWords 0xCAFEBABE long maxLong 0x7fffffffffffffffL byte nybbles 0b00100101 long bytes 0b11010010011010011001010010010010 You can place underscores only between digits you cannot place underscores in the following": "input.pdf", "places At the beginning or end of a number Adjacent to a decimal point in a \ufb02oating point literal Prior to an F or L su\ufb03x In positions where a string of digits is expected Section 151.5 Type Inference for Generic Instance Creation You can use MapString, ListString myMap new HashMap instead of MapString, ListString myMap new HashMap String, ListString However, you cant use ListString list new ArrayList list.addA The following statement should fail since addAll expects Collection? extends String list.addAllnew ArrayList because it cant compile. Note that the diamond often works in method calls however, it is suggested that you use the diamond primarily for variable declarations. Section 151.6 Strings in switch Statements public String getTypeOfDayWithSwitchStatement String dayOfWeekArg String typeOfDay GoalKicker.com Java Notes for Professionals 830 switch dayOfWeekArg case Monday typeOfDay Start of work week break case Tuesday case Wednesday case Thursday typeOfDay Midweek break case Friday typeOfDay End of work week break case Saturday case Sunday typeOfDay Weekend break default throw new IllegalArgumentException Invalid day of the week dayOfWeekArg return typeOfDay GoalKicker.com Java Notes for Professionals 831Chapter 152 Java SE 8 Features In this topic youll \ufb01nd a summary of the new features added to the Java": "input.pdf", "programming language in Java SE 8. There are many other new features in other \ufb01elds such as JDBC and Java Virtual Machine JVM that are not going to be covered in this topic. Section 152.1 New Java SE 8 programming language features Lambda Expressions , a new language feature, has been introduced in this release. They enable you to treat functionality as a method argument, or code as data. Lambda expressions let you express instances of single-method interfaces referred to as functional interfaces more compactly. Method references provide easy-to-read lambda expressions for methods that already have a name. Default methods enable new functionality to be added to the interfaces of libraries and ensure binary compatibility with code written for older versions of those interfaces. New and Enhanced APIs That Take Advantage of Lambda Expressions and Streams in Java SE 8 describe new and enhanced classes that take advantage of lambda expressions and streams. Improved Type Inference - The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. The target type of an expression is the data type that the Java compiler expects depending on where the expression appears. For example, you": "input.pdf", "can use an assignment statements target type for type inference in Java SE 7. However, in Java SE 8, you can use the target type for type inference in more contexts. Target Typing in Lambda Expressions Type Inference Repeating Annotations provide the ability to apply the same annotation type more than once to the same declaration or type use. Type Annotations provide the ability to apply an annotation anywhere a type is used, not just on a declaration. Used with a pluggable type system, this feature enables improved type checking of your code. Method parameter re\ufb02ection - You can obtain the names of the formal parameters of any method or constructor with the method java.lang.reflect.Executable .getParameters . The classes Method and Constructor extend the class Executable and therefore inherit the method Executable. getParameters However, .class \ufb01les do not store formal parameter names by default. To store formal parameter names in a particular .class \ufb01le, and thus enable the Re\ufb02ection API to retrieve formal parameter names, compile the source \ufb01le with the -parameters option of the javac compiler. Date-time-api - Added new time api in java.time . If used this, you dont need to designate timezone. GoalKicker.com Java Notes for": "input.pdf", "Professionals 832Chapter 153 Dynamic Method Dispatch What is Dynamic Method Dispatch? Dynamic Method Dispatch is a process in which the call to an overridden method is resolved at runtime rather than at compile-time. When an overridden method is called by a reference, Java determines which version of that method to execute based on the type of object it refer to. This is also know as runtime polymorphism. We will see this through an example. Section 153.1 Dynamic Method Dispatch - Example Code Abstract Class package base Abstract classes cannot be instantiated, but they can be subclassed public abstract class ClsVirusScanner With One Abstract method public abstract void fnStartScan protected void fnCheckForUpdateVersion System.out.printlnPerform Virus Scanner Version Check protected void fnBootTimeScan System.out.printlnPerform BootTime Scan protected void fnInternetSecutiry System.out.printlnScan for Internet Security protected void fnRealTimeScan System.out.printlnPerform RealTime Scan protected void fnVirusMalwareScan System.out.printlnDetect Virus Malware Overriding Abstract Method in Child Class import base.ClsVirusScanner All the 3 child classes inherits the base class ClsVirusScanner Child Class 1 class ClsPaidVersion extends ClsVirusScanner Override public void fnStartScan super.fnCheckForUpdateVersion super.fnBootTimeScan GoalKicker.com Java Notes for Professionals 833 super.fnInternetSecutiry super.fnRealTimeScan super.fnVirusMalwareScan ClsPaidVersion IS-A ClsVirusScanner Child Class 2 class ClsTrialVersion extends ClsVirusScanner Override public void fnStartScan super.fnInternetSecutiry super.fnVirusMalwareScan ClsTrialVersion IS-A": "input.pdf", "ClsVirusScanner Child Class 3 class ClsFreeVersion extends ClsVirusScanner Override public void fnStartScan super.fnVirusMalwareScan ClsTrialVersion IS-A ClsVirusScanner DynamicLate Binding leads to Dynamic method dispatch Calling Class public class ClsRunTheApplication public static void mainString args final String VIRUSSCANNERVERSION TRIALVERSION Parent Refers Null ClsVirusScanner objVS null String Cases Supported from Java SE 7 switch VIRUSSCANNERVERSION case FREEVERSION Parent Refers Child Object 3 ClsFreeVersion IS-A ClsVirusScanner objVS new ClsFreeVersion Dynamic or Runtime Binding break case PAIDVERSION Parent Refers Child Object 1 ClsPaidVersion IS-A ClsVirusScanner objVS new ClsPaidVersion Dynamic or Runtime Binding break case TRIALVERSION Parent Refers Child Object 2 objVS new ClsTrialVersion Dynamic or Runtime Binding break Method fnStartScan is the Version of ClsTrialVersion objVS. fnStartScan GoalKicker.com Java Notes for Professionals 834 Result Scan for Internet Security Detect Virus Malware Upcasting objVS new ClsFreeVersion objVS new ClsPaidVersion objVS new ClsTrialVersion GoalKicker.com Java Notes for Professionals 835Chapter 154 Generating Java Code Section 154.1 Generate POJO From JSON Install JSON Model Genrator plugin of Intellij by searching in Intellij setting. Start the plugin from Tools Input the \ufb01eld of UI as following shows Path Source Package is required Click Generate button and your are done. GoalKicker.com Java Notes for Professionals 836Chapter 155 JShell JShell is": "input.pdf", "an interactive REPL for Java added in JDK 9. It allows developers to instantly evaluate expressions, test classes, and experiment with the Java language. Early access for jdk 9 can be obtained from httpjdk.java.net9 Section 155.1 Editting Snippets The basic unit of code used by JShell is the snippet , or source entry . Every time you declare a local variable or de\ufb01ne a local method or class, you create a snippet whose name is the identi\ufb01er of the variablemethodclass. At any time, you can edit a snippet you have created with the edit command. For example, lets say I have created the class Foo with a single, method, bar jshell class Foo ... void bar ... ... Now, I want to \ufb01ll in the body of my method. Rather than rewrite the entire class, I can edit it jshell edit Foo By default, a swing editor will pop up with the most basic features possible. However you can change the editor that JShell uses jshell set editor emacs jshell set editor vi jshell set editor nano jshell set editor -default Note that if the new version of the snippet contains any syntax errors, it may not be saved.": "input.pdf", "Likewise, a snippet is only created if the original declarationde\ufb01nition is syntactically correct the following does not work jshell String st String 3 error omitted jshell edit st No such snippet st However, snippets may be compiled and hence editable despite certain compile-time errors, such as mismatched types the following works jshell int i hello error omitted jshell edit i Finally, snippets may be deleted using the drop command jshell int i 13 jshell drop i jshell System.out.printlni Error cannot find symbol symbol variable i System.out.printlni GoalKicker.com Java Notes for Professionals 837To delete all snippets, thereby reseting the state of the JVM, use reset jshell int i 2 jshell String s hi jshell reset Resetting state. jshell i Error cannot find symbol symbol variable i i jshell s Error cannot find symbol symbol variable s s Section 155.2 Entering and Exiting JShell Starting JShell Before trying to start JShell, make sure your JAVAHOME environment variable points to a JDK 9 installation. To start JShell, run the following command jshell If all goes well, you should see a jshell prompt. Exiting JShell To exit JShell, run the following command from the JShell prompt jshell exit Section 155.3 Expressions Within JShell,": "input.pdf", "you can evaluate Java expressions, with or without semicolons. These can range from basic expressions and statements to more complex ones jshell 42 jshell System.out.printfI am d years old. n, 421 Loops and conditionals are \ufb01ne, too jshell for int i 0 i3 i ... System.out.printlni ... It is important to note that expressions within blocks must have semicolons! GoalKicker.com Java Notes for Professionals 838Section 155.4 Methods and Classes You can de\ufb01ne methods and classes within JShell jshell void speak ... System.out.printlnhello ... jshell class MyClass ... void doNothing ... No access modi\ufb01ers are necessary. As with other blocks, semicolons are required inside of method bodies. Keep in mind that, as with variables, it is possible to rede\ufb01ne methods and classes. To see a list of methods or classes, enter methods or types at the JShell prompt, respectively. Section 155.5 Variables You can declare local variables within JShell jshell String s hi jshell int i s.length Keep in mind that variables can be redeclared with di\ufb00erent types this is perfectly valid in JShell jshell String var hi jshell int var 3 To see a list of variables, enter vars at the JShell prompt. GoalKicker.com Java Notes for Professionals 839Chapter": "input.pdf", "156 Stack-Walking API Prior to Java 9, access to the thread stack frames was limited to an internal class sun.reflect.Reflection . Speci\ufb01cally the method sun.reflect.Reflection getCallerClass . Some libraries relies on this method which is deprecated. An alternative standard API is now provided in JDK 9 via the java.lang.StackWalker class, and is designed to be e\ufb03cient by allowing lazy access to the stack frames. Some applications may use this API to traverse the execution stack and \ufb01lter on classes. Section 156.1 Print all stack frames of the current thread The following prints all stack frames of the current thread 1 package test 2 3 import java.lang.StackWalker.StackFrame 4 import java.lang.reflect.InvocationTargetException 5 import java.lang.reflect.Method 6 import java.util.List 7 import java.util.stream.Collectors 8 9 public class StackWalkerExample 10 11 public static void mainString args throws NoSuchMethodException , SecurityException , IllegalAccessException , IllegalArgumentException , InvocationTargetException 12 Method fooMethod FooHelper. class.getDeclaredMethod foo, Class?null 13 fooMethod. invokenull, Object null 14 15 16 17 class FooHelper 18 protected static void foo 19 BarHelper. bar 20 21 22 23 class BarHelper 24 protected static void bar 25 List StackFrame stack StackWalker. getInstance 26 . walks - s.collectCollectors. toList 27 forStackFrame frame stack 28 System.out.printlnframe.getClassName frame.getLineNumber frame.getMethodName 29 30": "input.pdf", "31 Output test.BarHelper 26 bar test.FooHelper 19 foo test.StackWalkerExample 13 main GoalKicker.com Java Notes for Professionals 840Section 156.2 Print current caller class The following prints the current caller class. Note that in this case, the StackWalker needs to be created with the option RETAINCLASSREFERENCE , so that Class instances are retained in the StackFrame objects. Otherwise an exception would occur. public class StackWalkerExample public static void mainString args FooHelper. foo class FooHelper protected static void foo BarHelper. bar class BarHelper protected static void bar System.out.printlnStackWalker. getInstance Option.RETAINCLASSREFERENCE .getCallerClass Output class test.FooHelper Section 156.3 Showing re\ufb02ection and other hidden frames A couple of other options allow stack traces to include implementation andor re\ufb02ection frames. This may be useful for debugging purposes. For instance, we can add the SHOWREFLECTFRAMES option to the StackWalker instance upon creation, so that the frames for the re\ufb02ective methods are printed as well package test import java.lang.StackWalker.Option import java.lang.StackWalker.StackFrame import java.lang.reflect.InvocationTargetException import java.lang.reflect.Method import java.util.List import java.util.stream.Collectors public class StackWalkerExample public static void mainString args throws NoSuchMethodException , SecurityException , IllegalAccessException , IllegalArgumentException , InvocationTargetException Method fooMethod FooHelper. class.getDeclaredMethod foo, Class?null fooMethod. invokenull, Object null class FooHelper protected static void foo GoalKicker.com Java Notes for Professionals": "input.pdf", "841 BarHelper. bar class BarHelper protected static void bar show reflection methods List StackFrame stack StackWalker. getInstance Option.SHOWREFLECTFRAMES . walks - s.collectCollectors. toList forStackFrame frame stack System.out.printlnframe.getClassName frame.getLineNumber frame.getMethodName Output test.BarHelper 27 bar test.FooHelper 20 foo jdk.internal.reflect.NativeMethodAccessorImpl -2 invoke0 jdk.internal.reflect.NativeMethodAccessorImpl 62 invoke jdk.internal.reflect.DelegatingMethodAccessorImpl 43 invoke java.lang.reflect.Method 563 invoke test.StackWalkerExample 14 main Note that line numbers for some re\ufb02ection methods may not be available so StackFrame. getLineNumber may return negative values. GoalKicker.com Java Notes for Professionals 842Chapter 157 Sockets A socket is one end-point of a two-way communication link between two programs running on the network. Section 157.1 Read from socket String hostName args0 int portNumber Integer.parseInt args1 try Socket echoSocket new SockethostName, portNumber PrintWriter out new PrintWriter echoSocket. getOutputStream , true BufferedReader in new BufferedReader new InputStreamReader echoSocket. getInputStream BufferedReader stdIn new BufferedReader new InputStreamReader System.in Use the socket GoalKicker.com Java Notes for Professionals 843Chapter 158 Java Sockets Sockets are a low-level network interface that helps in creating a connection between two program mainly clients which may or may not be running on the same machine. Socket Programming is one of the most widely used networking concepts. Section 158.1 A simple TCP echo back server Our TCP echo back": "input.pdf", "server will be a separate thread. Its simple as its a start. It will just echo back whatever you send it but in capitalised form. public class CAPECHOServer extends Thread This class implements server sockets. A server socket waits for requests to come in over the network only when it is allowed through the local firewall ServerSocket serverSocket public CAPECHOServer int port, int timeout try Create a new Server on specified port. serverSocket new ServerSocket port SoTimeout is basiacally the socket timeout. timeout is the time until socket timeout in milliseconds serverSocket. setSoTimeout timeout catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Override public void run try We want the server to continuously accept connections while!Thread.interrupted Close the server once done. serverSocket. close catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Now to accept connections. Lets update the run method. Override public void run while!Thread.interrupted try Log with the port number and machine ip Logger. getLogger this.getClass .getName.logLevel.INFO, Listening for Clients at 0 on 1 , new ObjectserverSocket. getLocalPort , InetAddress .getLocalHost .getHostAddress Socket client serverSocket. accept Accept client conncetion Now get DataInputStream and DataOutputStreams GoalKicker.com Java Notes for Professionals 844 DataInputStream istream new DataInputStream client.getInputStream From": "input.pdf", "clients input stream DataOutputStream ostream new DataOutputStream client.getOutputStream Important Note The servers input is the clients output The clients input is the servers output Send a welcome message ostream. writeUTF Welcome! Close the connection istream. close ostream. close client. close catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Close the server once done try serverSocket. close catch IOException ex Logger. getLogger CAPECHOServer. class.getName.logLevel.SEVERE, null, ex Now if you can open telnet and try connecting Youll see a Welcome message. You must connect with the port you speci\ufb01ed and IP Adress. You should see a result similar to this Welcome! Connection to host lost. Well, the connection was lost because we terminated it. Sometimes we would have to program our own TCP client. In this case, we need a client to request input from the user and send it across the network, receive the capitalised input. If the server sends data \ufb01rst, then the client must read the data \ufb01rst. public class CAPECHOClient extends Thread Socket server Scanner key Scanner for input public CAPECHOClient String ip, int port try server new Socketip, port key new Scanner System.in catch IOException ex Logger. getLogger CAPECHOClient. class.getName.logLevel.SEVERE, null, ex Override GoalKicker.com Java": "input.pdf", "Notes for Professionals 845 public void run DataInputStream istream null DataOutputStream ostream null try istream new DataInputStream server.getInputStream Familiar lines ostream new DataOutputStream server.getOutputStream System.out.printlnistream. readUTF Print what the server sends System.out.print String tosend key.nextLine ostream. writeUTF tosend Send whatever the user typed to the server System.out.printlnistream. readUTF Finally read what the server sends before exiting. catch IOException ex Logger. getLogger CAPECHOClient. class.getName.logLevel.SEVERE, null, ex finally try istream. close ostream. close server. close catch IOException ex Logger. getLogger CAPECHOClient. class.getName.logLevel.SEVERE, null, ex Now update the server ostream. writeUTF Welcome! String inString istream. readUTF Read what the user sent String outString inString. toUpperCase Change it to caps ostream. writeUTF outString Close the connection istream. close And now run the server and client, You should have an output similar to this Welcome! GoalKicker.com Java Notes for Professionals 846Chapter 159 FTP File Transfer Protocol Parameters Details host Either the host name or IP address of the FTP server port The FTP server port username The FTP server username password The FTP server password Section 159.1 Connecting and Logging Into a FTP Server To start using FTP with Java, you will need to create a new FTPClient and then connect and login to": "input.pdf", "the server using .connectString server, int port and .loginString username, String password . import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply Import all the required resource for this project. public class FTPConnectAndLogin public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com Server can be either host name or IP address. int port 21 String user Username String pass Password FTPClient ftp new FTPClient ftp. connectserver, port ftp. loginuser, pass Now we have the basics done. But what if we have an error connecting to the server? Well want to know when something goes wrong and get the error message. Lets add some code to catch errors while connecting. try ftp. connectserver, port showServerReply ftp int replyCode ftp.getReplyCode if !FTPReply. isPositiveCompletion replyCode System.out.printInOperation failed. Server reply code replyCode return ftp. loginuser, pass catch Lets break down what we just did, step by step. showServerReply ftp This refers to a function we will be making in a later step. int replyCode ftp.getReplyCode GoalKicker.com Java Notes for Professionals 847This grabs the replyerror code from the server and stores it as an integer. if !FTPReply. isPositiveCompletion replyCode System.out.printInOperation failed. Server reply code replyCode return This checks the reply code": "input.pdf", "to see if there was an error. If there was an error, it will simply print Operation failed. Server reply code followed by the error code. We also added a trycatch block which we will add to in the next step. Next, lets also create a function that checks ftp.login for errors. boolean success ftp.loginuser, pass showServerReply ftp if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER Lets break this block down too. boolean success ftp.loginuser, pass This will not just attempt to login to the FTP server, it will also store the result as a boolean. showServerReply ftp This will check if the server sent us any messages, but we will \ufb01rst need to create the function in the next step. if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER This statement will check if we logged in successfully if so, it will print LOGGED IN SERVER, otherwise it will print Failed to log into the server. This is our script so far import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply public class FTPConnectAndLogin public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com int port 21": "input.pdf", "String user username String pass password FTPClient ftp new FTPClient try ftp. connectserver, port showServerReply ftp int replyCode ftpClient. getReplyCode if !FTPReply. isPositiveCompletion replyCode GoalKicker.com Java Notes for Professionals 848 System.out.printlnOperation failed. Server reply code replyCode return boolean success ftp.loginuser, pass showServerReply ftp if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER catch Now next lets create complete the Catch block in case we run into any errors with the whole process. catch IOException ex System.out.printlnOops! Something went wrong. ex.printStackTrace The completed catch block will now print Oops! Something went wrong. and the stacktrace if there is an error. Now our \ufb01nal step is to create the showServerReply we have been using for a while now. private static void showServerReply FTPClient ftp String replies ftp.getReplyStrings if replies ! null replies. length 0 for String aReply replies System.out.printlnSERVER aReply This function takes an FTPClient as a variable, and calls it ftp. After that it stores any server replies from the server in a string array. Next it checks if any messages were stored. If there is any, it prints each of them as SERVER reply. Now that we have that function done, this is the completed": "input.pdf", "script import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply public class FTPConnectAndLogin private static void showServerReply FTPClient ftp String replies ftp.getReplyStrings if replies ! null replies. length 0 for String aReply replies System.out.printlnSERVER aReply public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com int port 21 String user username String pass password GoalKicker.com Java Notes for Professionals 849 FTPClient ftp new FTPClient try ftp. connectserver, port showServerReply ftp int replyCode ftpClient. getReplyCode if !FTPReply. isPositiveCompletion replyCode System.out.printlnOperation failed. Server reply code replyCode return boolean success ftp.loginuser, pass showServerReply ftp if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER catch IOException ex System.out.printlnOops! Something went wrong. ex. printStackTrace We \ufb01rst need to create a new FTPClient and try connecting to the server it and logging into it using .connectString server, int port and .loginString username, String password . It is important to connect and login using a trycatch block in case our code fails to connect with the server. We will also need to create a function that checks and displays any messages we may receive from the server as we try connecting and logging in. We will call this function showServerReply": "input.pdf", "FTPClient ftp . import java.io.IOException import org.apache.commons.net.ftp.FTPClient import org.apache.commons.net.ftp.FTPReply public class FTPConnectAndLogin private static void showServerReply FTPClient ftp if replies ! null replies. length 0 for String aReply replies System.out.printlnSERVER aReply public static void mainString args SET THESE TO MATCH YOUR FTP SERVER String server www.server.com int port 21 String user username String pass password FTPClient ftp new FTPClient try ftp. connectserver, port showServerReply ftp int replyCode ftpClient. getReplyCode if !FTPReply. isPositiveCompletion replyCode System.out.printlnOperation failed. Server reply code replyCode return boolean success ftp.loginuser, pass showServerReply ftp GoalKicker.com Java Notes for Professionals 850 if !success System.out.printlnFailed to log into the server return else System.out.printlnLOGGED IN SERVER catch IOException ex System.out.printlnOops! Something went wrong. ex. printStackTrace After this, you should now have your FTP server connected to you Java script. GoalKicker.com Java Notes for Professionals 851Chapter 160 Using Other Scripting Languages in Java Java in itself is an extremely powerful language, but its power can further be extended Thanks to JSR223 Java Speci\ufb01cation Request 223 introducing a script engine Section 160.1 Evaluating A JavaScript \ufb01le in -scripting mode of nashorn public class JSEngine Note Nashorn is only available for Java-8 onwards You can use rhino from ScriptEngineManager.getEngineByNamejs ScriptEngine engine ScriptContext context": "input.pdf", "public Bindings scope Initialize the Engine from its factory in scripting mode public JSEngine engine new NashornScriptEngineFactory .getScriptEngine -scripting Script context is an interface so we need an implementation of it context new SimpleScriptContext Create bindings to expose variables into scope engine. createBindings Clear the bindings to remove the previous variables public void newBatch scope. clear public void execute String file try Get a buffered reader for input BufferedReader br new BufferedReader new FileReader file Evaluate code, with input as bufferdReader engine. evalbr catch FileNotFoundException ex Logger. getLogger JSEngine. class.getName.logLevel.SEVERE, null, ex catch ScriptException ex Script Exception is basically when there is an error in script Logger. getLogger JSEngine. class.getName.logLevel.SEVERE, null, ex public void evalString code try Engine.eval basically treats any string as a line of code and evaluates it, executes it engine. evalcode catch ScriptException ex Script Exception is basically when there is an error in script Logger. getLogger JSEngine. class.getName.logLevel.SEVERE, null, ex GoalKicker.com Java Notes for Professionals 852 Apply the bindings to the context and set the engines default context public void startBatch int SCP context. setBindings scope, SCP engine. setContext context We use the invocable interface to access methods from the script Invocable is an optional": "input.pdf", "interface, please check if your engine implements it public Invocable invocable return Invocable engine Now the main method public static void mainString args JSEngine jse new JSEngine Create a new batch probably unecessary jse. newBatch Expose variable x into script with value of hello world jse. scope.putx, hello world Apply the bindings and start the batch jse. startBatch ScriptContext. ENGINESCOPE Evaluate the code jse. evalprintx Your output should be similar to this hello world As you can see the exposed variable x has been printed. Now testing with a \ufb01le. Here we have test.js printx function test print hello test.jstest test And the updated main method public static void mainString args JSEngine jse new JSEngine Create a new batch probably unecessary jse. newBatch Expose variable x into script with value of hello world jse. scope.putx, hello world Apply the bindings and start the batch jse. startBatch ScriptContext. ENGINESCOPE Evaluate the code jse. execute.test.js GoalKicker.com Java Notes for Professionals 853Assuming that test.js is in the same directory as your application You should have output similar to this hello world hello test.jstest GoalKicker.com Java Notes for Professionals 854Chapter 161 C Comparison Java and C are similar languages. This topic serves as": "input.pdf", "a quick reference guide for Java and C Engineers. Section 161.1 Static Class Members Static members have class scope as opposed to object scope C Example define in header class Singleton public static Singleton getInstance private Singleton static Singleton instance initialize in .cpp Singleton Singleton instance 0 Java Example public class Singleton private static Singleton instance private Singleton public static Singleton getInstance ifinstance null instance new Singleton return instance Section 161.2 Classes De\ufb01ned within Other Constructs De\ufb01ned within Another Class C Nested Class ref needs a reference to enclosing class class Outer class Inner public Inner Outer o outero private Outer outer Java non-static Nested Class aka Inner Class or Member Class GoalKicker.com Java Notes for Professionals 855class OuterClass ... class InnerClass ... Statically De\ufb01ned within Another Class C Static Nested Class class Outer class Inner ... Java Static Nested Class aka Static Member Class ref class OuterClass ... static class StaticNestedClass ... De\ufb01ned within a Method e.g. event handling C Local Class ref void fun class Test members of Test class Java Local Class ref class Test void f new Threadnew Runnable public void run doSomethingBackgroundish .start GoalKicker.com Java Notes for Professionals 856Section 161.3 Pass-by-value Pass-by-reference Many argue": "input.pdf", "that Java is ONLY pass-by-value, but its more nuanced than that. Compare the following C and Java examples to see the many \ufb02avors of pass-by-value aka copy and pass-by-reference aka alias. C Example complete code passes a COPY of the object static void passByCopy PassIt obj obj. i 22 only a local change passes a pointer static void passByPointer PassIt ptr ptr -i 33 ptr 0 better to use nullptr instead if 0 passes an alias aka reference static void passByAlias PassIt ref ref. i 44 This is an old-school way of doing it. Check out stdswap for the best way to do this static void swapPassIt pptr1, PassIt pptr2 PassIt tmp pptr1 pptr1 pptr2 pptr2 tmp Java Example complete code passes a copy of the variable NOTE in java only primitives are pass-by-copy public static void passByCopy int copy copy 33 only a local change No such thing as pointers in Java public static void passByPointerPassIt ptr ptr-i 33 ptr 0 better to use nullptr instead if 0 passes an alias aka reference public static void passByAlias PassIt ref ref. i 44 passes aliases aka references, but need to do manual, potentially expensive copies public static void swapPassIt": "input.pdf", "ref1, PassIt ref2 PassIt tmp new PassItref1 ref1. copyref2 ref2. copytmp GoalKicker.com Java Notes for Professionals 857Section 161.4 Inheritance vs Composition C Java are both object-oriented languages, thus the following diagram applies to both. Section 161.5 Outcast Downcasting Beware of using downcasting - Downcasting is casting down the inheritance hierarchy from a base class to a subclass i.e. opposite of polymorphism. In general, use polymorphism overriding instead of instanceof downcasting. C Example explicit type case required Child pChild Child parent Java Example ifmySubClass instanceof SubClass SubClass mySubClass SubClass someBaseClass mySubClass. nonInheritedMethod Section 161.6 Abstract Methods Classes Abstract Method declared without an implementation C pure virtual method virtual void eatvoid 0 Java abstract method GoalKicker.com Java Notes for Professionals 858abstract void draw Abstract Class cannot be instantiated C cannot be instantiated has at least 1 pure virtual method class AB public virtual void f 0 Java cannot be instantiated can have non-abstract methods abstract class GraphicObject Interface no instance \ufb01elds C nothing comparable to Java Java very similar to abstract class, but 1 supports multiple inheritance 2 no instance \ufb01elds interface TestInterface GoalKicker.com Java Notes for Professionals 859Chapter 162 Audio Section 162.1 Play a MIDI \ufb01le MIDI \ufb01les can be": "input.pdf", "played by using several classes from the javax.sound.midi package. A Sequencer performs playback of the MIDI \ufb01le, and many of its methods can be used to set playback controls such as loop count, tempo, track muting, and others. General playback of MIDI data can be done in this way import java.io.File import java.io.IOException import javax.sound.midi.InvalidMidiDataException import javax.sound.midi.MidiSystem import javax.sound.midi.MidiUnavailableException import javax.sound.midi.Sequence import javax.sound.midi.Sequencer public class MidiPlayback public static void mainString args try Sequencer sequencer MidiSystem .getSequencer Get the default Sequencer if sequencer null System.err.printlnSequencer device not supported return sequencer. open Open device Create sequence, the File must contain MIDI file data. Sequence sequence MidiSystem .getSequence new Fileargs0 sequencer. setSequence sequence load it into sequencer sequencer. start start the playback catch MidiUnavailableException InvalidMidiDataException IOException ex ex. printStackTrace To stop the playback use sequencer. stop Stop the playback A sequencer can be set to mute one or more of the sequences tracks during playback so none of the instruments in those speci\ufb01ed play. The following example sets the \ufb01rst track in the sequence to be muted import javax.sound.midi.Track ... Track track sequence. getTracks sequencer. setTrackMute track0 A sequencer can play a sequence repeatedly if the loop count is given. The following": "input.pdf", "sets the sequencer to play a sequence four times and inde\ufb01nitely sequencer. setLoopCount 3 sequencer. setLoopCount Sequencer .LOOPCONTINUOUSLY The sequencer does not always have to play the sequence from the beginning, nor does it have to play the GoalKicker.com Java Notes for Professionals 860sequence until the end. It can start and end at any point by specifying the tick in the sequence to start and end at. It is also possible to specify manually which tick in the sequence the sequencer should play from sequencer. setLoopStartPoint 512 sequencer. setLoopEndPoint 32768 sequencer. setTickPosition 8192 Sequencers can also play a MIDI \ufb01le at a certain tempo, which can be controlled by specifying the tempo in beats per minute BPM or microseconds per quarter note MPQ. The factor at which the sequence is played can be adjusted as well. sequencer. setTempoInBPM 1250f sequencer. setTempoInMPQ 4750f sequencer. setTempoFactor 1.5f When you \ufb01nished using the Sequencer , remeber to close it sequencer. close Section 162.2 Play an Audio \ufb01le Looped Needed imports import javax.sound.sampled.AudioSystem import javax.sound.sampled.Clip This code will create a clip and play it continuously once started Clip clip AudioSystem .getClip clip.openAudioSystem .getAudioInputStream new URLfilename clip.start clip.loopClip.LOOPCONTINUOUSLY Get an Array with all supported": "input.pdf", "\ufb01le types AudioFileFormat. Type audioFileTypes AudioSystem .getAudioFileTypes Section 162.3 Basic audio output The Hello Audio! of Java that plays a sound \ufb01le from local or internet storage looks as follows. It works for uncompressed .wav \ufb01les and should not be used for playing mp3 or compressed \ufb01les. import java.io. import java.net.URL import javax.sound.sampled. public class SoundClipTest Constructor public SoundClipTest try Open an audio input stream. File soundFile new FileusrsharesoundsalsaFrontCenter.wav you could also get the sound file with an URL AudioInputStream audioIn AudioSystem .getAudioInputStream soundFile AudioFormat format audioIn. getFormat GoalKicker.com Java Notes for Professionals 861 Get a sound clip resource. DataLine. Info info new DataLine. InfoClip.class, format Clip clip ClipAudioSystem .getLineinfo Open audio clip and load samples from the audio input stream. clip. openaudioIn clip. start catch UnsupportedAudioFileException e e. printStackTrace catch IOException e e. printStackTrace catch LineUnavailableException e e. printStackTrace public static void mainString args new SoundClipTest Section 162.4 Bare metal sound You can also go almost bare-metal when producing sound with java. This code will write raw binary data into the OS audio bu\ufb00er to generate sound. Its extremely important to understand the limitations and necessary calculations to generating sound like this. Since playback is basically instantaneous, calculations": "input.pdf", "need to be performed at almost real-time. As such this method is unusable for more complicated sound-sampling. For such purposes using specialized tools is the better approach. The following method generates and directly outputs a rectangle-wave of a given frequency in a given volume for a given duration. public void rectangleWave byte volume, int hertz, int msecs final SourceDataLine dataLine 24 kHz x 8bit, single-channel, signed little endian AudioFormat AudioFormat af new AudioFormat 24000, 8, 1, true, false try dataLine AudioSystem .getSourceDataLine af dataLine. openaf, 10000 audio buffer size 10k samples catch LineUnavailableException e throw new RuntimeException e int waveHalf 24000 hertz samples for half a period byte buffer new bytewaveHalf 20 int samples msecs 24000 1000 24k samples sec 1000 mssec timems dataLine. start starts playback int sign 1 for int i 0 i samples i buffer. length for int j 0 j 20 j generate 10 waves into buffer sign -1 fill from the jth wave-half to the j1th wave-half with volume Arrays.fillbuffer, waveHalf j, waveHalf j1, byte volume sign dataLine. writebuffer, 0, buffer. length dataLine. drain forces buffer drain to hardware GoalKicker.com Java Notes for Professionals 862 dataLine. stop ends playback For a more di\ufb00erentiated way": "input.pdf", "to generate di\ufb00erent soundwaves sinus calculations and possibly larger sample sizes are necessary. This results in signi\ufb01cantly more complex code and is accordingly omitted here. GoalKicker.com Java Notes for Professionals 863Chapter 163 Java Print Service The Java Print Service API provides functionalities to discover print services and send print requests for them. It includes extensible print attributes based on the standard attributes speci\ufb01ed in the Internet Printing Protocol IPP 1.1 from the IETF Speci\ufb01cation, RFC 2911 . Section 163.1 Building the Doc that will be printed Doc is an interface and the Java Print Service API provide a simple implementation called SimpleDoc . Every Doc instance is basically made of two aspects the print data content itself an E-mail, an image, a document etc the print data format, called DocFlavor MIME type Representation class. Before creating the Doc object, we need to load our document from somewhere. In the example, we will load an speci\ufb01c \ufb01le from the disk FileInputStream pdfFileInputStream new FileInputStream something.pdf So now, we have to choose a DocFlavor that matches our content. The DocFlavor class has a bunch of constants to represent the most usual types of data. Lets pick the INPUTSTREAM. PDF one DocFlavor": "input.pdf", "pdfDocFlavor DocFlavor. INPUTSTREAM .PDF Now, we can create a new instance of SimpleDoc Doc doc new SimpleDoc pdfFileInputStream, pdfDocFlavor , null The doc object now can be sent to the print job request see Creating a print job from a print service. Section 163.2 Discovering the available print services To discovery all the available print services, we can use the PrintServiceLookup class. Lets see how import javax.print.PrintService import javax.print.PrintServiceLookup public class DiscoveringAvailablePrintServices public static void mainString args discoverPrintServices public static void discoverPrintServices PrintService allPrintServices PrintServiceLookup. lookupPrintServices null, null for Printservice printService allPrintServices System.out.printlnPrint service name printService. getName GoalKicker.com Java Notes for Professionals 864This program, when executed on a Windows environment, will print something like this Print service name Fax Print service name Microsoft Print to PDF Print service name Microsoft XPS Document Viewer Section 163.3 De\ufb01ning print request attributes Sometimes we need to determine some aspects of the print request. We will call them attribute . Are examples of print request attributes amount of copies 1, 2 etc, orientation portrait or landscape chromacity monochrome, color quality draft, normal, high sides one-sided, two-sided etc and so on... Before choosing one of them and which value each one will have, \ufb01rst": "input.pdf", "we need to build a set of attributes PrintRequestAttributeSet pras new HashPrintRequestAttributeSet Now we can add them. Some examples are pras.addnew Copies5 pras.addMediaSize. ISOA4 pras.addOrientationRequested. PORTRAIT pras.addPrintQuality. NORMAL The pras object now can be sent to the print job request see Creating a print job from a print service. Section 163.4 Listening print job request status change For the most printing clients, is extremely useful to know if a print job has \ufb01nished or failed. The Java Print Service API provide some functionalities to get informed about these scenarios. All we have to do is provide an implementation for PrintJobListener interface and register this implementation at the print job. When the print job state changes, we will be noti\ufb01ed. We can do anything is needed, for example update a user interface, start another business process, record something in the database, or simply log it. In the example bellow, we will log every print job status change import javax.print.event.PrintJobEvent import javax.print.event.PrintJobListener public class LoggerPrintJobListener implements PrintJobListener GoalKicker.com Java Notes for Professionals 865 Your favorite Logger class goes here! private static final Logger LOG Logger. getLogger LoggerPrintJobListener. class public void printDataTransferCompleted PrintJobEvent pje LOG. infoPrint data transfer completed public void printJobCompleted": "input.pdf", "PrintJobEvent pje LOG. infoPrint job completed public void printJobFailed PrintJobEvent pje LOG. infoPrint job failed public void printJobCanceled PrintJobEvent pje LOG. infoPrint job canceled public void printJobNoMoreEvents PrintJobEvent pje LOG. infoNo more events to the job public void printJobRequiresAttention PrintJobEvent pje LOG. infoPrint job requires attention O Finally, we can add our print job listener implementation on the print job before the print request itself, as follows DocPrintJob printJob printService. createPrintJob printJob. addPrintJobListener new LoggerPrintJobListener printJob. printdoc, pras The PrintJobEvent pje argument Notice that every method has a PrintJobEvent pje argument. We dont use it in this example for simplicity purposes, but you can use it to explore the status. For example pje.getPrintJob .getAttributes Will return a PrintJobAttributeSet object instance and you can run them in a for-each way. Another way to achieve the same goal Another option to achieve the same goal is extending the PrintJobAdapter class, as the name says, is an adapter for PrintJobListener . Implementing the interface we compulsorily have to implement all of them. The advantage of this way its we need to override only the methods we want. Lets see how it works import javax.print.event.PrintJobEvent import javax.print.event.PrintJobAdapter public class LoggerPrintJobAdapter extends PrintJobAdapter Your": "input.pdf", "favorite Logger class goes here! GoalKicker.com Java Notes for Professionals 866 private static final Logger LOG Logger. getLogger LoggerPrintJobAdapter. class public void printJobCompleted PrintJobEvent pje LOG. infoPrint job completed public void printJobFailed PrintJobEvent pje LOG. infoPrint job failed Notice that we override only some speci\ufb01c methods. As the same way in the example implementing the interface PrintJobListener , we add the listener to the print job before sending it to print printJob. addPrintJobListener new LoggerPrintJobAdapter printJob. printdoc, pras Section 163.5 Discovering the default print service To discovery the default print service, we can use the PrintServiceLookup class. Lets see how import javax.print.PrintService import javax.print.PrintServiceLookup public class DiscoveringDefaultPrintService public static void mainString args discoverDefaultPrintService public static void discoverDefaultPrintService PrintService defaultPrintService PrintServiceLookup. lookupDefaultPrintService System.out.printlnDefault print service name defaultPrintService. getName Section 163.6 Creating a print job from a print service A print job is a request of printing something in a speci\ufb01c print service. It consists, basically, by the data that will be printed see Building the Doc that will be printed a set of attributes After picking-up the right print service instance, we can request the creation of a print job DocPrintJob printJob printService. createPrintJob The DocPrintJob interface provide us the": "input.pdf", "print method printJob. printdoc, pras The doc argument is a Doc the data that will be printed. GoalKicker.com Java Notes for Professionals 867And the pras argument is a PrintRequestAttributeSet interface a set of PrintRequestAttribute . Are examples of print request attributes amount of copies 1, 2 etc, orientation portrait or landscape chromacity monochrome, color quality draft, normal, high sides one-sided, two-sided etc and so on... The print method may throw a PrintException . GoalKicker.com Java Notes for Professionals 868Chapter 164 CompletableFuture CompletableFuture is a class added to Java SE 8 which implements the Future interface from Java SE 5. In addition to supporting the Future interface it adds many methods that allow asynchronous callback when the future is completed. Section 164.1 Simple Example of CompletableFuture In the example below, the calculateShippingPrice method calculates shipping cost, which takes some processing time. In a real world example, this would e.g. be contacting another server which returns the price based on the weight of the product and the shipping method. By modeling this in an async way via CompletableFuture , we can continue di\ufb00erent work in the method i.e. calculating packaging costs. public static void mainString args int price 15 Lets keep": "input.pdf", "it simple and work with whole number prices here int weightInGrams 900 calculateShippingPrice weightInGrams Here, we get the future . thenAccept shippingPrice - And then immediately work on it! This fluent style is very useful for keeping it concise System.out.printlnYour total price is price shippingPrice System.out.printlnPlease stand by. We are calculating your total price. public static CompletableFuture Integer calculateShippingPrice int weightInGrams return CompletableFuture. supplyAsync - supplyAsync is a factory method that turns a given SupplierU into a CompletableFutureU Lets just say each 200 grams is a new dollar on your shipping costs int shippingCosts weightInGrams 200 try Thread.sleep2000L Now lets simulate some waiting time... catchInterruptedException e We can safely ignore that return shippingCosts And send the costs back! GoalKicker.com Java Notes for Professionals 869Chapter 165 Runtime Commands Section 165.1 Adding shutdown hooks Sometimes you need a piece of code to execute when the program stops, such as releasing system resources that you open. You can make a thread run when the program stops with the addShutdownHook method Runtime.getRuntime .addShutdownHook new Thread - ImportantStuff. someImportantIOStream .close GoalKicker.com Java Notes for Professionals 870Chapter 166 Unit Testing Unit testing is an integral part of test-driven development, and an important feature for building": "input.pdf", "any robust application. In Java, Unit testing is almost exclusively performed using external libraries and frameworks, most of which have their own documentation tag. This stub serves as a means of introducing the reader to the tools available, and their respective documentation. Section 166.1 What is Unit Testing? This is a bit of a primer. Its mostly put it in because documentation is forced to have an example, even if its intended as a stub article. If you already know unit-testing basics, feel free to skip forward to the remarks, where speci\ufb01c frameworks are mentioned. Unit testing is ensuring that a given module behaves as expected. In large-scale applications, ensuring the appropriate execution of modules in a vacuum is an integral part of ensuring application \ufb01delity. Consider the following trivial pseudo-example public class Example public static void main String args new Example Application-level test. public Example Consumer c new Consumer System.out.printlnVALUE c.getVal Your Module. class Consumer private Capitalizer c public Consumer c new Capitalizer public String getVal return c.getVal Another teams module. class Capitalizer private DataReader dr public Capitalizer dr new DataReader public String getVal return dr.readVal.toUpperCase Another teams module. class DataReader public String readVal GoalKicker.com Java Notes for": "input.pdf", "Professionals 871 Refers to a file somewhere in your application deployment, or perhaps retrieved over a deployment-specific network. File f String s data ... Read data from f into s ... return s So this example is trivial DataReader gets the data from a \ufb01le, passes it to the Capitalizer , which converts all the characters to upper-case, which then gets passed to the Consumer . But the DataReader is heavily-linked to our application environment, so we defer testing of this chain until we are ready to deploy a test release. Now, assume, somewhere along the way in a release, for reasons unknown, the getVal method in Capitalizer changed from returning a toUpperCase String to a toLowerCase String Another teams module. class Capitalizer ... public String getVal return dr.readVal.toLowerCase Clearly, this breaks expected behavior. But, because of the arduous processes involved with execution of the DataReader , we wont notice this until our next test deployment. So daysweeksmonths go by with this bug sitting in our system, and then the product manager sees this, and instantly turns to you, the team leader associated with the Consumer . Why is this happening? What did you guys change? Obviously, youre clueless.": "input.pdf", "You have no idea whats going on. You didnt change any code that should be touching this why is it suddenly broken? Eventually, after discussion between the teams and collaboration, the issue is traced, and the problem solved. But, it begs the question how could this have been prevented? There are two obvious things Tests need to be automated Our reliance upon manual testing let this bug go by unnoticed far too long. We need a way to automate the process under which bugs are introduced instantly . Not 5 weeks from now. Not 5 days from now. Not 5 minutes from now. Right now. You have to appreciate that, in this example, Ive expressed one very trivial bug that was introduced and unnoticed. In an industrial application, with dozens of modules constantly being updated, these can creep in all over the place. You \ufb01x something with one module, only to realize that the very behavior you \ufb01xed was relied upon in some manner elsewhere either internally or externally. Without rigorous validation, things will creep into the system. Its possible that, if neglected far enough, this will result in so much extra work trying to \ufb01x changes and then": "input.pdf", "\ufb01xing those \ufb01xes, etc., that a product will actually increase in remaining work as e\ufb00ort is put into it. You do not want to be in this situation. Tests need to be \ufb01ne-grained The second problem noted in our above example is the amount of time it took to trace the bug. The product manager pinged you when the testers noticed it, you investigated and found that the Capitalizer was returning GoalKicker.com Java Notes for Professionals 872seemingly bad data, you pinged the Capitalizer team with your \ufb01ndings, they investigated, etc. etc. etc. The same point I made above about the quantity and di\ufb03culty of this trivial example hold here. Obviously anyone reasonably well-versed with Java could \ufb01nd the introduced problem quickly. But its often much, much more di\ufb03cult to trace and communicate issues. Maybe the Capitalizer team provided you a JAR with no source. Maybe theyre located on the other side of the world, and communication hours are very limited perhaps to e-mails that get sent once daily. It can result in bugs taking weeks or longer to trace and, again, there could be several of these for a given release. In order to mitigate against this, we want": "input.pdf", "rigorous testing on as \ufb01ne a level as possible you also want coarse- grained testing to ensure modules interact properly, but thats not our focal point here. We want to rigorously specify how all outward-facing functionality at minimum operates, and tests for that functionality. Enter unit-testing Imagine if we had a test, speci\ufb01cally ensuring that the getVal method of Capitalizer returned a capitalized string for a given input string. Furthermore, imagine that test was run before we even committed any code. The bug introduced into the system that is, toUpperCase being replaced with toLowerCase would cause no issues because the bug would never be introduced into the system. We would catch it in a test, the developer would hopefully realize their mistake, and an alternative solution would be reached as to how to introduce their intended e\ufb00ect. Theres some omissions made here as to how to implement these tests, but those are covered in the framework- speci\ufb01c documentation linked in the remarks. Hopefully, this serves as an example of why unit testing is important. GoalKicker.com Java Notes for Professionals 873Chapter 167 Asserting Parameter Details expression1 The assertion statement throws an AssertionError if this expression evaluates to false . expression2": "input.pdf", "Optional. When used, AssertionError s thrown by the assert statement have this message. Section 167.1 Checking arithmetic with assert a 1 - Math.abs1 - a 2 This will throw an error if my arithmetic above is wrong. assert a 0 a 1 Calculated value of a is outside of expected bounds return a GoalKicker.com Java Notes for Professionals 874Chapter 168 Multi-Release JAR Files One of the features introduced in Java 9 is the multi-release Jar MRJAR which allows bundling code targeting multiple Java releases within the same Jar \ufb01le. The feature is speci\ufb01ed in JEP 238 . Section 168.1 Example of a multi-release Jar \ufb01les contents By setting Multi-Release true in the MANIFEST.MF \ufb01le, the Jar \ufb01le becomes a multi-release Jar and the Java runtime as long as it supports the MRJAR format will pick the appropriate versions of classes depending on the current major version. The structure of such a Jar is the following jar root - A.class - B.class - C.class - D.class - META-INF - versions - 9 - A.class - B.class - 10 - A.class On JDKs 9, only the classes in the root entry are visible to the Java runtime. On a JDK 9,": "input.pdf", "the classes A and B will be loaded from the directory rootMETA-INFversions 9, while C and D will be loaded from the base entry. On a JDK 10, class A would be loaded from the directory rootMETA-INFversions 10. Section 168.2 Creating a multi-release Jar using the jar tool The jar command can be used to create a multi-release Jar containing two versions of the same class compiled for both Java 8 and Java 9, albeit with a warning telling that the classes are identical CUsersmanouti jar --create --file MR. jar -C sampleproject -base demo --release 9 -C sampleproject -9 demo Warning entry META -INFversions 9demoSampleClass. class contains a class that is identical to an entry already in the jar The --release 9 option tells jar to include everything that follows the demo package inside the sampleproject -9 directory inside a versioned entry in the MRJAR, namely under rootMETA-INFversions 9. The result is the following contents jar root - demo - SampleClass. class - META-INF - versions - 9 - demo - SampleClass. class Let us now create a class called Main that prints the URL of the SampleClass , and add it for the Java 9 version GoalKicker.com Java": "input.pdf", "Notes for Professionals 875package demo import java.net.URL public class Main public static void mainString args throws Exception URL url Main.class.getClassLoader .getResource demoSampleClass.class System.out.printlnurl If we compile this class and re-run the jar command, we get an error CUsersmanouti jar --create --file MR. jar -C sampleproject -base demo --release 9 -C sampleproject -9 demoentry META-INFversions 9demoMain.class, contains a new public class not found in base entries Warning entry META -INFversions 9demoMain.java, multiple resources with same name Warning entry META -INFversions 9demoSampleClass. class contains a class that is identical to an entry already in the jar invalid multi -release jar file MR. jar deleted The reason is that the jar tool prevents adding public classes to versioned entries if they are not added to the base entries as well. This is done so that the MRJAR exposes the same public API for the di\ufb00erent Java versions. Note that at runtime, this rule is not required. It may be only applied by tools like jar. In this particular case, the purpose of Main is to run sample code, so we can simply add a copy in the base entry. If the class were part of a newer implementation that we only need": "input.pdf", "for Java 9, it could be made non-public. To add Main to the root entry, we \ufb01rst need to compile it to target a pre-Java 9 release. This can be done using the new --release option of javac CUsersmanoutisampleproject-basedemo javac --release 8 Main.java CUsersmanoutisampleproject-basedemo cd .... CUsersmanouti jar --create --file MR.jar -C sampleproject-base demo --release 9 -C sampleproject- 9 demo Running the Main class shows that the SampleClass gets loaded from the versioned directory CUsersmanouti java --class-path MR. jar demo.Main jarfileCUsersmanoutiMR.jar!META-INFversions 9demoSampleClass. class Section 168.3 URL of a loaded class inside a multi-release Jar Given the following multi-release Jar jar root - demo - SampleClass. class - META-INF - versions - 9 - demo - SampleClass. class The following class prints the URL of the SampleClass package demo GoalKicker.com Java Notes for Professionals 876import java.net.URL public class Main public static void mainString args throws Exception URL url Main.class.getClassLoader .getResource demoSampleClass.class System.out.printlnurl If the class is compiled and added on the versioned entry for Java 9 in the MRJAR, running it would result in CUsersmanouti java --class-path MR. jar demo.Main jarfileCUsersmanoutiMR.jar!META-INFversions 9demoSampleClass. class GoalKicker.com Java Notes for Professionals 877Chapter 169 Just in Time JIT compiler Section 169.1 Overview The Just-In-Time": "input.pdf", "JIT compiler is a component of the Java Runtime Environment that improves the performance of Java applications at run time. Java programs consists of classes, which contain platform-neutral bytecodes that can be interpreted by a JVM on many di\ufb00erent computer architectures. At run time, the JVM loads the class \ufb01les, determines the semantics of each individual bytecode, and performs the appropriate computation. The additional processor and memory usage during interpretation means that a Java application performs more slowly than a native application. The JIT compiler helps improve the performance of Java programs by compiling bytecodes into native machine code at run time. GoalKicker.com Java Notes for Professionals 878The JIT compiler is enabled by default, and is activated when a Java method is called. The JIT compiler compiles the bytecodes of that method into native machine code, compiling it just in time to run. When a method has been compiled, the JVM calls the compiled code of that method directly instead of interpreting it. Theoretically, if compilation did not require processor time and memory usage, compiling every method could allow the speed of the Java program to approach that of a native application. JIT compilation does require processor time and": "input.pdf", "memory usage. When the JVM \ufb01rst starts up, thousands of methods are called. Compiling all of these methods can signi\ufb01cantly a\ufb00ect startup time, even if the program eventually achieves very good peak performance. In practice, methods are not compiled the \ufb01rst time they are called. For each method, the JVM maintains a call count which is incremented every time the method is called. The JVM interprets a method until its call count exceeds a JIT compilation threshold. Therefore, often-used methods are compiled soon after the JVM has started, and less-used methods are compiled much later, or not at all. The JIT compilation threshold helps the JVM start quickly and still have improved performance. The threshold has been carefully selected to obtain an optimal balance between startup times and long term performance. After a method is compiled, its call count is reset to zero and subsequent calls to the method continue to increment its count. When the call count of a method reaches a JIT recompilation threshold, the JIT compiler compiles it a second time, applying a larger selection of optimizations than on the previous compilation. This process is repeated until the maximum optimization level is reached. The busiest methods": "input.pdf", "of a Java program are always optimized most aggressively, maximizing the performance bene\ufb01ts of using the JIT compiler. The JIT compiler can also measure operational data at run time , and use that data to improve the quality of further recompilations. The JIT compiler can be disabled, in which case the entire Java program will be interpreted. Disabling the JIT compiler is not recommended except to diagnose or work around JIT compilation problems. GoalKicker.com Java Notes for Professionals 879Chapter 170 Bytecode Modi\ufb01cation Section 170.1 What is Bytecode? Bytecode is the set of instructions used by the JVM. To illustrate this lets take this Hello World program. public static void mainString args System.out.printlnHello World This is what it turns into when compiled into bytecode. public static mainLjavalangString argsV getstatic java langSystem out Ljava ioPrintStream ldc Hello World invokevirtual java ioPrintStream printLjavalangStringV Whats the logic behind this? getstatic - Retrieves the value of a static \ufb01eld of a class. In this case, the PrintStream Out of System . ldc - Push a constant onto the stack. In this case, the String Hello World invokevirtual - Invokes a method on a loaded reference on the stack and puts the result on the": "input.pdf", "stack. Parameters of the method are also taken from the stack. Well, there has to be more right? There are 255 opcodes, but not all of them are implemented yet. A table with all of the current opcodes can be found here Java bytecode instruction listings . How can I write edit bytecode? Theres multiple ways to write and edit bytecode. You can use a compiler, use a library, or use a program. For writing Jasmin Krakatau For editing Libraries ASM Javassist BCEL - Doesnt support Java 8 Tools Bytecode-Viewer JBytedit reJ - Doesnt support Java 8 JBE - Doesnt support Java 8 Id like to learn more about bytecode! Theres probably a speci\ufb01c documentation page speci\ufb01cially for bytecode. This page focuses on the modi\ufb01cation of GoalKicker.com Java Notes for Professionals 880bytecode using di\ufb00erent libraries and tools. Section 170.2 How to edit jar \ufb01les with ASM Firstly the classes from the jar need to be loaded. Well use three methods for this process loadClassesFile readJarJarFile, JarEntry, Map getNodebyte MapString, ClassNode loadClasses File jarFile throws IOException MapString, ClassNode classes new HashMap String, ClassNode JarFile jar new JarFilejarFile Stream JarEntry str jar.stream str. forEachz - readJar jar, z, classes jar. close": "input.pdf", "return classes MapString, ClassNode readJar JarFile jar, JarEntry entry, Map String, ClassNode classes String name entry.getName try InputStream jis jar.getInputStream entry if name.endsWith .class byte bytes IOUtils. toByteArray jis String cafebabe String.format02X02X02X02X , bytes0, bytes1, bytes2, bytes3 if !cafebabe. toLowerCase .equalscafebabe This class doesnt have a valid magic return classes try ClassNode cn getNode bytes classes. putcn.name, cn catch Exception e e. printStackTrace catch IOException e e. printStackTrace return classes ClassNode getNode byte bytes ClassReader cr new ClassReader bytes ClassNode cn new ClassNode try cr. acceptcn, ClassReader. EXPANDFRAMES catch Exception e e. printStackTrace cr null return cn With these methods loading and changing a jar \ufb01le becomes a simple matter of changing ClassNodes in a map. In this example we will replace all Strings in the jar with capitalized ones using the Tree API. File jarFile new Filesample.jar MapString, ClassNode nodes loadClasses jarFile GoalKicker.com Java Notes for Professionals 881 Iterate ClassNodes for ClassNode cn nodes.values Iterate methods in class for MethodNode mn cn.methods Iterate instructions in method for AbstractInsnNode ain mn.instructions .toArray If the instruction is loading a constant value if ain.getOpcode Opcodes. LDC Cast current instruction to Ldc If the constant is a string then capitalize it. LdcInsnNode": "input.pdf", "ldc LdcInsnNode ain if ldc.cst instanceof String ldc. cst ldc.cst.toString .toUpperCase Now that all of the ClassNodes strings have been modi\ufb01ed we need to save the changes. In order to save the changes and have a working output a few things have to be done Export ClassNodes to bytes Load non-class jar entries Ex Manifest.mf other binary resources in jar as bytes Save all bytes to a new jar From the last portion above, well create three methods. processNodesMapString, ClassNode nodes loadNonClassesFile jarFile saveAsJarMapString, byte outBytes, String \ufb01leName Usage MapString, byte out process nodes, new HashMap String, MappedClass out.putAllloadNonClassEntries jarFile saveAsJar out, sample-edit.jar The methods used static MapString, byte processNodes MapString, ClassNode nodes, Map String, MappedClass mappings MapString, byte out new HashMap String, byte Iterate nodes and add them to the map of Class names , Class bytes Using ComputeFrames ensures that stack-frames will be re-calculated automatically for ClassNode cn nodes.values ClassWriter cw new ClassWriter ClassWriter. COMPUTEFRAMES out. putmappings. containsKey cn.name ? mappings. getcn.name.getNewName cn.name, cw.toByteArray return out static MapString, byte loadNonClasses File jarFile throws IOException MapString, byte entries new HashMap String, byte ZipInputStream jis new ZipInputStream new FileInputStream jarFile ZipEntry entry Iterate all entries while entry jis.getNextEntry !": "input.pdf", "null GoalKicker.com Java Notes for Professionals 882 try String name entry.getName if !name.endsWith .class !entry.isDirectory Apache Commons - byte toByteArrayInputStream input Add each entry to the map Entry name , Entry bytes byte bytes IOUtils. toByteArray jis entries. putname, bytes catch Exception e e. printStackTrace finally jis. closeEntry jis. close return entries static void saveAsJar MapString, byte outBytes, String fileName try Create jar output stream JarOutputStream out new JarOutputStream new FileOutputStream fileName For each entry in the map, save the bytes for String entry outBytes. keySet Appent class names to class entries String ext entry.contains . ? .class out. putNextEntry new ZipEntry entry ext out. writeoutBytes. getentry out. closeEntry out. close catch IOException e e. printStackTrace Thats it. All the changes will be saved to sample-edit.jar. Section 170.3 How to load a ClassNode as a Class Load a class by from a ClassNode param cn ClassNode to load return public static Class? loadClassNode cn ClassWriter cw new ClassWriter ClassWriter. COMPUTEFRAMES return new ClassDefiner ClassLoader .getSystemClassLoader .getcn.name.replace, ., cw.toByteArray Classloader that loads a class from bytes. static class ClassDefiner extends ClassLoader public ClassDefiner ClassLoader parent superparent GoalKicker.com Java Notes for Professionals 883 public Class? getString name, byte bytes Class ?": "input.pdf", "c defineClass name, bytes, 0, bytes. length resolveClass c return c Section 170.4 How to rename classes in a jar \ufb01le public static void mainString args throws Exception File jarFile new FileInput.jar MapString, ClassNode nodes JarUtils. loadClasses jarFile MapString, byte out JarUtils. loadNonClassEntries jarFile MapString, String mappings new HashMap String, String mappings. putmeexampleExampleClass , meexampleExampleRenamed out. putAllprocessnodes, mappings JarUtils. saveAsJar out, Input-new.jar static MapString, byte process MapString, ClassNode nodes, Map String, String mappings MapString, byte out new HashMap String, byte Remapper mapper new SimpleRemapper mappings for ClassNode cn nodes.values ClassWriter cw new ClassWriter ClassWriter. COMPUTEFRAMES ClassVisitor remapper new ClassRemapper cw, mapper cn. acceptremapper out. putmappings. containsKey cn.name ? mappings. getcn.name cn.name, cw.toByteArray return out SimpleRemapper is an existing class in the ASM library. However it only allows for class names to be changed. If you wish to rename \ufb01elds and methods you should create your own implemenation of the Remapper class. Section 170.5 Javassist Basic Javassist is a bytecode instrumentation library that allows you to modify bytecode injecting Java code that will be converted to bytecode by Javassist and added to the instrumented classmethod at runtime. Lets write the \ufb01rst transformer that actually take an hypothetical class com.my.to.be.instrumented.MyClass and": "input.pdf", "add to the instructions of each method a log call. import java.lang.instrument.ClassFileTransformer import java.lang.instrument.IllegalClassFormatException import java.security.ProtectionDomain import javassist.ClassPool import javassist.CtClass import javassist.CtMethod public class DynamicTransformer implements ClassFileTransformer public byte transform ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte classfileBuffer throws IllegalClassFormatException byte byteCode classfileBuffer into the transformer will arrive every class loaded so we filter GoalKicker.com Java Notes for Professionals 884 to match only what we need if className. equalscommytobeinstrumentedMyClass try retrive default Javassist class pool ClassPool cp ClassPool. getDefault get from the class pool our class with this qualified name CtClass cc cp.getcom.my.to.be.instrumented.MyClass get all the methods of the retrieved class CtMethod methods cc.getDeclaredMethods forCtMethod meth methods The instrumentation code to be returned and injected final StringBuffer buffer new StringBuffer String name meth.getName just print into the buffer a log for example buffer. appendSystem.out.println Method name executed meth. insertBefore buffer.toString create the byteclode of the class byteCode cc.toBytecode remove the CtClass from the ClassPool cc. detach catch Exception ex ex. printStackTrace return byteCode Now in order to use this transformer so that our JVM will call the method transform on each class at load time we need to add this instrumentor this with an agent import java.lang.instrument.Instrumentation": "input.pdf", "public class EasyAgent public static void premain String agentArgs, Instrumentation inst registers the transformer inst. addTransformer new DynamicTransformer Last step to start our \ufb01rst instrumentor experiment is to actually register this agent class to the JVM machine execution. The easiest way to actually do it is to register it with an option into the shell command java -javaagent myAgent. jar MyJavaApplication As we can see the agenttransformer project is added as a jar to the execution of any application named MyJavaApplication that is supposed to contain a class named com.my.to.be.instrumented.MyClass to actually execute our injected code. GoalKicker.com Java Notes for Professionals 885Chapter 171 Disassembling and Decompiling Name Description classes List of classes to disassemble. Can be in either package1. package2 .Classname format, or package1 package2 Classname format. Do not include the .class extension. -help , --help , -? Print this usage message -version Version information -v, -verbose Print additional information -l Print line number and local variable tables -public Show only public classes and members -protected Show protectedpublic classes and members -package Show packageprotectedpublic classes and members default -p, -private Show all classes and members -c Disassemble the code -s Print internal type signatures -sysinfo Show system info path,": "input.pdf", "size, date, MD5 hash of class being processed -constants Show \ufb01nal constants -classpath path Specify where to \ufb01nd user class \ufb01les -cp path Specify where to \ufb01nd user class \ufb01les -bootclasspath pathOverride location of bootstrap class \ufb01les Section 171.1 Viewing bytecode with javap If you want to see the generated bytecode for a Java program, you can use the provided javap command to view it. Assuming that we have the following Java source \ufb01le package com.stackoverflow.documentation import org.springframework.stereotype.Service import java.io.IOException import java.io.InputStream import java.util.List Service public class HelloWorldService public void sayHello System.out.printlnHello, World! private Object pvtMethod ListString strings return new Objectstrings protected String tryCatchResources String filename throws IOException try InputStream inputStream getClass .getResourceAsStream filename byte bytes new byte8192 int read inputStream. readbytes return new Stringbytes, 0, read catch IOException RuntimeException e GoalKicker.com Java Notes for Professionals 886 e. printStackTrace throw e void stuff System.out.printlnstuff After compiling the source \ufb01le, the most simple usage is cd directory containing classes e.g. target classes javap com stackoverflow documentation SpringExample Which produces the output Compiled from HelloWorldService.java public class com.stackoverflow.documentation.HelloWorldService public com.stackoverflow.documentation.HelloWorldService public void sayHello protected java.lang.String tryCatchResourcesjava.lang.String throws java.io.IOException void stuff This lists all non-private methods in the class, but that is": "input.pdf", "not particularly useful for most purposes. The following command is a lot more useful javap -p -c -s -constants -l -v comstackoverflow documentation HelloWorldService Which produces the output Classfile UserspivotalIdeaProjectsstackoverflow-spring- docstargetclassescomstackoverflowdocumentationHelloWorldService.class Last modified Jul 22, 2016 size 2167 bytes MD5 checksum 6e33b5c292ead21701906353b7f06330 Compiled from HelloWorldService.java public class com.stackoverflow.documentation.HelloWorldService minor version 0 major version 51 flags ACCPUBLIC, ACCSUPER Constant pool 1 Methodref 5.60 javalangObject.V 2 Fieldref 61.62 javalangSystem.outLjavaioPrintStream 3 String 63 Hello, World! 4 Methodref 64.65 javaioPrintStream.printlnLjavalangStringV 5 Class 66 javalangObject 6 Methodref 5.67 javalangObject.getClassLjavalangClass 7 Methodref 68.69 javalangClass.getResourceAsStreamLjavalangStringLjavaioInputStream 8 Methodref 70.71 javaioInputStream.readBI 9 Class 72 javalangString 10 Methodref 9.73 javalangString.BIIV 11 Methodref 70.74 javaioInputStream.closeV 12 Class 75 javalangThrowable 13 Methodref 12.76 javalangThrowable.addSuppressedLjavalangThrowableV 14 Class 77 javaioIOException 15 Class 78 javalangRuntimeException GoalKicker.com Java Notes for Professionals 88716 Methodref 79.80 javalangException.printStackTraceV 17 String 55 stuff 18 Class 81 comstackoverflowdocumentationHelloWorldService 19 Utf8 20 Utf8 V 21 Utf8 Code 22 Utf8 LineNumberTable 23 Utf8 LocalVariableTable 24 Utf8 this 25 Utf8 LcomstackoverflowdocumentationHelloWorldService 26 Utf8 sayHello 27 Utf8 pvtMethod 28 Utf8 LjavautilListLjavalangObject 29 Utf8 strings 30 Utf8 LjavautilList 31 Utf8 LocalVariableTypeTable 32 Utf8 LjavautilList 33 Utf8 Signature 34 Utf8 LjavautilListLjavalangObject 35 Utf8 tryCatchResources 36 Utf8 LjavalangStringLjavalangString 37 Utf8 bytes 38 Utf8 B 39 Utf8 read": "input.pdf", "40 Utf8 I 41 Utf8 inputStream 42 Utf8 LjavaioInputStream 43 Utf8 e 44 Utf8 LjavalangException 45 Utf8 filename 46 Utf8 LjavalangString 47 Utf8 StackMapTable 48 Class 81 comstackoverflowdocumentationHelloWorldService 49 Class 72 javalangString 50 Class 82 javaioInputStream 51 Class 75 javalangThrowable 52 Class 38 B 53 Class 83 javalangException 54 Utf8 Exceptions 55 Utf8 stuff 56 Utf8 SourceFile 57 Utf8 HelloWorldService.java 58 Utf8 RuntimeVisibleAnnotations 59 Utf8 LorgspringframeworkstereotypeService 60 NameAndType 1920 V 61 Class 84 javalangSystem 62 NameAndType 8586 outLjavaioPrintStream 63 Utf8 Hello, World! 64 Class 87 javaioPrintStream 65 NameAndType 8889 printlnLjavalangStringV 66 Utf8 javalangObject 67 NameAndType 9091 getClassLjavalangClass 68 Class 92 javalangClass 69 NameAndType 9394 getResourceAsStreamLjavalangStringLjavaioInputStream 70 Class 82 javaioInputStream 71 NameAndType 3995 readBI 72 Utf8 javalangString 73 NameAndType 1996 BIIV 74 NameAndType 9720 closeV 75 Utf8 javalangThrowable 76 NameAndType 9899 addSuppressedLjavalangThrowableV 77 Utf8 javaioIOException 78 Utf8 javalangRuntimeException GoalKicker.com Java Notes for Professionals 88879 Class 83 javalangException 80 NameAndType 10020 printStackTraceV 81 Utf8 comstackoverflowdocumentationHelloWorldService 82 Utf8 javaioInputStream 83 Utf8 javalangException 84 Utf8 javalangSystem 85 Utf8 out 86 Utf8 LjavaioPrintStream 87 Utf8 javaioPrintStream 88 Utf8 println 89 Utf8 LjavalangStringV 90 Utf8 getClass 91 Utf8 LjavalangClass 92 Utf8 javalangClass 93 Utf8 getResourceAsStream 94 Utf8 LjavalangStringLjavaioInputStream 95 Utf8 BI 96 Utf8 BIIV 97": "input.pdf", "Utf8 close 98 Utf8 addSuppressed 99 Utf8 LjavalangThrowableV 100 Utf8 printStackTrace public com.stackoverflow.documentation.HelloWorldService descriptor V flags ACCPUBLIC Code stack1, locals1, argssize1 0 aload0 1 invokespecial 1 Method javalangObject.V 4 return LineNumberTable line 10 0 LocalVariableTable Start Length Slot Name Signature 0 5 0 this LcomstackoverflowdocumentationHelloWorldService public void sayHello descriptor V flags ACCPUBLIC Code stack2, locals1, argssize1 0 getstatic 2 Field javalangSystem.outLjavaioPrintStream 3 ldc 3 String Hello, World! 5 invokevirtual 4 Method javaioPrintStream.printlnLjavalangStringV 8 return LineNumberTable line 13 0 line 14 8 LocalVariableTable Start Length Slot Name Signature 0 9 0 this LcomstackoverflowdocumentationHelloWorldService private java.lang.Object pvtMethodjava.util.List descriptor LjavautilListLjavalangObject flags ACCPRIVATE Code stack4, locals2, argssize2 0 iconst1 1 anewarray 5 class javalangObject 4 dup 5 iconst0 6 aload1 7 aastore GoalKicker.com Java Notes for Professionals 8898 areturn LineNumberTable line 17 0 LocalVariableTable Start Length Slot Name Signature 0 9 0 this LcomstackoverflowdocumentationHelloWorldService 0 9 1 strings LjavautilList LocalVariableTypeTable Start Length Slot Name Signature 0 9 1 strings LjavautilList Signature 34 LjavautilListLjavalangObject protected java.lang.String tryCatchResourcesjava.lang.String throws java.io.IOException descriptor LjavalangStringLjavalangString flags ACCPROTECTED Code stack5, locals10, argssize2 0 aload0 1 invokevirtual 6 Method javalangObject.getClassLjavalangClass 4 aload1 5 invokevirtual 7 Method javalangClass.getResourceAsStreamLjavalangStringLjavaioInputStream 8 astore2 9 aconstnull 10 astore3 11 sipush 8192 14 newarray byte 16": "input.pdf", "astore 4 18 aload2 19 aload 4 21 invokevirtual 8 Method javaioInputStream.readBI 24 istore 5 26 new 9 class javalangString 29 dup 30 aload 4 32 iconst0 33 iload 5 35 invokespecial 10 Method javalangString.BIIV 38 astore 6 40 aload2 41 ifnull 70 44 aload3 45 ifnull 66 48 aload2 49 invokevirtual 11 Method javaioInputStream.closeV 52 goto 70 55 astore 7 57 aload3 58 aload 7 60 invokevirtual 13 Method javalangThrowable.addSuppressedLjavalangThrowableV 63 goto 70 66 aload2 67 invokevirtual 11 Method javaioInputStream.closeV 70 aload 6 72 areturn 73 astore 4 75 aload 4 77 astore3 78 aload 4 80 athrow 81 astore 8 83 aload2 84 ifnull 113 GoalKicker.com Java Notes for Professionals 89087 aload3 88 ifnull 109 91 aload2 92 invokevirtual 11 Method javaioInputStream.closeV 95 goto 113 98 astore 9 100 aload3 101 aload 9 103 invokevirtual 13 Method javalangThrowable.addSuppressedLjavalangThrowableV 106 goto 113 109 aload2 110 invokevirtual 11 Method javaioInputStream.closeV 113 aload 8 115 athrow 116 astore2 117 aload2 118 invokevirtual 16 Method javalangException.printStackTraceV 121 aload2 122 athrow Exception table from to target type 48 52 55 Class javalangThrowable 11 40 73 Class javalangThrowable 11 40 81 any 91 95 98 Class javalangThrowable 73 83 81 any 0 70": "input.pdf", "116 Class javaioIOException 0 70 116 Class javalangRuntimeException 73 116 116 Class javaioIOException 73 116 116 Class javalangRuntimeException LineNumberTable line 21 0 line 22 11 line 23 18 line 24 26 line 25 40 line 21 73 line 25 81 line 26 117 line 27 121 LocalVariableTable Start Length Slot Name Signature 18 55 4 bytes B 26 47 5 read I 9 107 2 inputStream LjavaioInputStream 117 6 2 e LjavalangException 0 123 0 this LcomstackoverflowdocumentationHelloWorldService 0 123 1 filename LjavalangString StackMapTable numberofentries 9 frametype 255 fullframe offsetdelta 55 locals class comstackoverflowdocumentationHelloWorldService, class javalangString, class javaioInputStream, class javalangThrowable, class B, int, class javalangString stack class javalangThrowable frametype 10 same frametype 3 same frametype 255 fullframe offsetdelta 2 locals class comstackoverflowdocumentationHelloWorldService, class javalangString, class javaioInputStream, class javalangThrowable stack class javalangThrowable frametype 71 samelocals1stackitem stack class javalangThrowable GoalKicker.com Java Notes for Professionals 891frametype 255 fullframe offsetdelta 16 locals class comstackoverflowdocumentationHelloWorldService, class javalangString, class javaioInputStream, class javalangThrowable, top, top, top, top, class javalangThrowable stack class javalangThrowable frametype 10 same frametype 3 same frametype 255 fullframe offsetdelta 2 locals class comstackoverflowdocumentationHelloWorldService, class javalangString stack class javalangException Exceptions throws java.io.IOException void stuff descriptor V flags Code stack2, locals1, argssize1 0 getstatic 2 Field": "input.pdf", "javalangSystem.outLjavaioPrintStream 3 ldc 17 String stuff 5 invokevirtual 4 Method javaioPrintStream.printlnLjavalangStringV 8 return LineNumberTable line 32 0 line 33 8 LocalVariableTable Start Length Slot Name Signature 0 9 0 this LcomstackoverflowdocumentationHelloWorldService SourceFile HelloWorldService.java RuntimeVisibleAnnotations 0 59 GoalKicker.com Java Notes for Professionals 892Chapter 172 JMX The JMX technology provides the tools for building distributed, Web-based, modular and dynamic solutions for managing and monitoring devices, applications, and service-driven networks. By design, this standard is suitable for adapting legacy systems, implementing new management and monitoring solutions, and plugging into those of the future. Section 172.1 Simple example with Platform MBean Server Lets say we have some server that registers new users and greets them with some message. And we want to monitor this server and change some of its parameters. First, we need an interface with our monitoring and control methods public interface UserCounterMBean long getSleepTime void setSleepTime long sleepTime int getUserCount void setUserCount int userCount String getGreetingString void setGreetingString String greetingString void stop And some simple implementation that will let us see how its working and how we a\ufb00ect it public class UserCounter implements UserCounterMBean, Runnable private AtomicLong sleepTime new AtomicLong 10000 private AtomicInteger userCount new AtomicInteger 0 private AtomicReference String": "input.pdf", "greetingString new AtomicReference welcome private AtomicBoolean interrupted new AtomicBoolean false Override public long getSleepTime return sleepTime. get Override public void setSleepTime long sleepTime this.sleepTime .setsleepTime Override public int getUserCount return userCount. get Override public void setUserCount int userCount this.userCount .setuserCount GoalKicker.com Java Notes for Professionals 893 Override public String getGreetingString return greetingString. get Override public void setGreetingString String greetingString this.greetingString .setgreetingString Override public void stop this.interrupted .settrue Override public void run while !interrupted. get try System.out.printfUser d, sn , userCount. incrementAndGet , greetingString. get Thread.sleepsleepTime. get catch InterruptedException ignored For simple example with local or remote management, we need to register our MBean import javax.management.InstanceAlreadyExistsException import javax.management.MBeanRegistrationException import javax.management.MBeanServer import javax.management.MalformedObjectNameException import javax.management.NotCompliantMBeanException import javax.management.ObjectName import java.lang.management.ManagementFactory public class Main public static void mainString args throws MalformedObjectNameException, NotCompliantMBeanException, InstanceAlreadyExistsException, MBeanRegistrationException, InterruptedException final UserCounter userCounter new UserCounter final MBeanServer mBeanServer ManagementFactory. getPlatformMBeanServer final ObjectName objectName new ObjectName ServerManagertypeUserCounter mBeanServer. registerMBean userCounter, objectName final Thread thread new ThreaduserCounter thread. start thread. join After that we can run our application and connect to it via jConsole, which can be found in your JAVAHOME bin directory. First, we need to \ufb01nd our local java process with our application GoalKicker.com Java Notes for Professionals": "input.pdf", "894 then switch to MBeans tab and \ufb01nd that MBean that we used in our Main class as an ObjectName in the example above its ServerManager . In Attributes section we can see out attributes. If you speci\ufb01ed get method only, attribute will be readable but not writeable. If you speci\ufb01ed both get and set methods, attribute would be readable and writeable. Speci\ufb01ed methods can be invoked in Operations section. GoalKicker.com Java Notes for Professionals 895 If you want to be able to use remote management, you will need additional JVM parameters, like -Dcom.sun.management .jmxremote true true by default -Dcom.sun.management .jmxremote .port36006 -Dcom.sun.management .jmxremote .authenticate false -Dcom.sun.management .jmxremote .sslfalse These parameters can be found in Chapter 2 of JMX guides . After that you will be able to connect to your application via jConsole remotely with jconsole host port or with specifying hostport or servicejmxrmijndirmihostNameportNumjmxrmi in jConsole GUI. Useful links JMX guides JMX Best practices GoalKicker.com Java Notes for Professionals 896Chapter 173 Java Virtual Machine JVM Section 173.1 These are the basics JVM is an abstract computing machine or Virtual machine that resides in your RAM. It has a platform- independent execution environment that interprets Java bytecode into native": "input.pdf", "machine code. Javac is Java Compiler which compiles your Java code into Bytecode Java program will be running inside the JVM which is then mapped onto the underlying physical machine. It is one of programming tool in JDK. Byte code is platform-independent code which is run on every platform and Machine code is platform-speci\ufb01c code which is run in only speci\ufb01c platform such as windows or linux it depend on execution. Some of the components Class Loder - load the .class \ufb01le into RAM. Bytecode veri\ufb01er - check whether there are any access restriction violations in your code. Execution engine - convert the byte code into executable machine code. JITjust in time - JIT is part of JVM which used to improves the performance of JVM.It will dynamically compile or translate java bytecode into native machine code during execution time. Edited GoalKicker.com Java Notes for Professionals 897Chapter 174 XJC Parameter Details schema \ufb01le The xsd schema \ufb01le to convert to java XJC is a Java SE tool that compiles an XML schema \ufb01le into fully annotated Java classes. It is distributed within the JDK package and is located at binxjc path. Section 174.1 Generating Java code from simple XSD": "input.pdf", "\ufb01le XSD schema schema.xsd The following xml schema xsd de\ufb01nes a list of users with attributes name and reputation . ?xml version1.0? xsschema version1.0 xmlnsxs httpwww.w3.org2001XMLSchema xmlnsns httpwww.stackoverflow.comusers elementFormDefault qualified targetNamespace httpwww.stackoverflow.comusers xselement nameusers typensUsers xscomplexType nameUsers xssequence xselement typensUser nameuser minOccurs 0 maxOccurs unbounded xssequence xscomplexType xscomplexType nameUser xsattribute namename userequired typexsstring xsattribute namereputation userequired xssimpleType xsrestriction basexsint xsminInclusive value1 xsrestriction xssimpleType xsattribute xscomplexType xsschema Using xjc This requires the path to the xjc tool JDK binaries to be in the OS path variable. The code generation can be started using xjc schema. xsd This will generate java \ufb01les in the working directory. Result \ufb01les There will be some additional comments, but basically the java \ufb01les generated look like this package com.stackoverflow.users GoalKicker.com Java Notes for Professionals 898import java.util.ArrayList import java.util.List import javax.xml.bind.annotation.XmlAccessType import javax.xml.bind.annotation.XmlAccessorType import javax.xml.bind.annotation.XmlType XmlAccessorType XmlAccessType. FIELD XmlType name Users, propOrder user public class Users protected ListUser user public ListUser getUser if user null user new ArrayList User return this.user package com.stackoverflow.users import javax.xml.bind.annotation.XmlAccessType import javax.xml.bind.annotation.XmlAccessorType import javax.xml.bind.annotation.XmlAttribute import javax.xml.bind.annotation.XmlType XmlAccessorType XmlAccessType. FIELD XmlType name User public class User XmlAttribute name name, required true protected String name XmlAttribute name reputation , required true protected int": "input.pdf", "reputation public String getName return name public void setName String value this.name value public int getReputation return reputation public void setReputation int value this.reputation value package com.stackoverflow.users import javax.xml.bind.JAXBElement import javax.xml.bind.annotation.XmlElementDecl import javax.xml.bind.annotation.XmlRegistry import javax.xml.namespace.QName GoalKicker.com Java Notes for Professionals 899XmlRegistry public class ObjectFactory private final static QName UsersQNAME new QNamehttpwww.stackoverflow.comusers , users public ObjectFactory public Users createUsers return new Users public User createUser return new User XmlElementDecl namespace httpwww.stackoverflow.comusers , name users public JAXBElement Users createUsers Users value return new JAXBElement UsersUsersQNAME, Users. class, null, value package-info.java javax.xml.bind.annotation .XmlSchema namespace httpwww.stackoverflow.comusers , elementFormDefault javax.xml.bind.annotation .XmlNsForm .QUALIFIED package com.stackoverflow.users GoalKicker.com Java Notes for Professionals 900Chapter 175 JVM Flags Section 175.1 -XXaggressive -XXaggressive is a collection of con\ufb01gurations that make the JVM perform at a high speed and reach a stable state as soon as possible. To achieve this goal, the JVM uses more internal resources at startup however, it requires less adaptive optimization once the goal is reached. We recommend that you use this option for long-running, memory- intensive applications that work alone. Usage -XXaggressive param param Description optSchedules adaptive optimizations earlier and enables new optimizations, which are expected to be the default in future releases. memoryCon\ufb01gures the memory": "input.pdf", "system for memory-intensive workloads and sets an expectation to enable large amounts of memory resources to ensure high throughput. JRockit JVM will also use large pages, if available. Section 175.2 -XXallocClearChunks This option allows you to clear a TLA for references and values at TLA allocation time and pre-fetch the next chunk. When an integer, a reference, or anything else is declared, it has a default value of 0 or null depending upon type. At the appropriate time, you will need to clear these references and values to free the memory on the heap so Java can use- or reuse- it. You can do either when the object is allocated or, by using this option, when you request a new TLA. Usage -XXallocClearChunks -XXallocClearChunks true false The above is a boolean option and is generally recommended on IA64 systems ultimately, its use depends upon the application. If you want to set the size of chunks cleared, combine this option with -XXallocClearChunkSize . If you use this \ufb02ag but do not specify a boolean value, the default is true . Section 175.3 -XXallocClearChunkSize When used with -XXallocClearChunkSize , this option sets the size of the chunks to be cleared. If": "input.pdf", "this \ufb02ag is used but no value is speci\ufb01ed, the default is 512 bytes. Usage -XXallocClearChunks -XXallocClearChunkSize sizekKmMgG Section 175.4 -XXcallPro\ufb01ling This option enables the use of call pro\ufb01ling for code optimizations. Pro\ufb01ling records useful runtime statistics speci\ufb01c to the application and can in many cases increase performance because JVM can then act on those statistics. GoalKicker.com Java Notes for Professionals 901Note This option is supported with the JRockit JVM R27.3.0 and later version. It may become default in future versions. Usage java -XXcallProfiling myApp This option is disabled by default. You must enable it to use it. Section 175.5 -XXdisableFatSpin This option disables the fat lock spin code in Java, allowing threads that block trying to acquire a fat lock go to sleep directly. Objects in Java become a lock as soon as any thread enters a synchronized block on that object. All locks are held that is, stayed locked until released by the locking thread. If the lock is not going to be released very fast, it can be in\ufb02ated to a fat lock. Spinning occurs when a thread that wants a speci\ufb01c lock continuously checks that lock to see if it is still taken, spinning in": "input.pdf", "a tight loop as it makes the check. Spinning against a fat lock is generally bene\ufb01cial although, in some instances, it can be expensive and might a\ufb00ect performance. -XXdisableFatSpin allows you to turn o\ufb00 spinning against a fat lock and eliminate the potential performance hit. Usage -XXdisableFatSpin Section 175.6 -XXdisableGCHeuristics This option disables the garbage collector strategy changes. Compaction heuristics and nursery size heuristics are not a\ufb00ected by this option. By default, the garbage collection heuristics are enabled. Usage -XXdisableFatSpin Section 175.7 -XXdumpSize This option causes a dump \ufb01le to be generated and allows you to specify the relative size of that \ufb01le that is, small, medium, or large. Usage -XXdumpsize size size Description none Does not generate a dump \ufb01le. smallOn Windows, a small dump \ufb01le is generated on Linux a full core dump is generated. A small dump only include the thread stacks including their traces and very little else. This was the default in the JRockit JVM 8.1 with service packs 1 and 2, as well as 7.0 with service pack 3 and higher. normalCauses a normal dump to be generated on all platforms. This dump \ufb01le includes all memory except the java heap. This is": "input.pdf", "the default value for the JRockit JVM 1.4.2 and later. largeIncludes everything that is in memory, including the Java heap. This option makes -XXdumpSize equivalent to -XXdumpFullState . GoalKicker.com Java Notes for Professionals 902Section 175.8 -XXexitOnOutOfMemory This option makes JRockit JVM exit on the \ufb01rst occurrence of an out of memory error. It can be used if you prefer restarting an instance of JRockit JVM rather than handling out of memory errors. Enter this command at startup to force JRockit JVM to exit on the \ufb01rst occurrence of an out of memory error. Usage -XXexitOnOutOfMemory GoalKicker.com Java Notes for Professionals 903Chapter 176 JVM Tool Interface Section 176.1 Iterate over objects reachable from object Heap 1.0 include vector include string include agentutil.hpp this file can be found in Java SE Development Kit 8u101 Demos and Samples see httpdownload.oracle.comotn-pubjavajdk8u101-b13-demosjdk-8u101-windows-x64-demos.zip jdk1.8.0101.zip!demojvmtiversionChecksrcagentutil.h Struct used for jvmti-SetTagobject, pointer to tag httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlSetTag typedef struct Tag jlong referrertag jlong size char classSignature jint hashCode Tag Utility function jlong - Tag static Tag pointerToTag jlong tagptr if tagptr 0 return new Tag return Tagptrdifft voidtagptr Utility function Tag - jlong static jlong tagToPointer Tag tag return jlongptrdifft voidtag Heap 1.0 Callback httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmljvmtiObjectReferenceCallback static jvmtiIterationControl JNICALL heabObjectReferencesCallback jvmtiObjectReferenceKind": "input.pdf", "referencekind, jlong classtag, jlong size, jlong tagptr, jlong referrertag, jint referrerindex, void userdata GoalKicker.com Java Notes for Professionals 904 iterate only over reference field if referencekind ! JVMTIHEAPREFERENCEFIELD return JVMTIITERATIONIGNORE auto tagptrlist stdvectorjlongptrdifft voiduserdata create and assign tag auto t pointerToTag tagptr t-referrertag referrertag t-size size tagptr tagToPointer t collect tag tagptrlist .pushback tagptr return JVMTIITERATIONCONTINUE Main function for demonstration of Iterate Over Objects Reachable From Object httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlIterateOverObjectsReachableFromObject void iterateOverObjectHeapReferences jvmtiEnv jvmti, JNIEnv env, jobject object stdvectorjlong tagptrlist auto t new Tag jvmti -SetTagobject, tagToPointer t tagptrlist. pushback tagToPointer t stdoutmessage tag list size before call callback d n, tagptrlist. size Call Callback for every reachable object reference see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlIterateOverObjectsReachableFromObject jvmti -IterateOverObjectsReachableFromObject object, heabObjectReferencesCallback, voidtagptrlist stdoutmessage tag list size after call callback d n, tagptrlist. size if tagptrlist. size 0 jint foundcount 0 jlong tags tagptrlist 0 jobject foundobjects jlong foundtags collect all tagged object via tagptr pointer to tag see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlGetObjectsWithTags jvmti -GetObjectsWithTags tagptrlist. size, tags, foundcount, foundobjects, foundtags stdoutmessage found d objects n, foundcount for auto i 0 i foundcount i jobject foundobject foundobjects i char classSignature jclass foundobjectclass env-GetObjectClass foundobject GoalKicker.com Java Notes for Professionals 905 Get string representation of foundobjectclass see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlGetClassSignature jvmti -GetClassSignature foundobjectclass,": "input.pdf", "classSignature, nullptr jint hashCode Getting hash code for foundobject see httpdocs.oracle.comjavase7docsplatformjvmtijvmti.htmlGetObjectHashCode jvmti -GetObjectHashCode foundobject, hashCode save all it in Tag Tag t pointerToTag foundtags i t -classSignature classSignature t -hashCode hashCode print all saved information for auto i 0 i foundcount i auto t pointerToTag foundtags i auto rt pointerToTag t-referrertag if t-referrertag ! 0 stdoutmessage referrer object sd -- object sd size 2d n, rt -classSignature, rt -hashCode, t -classSignature, t -hashCode, t -size Section 176.2 Get JVMTI environment Inside AgentOnLoad method jvmtiEnv jvmti Get JVMTI environment vm-GetEnvreinterpretcast void jvmti, JVMTIVERSION Section 176.3 Example of initialization inside of AgentOnLoad method Callback for JVMTIEVENTVMINIT static void JNICALL vminit jvmtiEnv jvmti, JNIEnv env, jthread thread jint runtimeversion jvmti -GetVersionNumber runtimeversion stdoutmessage JVMTI Version d n, runtimeverision AgentOnLoad is called first, we prepare for a VMINIT event here. JNIEXPORT jint JNICALL AgentOnLoad JavaVM vm, char options, void reserved jint rc jvmtiEventCallbacks callbacks GoalKicker.com Java Notes for Professionals 906 jvmtiCapabilities capabilities jvmtiEnv jvmti Get JVMTI environment rc vm-GetEnvreinterpretcast void jvmti, JVMTIVERSION if rc ! JNIOK return -1 Immediately after getting the jvmtiEnv we need to ask for the capabilities this agent will need. jvmti -GetCapabilities capabilities capabilities. cantagobjects 1 jvmti -AddCapabilities capabilities": "input.pdf", "Set callbacks and enable event notifications memset callbacks, 0, sizeof callbacks callbacks. VMInit vminit jvmti -SetEventCallbacks callbacks, sizeof callbacks jvmti -SetEventNotificationMode JVMTIENABLE, JVMTIEVENTVMINIT, nullptr return JNIOK GoalKicker.com Java Notes for Professionals 907Chapter 177 Java Memory Management Section 177.1 Setting the Heap, PermGen and Stack sizes When a Java virtual machine starts, it needs to know how big to make the Heap, and the default size for thread stacks. These can be speci\ufb01ed using command-line options on the java command. For versions of Java prior to Java 8, you can also specify the size of the PermGen region of the Heap. Note that PermGen was removed in Java 8, and if you attempt to set the PermGen size the option will be ignored with a warning message. If you dont specify Heap and Stack sizes explicitly, the JVM will use defaults that are calculated in a version and platform speci\ufb01c way. This may result in your application using too little or too much memory. This is typically OK for thread stacks, but it can be problematic for a program that uses a lot of memory. Setting the Heap, PermGen and default Stack sizes The following JVM options set the heap": "input.pdf", "size -Xmssize - sets the initial heap size -Xmxsize - sets the maximum heap size -XXPermSize size - sets the initial PermGen size -XXMaxPermSize size - sets the maximum PermGen size -Xsssize - sets the default thread stack size The size parameter can be a number of bytes, or can have a su\ufb03x of k, m or g. The latter specify the size in kilobytes, megabytes and gigabytes respectively. Examples java -Xms512m -Xmx1024m JavaApp java -XXPermSize 64m -XXMaxPermSize 128m JavaApp java -Xss512k JavaApp Finding the default sizes The -XXprintFlagsFinal option can be used to print the values of all \ufb02ags before starting the JVM. This can be used to print the defaults for the heap and stack size settings as follows For Linux, Unix, Solaris and Mac OSX java -XXPrintFlagsFinal -version grep -iE HeapSizePermSizeThreadStackSize For Windows java -XXPrintFlagsFinal -version \ufb01ndstr i HeapSize PermSize ThreadStackSize The output of the above commands will resemble the following GoalKicker.com Java Notes for Professionals 908uintx InitialHeapSize 20655360 product uintx MaxHeapSize 331350016 product uintx PermSize 21757952 pd product uintx MaxPermSize 85983232 pd product intx ThreadStackSize 1024 pd product The sizes are given in bytes. Section 177.2 Garbage collection The C approach - new and delete": "input.pdf", "In a language like C, the application program is responsible for managing the memory used by dynamically allocated memory. When an object is created in the C heap using the new operator, there needs to be a corresponding use of the delete operator to dispose of the object If program forgets to delete an object and just forgets about it, the associated memory is lost to the application. The term for this situation is a memory leak , and it too much memory leaks an application is liable to use more and more memory, and eventually crash. On the other hand, if an application attempts to delete the same object twice, or use an object after it has been deleted, then the application is liable to crash due to problems with memory corruption In a complicated C program, implementing memory management using new and delete can be time consuming. Indeed, memory management is a common source of bugs. The Java approach - garbage collection Java takes a di\ufb00erent approach. Instead of an explicit delete operator, Java provides an automatic mechanism known as garbage collection to reclaim the memory used by objects that are no longer needed. The Java runtime": "input.pdf", "system takes responsibility for \ufb01nding the objects to be disposed of. This task is performed by a component called a garbage collector , or GC for short. At any time during the execution of a Java program, we can divide the set of all existing objects into two distinct subsets1 Reachable objects are de\ufb01ned by the JLS as follows A reachable object is any object that can be accessed in any potential continuing computation from any live thread. In practice, this means that there is a chain of references starting from an in-scope local variable or a static variable by which some code might be able to reach the object. Unreachable objects are objects that cannot possibly be reached as above. Any objects that are unreachable are eligible for garbage collection. This does not mean that they will be garbage collected. In fact An unreachable object does not get collected immediately on becoming unreachable1. An unreachable object may not ever be garbage collected. GoalKicker.com Java Notes for Professionals 909The Java language Speci\ufb01cation gives a lot of latitude to a JVM implementation to decide when to collect unreachable objects. It also in practice gives permission for a JVM implementation to": "input.pdf", "be conservative in how it detects unreachable objects. The one thing that the JLS guarantees is that no reachable objects will ever be garbage collected. What happens when an object becomes unreachable First of all, nothing speci\ufb01cally happens when an object becomes unreachable. Things only happen when the garbage collector runs and it detects that the object is unreachable. Furthermore, it is common for a GC run to not detect all unreachable objects. When the GC detects an unreachable object, the following events can occur. If there are any Reference objects that refer to the object, those references will be cleared before the object 1. is deleted. If the object is \ufb01nalizable , then it will be \ufb01nalized. This happens before the object is deleted. 2. The object can be deleted, and the memory it occupies can be reclaimed.3. Note that there is a clear sequence in which the above events can occur, but nothing requires the garbage collector to perform the \ufb01nal deletion of any speci\ufb01c object in any speci\ufb01c time-frame. Examples of reachable and unreachable objects Consider the following example classes A node in simple open linked-list. public class Node private static int counter 0 public int": "input.pdf", "nodeNumber counter public Node next public class ListTest public static void mainString args test M1 System.out.prinlnDone M2 private static void test Node n1 new Node T1 Node n2 new Node T2 Node n3 new Node T3 n1. next n2 T4 n2 null T5 n3 null T6 Let us examine what happens when test is called. Statements T1, T2 and T3 create Node objects, and the objects are all reachable via the n1, n2 and n3 variables respectively. Statement T4 assigns the reference to the 2nd Node object to the next \ufb01eld of the \ufb01rst one. When that is done, the 2nd Node is reachable via two paths n2 - Node2 GoalKicker.com Java Notes for Professionals 910 n1 - Node1, Node1. next - Node2 In statement T5, we assign null to n2. This breaks the \ufb01rst of the reachability chains for Node2 , but the second one remains unbroken, so Node2 is still reachable. In statement T6, we assign null to n3. This breaks the only reachability chain for Node3 , which makes Node3 unreachable. However, Node1 and Node2 are both still reachable via the n1 variable. Finally, when the test method returns, its local variables n1, n2 and n3": "input.pdf", "go out of scope, and therefore cannot be accessed by anything. This breaks the remaining reachability chains for Node1 and Node2 , and all of the Node objects are nor unreachable and eligible for garbage collection. 1 - This is a simpli\ufb01cation that ignores \ufb01nalization, and Reference classes. 2 - Hypothetically, a Java implementation could do this, but the performance cost of doing this makes it impractical. Section 177.3 Memory leaks in Java In the Garbage collection example, we implied that Java solves the problem of memory leaks. This is not actually true. A Java program can leak memory, though the causes of the leaks are rather di\ufb00erent. Reachable objects can leak Consider the following naive stack implementation. public class NaiveStack private Object stack new Object100 private int top 0 public void pushObject obj if top stack.length throw new StackException stack overflow stack top obj public Object pop if top 0 throw new StackException stack underflow return stack--top public boolean isEmpty return top 0 When you push an object and then immediately pop it, there will still be a reference to the object in the stack array. The logic of the stack implementation means that that reference cannot be": "input.pdf", "returned to a client of the API. If an object has been popped then we can prove that it cannot be accessed in any potential continuing computation from any live thread . The problem is that a current generation JVM cannot prove this. Current generation JVMs do not consider the logic of the program in determining whether references are reachable. For a start, it is not practical. But setting aside the issue of what reachability really means, we clearly have a situation here where the NaiveStack implementation is hanging onto objects that ought to be reclaimed. That is a memory leak. GoalKicker.com Java Notes for Professionals 911In this case, the solution is straightforward public Object pop if top 0 throw new StackException stack underflow Object popped stack--top stack top null Overwrite popped reference with null. return popped Caches can be memory leaks A common strategy for improving service performance is to cache results. The idea is that you keep a record of common requests and their results in an in-memory data structure known as a cache. Then, each time a request is made, you lookup the request in the cache. If the lookup succeeds, you return the corresponding saved": "input.pdf", "results. This strategy can be very e\ufb00ective if implemented properly. However, if implemented incorrectly, a cache can be a memory leak. Consider the following example public class RequestHandler private MapTask, Result cache new HashMap public Result doRequest Task task Result result cache.gettask if result null result doRequestProcessing task cache. puttask, result return result The problem with this code is that while any call to doRequest could add a new entry to the cache, there is nothing to remove them. If the service is continually getting di\ufb00erent tasks, then the cache will eventually consume all available memory. This is a form of memory leak. One approach to solving this is to use a cache with a maximum size, and throw out old entries when the cache exceeds the maximum. Throwing out the least recently used entry is a good strategy. Another approach is to build the cache using WeakHashMap so that the JVM can evict cache entries if the heap starts getting too full. Section 177.4 Finalization A Java object may declare a finalize method. This method is called just before Java releases the memory for the object. It will typically look like this public class MyClass Methods for the": "input.pdf", "class Override protected void finalize throws Throwable Cleanup code However, there some important caveats on the behavior of Java \ufb01nalization. GoalKicker.com Java Notes for Professionals 912Java makes no guarantees about when a finalize method will called. Java does not even guarantee that a finalize method will be called some time during the running applications lifetime. The only thing that is guaranteed is that the method will be called before the object is deleted ... if the object is deleted. The caveats above mean that it is a bad idea to rely on the finalize method to perform cleanup or other actions that must be performed in a timely fashion. Over reliance on \ufb01nalization can lead to storage leaks, memory leaks and other problems. In short, there are very few situation where \ufb01nalization is actually a good solution. Finalizers only run once Normally, an object is deleted after it has been \ufb01nalized. However, this doesnt happen all of the time. Consider the following example1 public class CaptainJack public static CaptainJack notDeadYet null protected void finalize Resurrection! notDeadYet this When an instance of CaptainJack becomes unreachable and the garbage collector attempts to reclaim it, the finalize method will assign a reference": "input.pdf", "to the instance to the notDeadYet variable. That will make the instance reachable once more, and the garbage collector wont delete it. Question Is Captain Jack immortal? Answer No. The catch is the JVM will only run a \ufb01nalizer on an object once in its lifetime. If you assign null to notDeadYet causing a resurected instance to be unreachable once more, the garbage collector wont call finalize on the object. 1 - See httpsen.wikipedia.orgwikiJackHarkness . Section 177.5 Manually triggering GC You can manually trigger the Garbage Collector by calling System.gc However, Java does not guarantee that the Garbage Collector has run when the call returns. This method simply suggests to the JVM Java Virtual Machine that you want it to run the garbage collector, but does not force it to do so. It is generally considered a bad practice to attempt to manually trigger garbage collection. The JVM can be run with the -XXDisableExplicitGC option to disable calls to System.gc. Triggering garbage collection by calling System.gc can disrupt normal garbage management object promotion activities of the speci\ufb01c garbage collector implementation in use by the JVM. GoalKicker.com Java Notes for Professionals 913Chapter 178 Java Performance Tuning Section 178.1 An evidence-based": "input.pdf", "approach to Java performance tuning Donald Knuth is often quoted as saying this Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at e\ufb03ciency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small e\ufb03ciencies, say about 97 of the time premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3. source Bearing that sage advice in mind, here is the recommended procedure for optimizing programs First of all, design and code your program or library with a focus on simplicity and correctness. To start with,1. dont spend much e\ufb00ort on performance. Get it to a working state, and ideally develop unit tests for the key parts of the codebase.2. Develop an application level performance benchmark. The benchmark should cover the performance critical3. aspects of your application, and should perform a range of tasks that are typical of how the application will be used in production. Measure the performance.4. Compare the measured performance against your criteria for how fast the application needs to be. Avoid5. unrealistic, unattainable or unquanti\ufb01able": "input.pdf", "criteria such as as fast as possible. If you have met the criteria, STOP. You job is done. Any further e\ufb00ort is probably a waste of time.6. Pro\ufb01le the application while it is running your performance benchmark.7. Examine the pro\ufb01ling results and pick the biggest unoptimized performance hotspots i.e. sections of the8. code where the application seems to be spending the most time. Analyse the hotspot code section to try to understand why it is a bottleneck, and think of a way to make it9. faster. Implement that as a proposed code change, test and debug. 10. Rerun the benchmark to see if the code change has improved the performance 11. If Yes, then return to step 4. If No, then abandon the change and return to step 9. If you are making no progress, pick a di\ufb00erent hotspot for your attention. Eventually you will get to a point where the application is either fast enough, or you have considered all of the signi\ufb01cant hotspots. At this point you need to stop this approach. If a section of code is consuming say 1 of the overall time, then even a 50 improvement is only going to make the application": "input.pdf", "0.5 faster overall. Clearly, there is a point beyond which hotspot optimization is a waste of e\ufb00ort. If you get to that point, you need to GoalKicker.com Java Notes for Professionals 914take a more radical approach. For example Look at the algorithmic complexity of your core algorithms. If the application is spending a lot of time garbage collection, look for ways to reduce the rate of object creation. If key parts of the application are CPU intensive and single-threaded, look for opportunities for parallelism. If the application is already multi-threaded, look for concurrency bottlenecks. But wherever possible, rely on tools and measurement rather than instinct to direct your optimization e\ufb00ort. Section 178.2 Reducing amount of Strings In Java, its too easy to create many String instances which are not needed. That and other reasons might cause your program to have lots of Strings that the GC is busy cleaning up. Some ways you might be creating String instances myString foo Or worse, in a loop or recursion for int i 0 i N i myString foo i The problem is that each creates a new String usually, since new compilers optimize some cases. A possible optimization can be made": "input.pdf", "using StringBuilder or StringBuffer StringBuffer sb new StringBuffer myString for int i 0 i N i sb.appendfoo.appendi myString sb.toString If you build long Strings often SQLs for example, use a String building API. Other things to consider Reduce usage of replace , substring etc. Avoid String.toArray, especially in frequently accessed code. Log prints which are destined to be \ufb01ltered due to log level for example should not be generated log level should be checked in advance. Use libraries like this if necessary. StringBuilder is better if the variable is used in a non-shared manner across threads. Section 178.3 General approach The internet is packed with tips for performance improvement of Java programs. Perhaps the number one tip is awareness. That means Identify possible performance problems and bottlenecks. Use analyzing and testing tools. Know good practices and bad practices. GoalKicker.com Java Notes for Professionals 915The \ufb01rst point should be done during the design stage if speaking about a new system or module. If speaking about legacy code, analyzing and testing tools come into the picture. The most basic tool for analyzing your JVM performance is JVisualVM, which is included in the JDK. The third point is mostly about experience and": "input.pdf", "extensive research, and of course raw tips that will show up on this page and others, like this. GoalKicker.com Java Notes for Professionals 916Chapter 179 Benchmarks Writing performance benchmarks in java is not as simple as getting System.currentTimeMillis in the beginning and in the end and calculating the di\ufb00erence. To write valid performance benchmarks, one should use proper tools. Section 179.1 Simple JMH example One of the tools for writing proper benchmark tests is JMH. Lets say we want to compare performance of searching an element in HashSet vs TreeSet . The easiest way to get JHM into your project - is to use maven and shade plugin. Also you can see pom.xml from JHM examples . build plugins plugin groupId org.apache.maven.plugins groupId artifactId maven-shade-plugin artifactId version 3.0.0version executions execution phasepackagephase goals goalshadegoal goals configuration finalName benchmarks finalName transformers transformer implementation org.apache.maven.plugins.shade.resource.ManifestResourceTransformer mainClass org.openjdk.jmh.Main mainClass transformer transformers filters filter artifact artifact excludes exclude META-INF.SF exclude exclude META-INF.DSA exclude exclude META-INF.RSA exclude excludes filter filters configuration execution executions plugin plugins build dependencies dependency groupId org.openjdk.jmh groupId artifactId jmh-core artifactId version 1.18version dependency dependency groupId org.openjdk.jmh groupId GoalKicker.com Java Notes for Professionals 917 artifactId jmh-generator-annprocess artifactId version 1.18version dependency dependencies After": "input.pdf", "this you need to write benchmark class itself package benchmark import org.openjdk.jmh.annotations. import org.openjdk.jmh.infra.Blackhole import java.util.HashSet import java.util.Random import java.util.Set import java.util.TreeSet import java.util.concurrent.TimeUnit StateScope.Thread public class CollectionFinderBenchmarkTest private static final int SETSIZE 10000 private SetString hashSet private SetString treeSet private String stringToFind 8888 Setup public void setupCollections hashSet new HashSet SETSIZE treeSet new TreeSet for int i 0 i SETSIZE i final String value String.valueOfi hashSet. addvalue treeSet. addvalue stringToFind String.valueOfnew Random.nextIntSETSIZE Benchmark BenchmarkMode Mode.AverageTime OutputTimeUnit TimeUnit. NANOSECONDS public void testHashSet Blackhole blackhole blackhole. consumehashSet. contains stringToFind Benchmark BenchmarkMode Mode.AverageTime OutputTimeUnit TimeUnit. NANOSECONDS public void testTreeSet Blackhole blackhole blackhole. consumetreeSet. contains stringToFind Please keep in mind this blackhole. consume, well get back to it later. Also we need main class for running benchmark package benchmark GoalKicker.com Java Notes for Professionals 918import org.openjdk.jmh.runner.Runner import org.openjdk.jmh.runner.RunnerException import org.openjdk.jmh.runner.options.Options import org.openjdk.jmh.runner.options.OptionsBuilder public class BenchmarkMain public static void mainString args throws RunnerException final Options options new OptionsBuilder . includeCollectionFinderBenchmarkTest. class.getSimpleName . forks1 . build new Runneroptions.run And were all set. We just need to run mvn package it will create benchmarks. jar in your target folder and run our benchmark test java -cp target benchmarks. jar benchmark. BenchmarkMain And after some warmup": "input.pdf", "and calculation iterations, we will have our results Run complete. Total time 000121 Benchmark Mode Cnt Score Error Units CollectionFinderBenchmarkTest. testHashSet avgt 20 9.940 0.270 nsop CollectionFinderBenchmarkTest. testTreeSet avgt 20 98.858 13.743 nsop About that blackhole. consume. If your calculations do not change the state of your application, java will most likely just ignore it. So, in order to avoid it, you can either make your benchmark methods return some value, or use Blackhole object to consume it. You can \ufb01nd more information about writing proper benchmarks in Aleksey Shipil \u00ebvs blog , in Jacob Jenkovs blog and in java-performance blog 1, 2. GoalKicker.com Java Notes for Professionals 919Chapter 180 FileUpload to AWS Upload File to AWS s3 bucket using spring rest API. Section 180.1 Upload \ufb01le to s3 bucket Here we will create a rest API which will take \ufb01le object as a multipart parameter from front end and upload it to S3 bucket using java rest API. Requirement secrete key and Access key for s3 bucket where you wanna upload your \ufb01le. code DocumentController.java RestController RequestMapping apiv2 public class DocumentController private static String bucketName pharmerz-chat private static String keyName Pharmerz UUID.randomUUID RequestMapping value upload , method RequestMethod.": "input.pdf", "POST, consumes MediaType. MULTIPARTFORMDATA public URL uploadFileHandler RequestParam name String name, RequestParam file MultipartFile file throws IOException Printing all the possible parameter from RequestParam System.out.println System.out.printlnfile.getOriginalFilename file.getOriginalFilename System.out.printlnfile.getContentType file.getContentType System.out.printlnfile.getInputStream file.getInputStream System.out.printlnfile.toString file.toString System.out.printlnfile.getSize file.getSize System.out.printlnname name System.out.printlnfile.getBytes file.getBytes System.out.printlnfile.hashCode file.hashCode System.out.printlnfile.getClass file.getClass System.out.printlnfile.isEmpty file.isEmpty Parameters to b pass to s3 bucket put Object InputStream is file.getInputStream String keyName file.getOriginalFilename Credentials for Aws AWSCredentials credentials new BasicAWSCredentials AKIA , zr DocumentController.uploadfilecredentials AmazonS3 s3client new AmazonS3Client credentials try System.out.printlnUploading a new object to S3 from a file n File file new Fileawsuploadfile s3client. putObject new PutObjectRequest bucketName, keyName, is, new ObjectMetadata GoalKicker.com Java Notes for Professionals 920 URL url s3client. generatePresignedUrl bucketName, keyName, Date.fromInstant. now.plus5, ChronoUnit. MINUTES URL urls3client.generatePresignedUrlbucketName,keyName, Date.fromInstant.now.plus5, ChronoUnit. System.out.println System.out.printlnurl return url catch AmazonServiceException ase System.out.printlnCaught an AmazonServiceException, which means your request made it to Amazon S3, but was rejected with an error response for some reason. System.out.printlnError Message ase.getMessage System.out.printlnHTTP Status Code ase.getStatusCode System.out.printlnAWS Error Code ase.getErrorCode System.out.printlnError Type ase.getErrorType System.out.printlnRequest ID ase.getRequestId catch AmazonClientException ace System.out.printlnCaught an AmazonClientException, which means the client encountered an internal error while trying to communicate with S3, such as not being able to access the network. System.out.printlnError Message ace.getMessage return": "input.pdf", "null Front end Function var form new FormData form.appendfile, image.jpeg var settings async true, crossDomain true, url httpurl , method POST, headers cache-control no-cache , processData false, contentType false, mimeType multipartform-data , data form .ajaxsettings .donefunction response console. logresponse GoalKicker.com Java Notes for Professionals 921Chapter 181 AppDynamics and TIBCO BusinessWorks Instrumentation for Easy Integration As AppDynamics aims to provide a way to measure application performance, speed of development, delivery deployment of applications is an essential factor in making DevOps e\ufb00orts a true success. Monitoring a TIBCO BW application with AppD is generally simple and not time consuming but when deploying large sets of applications rapid instrumentation is key. This guide shows how to instrument all of your BW applications in a single step without modifying each application before deploying. Section 181.1 Example of Instrumentation of all BW Applications in a Single Step for Appdynamics Locate and open your TIBCO BW bwengine.tra \ufb01le typlically under TIBCOHOMEbw5.12binbwengine.tra1. Linux environment Look for the line that states2. Common variables. Modify these only. Add the following line right after that section tibco.deploymenttibco.deployment3. Go to the end of the \ufb01le and add replace ? with your own values as needed or remove the \ufb02ag that": "input.pdf", "does not4. apply java.extended.properties-javaagentoptappdcurrentappagentjavaagent.jar - Dappdynamics.http.proxyHost? -Dappdynamics.http.proxyPort? -Dappdynamics.agent.applicationName? -Dappdynamics.agent.tierName? -Dappdynamics.agent.nodeNametibco.deployment - Dappdynamics.controller.ssl.enabled? -Dappdynamics.controller.sslPort? -Dappdynamics.agent.logs.dir? - Dappdynamics.agent.runtime.dir? -Dappdynamics.controller.hostName? -Dappdynamics.controller.port? -Dappdynamics.agent.accountName? -Dappdynamics.agent.accountAccessKey? Save \ufb01le and redeploy. All your applications should now be instrumented automatically at deployment time.5. GoalKicker.com Java Notes for Professionals 922Appendix A Installing Java Standard Edition This documentation page gives access to instructions for installing java standard edition on Windows , Linux , and macOS computers. Section A.1 Setting PATH and JAVAHOME after installing on Windows Assumptions An Oracle JDK has been installed. The JDK was installed to the default directory. Setup steps Open Windows Explorer.1. In the navigation pane on the left right click on This PC or Computer for older Windows versions. There is a 2. shorter way without using the explorer in actual Windows versions Just press Win Pause In the newly opened Control Panel window, left click Advanced System Settings which should be in the top left 3. corner. This will open the System Properties window. Alternatively, type SystemPropertiesAdvanced case insensitive in the Run Win R , and hit Enter . In the Advanced tab of System Properties select the Environment Variables... button in the lower right 4. corner of the window. Add a New": "input.pdf", "System Variable by clicking the New... button in System Variables with the name JAVAHOME 5. and whose value is the path to the directory where the JDK was installed. After entering these values, press OK . GoalKicker.com Java Notes for Professionals 923 Scroll down the list of System Variables and select the Path variable. 6. CAUTION Windows relies on Path to \ufb01nd important programs. If any or all of it is removed, 7. Windows may not be able to function properly. It must be modi\ufb01ed to allow Windows to run the JDK. With this in mind ,click the Edit... button with the Path variable selected. Add JAVAHOME bin to the beginning of the Path variable. It is better to append at the beginning of the line because Oracles software used to register their own version of Java in Path - This will cause your version to be ignored if it occurs after Oracles declaration. Check your work Open the command prompt by clicking Start then typing cmd and pressing Enter . 1. Enter javac -version into the prompt. If it was successful, then the version of the JDK will be printed to the 2. screen. Note If you have": "input.pdf", "to try again, close the prompt before checking your work. This will force windows to get the new version of Path . Section A.2 Installing a Java JDK on Linux Using the Package Manager JDK andor JRE releases for OpenJDK or Oracle can be installed using the package manager on most mainstream Linux distribution. The choices that are available to you will depend on the distro. As a general rule, the procedure is to open terminal window and run the commands shown below. It is assumed that you have su\ufb03cient access to run commands as the root user ... which is what the sudo command does. If you do not, then please talk to your systems administrators. Using the package manager is recommended because it generally makes it easier to keep your Java installation up to date. apt-get, Debian based Linux distributions Ubuntu, etc The following instructions will install Oracle Java 8 sudo add-apt-repository ppawebupd8team java sudo apt-get update sudo apt-get install oracle-java8-installer GoalKicker.com Java Notes for Professionals 924Note To automatically set up the Java 8 environment variables, you can install the following package sudo apt-get install oracle-java8-set-default Creating a .deb \ufb01le If you prefer to create the .deb": "input.pdf", "\ufb01le yourself from the .tar.gz \ufb01le downloaded from Oracle, do the following assuming youve downloaded the .tar.gz to .jdk.tar.gz sudo apt-get install java-package might not be available in default repos make-jpkg . jdk.tar.gz should not be run as root sudo dpkg -i j2sdk.deb Note This expects the input to be provided as a .tar.gz \ufb01le. slackpkg , Slackware based Linux distributions sudo slapt-get install default-jdk yum, RedHat, CentOS, etc sudo yum install java-1.8.0-openjdk-devel.x8664 dnf, Fedora On recent Fedora releases, yum has been superseded by dnf. sudo dnf install java-1.8.0-openjdk-devel.x8664 In recent Fedora releases, there are no packages for installing Java 7 and earlier. pacman , Arch based Linux distributions sudo pacman -S jdk8-openjdk Using sudo is not required if youre running as the root user. Gentoo Linux The Gentoo Java guide is maintained by the Gentoo Java team and keeps an updated wiki page including the correct portage packages and USE \ufb02ags needed. Installing Oracle JDKs on Redhat, CentOS, Fedora Installing JDK from an Oracle JDK or JRE tar.gz \ufb01le. Download the appropriate Oracle archive tar.gz \ufb01le for the desired release from the Oracle Java 1. downloads site . Change directory to the place where you want to put": "input.pdf", "the installation2. Decompress the archive \ufb01le e.g.3. tar xzvf jdk -8u67-linux-x64.tar.gz GoalKicker.com Java Notes for Professionals 925Installing from an Oracle Java RPM \ufb01le. Retrieve the required RPM \ufb01le for the desired release from the Oracle Java downloads site . 1. Install using the rpm command. For example 2. sudo rpm -ivh jdk-8u67-linux-x644.rpm Section A.3 Installing a Java JDK on macOS Oracle Java 7 and Java 8 Java 7 and Java 8 for macOS are available from Oracle. This Oracle page answers a lot of questions about Java for Mac. Note that Java 7 prior to 7u25 have been disabled by Apple for security reasons. In general, Oracle Java Version 7 and later requires an Intel-based Mac running macOS 10.7.3 or later. Installation of Oracle Java Java 7 8 JDK and JRE installers for macOS can be downloaded from Oracle s website Java 8 - Java SE Downloads Java 7 - Oracle Java Archive. After downloading the relevant package, double click on the package and go through the normal installation process. A JDK should get installed here LibraryJavaJavaVirtualMachines version.jdkContents Home where corresponds to the installed version. Command-Line Switching When Java is installed, the installed version is automatically set as the": "input.pdf", "default. To switch between di\ufb00erent, use export JAVAHOME usrlibexecjavahome -v 1.6 Or 1.7 or 1.8 The following functions can be added to the .bashprofile If you use the default Bash shell for ease of use function javaversion echo java -version function javaset if 1 6 then export JAVAHOME usrlibexecjavahome -v 1.6 echo Setting Java to version 6... echo JAVAHOME elif 1 7 then export JAVAHOME usrlibexecjavahome -v 1.7 echo Setting Java to version 7... echo JAVAHOME elif 1 8 then GoalKicker.com Java Notes for Professionals 926 export JAVAHOME usrlibexecjavahome -v 1.8 echo Setting Java to version 8... echo JAVAHOME fi Apple Java 6 on macOS On older versions of macOS 10.11 El Capitan and earlier, Apples release of Java 6 comes pre-installed. If installed, it can be be found at this location SystemLibraryJavaJavaVirtualMachines 1.6.0.jdkContents Home Note that Java 6 passed its end-of-life long ago, so upgrading to a newer version is recommended. There is more information on reinstalling Apple Java 6 on the Oracle website. Section A.4 Installing a Java JDK or JRE on Windows Only Oracle JDKs and JREs are available for Windows platforms. The installation procedure is straight-forward Visit the Oracle Java Downloads page 1. Click on": "input.pdf", "either the JDK button, the JRE button or the Server JRE button. Note that to develop using Java you2. need JDK. To know the di\ufb00erence between JDK and JRE, see here Scroll down to the version you want to download. Generally speaking, the most recent one is3. recommended. Select the Accept License Agreement radio button.4. Download the Windows x86 32 bit or Windows x64 64 bit installer.5. Run the installer ... in the normal way for your version of Windows.6. An alternate way to install Java on Windows using the command prompt is to use Chocolately Install Chocolately from httpschocolatey.org 1. Open a cmd instance, for example hit Win R and then type cmd in the Run window followed by an 2. enter. In your cmd instance, run the following command to download and install a Java 8 JDK3. C choco install jdk8 Getting up and running with portable versions There are instances where you might want to install JDKJRE on a system with limited privileges like a VM or you might want to install and use multiple versions or architectures x64x86 of JDKJRE. The steps remain same till the point you download the installer .EXE. The steps after": "input.pdf", "that are as follows The steps are applicable for JDKJRE 7 and above, for older versions they are slightly di\ufb00erent in the names of folders and \ufb01les Move the \ufb01le to an appropriate location where you would want your Java binaries to reside permanently.1. Install 7-Zip or its portable version if you have limited privileges.2. With 7-Zip, extract the \ufb01les from the Java installer EXE to the location.3. Open up command prompt there by holding Shift and Right-Click ing in the folder in explorer or navigate 4. to that location from anywhere. GoalKicker.com Java Notes for Professionals 927Navigate to the newly created folder. Lets say the folder name is jdk-7u25-windows-x64. So type cd 5. jdk-7u25-windows-x64 . Then type the following commands in order cd .rsrcJAVACAB10 extrac32 111 This will create a tools.zip \ufb01le in that location. Extract the tools.zip with 7-Zip so that the \ufb01les inside it are 6. now created under tools in the same directory. Now execute these commands on the already opened command prompt 7. cd tools for r x in .pack do .binunpack200 -r x dxpxnx.jar Wait for the command to complete. Copy the contents of tools to the location where you want your binaries": "input.pdf", "8. to be. This way, you can install any versions of JDKJRE you need to be installed simultaneously. Original post httpstackover\ufb02ow.coma65717361448252 Section A.5 Con\ufb01guring and switching Java versions on Linux using alternatives Using Alternatives Many Linux distributions use the alternatives command for switching between di\ufb00erent versions of a command. You can use this for switching between di\ufb00erent versions of Java installed on a machine. In a command shell, set JDK to the pathname of a newly installed JDK e.g.1. JDKDatajdk1.8.067 Use alternatives --install to add the commands in the Java SDK to alternatives 2. sudo alternatives --install usrbinjava java JDKbinjava 2 sudo alternatives --install usrbinjavac javac JDKbinjavac 2 sudo alternatives --install usrbinjar jar JDKbinjar 2 And so on. Now you can switch between di\ufb00erent versions of a Java command as follows sudo alternatives --config javac There is 1 program that provides javac. Selection Command ----------------------------------------------- 1 usrlibjvmjava-1.8.0-openjdk-1.8.0.101- 1.b14.fc23.x8664 binjavac GoalKicker.com Java Notes for Professionals 928 2 Datajdk1.8.067 binjavac Enter to keep the current selection , or type selection number 2 For more information on using alternatives , refer to the alternatives8 manual entry. Arch based installs Arch Linux based installs come with the command archlinux -java to switch java": "input.pdf", "versions. Listing installed environments archlinux -java status Available Java environments java-7-openjdk default java-8-openjdkjre Switching current environment archlinux -java set JAVAENVNAME Eg archlinux -java set java -8-openjdkjre More information can be found on the Arch Linux Wiki Section A.6 What do I need for Java Development A JDK installation and a text editor are the bare minimum for Java development. It is nice to have a text editor that can do Java syntax highlighting, but you can do without. However for serious development work it is recommended that you also use the following A Java IDE such as Eclipse, Intellij IDEA or NetBeans A Java build tool such as Ant, Gradle or Maven A version control system for managing your code base with appropriate backups, and o\ufb00-site replication Test tools and CI continuous integration tools Section A.7 Selecting an appropriate Java SE release There have been many releases of Java since the original Java 1.0 release in 1995. Refer to Java version history for a summary. However most releases have passed their o\ufb03cial End Of Life dates. This means that the vendor typically Oracle now has ceased new development for the release, and no longer provides public free patches for": "input.pdf", "any bugs or security issues. Private patch releases are typically available for people organizations with a support contract contact your vendors sales o\ufb03ce. In general, the recommended Java SE release for use will be the latest update for the latest public version. Currently, this means the latest available Java 8 release. Java 9 is due for public release in 2017. Java 7 has passed its End Of Life and the last public release was in April 2015. Java 7 and earlier releases are not recommended. This recommendation applies for all new Java development, and anyone learning Java. It also applies to people who just want to run Java software provided by a third-party. Generally speaking, well-written Java code will work on a newer release of Java. But check the softwares release notes, and contact the author supplier vendor if you have doubts. GoalKicker.com Java Notes for Professionals 929If you are working on an older Java codebase, you would be advised to ensure that your code runs on the latest release of Java. Deciding when to start using the features of newer Java releases is more di\ufb03cult, as this will impact your ability to support customers who are unable or": "input.pdf", "unwilling their Java installation. Section A.8 Java release and version naming Java release naming is a little confusing. There are actually two systems of naming and numbering, as shown in this table JDK version Marketing name jdk-1.0 JDK 1.0 jdk-1.1 JDK 1.1 jdk-1.2 J2SE 1.2 ... ... jdk-1.5 J2SE 1.5 rebranded Java SE 5 jdk-1.6 Java SE 6 jdk-1.7 Java SE 7 jdk-1.8 Java SE 8 jdk-91 Java SE 9 not released yet 1 - It appears that Oracle intends to break from their previous practice of using a semantic version number scheme in the Java version strings. It remains to be seen if they will follow through with this. The SE in the marketing names refers to Standard Edition. This is the base release for running Java on most laptops, PCs and servers apart from Android. There are two other o\ufb03cial editions of Java Java ME is the Micro Edition, and Java EE is the Enterprise Edition. The Android \ufb02avor of Java is also signi\ufb01cantly di\ufb00erent from Java SE. Java ME, Java EE and Android Java are outside of the scope of this Topic. The full version number for a Java release looks like this 1.8.0101 -b13 This": "input.pdf", "says JDK 1.8.0, Update 101, Build 13. Oracle refers to this in the release notes as Java SE Development Kit 8, Update 101 JDK 8u101 The update number is important -- Oracle regularly issue updates to a major release with security patches, bug \ufb01xes and in some cases new features. The build number is usually irrelevant. Note that Java 8 and Java 1.8 refer to the same thing Java 8 is just the marketing name for Java 1.8. Section A.9 Installing Oracle Java on Linux with latest tar \ufb01le Follow the below steps to install Oracle JDK from the latest tar \ufb01le Download the latest tar \ufb01le from here - Current latest is Java SE Development Kit 8u112. 1. You need sudo privilages2. sudo su GoalKicker.com Java Notes for Professionals 930Create a dir for jdk install3. mkdir optjdk Extract downloaded tar into it4. tar -zxf jdk-8u5-linux-x64.tar.gz -C optjdk Verify if the \ufb01les are extracted5. ls optjdk Setting Oracle JDK as the default JVM6. update-alternatives --install usrbinjava java optjdkjdk1.8.005 binjava 100 and update-alternatives --install usrbinjavac javac optjdkjdk1.8.005 binjavac 100 Check Java version7. java -version Expected output java version 1.8.0111 JavaTM SE Runtime Environment build 1.8.0111-b14 Java HotSpotTM 64-Bit Server VM": "input.pdf", "build 25.111-b14, mixed mode Section A.10 Post-installation checking and con\ufb01guration on Linux After installing a Java SDK, it is advisable to check that it is ready to use. You can do this by running these two commands, using your normal user account java -version javac -version These commands print out the version information for the JRE and JDK respectively that are on your shells command search path. Look for the JDK JRE version string. If either of the above commands fails, saying command not found, then the JRE or JDK is not on the search path at all go to Con\ufb01guring PATH directly below. If either of the above commands displays a di\ufb00erent version string to what you were expecting, then either your search path or the alternatives system needs adjusting go to Checking Alternatives If the correct version strings are displayed, you are nearly done skip to Checking JAVAHOME Con\ufb01guring PATH directly If there is no java or javac on the search path at the moment, then the simple solution is to add it to your search GoalKicker.com Java Notes for Professionals 931path. First, \ufb01nd where you installed Java see Where was Java installed? below if you have": "input.pdf", "doubts. Next, assuming that bash is your command shell, use a text editor to add the following lines to the end of either .bashprofile or .bashrc If you use Bash as your shell. JAVAHOME installation directory PATHJAVAHOME binPATH export JAVAHOME export PATH ... replacing installation directory with the pathname for your Java installation directory. Note that the above assumes that the installation directory contains a bin directory, and the bin directory contains the java and javac commands that you are trying to use. Next, source the \ufb01le that you just edited, so that the environment variables for your current shell are updated. source .bashprofile Next, repeat the java and javac version checks. If there are still problems, use which java and which javac to verify that you have updates the environment variables correctly. Finally, logout and login again so that the updated environment variables ptopagate to all of your shells. You should now be done. Checking Alternatives If java -version or javac -version worked but gave an unexpected version number, you need to check where the commands are coming from. Use which and ls -l to \ufb01nd this out as follows ls -l which java If the output looks": "input.pdf", "like this, lrwxrwxrwx. 1 root root 22 Jul 30 2218 usrbinjava - etcalternatives java then the alternatives version switching is being used. You needs to decide whether to continue using it, or simply override it by setting the PATH directly. Con\ufb01guring and Switching Java versions on Linux using alternatives See Con\ufb01guring PATH directly above. Where was Java installed? Java can be installed in a variety of places, depending on the installation method. The Oracle RPMs put the Java installation in usrjava. On Fedora, the default location is usrlibjvm. If Java was installed by hand from ZIP or JAR \ufb01les, the installation could be anywhere. If you are having di\ufb03cultly \ufb01nding the installation directory, We suggest that you use find or slocate to \ufb01nd the command. For example GoalKicker.com Java Notes for Professionals 932 find -name java -type f 2 devnull This gives you the pathnames for all \ufb01les called java on your system. The redirection of standard error to devnull suppresses messages about \ufb01les and directories that you cant access. GoalKicker.com Java Notes for Professionals 933Appendix B Java Editions, Versions, Releases and Distributions Section B.1 Dierences between Java SE JRE or Java SE JDK distributions Sun Oracle releases of": "input.pdf", "Java SE come in two forms JRE and JDK. In simple terms, JREs support running Java applications, and JDKs also support Java development. Java Runtime Environment Java Runtime Environment or JRE distributions consist of the set of libraries and tools needed to run and manage Java applications. The tools in a typical modern JRE include The java command for running a Java program in a JVM Java Virtual Machine The jjs command for running the Nashorn Javascript engine. The keytool command for manipulating Java keystores. The policytool command for editing security sandbox security policies. The pack200 and unpack200 tools for packing and unpacking pack200 \ufb01le for web deployment. The orbd , rmid , rmiregistry and tnameserv commands that support Java CORBA and RMI applications. Desktop JRE installers include a Java plugin suitable for some web browser. This is deliberately left out of Server JRE installers.linux syscall read benchmarku From Java 7 update 6 onwards, JRE installers have included JavaFX version 2.2 or later. Java Development Kit A Java Development Kit or JDK distribution includes the JRE tools, and additional tools for developing Java software. The additional tools typically include The javac command, which compiles Java source code .java to": "input.pdf", "bytecode \ufb01les .class. The tools for creating JAR \ufb01les such as jar and jarsigner Development tools such as appletviewer for running applets idlj the CORBA IDL to Java compiler javah the JNI stub generator native2ascii for character set conversion of Java source code schemagen the Java to XML schema generator part of JAXB serialver generate Java Object Serialization version string. the wsgen and wsimport support tools for JAX-WS Diagnostic tools such as jdb the basic Java debugger jmap and jhat for dumping and analysing a Java heap. jstack for getting a thread stack dump. javap for examining .class \ufb01les. Application management and monitoring tools such as jconsole a management console, jstat , jstatd , jinfo and jps for application monitoring A typical Sun Oracle JDK installation also includes a ZIP \ufb01le with the source code of the Java libraries. Prior to Java 6, this was the only publicly available Java source code. GoalKicker.com Java Notes for Professionals 934From Java 6 onwards, the complete source code for OpenJDK is available for download from the OpenJDK site. It is typically not included in Linux JDK packages, but is available as a separate package. Section B.2 Java SE Versions Java SE Version": "input.pdf", "History The following table provides the timeline for the signi\ufb01cant major versions of the Java SE platform. Java SE Version1 Code Name End-of-life free2 Release Date Java SE 10 Early Access None future 2018-03-20 estimated Java SE 9 None future 2017-07-27 Java SE 8 None future 2014-03-18 Java SE 7 Dolphin 2015-04-14 2011-07-28 Java SE 6 Mustang 2013-04-16 2006-12-23 Java SE 5 Tiger 2009-11-04 2004-10-04 Java SE 1.4.2 Mantis prior to 2009-11-04 2003-06-26 Java SE 1.4.1 Hopper Grasshopper prior to 2009-11-04 2002-09-16 Java SE 1.4 Merlin prior to 2009-11-04 2002-02-06 Java SE 1.3.1 Ladybird prior to 2009-11-04 2001-05-17 Java SE 1.3 Kestrel prior to 2009-11-04 2000-05-08 Java SE 1.2 Playground prior to 2009-11-04 1998-12-08 Java SE 1.1 Sparkler prior to 2009-11-04 1997-02-19 Java SE 1.0 Oak prior to 2009-11-04 1996-01-21 Footnotes The links are to online copies of the respective releases documentation on Oracles website. The1. documentation for many older releases no longer online, though it typically can be downloaded from the Oracle Java Archives. Most historical versions of Java SE have passed their o\ufb03cial end of life dates. When a Java version passes2. this milestone, Oracle stop providing free updates for it. Updates are still available to customers": "input.pdf", "with support contracts. Source JDK release dates by Roedy Green of Canadian Mind Products Java SE Version Highlights Java SE VersionHighlights Java SE 8Lambda expressions and MapReduce-inspired Streams. The Nashorn Javascript engine. Annotations on types and repeating annotations. Unsigned arithmetic extensions. New Date and Time APIs. Statically linked JNI libraries. JavaFX launcher. Removal of PermGen. Java SE 7String switches, try-with-resource , the diamond , numeric literal enhancements and exception handling rethrowing improvements. Concurrency library enhancements. Enhanced support for native \ufb01le systems. Timsort. ECC crypto algorithms. Improved 2D graphics GPU support. Pluggable annotations. Java SE 6Signi\ufb01cant performance enhancements to JVM platform and Swing. Scripting language API and Mozilla Rhino Javascript engine. JDBC 4.0. Compiler API. JAXB 2.0. Web Services support JAX-WS GoalKicker.com Java Notes for Professionals 935Java SE 5Generics, annotations, auto-boxing, enum classes, varargs, enhanced for loops and static imports. Speci\ufb01cation of the Java Memory Model. Swing and RMI enhancements. Addition of java.util.concurrent . package and Scanner . Java SE 1.4The assert keyword. Regular expression classes. Exception chaining. NIO APIs - non-blocking IO, Buffer and Channel . java.util.logging. API. Image IO API. Integrated XML and XSLT JAXP. Integrated security and cryptography JCE, JSSE, JAAS. Integrated Java Web Start. Preferences API.": "input.pdf", "Java SE 1.3HotSpot JVM included. CORBA RMI integration. Java Naming and Directory Interface JNDI. Debugger framework JPDA. JavaSound API. Proxy API. Java SE 1.2The strictfp keyword. Swing APIs. The Java plugin for web browsers. CORBA interoperability. Collections framework. Java SE 1.1Inner classes. Re\ufb02ection. JDBC. RMI. Unicode character streams. Internationalization support. Overhaul of AWT event model. JavaBeans. Source Wikipedia Java version history Section B.3 Dierences between Java EE, Java SE, Java ME and JavaFX Java technology is both a programming language and a platform. The Java programming language is a high-level object-oriented language that has a particular syntax and style. A Java platform is a particular environment in which Java programming language applications run. There are several Java platforms. Many developers, even long-time Java programming language developers, do not understand how the di\ufb00erent platforms relate to each other. The Java Programming Language Platforms There are four platforms of the Java programming language Java Platform, Standard Edition Java SE Java Platform, Enterprise Edition Java EE Java Platform, Micro Edition Java ME Java FX All Java platforms consist of a Java Virtual Machine VM and an application programming interface API. The Java Virtual Machine is a program, for a particular hardware and": "input.pdf", "software platform, that runs Java technology applications. An API is a collection of software components that you can use to create other software components or applications. Each Java platform provides a virtual machine and an API, and this allows applications written for that platform to run on any compatible system with all the advantages of the Java programming language platform-independence, power, stability, ease-of-development, and security. Java SE When most people think of the Java programming language, they think of the Java SE API. Java SEs API provides the core functionality of the Java programming language. It de\ufb01nes everything from the basic types and objects of the Java programming language to high-level classes that are used for networking, security, database access, graphical user interface GUI development, and XML parsing. In addition to the core API, the Java SE platform consists of a virtual machine, development tools, deployment technologies, and other class libraries and toolkits commonly used in Java technology applications. GoalKicker.com Java Notes for Professionals 936Java EE The Java EE platform is built on top of the Java SE platform. The Java EE platform provides an API and runtime environment for developing and running large-scale, multi-tiered, scalable, reliable, and secure": "input.pdf", "network applications. Java ME The Java ME platform provides an API and a small-footprint virtual machine for running Java programming language applications on small devices, like mobile phones. The API is a subset of the Java SE API, along with special class libraries useful for small device application development. Java ME applications are often clients of Java EE platform services. Java FX Java FX technology is a platform for creating rich internet applications written in Java FX ScriptTM. Java FX Script is a statically-typed declarative language that is compiled to Java technology bytecode, which can then be run on a Java VM. Applications written for the Java FX platform can include and link to Java programming language classes, and may be clients of Java EE platform services. Taken from the Oracle documentation GoalKicker.com Java Notes for Professionals 937Appendix C The Classpath The classpath lists places where the Java runtime should look for classes and resources. The classpath is also used by the Java compiler to \ufb01nd previously compiled and external dependencies. Section C.1 Dierent ways to specify the classpath There are three ways to set the classpath. It can be set using the CLASSPATH environment variable 1. set CLASSPATH": "input.pdf", "... Windows and csh export CLASSPATH ... Unix ksh bash It can be set on the command line as follows2. java -classpath ... javac -classpath ... Note that the -classpath or -cp option takes precedence over the CLASSPATH environment variable. The classpath for an executable JAR \ufb01le is speci\ufb01ed using the Class-Path element in MANIFEST. MF 3. Class-Path jar1-name jar2 -name directory -namejar3-name Note that this only applies when the JAR \ufb01le is executed like this java -jar some. jar ... In this mode of execution, the -classpath option and the CLASSPATH environment variable will be ignored, even if the JAR \ufb01le has no Class-Path element. If no classpath is speci\ufb01ed, then the default classpath is the selected JAR \ufb01le when using java -jar, or the current directory otherwise. Related httpsdocs.oracle.comjavasetutorialdeploymentjardownman.html httpdocs.oracle.comjavase7docstechnotestoolswindowsclasspath.html Section C.2 Adding all JARs in a directory to the classpath If you want to add all the JARs in directory to the classpath, you can do this concisely using classpath wildcard syntax for example someFolder This tells the JVM to add all JAR and ZIP \ufb01les in the someFolder directory to the classpath. This syntax can be used in a -cp argument, a CLASSPATH environment variable,": "input.pdf", "or a Class-Path attribute in an executable JAR \ufb01les manifest \ufb01le.See Setting the Class Path Class Path Wild Cards for examples and caveats. GoalKicker.com Java Notes for Professionals 938Notes Classpath wildcards were \ufb01rst introduced in Java 6. Earlier versions of Java do not treat as a wildcard.1. You cannot put other characters before or after the e.g. someFolder .jar is not a wildcard. 2. A wildcard matches only \ufb01les with the su\ufb03x .jar or .JAR. ZIP \ufb01les are ignored, as are JAR \ufb01les with a3. di\ufb00erent su\ufb03xes. A wildcard matches only JAR \ufb01les in the directory itself, not in its subdirectories.4. When a group of JAR \ufb01les is matched by a wildcard entry, their relative order on the classpath is not speci\ufb01ed.5. Section C.3 Load a resource from the classpath It can be useful to load a resource image, text \ufb01le, properties, KeyStore, ... that is packaged inside a JAR. For this purpose, we can use the Class and ClassLoader s. Suppose we have the following project structure program.jar -com -project -file.txt -Test.class And we want to access the contents of file.txt from the Test class. We can do so by asking the classloader InputStream is Test.class.getClassLoader .getResourceAsStream comprojectfile.txt": "input.pdf", "By using the classloader, we need to specify the fully quali\ufb01ed path of our resource each package. Or alternatively, we can ask the Test class object directly InputStream is Test.class.getResourceAsStream file.txt Using the class object, the path is relative to the class itself. Our Test.class being in the com.project package, the same as file.txt, we do not need to specify any path at all. We can, however, use absolute paths from the class object, like so is Test.class.getResourceAsStream comprojectfile.txt Section C.4 Classpath path syntax The classpath is a sequence of entries which are directory pathnames, JAR or ZIP \ufb01le pathnames, or JAR ZIP wildcard speci\ufb01cations. For a classpath speci\ufb01ed on the command line e.g. -classpath or as an environment variable, the entries must be separated with semicolon characters on Windows, or colon characters on other platforms Linux, UNIX, MacOSX and so on. For the Class-Path element in a JAR \ufb01les MANIFEST. MF, use a single space to separate the entries. Sometimes it is necessary to embed a space in a classpath entry GoalKicker.com Java Notes for Professionals 939When the classpath is speci\ufb01ed on the command line, it is simply a matter of using the appropriate shell quoting. For example": "input.pdf", "export CLASSPATH homeuserMy JAR Filesfoo.jarsecond.jar The details may depend on the command shell that you use. When the classpath is speci\ufb01ed in a JAR \ufb01les a MANIFEST.MF \ufb01le, URL encoding must be used. Class-Path homeuserMy20JAR20Filesfoo.jar second. jar Section C.5 Dynamic Classpath Sometimes, just adding all the JARs from a folder isnt enough, for example when you have native code and need to select a subset of JARs. In this case, you need two main methods. The \ufb01rst one builds a classloader and then uses this classloader to call the second main. Here is an example which selects the correct SWT native JAR for your platform, adds all your applications JARs and then invokes the real main method Create cross platform Java SWT Application Section C.6 Mapping classnames to pathnames The standard Java toolchain and 3rd-party tools designed to interoperate with them have speci\ufb01c rules for mapping the names of classes to the pathnames of \ufb01les and other resources that represent them. The mappings are as follows For classes in the default package, the pathnames are simple \ufb01lenames. For classes in a named package, the package name components map to directories. For named nested and inner classes, the \ufb01lename component": "input.pdf", "is formed by joining the class names with a character. For anonymous inner classes, numbers are used in place of names. This is illustrated in the following table Classname Source pathname Class\ufb01le pathname SomeClass SomeClass. java SomeClass. class com.example.SomeClass comexampleSomeClass. javacomexampleSomeClass. class SomeClass. Inner in SomeClass. java SomeClassInner. class SomeClass anon inner classes in SomeClass. java SomeClass1. class , SomeClass2. class , etc Section C.7 The bootstrap classpath The normal Java classloaders look for classes \ufb01rst in the bootstrap classpath, before checking for extensions and the application classpath. By default, the bootstrap classpath consists of the rt.jar \ufb01le and some other important JAR \ufb01les that are supplied by the JRE installation. These provide all of the classes in the standard Java SE class library, along with various internal implementation classes. Under normal circumstances, you dont need to concern yourself with this. By default, commands like java , javac and so on will use the appropriate versions of the runtime libraries. GoalKicker.com Java Notes for Professionals 940Very occasionally, it is necessary to override the normal behavior of the Java runtime by using an alternative version of a class in the standard libraries. For example, you might encounter a show stopper": "input.pdf", "bug in the runtime libraries that you cannot work around by normal means. In such a situation, it is possible to create a JAR \ufb01le containing the altered class and then add it to the bootstrap classpath which launching the JVM. The java command provides the following -X options for modifying the bootstrap classpath -Xbootclasspath path replaces the current boot classpath with the path provided. -Xbootclasspath apath appends the provided path to the current boot classpath. -Xbootclasspath ppath prepends the provided path to the current boot classpath. Note that when use the bootclasspath options to replace or override a Java class etcetera, you are technically modifying Java. There may be licensing implications if you then distribute your code. Refer to the terms and conditions of the Java Binary License ... and consult a lawyer. Section C.8 What the classpath means how searches work The purpose of the classpath is to tell a JVM where to \ufb01nd classes and other resources. The meaning of the classpath and the search process are intertwined. The classpath is a form of search path which speci\ufb01es a sequence of locations to look for resources. In a standard classpath, these places are either, a directory": "input.pdf", "in the host \ufb01le system, a JAR \ufb01le or a ZIP \ufb01le. In each cases, the location is the root of a namespace that will be searched. The standard procedure for searching for a class on the classpath is as follows Map the class name to a relative class\ufb01le pathname RP. The mapping for class names to class \ufb01lenames is 1. described elsewhere. For each entry E in the classpath 2. If the entry is a \ufb01lesystem directory Resolve RP relative to E to give an absolute pathname AP. Test if AP is a path for an existing \ufb01le. If yes, load the class from that \ufb01le If the entry is a JAR or ZIP \ufb01le Lookup RP in the JAR ZIP \ufb01le index. If the corresponding JAR ZIP \ufb01le entry exists, load the class from that entry. The procedure for searching for a resource on the classpath depends on whether the resource path is absolute or relative. For an absolute resource path, the procedure is as above. For a relative resource path resolved using Class.getResource or Class.getResourceAsStream , the path for the classes package is prepended prior to searching. Note these are the procedures implemented by the standard": "input.pdf", "Java classloaders. A custom classloader might perform the search di\ufb00erently. GoalKicker.com Java Notes for Professionals 941Appendix D Resources on classpath Java allows the retrieval of \ufb01le-based resources stored inside of a JAR alongside compiled classes. This topic focuses on loading those resources and making them available to your code. Section D.1 Loading default con\ufb01guration To read default con\ufb01guration properties package com.example public class ExampleApplication private Properties getDefaults throws IOException Properties defaults new Properties try InputStream defaultsStream ExampleApplication. class.getResourceAsStream config.properties defaults. loaddefaultsStream return defaults Section D.2 Loading an image from a resource To load a bundled image package com.example public class ExampleApplication private Image getIcon throws IOException URL imageURL ExampleApplication. class.getResource icon.png return ImageIO. readimageURL Section D.3 Finding and reading resources using a classloader Resource loading in Java comprises the following steps Finding the Class or ClassLoader that will \ufb01nd the resource. 1. Finding the resource.2. Obtaining the byte stream for the resource.3. Reading and processing the byte stream.4. Closing the byte stream.5. The last three steps are typically accomplished by passing the URL to a library method or constructor to load the resource. You will typically use a getResource method in this case. It is also possible to read": "input.pdf", "the resource data in application code. You will typically use getResourceAsStream in this case. Absolute and relative resource paths GoalKicker.com Java Notes for Professionals 942Resources that can be loaded from the classpath are denoted by a path . The syntax of the path is similar to a UNIX Linux \ufb01le path. It consists of simple names separated by forward slash characters. A relative path starts with a name, and an absolute path starts with a separator. As the Classpath examples describe, a JVMs classpath de\ufb01nes a namespace by overlaying the namespaces of the directories and JAR or ZIP \ufb01les in the classpath. When an absolute path is resolved, it the classloaders interpret the initial as meaning the root of the namespace. By contrast, a relative path may be resolved relative to any folder in the namespace. The folder used will depend on the object that you use to resolve the path. Obtaining a Class or Classloader A resource can be located using either a Class object or a ClassLoader object. A Class object can resolve relative paths, so you will typically use one of these if you have a class relative resource. There are a variety of ways to": "input.pdf", "obtain a Class object. For example A class literal will give you the Class object for any class that you can name in Java source code e.g. String.class gives you the Class object for the String type. The Object.getClass will give you the Class object for the type od any object e.g. hello.getClass is another way to get Class of the String type. The Class.forNameString method will if necessary dynamically load a class and return its Class object e.g. Class.forNamejava.lang.String . A ClassLoader object is typically obtained by calling getClassLoader on a Class object. It is also possible to get hold of the JVMs default classloader using the static ClassLoader .getSystemClassLoader method. The get methods Once you have a Class or ClassLoader instance, you can \ufb01nd a resource, using one of the following methods Methods Description ClassLoader .getResource path ClassLoader .getResources pathReturns a URL which represents the location of the resource with the given path. ClassLoader .getResources path Class.getResources pathReturns an Enumeration URL giving the URLs which can be used to locate the foo.bar resource see below. ClassLoader .getResourceAsStream path Class.getResourceStream pathReturns an InputStream from which you can read the contents of the foo.bar resource as a sequence of": "input.pdf", "bytes. Notes The main di\ufb00erence between the ClassLoader and Class versions of the methods is in the way that relative paths are interpreted. The Class methods resolve a relative path in the folder that corresponds to the classes package. The ClassLoader methods treat relative paths as if they were absolute i.e. the resolve them in the root folder of the classpath namespace. If the requested resource or resources cannot be found, the getResource and getResourceAsStream methods return null, and the getResources methods return an empty Enumeration. The URLs returned will be resolvable using URL.toStream . They could be file URLs or other conventional URLs, but if the resource resides in a JAR \ufb01le, they will be jar URLs that identify the JAR \ufb01le and a speci\ufb01c resource within it. GoalKicker.com Java Notes for Professionals 943If your code uses a getResourceAsStream method or URL.toStream to obtain an InputStream , it is responsible for closing the stream object. Failure to close the stream could lead to a resource leak. Section D.4 Loading same-name resource from multiple JARs Resource with same path and name may exist in more than one JAR \ufb01le on the classpath. Common cases are resources following a convention": "input.pdf", "or that are part of a packaging speci\ufb01cation. Examples for such resources are META-INFMANIFEST.MF META-INFbeans.xml CDI Spec ServiceLoader properties containing implementation providers To get access to all of these resources in di\ufb00erent jars, one has to use a ClassLoader, which has a method for this. The returned Enumeration can be conveniently converted to a List using a Collections function. Enumeration URL resEnum MyClass. class.getClassLoader .getResources META-INFMANIFEST.MF ArrayList URL resources Collections .listresEnum GoalKicker.com Java Notes for Professionals 944Credits Thank you greatly to all the people from Stack Over\ufb02ow Documentation who helped provide this content, more changes can be sent to webpetercv.com for new content to be published or updated 100rabh Chapters 18 and 79 17slim Chapters 28, 40, 72 and 109 1d0m3n30 Chapters 9, 35, 45, 47 and 106 3442 Chapter 23 3751Creator Chapter 1 4castle Chapters 2 and 57 A Boschman Chapters 42 and 67 A.J. Brown Chapter 11 Aaron Digulla Chapters 47 and 184 Aaron Franke Chapter 56 Aasmund Eldhuset Chapter 46 ABDUL KHALIQ Chapter 90 Abhijeet Chapter 65 Abhishek Jain Chapters 11, 23 and 79 Abubakkar Chapters 11, 23, 57, 67 and 102 acdcjunior Chapters 23 and 57 Ad In\ufb01nitum Chapters 23, 24, 33, 43 and 73": "input.pdf", "Adam Ratzman Chapter 11 Adeel Ansari Chapter 182 Adowrath Chapters 79 and 164 Adrian Krebs Chapters 11, 23, 54, 69, 74 and 111 afzalex Chapter 23 agilob Chapters 11, 23 and 69 agoeb Chapter 54 Aiden Deom Chapter 11 Aimee Borda Chapters 22 and 57 aioobe Chapters 35 and 117 ajablonski Chapter 182 AJNeufeld Chapter 74 akgrensoar Chapter 58 Akhil S K Chapters 1, 66, 69, 117 and 182 alain.janinm Chapters 16, 19 and 138 Alek Mieczkowski Chapters 20, 33 and 78 Alex A Chapter 182 Alex Meiburg Chapters 11 and 47 Alex Shesterov Chapters 11 and 20 Alex T. Chapter 132 Alexandre Grimaud Chapter 181 Alexey Lagunov Chapter 83 alexey semenyuk Chapters 47 and 117 Alexiy Chapter 149 Alon .G. Chapter 43 Alper F \u0131rat Kaya Chapter 77 alphaloop Chapter 144 altomnr Chapters 24 and 182 Amani Kilumanga Chapters 10, 11, 35, 40, 80 and 111 Amit Gujarathi Chapters 12, 29, 30, 31 and 180 GoalKicker.com Java Notes for Professionals 945Amit Gupta Chapter 73 Anatoly Yakimchuk Chapter 23 Andreas Chapters 40, 99 and 106 Andreas Fester Chapter 35 Andrew Chapters 23, 40, 73 and 79 Andrew Antipov Chapter 88 Andrew Brooke Chapter 74 Andrew Sklyarevsky Chapter 35 Andrii": "input.pdf", "Abramov Chapters 41, 57, 73, 75, 81, 117 and 134 Androbin Chapter 33 Andy Thomas Chapters 11, 80, 85 and 130 Ani Menon Chapters 1, 42, 56 and 182 Anil Chapter 23 ankidaemon Chapter 23 Ankit Katiyar Chapters 73, 122 and 141 Ankur Anand Chapter 1 Anony Chapters 10, 11, 24, 35, 47, 73 and 89 anotherGatsby Chapter 23 Anthony Raymond Chapter 182 Anton Hlinisty Chapter 130 antonio Chapters 1 and 23 anuvab1911 Chapters 42 and 182 ar4ers Chapter 52 Arash Chapter 122 ArcticLord Chapters 103 and 105 arcy Chapters 16 and 68 Arkadiy Chapters 1 and 54 arpit pandey Chapter 21 ArsenArsen Chapter 57 Arthur Chapters 23, 71, 72, 77, 87, 93 and 110 Asaph Chapter 11 AshanPerera Chapter 74 Asiat Chapter 41 assylias Chapters 73 and 126 AstroCB Chapter 23 ata Chapters 28 and 77 Athari Chapters 23 and 57 augray Chapter 42 Aurasphere Chapter 77 Austin Chapter 11 Austin Day Chapter 11 AArnold Chapters 11, 16, 18 and 26 Bart Kummel Chapter 57 Batty Chapter 66 bcosynot Chapter 35 ben75 Chapter 97 Bhavik Patel Chapter 69 Bilbo Baggins Chapter 17 Bilesh Ganguly Chapters 10 and 66 Binary Nerd Chapter 28 Blubberguy22 Chapters 25 and 40 bn.": "input.pdf", "Chapter 100 Bob Rivers Chapters 10, 16, 18, 24, 35, 70 and 123 GoalKicker.com Java Notes for Professionals 946BobasPett Chapter 85 Bohdan Korinnyi Chapter 107 Bohemian Chapters 15, 45 and 54 bowmore Chapters 17, 67 and 126 Bo\u017eo Stojkovi \u0107 Chapter 23 bpoiss Chapters 23 and 57 Brendon Dugan Chapter 129 Brett Kail Chapter 42 Brian Goetz Chapter 73 BrunoDM Chapter 41 Buddy Chapter 74 Burkhard Chapters 1, 6, 7, 11, 23, 54, 66, 69, 77 and 107 bwegs Chapter 23 c.uent Chapter 40 c1phr Chapter 23 Cache Staheli Chapters 11, 13, 23, 47 and 107 Ca\ufb00eineToCode Chapter 42 Caleb Brinkman Chapters 6 and 74 Caner Bal \u0131m Chapter 11 carloabelli Chapters 11 and 74 Carlton Chapter 1 CarManuel Chapter 71 Carter Brainerd Chapter 6 Cas Eli\u00ebns Chapter 74 Catalina Island Chapter 46 cdm Chapter 70 ced Chapters 24, 25, 26, 41 and 80 charlesreid1 Chapter 85 Charlie H Chapters 1, 23 and 67 Chetya Chapter 126 Chirag Parmar Chapters 24, 26, 78 and 86 Chris Midgley Chapter 40 Christian Chapter 19 Christian Wilkie Chapter 16 Christophe Weis Chapters 84, 103 and 115 Christopher Schneider Chapter 23 Claudia Chapter 40 Claudio Chapter 57 clinomaniac Chapter 24 code11 Chapter 47": "input.pdf", "Codebender Chapters 24, 41 and 47 coder Chapters 11, 23 and 35 Co\ufb00ee Ninja Chapter 98 Co\ufb00eehouse Coder Chapters 1 and 74 Cold Fire Chapter 23 compuhosny Chapters 151 and 152 Con\ufb01qure Chapters 1, 23, 48, 85, 175 and 182 Constantine Chapters 35 and 57 corsiKa Chapter 126 CraftedCart Chapters 5, 74 and 182 cricket007 Chapter 42 cyberscientist Chapter 11 c\u029fs Chapter 1 GoalKicker.com Java Notes for Professionals 947D D Chapter 22 Daniel Chapter 10 Daniel K\u00e4fer Chapter 23 Daniel LIn Chapters 48 and 111 Daniel M. Chapters 35, 46, 57, 73, 80, 112 and 177 Daniel Nugent Chapters 81, 114, 130 and 139 Daniel Stradowski Chapters 11, 23, 24, 26 and 57 Daniel Wild Chapter 116 Danilo Guimaraes Chapters 35 and 163 Dariusz Chapters 23, 43, 54, 57, 82, 91, 102, 126, 128 and 138 DarkV1 Chapters 1, 11, 23 and 86 Datagrammar Chapter 95 Dave Ranjan Chapter 48 David Grinberg Chapter 54 David Soroko Chapter 87 DeepCoder Chapter 1 Demon Coldmist Chapter 43 demongolem Chapter 26 desilijic Chapter 176 devguy Chapter 79 devnull69 Chapter 93 DimaSan Chapters 26, 33, 50 and 126 dimo414 Chapters 69, 120 and 131 Display Name Chapters 113 and 170 Dmitriy Kotov Chapter": "input.pdf", "28 dnup1092 Chapters 10 and 11 Do Nhu Vy Chapters 6 and 10 DonyorM Chapters 54, 57 and 93 dorukayhan Chapters 11, 20, 76, 87, 133 and 134 Draken Chapter 73 Drizzt321 Chapters 43 and 103 Duh Chapter 23 Durgpal Singh Chapters 23 and 28 Dushko Jovanovski Chapters 43, 57 and 130 Dushman Chapters 111, 114 and 173 DVarga Chapters 11, 23, 47, 54, 57 and 79 dwursteisen Chapter 57 Dylan Chapter 41 ebo Chapter 74 Eduard Wirch Chapter 120 Eilit Chapter 23 EJP Chapters 66 and 145 ekaerovets Chapter 97 Elazar Chapter 42 Emil Sier \u017c\u0119ga Chapters 23, 42, 115 and 182 Emily Mabrey Chapters 28 and 185 emotionlessbananas Chapters 66 and 120 Emre Bolat Chapters 1 and 23 Enamul Hassan Chapter 56 Eng.Fouad Chapter 23 engineercoding Chapter 33 Enigo Chapters 13, 24, 28, 42 and 77 enrico.bacis Chapters 1, 11, 23 and 57 GoalKicker.com Java Notes for Professionals 948Enwired Chapter 132 Eran Chapters 1, 23 and 24 erickson Chapter 117 Erik Minarini Chapter 23 Erkan Haspulat Chapter 56 esin88 Chapters 22, 172 and 179 Etki Chapter 23 explv Chapters 16, 23, 54 and 57 F. Stephen Q Chapters 87 and 143 fabian Chapters 10, 13, 40, 43,": "input.pdf", "48, 74, 80, 85, 91, 103, 117, 122, 136 and 174 faraa Chapter 47 FFY00 Chapter 137 fgb Chapter 13 \ufb01kovnik Chapter 67 Fildor Chapters 3, 116, 126 and 127 Filip Smola Chapter 2 FlyingPiMonster Chapters 40, 77 and 122 FMC Chapter 69 foxt7ot Chapter 150 Francesco Menzani Chapters 1, 10 and 97 Freddie Coleman Chapter 126 Friederike Chapter 132 Functino Chapters 1 and 23 futureelite7 Chapter 40 fpuras Chapter 35 Gal Dreiman Chapters 23, 35, 57, 69, 73, 130, 131, 132 and 183 gar Chapters 10 and 73 garg10may Chapter 1 Garreth Golding Chapter 19 Gautam Jose Chapter 182 Gene Marin Chapters 23, 35 and 178 geniushkg Chapter 54 George Bailey Chapters 6 and 41 Gerald M\u00fccke Chapters 6, 22, 77, 130, 136 and 185 GhostCat Chapter 43 Gihan Chathuranga Chapter 86 GingerHead Chapters 1 and 23 giucal Chapter 117 glee8e Chapter 93 gontard Chapter 57 GPI Chapters 24, 28, 63, 73, 81, 108, 126, 135 and 184 GradAsso Chapter 66 granmirupa Chapters 23 and 25 Gray Chapter 11 GreenGiant Chapters 11, 69 and 88 Grexis Chapters 35 and 146 Grzegorz Oledzki Chapter 57 Gubbel Chapter 58 Guilherme Torres Castro Chapter 23 Gustavo Coelho Chapter 23 gwintrob Chapter": "input.pdf", "67 Gytis Tenovimas Chapters 1 and 23 hamena314 Chapters 11 and 85 GoalKicker.com Java Notes for Professionals 949Hank D Chapters 57 and 73 Hay Chapter 77 Hazem Farahat Chapter 81 HCarrasko Chapter 116 hellrocker Chapter 126 hexafraction Chapters 47, 69, 73, 126 and 144 hirosht Chapter 54 Holger Chapter 137 HON95 Chapter 11 HTNW Chapters 82 and 130 Hulk Chapter 102 hzpz Chapter 67 Idcmp Chapter 45 iliketocode Chapters 1, 11, 23 and 57 Ilya Chapters 11, 23, 82, 93, 97, 118 and 126 Infuzion Chapter 11 InitializeSahib Chapter 97 inovaovao Chapter 79 intboolstring Chapters 23, 46, 74 and 79 Inzimam Tariq IT Chapter 74 ipsi Chapters 1, 10, 35, 171 and 182 iqbalcs Chapter 140 Ironcache Chapters 3 and 166 Ivan Vergiliev Chapter 73 J Atkin Chapters 10, 28, 43, 57, 58, 67, 73 and 89 J\u00e9r\u00e9mie Bolduc Chapter 23 J. Pichardo Chapter 150 J.D. Sandifer Chapter 117 Jabir Chapters 11, 16, 24, 28, 69, 72, 86 and 91 Jacob G. Chapter 61 JakeD Chapter 10 James Jensen Chapter 77 james large Chapters 42, 126 and 133 James Oswald Chapter 79 James Taylor Chapters 1 and 23 JamesENL Chapters 42 and 53 Jan Vladimir Mostert Chapters 25, 47": "input.pdf", "and 79 janos Chapters 25 and 89 Jared Hooper Chapter 35 jatanp Chapter 178 Jatin Balodhi Chapter 5 javac Chapter 11 JAVAC Chapter 81 JavaHopper Chapters 1, 23, 40, 57, 69, 79 and 85 Javant Chapters 23 and 85 Javier Diaz Chapter 28 jayantS Chapter 56 JD9999 Chapters 25 and 59 Jean Chapter 16 Jean Vitor Chapter 1 Jeet Chapter 153 Je\ufb00 Coleman Chapter 182 Je\ufb00rey Bosboom Chapters 23, 28, 52 and 54 GoalKicker.com Java Notes for Professionals 950Je\ufb00rey Lin Chapters 1 and 11 Jens Schauder Chapters 1, 23, 47, 48, 58, 69, 74, 88, 126 and 127 Jeroen Vandevelde Chapter 73 Jeutnarg Chapter 23 Jim Garrison Chapter 23 jitendra varshney Chapter 23 jmattheis Chapter 23 Joe C Chapter 121 Johannes Chapters 23, 35, 79 and 126 John DiFini Chapters 64 and 161 John Fergus Chapter 1 John Nash Chapters 19, 21, 58 and 142 John Slegers Chapter 23 John Starich Chapter 135 johnnyaug Chapter 28 Jojodmo Chapters 10, 11, 23, 40 and 79 Jon Erickson Chapter 57 JonasCz Chapters 11, 69, 74, 78, 86 and 95 Jonathan Chapters 1, 23, 28, 46, 57, 79, 84, 88 and 125 Jonathan Barbero Chapters 96 and 119 Jonathan Lam Chapters 23": "input.pdf", "and 182 JonK Chapter 88 jopasserat Chapter 25 Jordi Castilla Chapter 11 Jordy Baylac Chapter 77 Jorel Ali Chapter 71 Jorn Vernee Chapters 4, 11, 42, 43, 47, 54, 57, 75, 79, 104, 126 and 135 Joshua Carmody Chapter 2 JStef Chapter 23 Jude Niroshan Chapters 11, 57, 67 and 73 JudgingNotJudging Chapters 13 and 73 juergen d Chapter 74 jwd630 Chapter 177 K Chapter 184 k3b Chapter 35 kaartic Chapter 1 Kai Chapters 52, 54, 69 and 79 kajacx Chapter 138 kann Chapter 70 kaotikmynd Chapter 80 Kapep Chapters 11, 43 and 57 KartikKannapur Chapter 28 kasperjj Chapter 97 Kaushal28 Chapters 20, 26 and 86 Kaushik NP Chapter 11 kcoppock Chapter 47 KdgDev Chapter 10 Kelvin Kellner Chapter 159 Ken Y Chapter 122 Kenster Chapters 11, 25, 28 and 63 Kevin DiTraglia Chapter 54 Kevin Raoo\ufb01 Chapter 73 Kevin Thorne Chapters 6, 23, 40 and 69 GoalKicker.com Java Notes for Professionals 951Kichiin Chapter 87 kiedysktos Chapter 95 Kineolyan Chapter 22 Kip Chapter 58 KIRAN KUMAR MATAM Chapters 27, 30, 36, 37, 39, 49, 53, 58, 59 and 92 Kirill Sokolov Chapter 89 Kishore Tulsiani Chapter 164 kristyna Chapter 45 Krzysztof Kraso \u0144 Chapter 25 kstandell Chapters 11, 42": "input.pdf", "and 79 KudzieChase Chapter 24 Kuroda Chapter 18 Lachlan Dowding Chapter 86 Lankymart Chapter 56 Laurel Chapters 79, 80 and 86 leaqui Chapter 77 Lernkurve Chapter 111 Li357 Chapter 106 Liju Thomas Chapters 23, 128 and 169 llamositopia Chapter 23 Loris Securo Chapters 19, 23 and 56 Luan Nico Chapters 23, 54, 89 and 103 Lukas Knuth Chapter 102 M M Chapter 14 Maarten Bodewes Chapters 20, 35, 86 and 140 Mac70 Chapter 40 madx Chapters 1, 35 and 103 Makoto Chapters 23, 70 and 74 Makyen Chapter 23 Malav Chapter 11 Malt Chapters 23, 32, 73, 88, 93 and 126 Manish Kothari Chapters 19 and 128 manouti Chapters 109, 156 and 168 Manuel Spigolon Chapter 11 Manuel Vieda Chapter 18 Marc Chapters 1 and 47 Mark Green Chapter 73 Mark Stewart Chapter 5 Mark Yisri Chapters 46 and 71 Maroun Chapter 24 Martin Frank Chapter 24 Marvin Chapters 11 and 23 MasterBlaster Chapters 48, 57 and 87 Matas Vaitkevicius Chapter 23 Mat\u011bj Kripner Chapter 126 mateuscb Chapter 77 Matsemann Chapter 88 Matt Chapters 1, 23 and 47 Matt Clark Chapters 11, 16, 58 and 86 matt freake Chapters 20, 43 and 52 Matthew Trout Chapter 73 Matthias Braun": "input.pdf", "Chapter 11 Matthieu Chapter 94 GoalKicker.com Java Notes for Professionals 952Maxim Kreschishin Chapter 23 Maxim Plevako Chapters 11 and 23 Maximillian Laumeister Chapter 23 mayha Chapter 11 mayojava Chapters 10 and 85 MBorsch Chapter 10 Md. Nasir Uddin Bhuiyan Chapters 20 and 126 Michael Chapters 11 and 58 Michael Myers Chapters 35 and 103 Michael Piefel Chapters 23, 45 and 126 Michael von Wenckstern Chapter 7 Michael Wiles Chapter 67 michaelbahr Chapters 28, 69 and 87 Micha \u0142 Rybak Chapter 135 Mick Mnemonic Chapter 35 MikeW Chapter 79 Miles Chapters 11, 16 and 17 Miljen Mikic Chapters 23, 42, 69 and 122 Mimouni Chapter 23 Mimyck Chapter 23 MineStone Chapter 93 Minhas Kamal Chapter 23 Miroslav Bradic Chapter 88 Mitch Talmadge Chapters 1 and 23 mnoronha Chapter 1 Mo.Ashfaq Chapter 28 Mohamed Fadhl Chapter 23 Mrunal Pagnis Chapters 107 and 116 Mshnik Chapters 47, 50, 54 and 81 mszymborski Chapter 19 Muhammed Refaat Chapters 23 and 54 Mukund Chapter 1 Murat K. Chapter 126 Mureinik Chapters 57 and 59 Muto Chapter 57 Mykola Yashchenko Chapter 44 Myridium Chapter 69 NageN Chapters 23, 35, 40, 42, 46, 55, 95, 111 and 122 Nagesh Lakinepally Chapter 6 NamshubWriter Chapters 16 and": "input.pdf", "88 Naresh Kumar Chapter 57 Nathaniel Ford Chapter 28 NatNgs Chapters 47 and 126 Nayuki Chapters 22, 23, 42 and 89 ncmathsadist Chapter 73 Nef10 Chapter 35 neohope Chapter 145 nhahtdh Chapter 80 nicael Chapter 23 Nicholas J Panella Chapter 107 Nick Donnelly Chapter 2 nickguletskii Chapter 126 Nicktar Chapters 16, 42 and 85 GoalKicker.com Java Notes for Professionals 953Nikhil R Chapters 158 and 160 Nikita Kurtin Chapters 69 and 107 Niklas Rosencrantz Chapter 162 NikolaB Chapter 11 Nishant123 Chapter 16 nishizawa23 Chapter 148 Nithanim Chapters 1, 128 and 182 niyasc Chapter 23 nobeh Chapter 73 Nolequen Chapters 35, 43 and 81 noscreenname Chapters 66 and 127 Nufail Chapter 20 Nuri Tasdemir Chapters 1, 11, 23, 40 and 57 nyarasha Chapter 1 Ocracoke Chapter 23 OldCurmudgeon Chapter 35 OldMcDonald Chapter 54 Oleg Sklyar Chapters 24, 25, 47 and 54 OliPro007 Chapter 35 Omar Ayala Chapter 114 Onur Chapters 11, 23, 47, 66 and 122 orccrusher99 Chapter 23 Ordiel Chapter 157 Ortomala Lokni Chapters 40, 43, 47 and 57 ostrichofevil Chapter 155 OverCoder Chapters 35 and 177 P.J.Meisch Chapters 11, 13, 35, 69, 100, 115 and 130 Pablo Chapter 24 Pace Chapter 42 padippist Chapter 177 paisanco Chapter 47 Panda": "input.pdf", "Chapter 23 ParkerHalo Chapters 9, 10, 40 and 46 Paul Bellora Chapter 47 PavneetSingh Chapter 1 Pawan Chapters 57 and 111 Pawe \u0142 Albecki Chapters 23, 24, 35 and 47 PcAF Chapter 47 Peter Rader Chapter 132 peterh Chapter 72 Petter Friberg Chapters 3, 11, 24, 35, 42, 47, 56, 57, 69, 73, 82, 103, 117 and 162 phant0m Chapter 11 phat\ufb01ngers Chapter 28 philnate Chapters 47, 52, 73, 74 and 127 PirateJack Chapter 57 Piyush Baderia Chapters 11, 89 and 132 PizzaFrog Chapter 6 Polostor Chapter 24 Pops Chapter 1 Powerlord Chapters 24 and 63 ppeterka Chapters 11, 16, 23, 33, 57, 69, 70, 80, 91, 105, 107, 122 and 135 Prasad Reddy Chapter 24 Prem Singh Bist Chapter 107 GoalKicker.com Java Notes for Professionals 954P\u0159emysl \u0160\u0165astn\u00fd Chapter 11 Pseudonym Patel Chapter 148 PSN Chapter 23 PSo Chapters 11 and 86 Pujan Srivastava Chapter 73 QoP Chapters 11 and 23 qxz Chapter 40 Radek Posto \u0142owicz Chapters 10 and 69 Radiodef Chapters 23 and 24 Radouane ROUFID Chapters 1, 11, 23, 35, 47, 57, 69, 73 and 182 Rafael Pacheco Chapter 114 rahul tyagi Chapter 40 rajadilipkolli Chapter 24 Rajesh Chapter 23 Rakiti \u0107 Chapters 57 and 182": "input.pdf", "rakwaht Chapter 170 Ralf Kleberho\ufb00 Chapters 16 and 41 Ram Chapters 1, 16, 23, 28, 42, 43, 48, 70, 74, 78, 80 and 91 RamenChef Chapters 1, 11, 23, 33, 40, 69, 73, 79, 86, 106, 126, 151 and 165 RAnders00 Chapters 10, 11, 60 and 77 Ravindra babu Chapters 54, 103, 111, 126 and 127 Ravindra HV Chapters 52 and 132 Raviteja Chapter 85 ravthiru Chapters 28, 57 and 82 rd22 Chapters 24, 33, 35, 47 and 126 rdonuk Chapters 24 and 69 Rednivrug Chapter 22 Redterd Chapter 78 Rens van der Heijden Chapter 116 reto Chapter 57 Reut Sharabani Chapters 1, 23, 40 and 57 richersoon Chapter 52 RobAu Chapters 57, 69 and 77 Robert Columbia Chapters 10, 23 and 42 Robin Chapter 75 Rocherlee Chapter 11 Rog\u00e9rio Chapter 47 rokonoid Chapters 66, 77 and 87 rolve Chapters 23, 47, 56 and 73 ronnyfm Chapter 182 Ronon Dex Chapter 35 RudolphEst Chapter 132 Ruslan Bes Chapter 20 RutledgePaulV Chapter 47 Ryan Cocuzzo Chapter 48 Ryan Hilbert Chapter 22 saagarjha Chapters 56 and 89 SachinSarawgi Chapters 1 and 131 Saclyr Barlonium Chapter 73 Sadiq Ali Chapter 71 Saif Chapter 80 Samk Chapters 33 and 35 Sanandrea Chapter 182": "input.pdf", "GoalKicker.com Java Notes for Professionals 955Sandeep Chatterjee Chapter 182 sanjaykumar81 Chapter 117 Santhosh Ramanan Chapters 74 and 117 sargue Chapters 6 and 50 Sa\u0161a \u0160ijak Chapter 69 Saurabh Chapter 23 SaWo Chapter 150 scorpp Chapter 131 screab Chapters 130 and 183 Sergii Bishyr Chapters 23, 57 and 73 sevenforce Chapters 11, 23, 57 and 74 Shaan Chapter 86 Shettyh Chapter 127 shibli049 Chapter 142 ShivBuyya Chapters 11, 40 and 77 shmosel Chapters 23, 35, 43, 57, 67, 88 and 106 Shoe Chapters 11, 23 and 57 Siguza Chapters 1 and 47 Simon Chapter 17 Simulant Chapters 10 and 79 Siva Sainath Reddy Bandi Chapter 66 SjB Chapter 24 skia.heliou Chapter 16 Sky Chapter 11 Skylar Sutton Chapter 73 smichel Chapter 101 Smit Chapter 148 solidcell Chapters 11 and 23 someoneigna Chapter 79 Somnath Musib Chapters 26 and 85 Spina Chapters 35 and 57 SRJ Chapter 57 stackptr Chapters 1, 23 and 57 Stefan Dollase Chapter 57 stefanobaghino Chapter 88 ste\ufb00en Chapter 135 Stephan Chapter 124 Stephen CChapters 1, 5, 7, 8, 9, 10, 11, 13, 23, 25, 28, 33, 40, 42, 43, 45, 47, 50, 51, 54, 57, 59, 67, 69, 73, 77, 79, 81, 82, 85, 86, 88,": "input.pdf", "89, 95, 102, 103, 106, 126, 127, 130, 131, 132, 133, 134, 135, 137, 139, 146, 147, 148, 169, 177, 178, 182, 183, 184 and 185 Stephen Leppik Chapters 1, 23, 47, 69 and 73 Steve K Chapter 57 stilllearning Chapters 54, 69, 77, 86 and 107 Stoyan Dekov Chapter 107 Sudhir Singh Chapters 54 and 126 Sugan Chapters 38 and 57 Sujith Niraikulathan Chapter 3 Suketu Patel Chapter 34 Suminda Sirinath S. DharmasenaChapters 127, 139, 146 and 147 sumit Chapter 85 svsav Chapter 93 GoalKicker.com Java Notes for Professionals 956S\u043d\u0430\u0111\u043e\u0448\u0192\u0430 Chapters 1, 5 and 182 taer Chapter 128 tainy Chapter 47 Tarun Maganti Chapters 17 and 35 TDG Chapter 11 thatguy Chapter 22 The Guy with The Hat Chapter 167 TheLostMind Chapter 11 ThePhantomGamer Chapters 9 and 11 Thisaru Guruge Chapters 3, 25 and 55 Thomas Chapters 23 and 47 Thomas Fritsch Chapter 91 Thomas Gerot Chapters 1 and 79 ThunderStruct Chapter 23 Tim Chapter 107 TMN Chapter 10 TNT Chapters 42 and 162 Tobias Friedinger Chapter 77 Tomasz Bawor Chapter 104 tonirush Chapters 40, 130, 162 and 182 Tony Chapter 154 Tony BenBrahim Chapters 11 and 103 Torsten Chapter 35 Tot Zam Chapters 80, 93 and 162": "input.pdf", "tpunt Chapters 23 and 57 trashgod Chapter 184 Travis J Chapter 23 Tripta Kiroula Chapter 69 Tunaki Chapters 23, 57 and 73 TuringTux Chapters 76 and 100 Tyler Zika Chapter 48 tynn Chapters 41 and 50 Un3qual Chapter 23 Unihedron Chapters 23, 57, 67, 73, 74, 80 and 89 Universal Electricity Chapters 6 and 103 Uri Agassi Chapters 74 and 167 user1121883 Chapter 102 user1133275 Chapters 1 and 57 user140547 Chapters 67 and 125 user1803551 Chapters 10, 98 and 101 user187470 Chapter 79 user2296600 Chapter 63 user2314737 Chapter 10 user2683146 Chapters 57 and 67 user3105453 Chapters 88, 131 and 132 user6653173 Chapter 23 Uux Chapter 144 uzaif Chapters 1 and 23 vallismortis Chapter 91 Vasilis Vasilatos Chapters 25 and 66 Vasiliy Vlasov Chapters 24, 52 and 68 VatsalSura Chapters 75 and 97 Veedrac Chapter 10 GoalKicker.com Java Notes for Professionals 957Ven Chapter 23 VGR Chapters 11, 72, 114 and 185 Viacheslav Vedenin Chapters 28 and 62 Victor G. Chapters 23 and 35 victorantunes Chapter 104 Vin Chapter 1 Vince Emigh Chapter 79 vincentvanjoe Chapter 73 Vinod Kumar Kashyap Chapter 16 Vivek Anoop Chapter 18 Vlad Chapters 47 and 126 Vladimir Vagaytsev Chapter 89 Vogel612 Chapters 8, 20, 23, 28,": "input.pdf", "41, 43, 58, 80, 104, 127 and 162 vorburger Chapter 123 vsminkov Chapter 107 vsnyc Chapter 57 Vucko Chapter 54 vvtx Chapter 11 webo80 Chapters 24 and 73 WillShackleford Chapters 102 and 164 Wilson Chapters 1, 11, 23, 47, 57 and 69 Wolfgang Chapter 73 xploreraj Chapters 24, 73 and 88 xTrollxDudex Chapters 126 and 139 xwoker Chapters 19 and 74 yitzih Chapter 123 yiwei Chapter 69 Yogesh Chapter 73 Yohanes Khosiawan \u8bb8\u5148 \u6c49Chapter 4 yuku Chapters 11 and 23 Yury Fedorov Chapters 23 and 107 Zachary David Saunders Chapter 1 Ze Rubeus Chapters 57 and 182 Zircon Chapters 79 and 134 \u0126\u011b\u0180\u0451 Chapters 78, 120 and 152 \u0141ukasz Piaszczyk Chapter 19 \u03a6Xoc\u0119 \uc6c3 \u041fepe\u00fapa \u30c4 Chapters 11, 17, 21, 23, 25, 43, 78 and 103 \u0280\u0274 Chapters 1 and 25 You may also like": "input.pdf"}}